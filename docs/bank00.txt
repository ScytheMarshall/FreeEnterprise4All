.include "header.inc"

.define r_calculate_perspective_data_tmp                           $06 ; 8-bit
.define r_load_initial_equipment_tmp                               $07 ; 8-bit
.define r_calculate_perspective_data_scanline                      $3D ; 16-bi

.define r_calculate_perspective_data_zoom                          $40 ; 8-bit
.define r_calculate_perspective_data_offset                        $43 ; 16-bit
.define r_calculate_perspective_data_offset_lo                     $43 ; 8-bit
.define r_calculate_perspective_data_offset_hi                     $44 ; 8-bit

.define r_load_outdoor_tilemap_row_tmp                           $0606 ; 8-bit
.define r_get_tile_properties_result_tile                        $0606 ; 8-bit
.define r_animate_overworld_water_tiles_tmp                      $0606 ; 8-bit
.define r_animate_underworld_water_tiles_tmp                     $0606 ; 8-bit
.define r_update_pending_tiles_tmp                               $0606 ; 8-bit
.define r_do_outdoor_movement_tmp                                $0606 ; 8-bit
.define r_load_dungeon_tilemap_bank                              $0606 ; 8-bit
.define r_copy_npc_field_sprite_to_vram_result                   $0606 ; 8-bit
.define r_load_map_title_start                                   $0606 ; 8-bit
.define r_draw_field_sprite_npcs_subtile_index                   $0606 ; 8-bit
.define r_enable_color_subtraction_tmp                           $0606 ; 8-bit
.define r_draw_field_sprite_npcs_tmp_1                           $0607 ; 8-bit
.define r_load_map_title_tmp                                     $0607 ; 8-bit
.define r_copy_outdoor_tilemap_to_vram_index                     $0607 ; 8-bit
.define r_copy_dungeon_tilemap_to_vram_index                     $0607 ; 8-bit
.define r_load_earth_moon_transition_background_value            $0607 ; 8-bit
.define r_check_treasure_open_tmp                                $0607 ; 8-bit
.define r_check_npc_visible_tmp_bit                              $0607 ; 8-bit
.define r_load_npcs_tmp                                          $0607 ; 8-bit
.define r_copy_dungeon_background_tilemap_to_vram_index          $0607 ; 8-bit
.define r_load_dialog_opcode_tmp                                 $0607 ; 8-bit
.define r_show_upper_dialog_tmp                                  $0607 ; 8-bit
.define r_copy_dungeon_background_tilemap_to_vram_y              $0608 ; 8-bit
.define r_copy_outdoor_tilemap_to_vram_y                         $0608 ; 8-bit
.define r_copy_dungeon_tilemap_to_vram_y                         $0608 ; 8-bit
.define r_draw_field_sprite_npcs_tmp_2                           $0608 ; 8-bit

.define r_check_direction_vehicle_blocking_result                $060A ; 8-bit
.define r_nmi_handler_tmp                                        $0610 ; 8-bit
.define r_tmp_dma_fixed_source                                   $0610 ; 8-bit
.define r_draw_dialog_text_lines                                 $0611 ; 8-bit
.define r_draw_dialog_text_vram_address                          $0612 ; 16-bit
.define r_draw_dialog_text_vram_address_lo                       $0612 ; 8-bit
.define r_draw_dialog_text_vram_address_hi                       $0613 ; 8-bit
.define r_draw_dialog_text_base                                  $0614 ; 16-bit
.define r_draw_dialog_text_base_lo                               $0614 ; 8-bit
.define r_draw_dialog_text_base_hi                               $0615 ; 8-bit

.define r_get_tile_properties_tmp_property_index                 $0618 ; 16-bit
.define r_get_tile_properties_tmp_property_index_lo              $0618 ; 8-bit
.define r_get_tile_properties_tmp_property_index_hi              $0619 ; 8-bit
.define r_replace_open_treasure_tiles_tmp                        $0618 ; 16-bit
.define r_replace_open_treasure_tiles_tmp_lo                     $0618 ; 8-bit
.define r_replace_open_treasure_tiles_tmp_hi                     $0619 ; 8-bit
.define r_load_dungeon_tilemap_row_tmp                           $0618 ; 16-bit
.define r_load_dungeon_tilemap_row_tmp_lo                        $0618 ; 8-bit
.define r_load_dungeon_tilemap_row_tmp_hi                        $0619 ; 8-bit
.define r_update_dungeon_pending_tiles_tmp_index                 $0618 ; 16-bit
.define r_update_dungeon_pending_tiles_tmp_index_lo              $0618 ; 8-bit
.define r_update_dungeon_pending_tiles_tmp_index_hi              $0619 ; 8-bit
.define r_load_dialog_opcode_tmp_index                           $0618 ; 16-bit
.define r_load_dialog_opcode_tmp_index_lo                        $0618 ; 16-bit
.define r_load_dialog_opcode_tmp_index_hi                        $0619 ; 16-bit

.enum $0618
    r_change_map_dungeon_index     .dw
    r_change_map_dungeon_index_lo  db
    r_change_map_dungeon_index_hi  db
    r_change_map_dungeon_index2    .dw
    r_change_map_dungeon_index2_lo db
    r_change_map_dungeon_index2_hi db
.ende

.enum $0618
    r_calculate_dungeon_vram_address_index     .dw
    r_calculate_dungeon_vram_address_index_lo  db
    r_calculate_dungeon_vram_address_index_hi  db
.ende

.define r_get_npc_pixel_coordinates_result_x                     $0618 ; 16-bit
.define r_get_npc_pixel_coordinates_result_y                     $061A ; 16-bit

.define r_get_tile_properties_arg_x                              $061A ; 8-bit
.define r_get_tile_properties_arg_y                              $061B ; 8-bit

.define r_get_tile_properties_result_properties                  $061E ; 16-bit
.define r_get_tile_properties_result_properties_lo               $061E ; 8-bit
.define r_get_tile_properties_result_properties_hi               $061F ; 8-bit
.define r_draw_explosion_sprite_x                                $0620 ; 8-bit
.define r_draw_explosion_sprite_y                                $0621 ; 8-bit
.define r_draw_explosion_index                                   $0624 ; 16-bit

.define r_load_earth_moon_transition_background_index            $063D ; 16-bit
.define r_load_earth_moon_transition_background_index_lo         $063D ; 8-bit
.define r_load_earth_moon_transition_background_index_hi         $063E ; 8-bit
.define r_copy_outdoor_tilemap_to_vram_tilemap_offset            $063D ; 16-bit
.define r_copy_outdoor_tilemap_to_vram_tilemap_offset_lo         $063D ; 8-bit
.define r_copy_outdoor_tilemap_to_vram_tilemap_offset_hi         $063E ; 8-bit
.define r_get_plot_flag_index_result                             $063D ; 16-bit
.define r_load_outdoor_tilemap_row_arg_index                     $063D ; 16-bit
.define r_get_plot_flag_index_result_lo                          $063D ; 8-bit
.define r_get_plot_flag_index_result_hi                          $063E ; 8-bit
.define r_load_outdoor_tilemap_row_arg_index_lo                  $063D ; 8-bit
.define r_load_outdoor_tilemap_row_arg_index_hi                  $063E ; 8-bit
.define r_get_tile_properties_tmp_tile_index                     $063D ; 16-bit
.define r_get_tile_properties_tmp_tile_index_lo                  $063D ; 8-bit
.define r_get_tile_properties_tmp_tile_index_hi                  $063E ; 8-bit
.define r_update_pending_tiles_index                             $063D ; 16-bit
.define r_update_pending_tiles_index_lo                          $063D ; 8-bit
.define r_update_pending_tiles_index_hi                          $063E ; 8-bit
.define r_load_dungeon_tilemap_index                             $063D ; 16-bit
.define r_load_dungeon_tilemap_index_lo                          $063D ; 8-bit
.define r_load_dungeon_tilemap_index_hi                          $063E ; 8-bit
.define r_get_current_trigger_offset_result                      $063D ; 16-bit
.define r_get_current_trigger_offset_result_lo                   $063D ; 8-bit
.define r_get_current_trigger_offset_result_hi                   $063E ; 8-bit

.enum $063D
    r_load_dungeon_tilemap_row_arg_coordinates instanceof coordinates
.ende

.define r_update_pending_tiles_index_initial                     $0640 ; 16-bit
.define r_update_pending_tiles_index_initial_lo                  $0640 ; 8-bit
.define r_draw_field_sprite_npcs_oam_index                       $0640 ; 16-bit
.define r_load_outdoor_tilemap_row_arg_offset                    $0640 ; 16-bit
.define r_load_outdoor_tilemap_row_arg_offset_lo                 $0640 ; 16-bit
.define r_load_outdoor_tilemap_row_arg_offset_hi                 $0641 ; 16-bit
.define r_load_dungeon_tilemap_index2                            $0640 ; 16-bit
.define r_load_dungeon_tilemap_index2_lo                         $0640 ; 8-bit
.define r_load_dungeon_tilemap_index2_hi                         $0641 ; 8-bit

.define r_update_dungeon_pending_tiles_index_initial             $0643 ; 16-bit
.define r_update_dungeon_pending_tiles_index_initial_lo          $0643 ; 8-bit
.define r_update_dungeon_pending_tiles_index_initial_hi          $0644 ; 8-bit
.define r_draw_field_sprite_npcs_base_tile                       $0643 ; 16-bit
.define r_draw_field_sprite_npcs_base_tile_lo                    $0643 ; 16-bit
.define r_draw_field_sprite_npcs_base_tile_hi                    $0644 ; 16-bit

.enum $0643
    r_update_dungeon_tilemap_row_addresses_coordinates instanceof coordinates
.ende

.define r_draw_dialog_cursor_tmp                                 $064A ; 16-bit
.define r_draw_dialog_cursor_tmp_lo                              $064A ; 8-bit
.define r_draw_dialog_cursor_tmp_hi                              $064B ; 8-bit

.define r_show_title_screen_wait                                 $0654 ; 8-bit

.define r_ppu_fade_counter                                       $0679 ; 8-bit
.define r_ppu_fade_tmp_arg                                       $0682 ; 8-bit

.define r_wait_for_x_frames_frames                               $0689 ; 16-bit
.define r_wait_for_x_frames_frames_lo                            $0689 ; 16-bit
.define r_wait_for_x_frames_frames_hi                            $068A ; 16-bit
.define r_decode_event_opcode_red_wings_north_over_ordeals_index $0689 ; 16-bit

.define r_copy_field_sprite_to_vram_arg_slot                     $06AE ; 8-bit
.define r_load_npcs_tmp_npc_index                                $06AF ; 8-bit
.define r_load_npcs_tmp_npc_index_lo                             $06AF ; 8-bit

.bank 0 slot 1
.section "Bank" namespace "bank00"

; main ($00:8000)
;
; This is the reset handler. The additional entry point at main_no_title_screen
; skips some of the early initialization as well as the title screen. This is
; used when the party dies during a battle to return to the save game screen.
main:
    SEI                                                                         ; $008000 | Disable interrupts
    CLC                                                                         ; $008001 |\ Enter native mode.
    XCE                                                                         ; $008002 |/
    REP #FLAG_P_INDEX                                                           ; $008003 | Use 16-bit index registers.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $008005 | Use 8-bit accumulator.
    STZ reg_cpu_memsel.w                                                        ; $008007 | Set memory cycle speed to 2.68Mhz.
    STZ reg_cpu_mdmaen.w                                                        ; $00800A | Initialize DMA.
    STZ reg_cpu_hdmaen.w                                                        ; $00800D | Initialize H-DMA.
    LDA #%10001111.b                                                            ; $008010 |\ Force PPU to blank and set brightness to max.
    STA reg_ppu_inidisp.w                                                       ; $008012 |/
    LDA #%00000000.b                                                            ; $008015 |\ Disable NMI, timer interrupts, and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $008017 |/
    LDA #0.b                                                                    ; $00801A |\
    XBA                                                                         ; $00801C | | Set 16-bit accumulator to zero.
    LDA #$00.b                                                                  ; $00801D |/
    PHA                                                                         ; $00801F |\ Set data bank register to zero.
    PLB                                                                         ; $008020 |/
    LDX #$0600                                                                  ; $008021 |\
    PHX                                                                         ; $008024 | | Set direct register to $0600.
    PLD                                                                         ; $008025 |/
    LDX #$02FF                                                                  ; $008026 |\ Set stack register to $02FF.
    TXS                                                                         ; $008029 |/
    JSR init_nmi_irq_handlers                                                   ; $00802A | Initialize the NMI and IRQ handlers.
    JSL bank15.init_ppu                                                         ; $00802D | Initialize the PPU.
    JSL bank15.init_ram                                                         ; $008031 | Initialize RAM, including the PRNG.
    JSL bank04.init_apu                                                         ; $008035 | Initialize APU.
    JSL bank01.initialize_joypad_maps                                           ; $008039 | Initialize the joypad maps.
    JSR _show_title_screen                                                      ; $00803D | Execute the title screen sequence.
main_no_title_screen:
    JSL bank01.menu_load_game                                                   ; $008040 | Display the load game menu if a valid save is available.
    LDA r_encounter_seed.w                                                      ; $008044 |\
    CLC                                                                         ; $008047 | | Load the current encounter seed, add the current value of
    ADC r_frame_counter.w                                                       ; $008048 | | the frame counter, and store that back in the new encounter
    STA r_encounter_seed.w                                                      ; $00804B | | seed. Set the formation seed to twice the encounter seed,
    ASL                                                                         ; $00804E | | modulo 256.
    STA r_formation_seed.w                                                      ; $00804F |/
    LDA r_saved.w                                                               ; $008052 |\
    CMP #0.b                                                                    ; $008055 | | If the saved flag is set, branch to skip the new save code.
    BNE _calculate_perspective_and_init_ppu_map_change                          ; $008057 |/
    JSR _init_data_structures                                                   ; $008059 | Initialize several arrays in memory.
    JSR init_cecil                                                              ; $00805C | Initialize Cecil's stats and equipment.
    JSL bank15.init_spell_lists                                                 ; $00805F | Initialize the spell lists.
    JSL bank15.init_ppu                                                         ; $008063 | Initialize the PPU again.
    JSR _set_movement_speed                                                     ; $008067 | Set the movement speed based on the current vehicle.
    JSR _calculate_perspective_data                                             ; $00806A | Calculate the airship perspective data.
    LDA #1.b                                                                    ; $00806D |\ Flag that a cutscene is currently active.
    STA <r_cutscene_active                                                      ; $00806F |/
    LDA #1.b                                                                    ; $008071 |\ Set the NMI status flag (will be reset by the NMI handler).
    STA <r_nmi_status                                                           ; $008073 |/
    LDA #%00001111.b                                                            ; $008075 |\ Set the PPU brightness to maximum.
    STA <r_ppu_brightness                                                       ; $008077 |/
    LDA #%10000001                                                              ; $008079 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00807B |/
    CLI                                                                         ; $00807E | Enable interrupts.
    STZ <r_movement_direction                                                   ; $00807F | Set movement direction to reflect no movement.
    LDA #EVENT_INDEX_OPENING_EVENTS.b                                           ; $008081 |\ Execute the opening events.
    JSR _decode_event                                                           ; $008083 |/
    STZ <r_cutscene_active                                                      ; $008086 | Reset the cutscene active flag.
    JMP _main_loop                                                              ; $008088 | Jump to the main loop.

; _calculate_perspective_and_init_ppu_map_change ($00:808B)
;
; Calculates the airship perspective data and then falls through to initialize
; the PPU and finalize the map change.
_calculate_perspective_and_init_ppu_map_change:
    JSR _calculate_perspective_data                                             ; $00808B | Calculate the airship perspective data.

; _init_ppu_and_finalize_map_change ($00:808E)
;
; Initializes the PPU and animates the transition into a new map before
; jumping back to the main loop.
_init_ppu_and_finalize_map_change:
    JSL bank15.init_ppu                                                         ; $00808E | Initialize the PPU.
    JSR _set_movement_speed                                                     ; $008092 | Set the movement speed based on the current vehicle.
    LDA #1.b                                                                    ; $008095 |\ Set the NMI status flag.
    STA <r_nmi_status                                                           ; $008097 |/
    STZ <r_upper_dialog_height                                                  ; $008099 | Set the upper dialog height to zero.
    STZ <r_cutscene_active                                                      ; $00809B | Reset the cutscene active flag.
    JMP _finalize_map_change                                                    ; $00809D | Finalize the map change to the current map and return to main loop.

; _main_loop_reset_map ($00:80A0)
;
; Resets various frame counters for a new map, enables interrupts and then
; falls through to the main loop.
_main_loop_reset_map:
    STZ <r_transition_index                                                     ; $0080A0 |\
    STZ <r_map_frame_counter                                                    ; $0080A2 | | Initialize various counters to zero.
    STZ <r_movement_frame_counter                                               ; $0080A4 |/
    LDA #%10000001.b                                                            ; $0080A6 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $0080A8 |/
    JSR _do_tile_animations                                                     ; $0080AB | Do any tile animations.
    CLI                                                                         ; $0080AE | Enable interrupts.

; _main_loop ($00:80AF)
;
; This is the main field loop.
_main_loop:
    JSR _wait_for_nmi_complete_field                                            ; $0080AF | Wait for the next frame.
    STZ <r_event_complete                                                       ; $0080B2 | Reset the event complete flag.
    JSL bank15.joypad_filter_unpressed_buttons                                  ; $0080B4 | Filter any unpressed buttons.
    JSR _check_menu                                                             ; $0080B8 | Check for the player opening the menu.
    LDA <r_event_complete                                                       ; $0080BB |\
    BEQ +                                                                       ; $0080BD | | If an event completed, branch to restart the loop.
    JMP _main_loop                                                              ; $0080BF |/
+   LDA r_map_area.w                                                            ; $0080C2 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $0080C5 | | If on a dungeon map, execute the dungeon main loop code and jump
    BNE +                                                                       ; $0080C7 | | back to the main loop.
    JMP _main_loop_dungeon                                                      ; $0080C9 |/
+   LDA #7.b                                                                    ; $0080CC |\ Otherwise, start by setting the background mode to 7.
    STA reg_ppu_bgmode.w                                                        ; $0080CE |/
    JSR _handle_outdoor_triggers                                                ; $0080D1 | Handle any triggers.
    LDA <r_event_complete                                                       ; $0080D4 |\
    BEQ +                                                                       ; $0080D6 | | If an event completed, jump back to the main loop.
    JMP _main_loop                                                              ; $0080D8 |/
+   LDA <r_map_changed_by_trigger                                               ; $0080DB |\
    BEQ +                                                                       ; $0080DD | | If a map changed, finalize the map change and jump back.
    JMP _finalize_map_change                                                    ; $0080DF |/
+   JSR _check_encounter                                                        ; $0080E2 | Check for an encounter.
    LDA <r_encounter_flag                                                       ; $0080E5 |\
    BEQ +                                                                       ; $0080E7 | | If there is supposed to be an encounter, execute the battle and
    JSR _outdoor_animate_transition_and_start_battle                            ; $0080E9 | | then reinitialize the map.
    JMP _init_ppu_and_finalize_map_change                                       ; $0080EC |/
+   LDA <r_event_complete                                                       ; $0080EF |\
    BEQ +                                                                       ; $0080F1 | | If an event completed, jump back to the main loop.
    JMP _main_loop                                                              ; $0080F3 |/
+   JSR _calculate_outdoor_movement_direction                                   ; $0080F6 | Calculate the outdoor movement direction.
    LDA <r_event_complete                                                       ; $0080F9 |\
    BEQ +                                                                       ; $0080FB | | If an event completed, set the movement direction to none and jump
    STZ r_movement_direction.w                                                  ; $0080FD | | back to the main loop.
    JMP _main_loop                                                              ; $008100 |/
+   JSR _do_outdoor_movement                                                    ; $008103 | Do any outdoor movement.
    JSR _init_oam                                                               ; $008106 | Initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $008109 | Draw the outdoor field sprites.
    JSR _animate_outdoor_water_tiles                                            ; $00810C | Animate any appropriate outdoor water tiles.
    JSL bank15.handle_r_field_sprite_slot_increment                             ; $00810F | Handle the R button sprite slot increment.
    LDA <r_agart_traversal_pending                                              ; $008113 |\
    BNE +                                                                       ; $008115 | | If an Agart traversal is not pending, jump back to the main loop.
    JMP _main_loop                                                              ; $008117 |/
+   STZ <r_agart_traversal_pending                                              ; $00811A |\
    LDA r_map_area.w                                                            ; $00811C | | If the current map area is the overworld, animate the flight to
    BNE +                                                                       ; $00811F | | the underworld and jump back to the main loop, resetting the map.
    JSR _animate_flight_to_underworld                                           ; $008121 | |
    JMP _main_loop_reset_map                                                    ; $008124 |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $008127 |\
    BNE +                                                                       ; $008129 | | If in the underworld, animate the flight to the overworld and jump
    JSR _animate_flight_from_underworld                                         ; $00812B | | back to the main loop, resetting the map.
    JMP _main_loop_reset_map                                                    ; $00812E |/
+   CMP #MAP_AREA_MOON.b                                                        ; $008131 |\
    BNE +                                                                       ; $008133 | | NOTE: This pointless check for the moon map area simply jumps back
+   JMP _main_loop                                                              ; $008135 |/        to the main loop.

; _main_loop_dungeon ($00:8138)
;
;  For dungeon maps, handles triggers, movement and changes between maps, among
; other minor things.
_main_loop_dungeon:
    JSR _handle_dungeon_triggers                                                ; $008138 | Handle the tile triggers for the current tile.
    LDA <r_map_changed_by_trigger                                               ; $00813B |\
    BEQ +                                                                       ; $00813D | | If a map change was the result, finalize the map change.
    JMP _finalize_map_change                                                    ; $00813F |/
+   JSR _check_encounter                                                        ; $008142 | Check for an encounter.
    LDA <r_encounter_flag                                                       ; $008145 |\
    BEQ +                                                                       ; $008147 | | If there is an encounter, execute the encounter and then
    JSR _animate_transition_and_start_battle                                    ; $008149 | | reinitialize the map before jumping back to the main loop.
    JMP _init_ppu_and_finalize_map_change                                       ; $00814C |/
+   JSR _field_handle_a_button_press                                            ; $00814F | Handle the field A button press.
    LDA <r_encounter_flag                                                       ; $008152 |\
    BEQ +                                                                       ; $008154 | | If an encounter resulted from the button press, execute the
    JSR _animate_transition_and_start_battle                                    ; $008156 | | battle and then reinitialize the map and jump to the main loop.
    JMP _init_ppu_and_finalize_map_change                                       ; $008159 |/
+   LDA <r_event_complete                                                       ; $00815C |\
    BEQ +                                                                       ; $00815E | | If an event completed, jump to the main loop.
    JMP _main_loop                                                              ; $008160 |/
+   JSR _calculate_dungeon_movement_direction                                   ; $008163 | Calculate the dungeon movement direction.
    JSR _update_npc_movement                                                    ; $008166 | Update NPC movement directions.
    JSR _do_outdoor_movement                                                    ; $008169 | Update scroll registers and coordinates for this frame's movement.
    JSR _do_npc_movement                                                        ; $00816C | Update NPC coordinates and coordinate offsets for this frame.
    JSR _init_oam                                                               ; $00816F | Initialize the OAM.
    JSL bank15.draw_dungeon_field_sprite_player                                 ; $008172 | Draw the player field sprite.
    JSR _draw_field_sprite_npcs                                                 ; $008176 | Draw the NPCs.
    JSL bank15.handle_r_field_sprite_slot_increment                             ; $008179 | Handle the press of the R button.
    JSR _dungeon_rotate_lake_tiles                                              ; $00817D | Rotate the lake tiles on the waterway map.
    LDA <r_exiting_map                                                          ; $008180 |\ If not exiting the map, branch to be done.
    BEQ @done                                                                   ; $008182 |/
    LDX r_map_history_index.w                                                   ; $008184 |\
    DEX                                                                         ; $008187 | | Subtract three from the map history index to pop a map from the
    DEX                                                                         ; $008188 | | stack.
    DEX                                                                         ; $008189 | |
    STX r_map_history_index.w                                                   ; $00818A |/
    LDA r_map_history.1.map_id.w,X                                              ; $00818D |\
    CMP #MAP_ID_OVERWORLD.b                                                     ; $008190 | | If the map is an outdoor map, fade the audio out.
    BCC +                                                                       ; $008192 | |
    JSR _audio_fade_out                                                         ; $008194 |/
+   JSR _do_out_transition                                                      ; $008197 | Animate the out transition.
    STZ <r_enable_triggers                                                      ; $00819A | Disable triggers.
    LDA r_map_history.1.map_id.w,X                                              ; $00819C |\
    SEC                                                                         ; $00819F | | If the map ID is less than $FB, skip the next block.
    SBC #MAP_ID_OVERWORLD.b                                                     ; $0081A0 | |
    BCC +                                                                       ; $0081A2 |/
    STA r_map_area.w                                                            ; $0081A4 | Store the map ID minus $FB as the new map area.
    LDA r_map_history.1.x.w,X                                                   ; $0081A7 |\ Set the X coordinate from the history.
    STA r_current_coordinates.x.w                                               ; $0081AA |/
    LDA #DIRECTION_DOWN.b                                                       ; $0081AD |\ Set the direction to down.
    STA r_direction.w                                                           ; $0081AF |/
    LDA r_map_history.1.y.w,X                                                   ; $0081B2 |\ Set the Y coordinate from the history.
    STA r_current_coordinates.y.w                                               ; $0081B5 |/
    LDX #0.w                                                                    ; $0081B8 |\ Set the map history index to zero.
    STX r_map_history_index.w                                                   ; $0081BB |/
    JSR _audio_fade_out                                                         ; $0081BE | Fade the audio out.
    JMP _finalize_map_change                                                    ; $0081C1 | Change to the new map and jump to the main loop.
+   LDA #MAP_AREA_DUNGEON.b                                                     ; $0081C4 |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $0081C6 |/
    LDA r_map_history.1.map_id.w,X                                              ; $0081C9 |\ Set the map ID from the history.
    STA r_map_id.w                                                              ; $0081CC |/
    LDA r_map_history.1.x.w,X                                                   ; $0081CF |\
    AND #%00111111.b                                                            ; $0081D2 | | Set the X coordinate from the history.
    STA r_current_coordinates.x.w                                               ; $0081D4 |/
    LDA r_map_history.1.x.w,X                                                   ; $0081D7 |\
    LSR A                                                                       ; $0081DA | | Set the new direction to the opposite of that recorded in the
    LSR A                                                                       ; $0081DB | | history.
    LSR A                                                                       ; $0081DC | |
    LSR A                                                                       ; $0081DD | |
    LSR A                                                                       ; $0081DE | |
    LSR A                                                                       ; $0081DF | |
    CLC                                                                         ; $0081E0 | |
    ADC #2.b                                                                    ; $0081E1 | |
    AND #%00000011.b                                                            ; $0081E3 | |
    STA r_direction.w                                                           ; $0081E5 |/
    LDA r_map_history.1.y.w,X                                                   ; $0081E8 |\ Set the Y coordinate from the history.
    STA r_current_coordinates.y.w                                               ; $0081EB |/
    JMP _finalize_map_change                                                    ; $0081EE | Change to the new map and jump to the main loop.
@done:
    JMP _main_loop                                                              ; $0081F1 | Jump to the main loop.

; _check_menu ($00:81F4)
;
; Checks for the menu button, and if pressed, displays the main menu. Also
; handles executing any events triggered as a result of the menu.
_check_menu:
    LDA <r_player_movement_calculation_enabled                                  ; $0081F4 |\
    BNE +                                                                       ; $0081F6 | | Return if player movement calculation is disabled.
    RTS                                                                         ; $0081F8 |/
+   LDA <r_joypad_x_pressed                                                     ; $0081F9 |\
    BEQ +                                                                       ; $0081FB | | Jump to done if the X button has already been handled.
    JMP @done                                                                   ; $0081FD |/
+   LDA <r_joypad_pressed_lo                                                    ; $008200 |\
    AND #JOYPAD_L_X.b                                                           ; $008202 | | Jump to done if the X button is not pressed.
    BNE +                                                                       ; $008204 | |
    JMP @done                                                                   ; $008206 |/
+   LDA #1.b                                                                    ; $008209 |\ Set the flag that indicates this code has already run.
    STA <r_joypad_x_pressed                                                     ; $00820B |/
    LDA r_map_area.w                                                            ; $00820D |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $008210 | | If this is a dungeon map, set the menu event flags to allow the
    BNE +                                                                       ; $008212 | | use of the Magazine and to allow Warp and Exit if allowed by the
    LDA r_map_properties.flags.w                                                ; $008214 | | map properties.
    AND #MAP_PROPERTIES_FLAGS_WARP_ENABLED | MAP_PROPERTIES_FLAGS_EXIT_ENABLED  ; $008217 | |
    ORA #MENU_EVENT_FLAGS_MAGAZINE.b                                            ; $008219 | |
    JMP ++                                                                      ; $00821B |/
+   LDA r_vehicle.w                                                             ; $00821E |\
    BNE +                                                                       ; $008221 | | If outdoors and not on a vehicle, set the menu event flags to
    LDA #MENU_EVENT_FLAGS_SIGHT.b                                               ; $008223 | | allow Sight.
    JMP ++                                                                      ; $008225 |/
+   LDA #%00000000                                                              ; $008228 | Otherwise, allow nothing.
++  STA r_menu_event_flags.w                                                    ; $00822A | Store the loaded value as the menu event flags.
    JSR _fade_out_and_disable_interrupts                                        ; $00822D | Fade out and disable interrupts.
    JSL bank01.menu_main                                                        ; $008230 | Execute the main menu.
    LDA r_map_area.w                                                            ; $008234 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $008237 | | If in a dungeon, set any new window color into the dialog palette.
    BNE +                                                                       ; $008239 | |
    LDX r_window_color.w                                                        ; $00823B | |
    STX r_cgram_data.1.color2.w                                                 ; $00823E |/
+   JSR _cleanup_menu_and_reinit_map                                            ; $008241 | Cleanup the menu and reinitialize the map.
    LDA r_menu_event.w                                                          ; $008244 |\ If no menu event was set, branch to the end.
    BEQ @done                                                                   ; $008247 |/
    LDA #1.b                                                                    ; $008249 |\ Set the cutscene active flag.
    STA <r_cutscene_active                                                      ; $00824B |/
    STZ <r_movement_direction                                                   ; $00824D | Set the movement direction to zero.
    LDA r_menu_event.w                                                          ; $00824F |\
    CMP #MENU_EVENT_WARP.b                                                      ; $008252 | | If the menu event was either Tent or Cabin, determine the correct
    BCS +                                                                       ; $008254 | | event index and branch to decode the event.
    LDA r_menu_event.w                                                          ; $008256 | |
    CLC                                                                         ; $008259 | |
    ADC #EVENT_INDEX_TENT.b - 1                                                 ; $00825A | |
    JMP @decode_event                                                           ; $00825C |/
+   CMP #MENU_EVENT_WARP.b                                                      ; $00825F |\
    BNE +                                                                       ; $008261 | | If the menu event was Warp, branch to decode the Warp event.
    LDA #EVENT_INDEX_WARP.b                                                     ; $008263 | |
    JMP @decode_event                                                           ; $008265 |/
+   CMP #MENU_EVENT_EXIT.b                                                      ; $008268 |\
    BNE +                                                                       ; $00826A | | If the menu event was Exit, branch to decode the Exit event.
    LDA #EVENT_INDEX_EXIT.b                                                     ; $00826C | |
    JMP @decode_event                                                           ; $00826E |/
+   CMP #MENU_EVENT_SIGHT.b                                                     ; $008271 |\
    BNE +                                                                       ; $008273 | | If the menu event was Sight, branch to decode the Sight event.
    LDA #EVENT_INDEX_SIGHT.b                                                    ; $008275 | |
    JMP @decode_event                                                           ; $008277 |/
+   CMP #MENU_EVENT_SIREN.b                                                     ; $00827A |\
    BNE +                                                                       ; $00827C | | If the menu event was Siren, set the flag to force an encounter
    LDA #1.b                                                                    ; $00827E | | and jump to skip doing an event.
    STA <r_force_encounter                                                      ; $008280 | |
    JMP ++                                                                      ; $008282 |/
+   LDA #EVENT_INDEX_MAGAZINE.b                                                 ; $008285 | Otherwise, load the Magazine event ID and fall through.
@decode_event:
    JSR _decode_event                                                           ; $008287 | Decode the loaded event.
++  STZ <r_cutscene_active                                                      ; $00828A | Reset the cutscene active flag.
    JSR _play_map_song                                                          ; $00828C | Play the song associated with the current map.
@done:
    RTS                                                                         ; $00828F

; _init_data_structures ($00:8290)
;
; Initializes various data structures in memory, including resetting the status
; of various vehicles, initializing several arrays, and adding the Sort and
; TrashCan items to the inventory.
_init_data_structures:
    STZ r_map_area.w                                                            ; $008290 |\ Initialize the map area and map plane to zero.
    STZ r_map_plane.w                                                           ; $008293 |/
    STZ r_field_sprite_slot.w                                                   ; $008296 | Set the field sprite slot to slot zero.
    STZ r_yellow_chocobo_status.w                                               ; $008299 |\
    STZ r_black_chocobo_status.w                                                ; $00829C | | Initialize the status of various vehicles to zero.
    STZ r_hovercraft_status.w                                                   ; $00829F | |
    STZ r_enterprise_status.w                                                   ; $0082A2 | |
    STZ r_falcon_status.w                                                       ; $0082A5 | |
    STZ r_big_whale_status.w                                                    ; $0082A8 | |
    STZ r_ship_status.w                                                         ; $0082AB |/
    STZ r_ship_plane.w                                                          ; $0082AE |\
    STZ r_hovercraft_plane.w                                                    ; $0082B1 | | Set the planes of the vehicles to zero.
    STZ r_enterprise_plane.w                                                    ; $0082B4 | |
    STZ r_falcon_plane.w                                                        ; $0082B7 | |
    STZ r_big_whale_plane.w                                                     ; $0082BA |/
    LDX #0.w                                                                    ; $0082BD |\ Initialize the map history index to zero.
    STX r_map_history_index.w                                                   ; $0082C0 |/
    LDX #0.w                                                                    ; $0082C3 |\
-   LDA bank12.initial_npc_status_data.l,X                                      ; $0082C6 | | Initialize the NPC status array by reading data from ROM.
    STA r_npc_status.w,X                                                        ; $0082CA | |
    INX                                                                         ; $0082CD | |
    CPX #_sizeof_r_npc_status.w                                                 ; $0082CE | |
    BNE -                                                                       ; $0082D1 |/
    LDX #0.w                                                                    ; $0082D3 |\
-   LDA bank12.initial_plot_flag_data.l,X                                       ; $0082D6 | | Initialize the plot flags array from ROM.
    STA r_plot_flags.w,X                                                        ; $0082DA | |
    INX                                                                         ; $0082DD | |
    CPX #_sizeof_r_plot_flags.w                                                 ; $0082DE | |
    BNE -                                                                       ; $0082E1 |/
    LDX #0.w                                                                    ; $0082E3 |\
-   STZ r_treasure_status.w,X                                                   ; $0082E6 | | Initialize the first half of the treasure status array.
    INX                                                                         ; $0082E9 | |
    CPX #_sizeof_r_treasure_status.w / 2                                        ; $0082EA | |
    BNE -                                                                       ; $0082ED |/
    LDA #ITEM_SORT.b                                                            ; $0082EF |\
    STA r_inventory.47.id.w                                                     ; $0082F1 | | Add the Sort and TrashCan items to the inventory.
    LDA #ITEM_TRASHCAN.b                                                        ; $0082F4 | |
    STA r_inventory.48.id.w                                                     ; $0082F6 | |
    LDA #1.b                                                                    ; $0082F9 | |
    STA r_inventory.47.count.w                                                  ; $0082FB | |
    STA r_inventory.48.count.w                                                  ; $0082FE |/
    RTS                                                                         ; $008301

; _set_movement_speed ($00:8302)
;
; Sets the current movement speed based on the current vehicle.
_set_movement_speed:
    LDA r_vehicle.w                                                             ; $008302 |\
    TAX                                                                         ; $008305 | | Read the current vehicle and use that data to look up the speed
    LDA vehicle_speed_data.w,X                                                  ; $008306 | | in the following data array.
    STA <r_movement_speed                                                       ; $008309 |/
    RTS                                                                         ; $00830B

; vehicle_speed_data ($00:830C)
;
; Contains data about the speed of each vehicle. Speed appears to be calculated
; by taking two to the power of the value here and using that as the number of
; pixels per frame.
vehicle_speed_data:
    .db MOVEMENT_SPEED_WALKING                                                  ; $00830C | $00 - Walking (0)
    .db MOVEMENT_SPEED_YELLOW_CHOCOBO                                           ; $00830D | $01 - Yellow Chocobo (1)
    .db MOVEMENT_SPEED_BLACK_CHOCOBO                                            ; $00830E | $02 - Black Chocobo (2)
    .db MOVEMENT_SPEED_HOVERCRAFT                                               ; $00830F | $03 - Hovercraft (1)
    .db MOVEMENT_SPEED_ENTERPRISE                                               ; $008310 | $04 - Enterprise (3)
    .db MOVEMENT_SPEED_FALCON                                                   ; $008311 | $05 - Falcon (3)
    .db MOVEMENT_SPEED_BIG_WHALE                                                ; $008312 | $06 - Big Whale (3)

; _finalize_map_change ($00:8313)
;
; Executes a map change and animates the in transition. Assumes any out
; transition has already been handled.
_finalize_map_change:
    LDA r_map_area.w                                                            ; $008313 |\
    BNE +                                                                       ; $008316 | | If the map area is the overworld, change map to the overworld, do
    JSR _change_map_overworld                                                   ; $008318 | | the in transition, and then return to the main loop.
    JSR _do_in_transition                                                       ; $00831B | |
    JMP _main_loop_reset_map                                                    ; $00831E |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $008321 |\
    BNE +                                                                       ; $008323 | | If the map area is the underworld, change map to the underworld,
    JSR _change_map_underworld                                                  ; $008325 | | do the in transition, and then return to the main loop.
    JSR _do_in_transition                                                       ; $008328 | |
    JMP _main_loop_reset_map                                                    ; $00832B |/
+   CMP #MAP_AREA_MOON.b                                                        ; $00832E |\
    BNE +                                                                       ; $008330 | | If the map area is the moon, change map to the moon, do the in
    JSR _change_map_moon                                                        ; $008332 | | transition and then return to the main loop.
    JSR _do_in_transition                                                       ; $008335 | |
    JMP _main_loop_reset_map                                                    ; $008338 |/
+   LDA <r_encounter_flag                                                       ; $00833B |\
    BEQ +                                                                       ; $00833D | | Otherwise, change map to a dungeon map, do the in transition, and
    JSR _change_map_dungeon_resume                                              ; $00833F | | return. If the encounter flag is set, execute the resume version.
    JMP ++                                                                      ; $008342 | | Otherwise, do the full version.
+   JSR _change_map_dungeon                                                     ; $008345 | |
++  JSR _do_in_transition                                                       ; $008348 | |
    JMP _main_loop_reset_map                                                    ; $00834B |/

; _init_map ($00:834E)
;
; Does a series of initializations in preparation for loading a new map.
_init_map:
    LDA #%10000000                                                              ; $00834E |\ Set forced blanking and brightness to zero.
    STA reg_ppu_inidisp                                                         ; $008350 |/
    STZ reg_cpu_hdmaen                                                          ; $008353 | Reset HDMA.
    STZ reg_cpu_nmitimen                                                        ; $008356 | Disable NMI, timer interrupts and joypad reading.
    SEI                                                                         ; $008359 | Disable interrupts.
    JSR _init_oam                                                               ; $00835A | Initialize the OAM.
    STZ <r_map_frame_counter                                                    ; $00835D | Reset the map frame counter.
    STZ <r_tilemap_dirty                                                        ; $00835F | Set the tilemap as clean.
    STZ <r_dialog_pending                                                       ; $008361 |\
    STZ <r_map_title_pending                                                    ; $008363 | | Clear various flags.
    STZ <r_dialog_pending                                                       ; $008365 | |
    STZ <r_dialog_erase_pending                                                 ; $008367 | |
    STZ <r_upper_dialog_text_pending                                            ; $008369 | |
    STZ <r_map_title_erase_pending                                              ; $00836B | |
    STZ <r_dialog_cursor_erase_pending                                          ; $00836D |/
    STZ <r_unknown_06e8                                                         ; $00836F |\
    STZ <r_tile_change_pending                                                  ; $008371 | | Clear some additional flags.
    STZ <r_movement_direction                                                   ; $008373 | |
    STZ <r_disable_direction_change                                             ; $008375 | |
    STZ <r_lower_dialog_height                                                  ; $008377 | |
    STZ <r_disable_background_scroll_updates                                    ; $008379 | |
    STZ <r_enable_flash_palette                                                 ; $00837B | |
    STZ <r_damaged_character_count                                              ; $00837D |/
    LDA #1.b                                                                    ; $00837F |\
    STA <r_joypad_a_pressed                                                     ; $008381 | | Initialize the button pressed flags to 1.
    STA <r_joypad_b_pressed                                                     ; $008383 | |
    STA <r_joypad_x_pressed                                                     ; $008385 | |
    STA <r_joypad_y_pressed                                                     ; $008387 | |
    STA <r_joypad_l_pressed                                                     ; $008389 | |
    STA <r_joypad_r_pressed                                                     ; $00838B | |
    STA <r_joypad_select_pressed                                                ; $00838D | |
    STA <r_joypad_start_pressed                                                 ; $00838F |/
    STZ <r_scroll_horizontal_offset_lo                                          ; $008391 |\
    STZ <r_scroll_horizontal_offset_hi                                          ; $008393 | | Reset the scrolling offsets to zero.
    STZ <r_scroll_vertical_offset_lo                                            ; $008395 | |
    STZ <r_scroll_vertical_offset_hi                                            ; $008397 |/
    LDA #16.b                                                                   ; $008399 |\ Set the zoom level to normal.
    STA <r_zoom_level                                                           ; $00839B |/
    LDX #0.w                                                                    ; $00839D |\ Set the swirl effect phase to zero.
    STX r_field_effect_swirl_current_phase.w                                    ; $0083A0 |/
    RTS                                                                         ; $0083A3

; _change_map_dungeon ($00:83A4)
;
; Goes through the necessary procedures to change the current map to a dungeon
; map. Expects the map plane, ID and coordinates to already be set. The _resume
; entry point allows the game to resume using an already loaded map. This
; variant is used after battle.
_change_map_dungeon:
    JSR _init_map                                                               ; $0083A4 | Initialize various map-related variables.
    JSR _remove_float_status                                                    ; $0083A7 | Remove float status from any character who has it.
    STZ <r_movement_speed                                                       ; $0083AA | Set the movement speed to walking speed.
    LDA r_map_id.w                                                              ; $0083AC |\
    STA <r_change_map_dungeon_index_lo                                          ; $0083AF | | This long piece of code calculates the index into the map property
    STZ <r_change_map_dungeon_index_hi                                          ; $0083B1 | | data. The base value is $XXYY where XX is the map plane and YY is
    LDA r_map_plane.w                                                           ; $0083B3 | | the map ID. This value is then multiplied by 13 (as each entry has
    BEQ +                                                                       ; $0083B6 | | 13 bytes).
    INC <r_change_map_dungeon_index_hi                                          ; $0083B8 | |
+   ASL <r_change_map_dungeon_index_lo                                          ; $0083BA | |
    ROL <r_change_map_dungeon_index_hi                                          ; $0083BC | |
    ASL <r_change_map_dungeon_index_lo                                          ; $0083BE | |
    ROL <r_change_map_dungeon_index_hi                                          ; $0083C0 | |
    LDX <r_change_map_dungeon_index                                             ; $0083C2 | |
    STX <r_change_map_dungeon_index2                                            ; $0083C4 | |
    ASL <r_change_map_dungeon_index_lo                                          ; $0083C6 | |
    ROL <r_change_map_dungeon_index_hi                                          ; $0083C8 | |
    LDA <r_change_map_dungeon_index_lo                                          ; $0083CA | |
    CLC                                                                         ; $0083CC | |
    ADC <r_change_map_dungeon_index2_lo                                         ; $0083CD | |
    STA <r_change_map_dungeon_index_lo                                          ; $0083CF | |
    LDA <r_change_map_dungeon_index_hi                                          ; $0083D1 | |
    ADC <r_change_map_dungeon_index2_hi                                         ; $0083D3 | |
    STA <r_change_map_dungeon_index_hi                                          ; $0083D5 | |
    LDA <r_change_map_dungeon_index_lo                                          ; $0083D7 | |
    CLC                                                                         ; $0083D9 | |
    ADC r_map_id.w                                                              ; $0083DA | |
    STA <r_change_map_dungeon_index_lo                                          ; $0083DD | |
    LDA r_map_plane.w                                                           ; $0083DF | |
    BEQ +                                                                       ; $0083E2 | |
    LDA #$01.b                                                                  ; $0083E4 | |
+   ADC <r_change_map_dungeon_index_hi                                          ; $0083E6 | |
    STA <r_change_map_dungeon_index_hi                                          ; $0083E8 | |
    LDX <r_change_map_dungeon_index                                             ; $0083EA |/
    LDY #$0000.w                                                                ; $0083EC |\
-   LDA bank15.map_property_data.l,X                                            ; $0083EF | | Copies the properties for the current map from ROM to RAM.
    STA r_map_properties,Y                                                      ; $0083F3 | |
    INX                                                                         ; $0083F6 | |
    INY                                                                         ; $0083F7 | |
    CPY #_sizeof_map_properties.w                                               ; $0083F8 | |
    BNE -                                                                       ; $0083FB |/
    LDA bank15.map_property_data.l + map_properties.treasure_index,X            ; $0083FD |\
    SEC                                                                         ; $008401 | | Calculate the treasure count by subtracting the current treasure
    SBC r_map_properties.treasure_index.w                                       ; $008402 | | index from the next map's (the X register hasn't been reset).
    STA r_map_treasure_count.w                                                  ; $008405 |/
    LDA r_map_properties.tilemap.w                                              ; $008408 |\ Copy the tilemap index to another location.
    STA r_tilemap.w                                                             ; $00840B |/
    LDA r_map_properties.tileset.w                                              ; $00840E |\
    STA <r_change_map_dungeon_index_hi                                          ; $008411 | | Copy the tile properties for this map's tileset to RAM.
    STZ <r_change_map_dungeon_index_lo                                          ; $008413 | |
    LDX <r_change_map_dungeon_index                                             ; $008415 | |
    LDY #$0000.w                                                                ; $008417 | |
-   LDA bank14.dungeon_tile_property_data.l,X                                   ; $00841A | |
    STA r_tile_properties,Y                                                     ; $00841E | |
    INX                                                                         ; $008421 | |
    INY                                                                         ; $008422 | |
    CPY #$0100.w                                                                ; $008423 | |
    BNE -                                                                       ; $008426 |/
    LDA r_map_properties.tileset.w                                              ; $008428 |\
    ASL A                                                                       ; $00842B | | Calculate an index by multiplying the tileset number by $400.
    ASL A                                                                       ; $00842C | | In other words, 4 bytes for each of the 256 tiles.
    STA <r_change_map_dungeon_index_hi                                          ; $00842D | |
    STZ <r_change_map_dungeon_index_lo                                          ; $00842F | |
    LDX <r_change_map_dungeon_index                                             ; $008431 |/
    LDA #$7F.b                                                                  ; $008433 |\
    PHA                                                                         ; $008435 | | Set the data bank register to $7F.
    PLB                                                                         ; $008436 |/
    LDY #$0000.w                                                                ; $008437 |\
-   LDA bank14.tile_composition_dungeon_data.l,X                                ; $00843A | | Copy the tile composition data from ROM to RAM.
    STA r_tile_composition_data & $FFFF,Y                                       ; $00843E | |
    INX                                                                         ; $008441 | |
    INY                                                                         ; $008442 | |
    CPY #_sizeof_r_tile_composition_data.w                                      ; $008443 | |
    BNE -                                                                       ; $008446 |/
    LDA #$00.b                                                                  ; $008448 |\
    PHA                                                                         ; $00844A | | Set the data bank register to $00.
    PLB                                                                         ; $00844B |/
    JSR _copy_dungeon_tilemap_to_vram                                           ; $00844C | Copy the dungeon tilemap to VRAM.
    JSR _load_npcs                                                              ; $00844F | Load the map's NPCs.
_change_map_dungeon_resume:
    JSR _init_map                                                               ; $008452 | Initialize some map variables.
    LDA #$17.b                                                                  ; $008455 |\ Set BG1, BG2, BG3 and OBJ as main screens.
    STA reg_ppu_tm                                                              ; $008457 |/
    LDA #$09.b                                                                  ; $00845A |\ Set BG mode to 1 and make BG3 highest priority.
    STA reg_ppu_bgmode                                                          ; $00845C |/
    JSL bank15.load_dialog_palettes                                             ; $00845F | Load the dialog palettes to the first palette.
    LDX #$2000.w                                                                ; $008463 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $008466 | | Copy the dialog tile data to the BG3 tile data in VRAM.
    LDX #bank0A._sizeof_dialog_tile_data.w                                      ; $008468 | |
    STX <r_start_vram_dma_arg_bytes                                             ; $00846B | |
    LDA #:bank0A.dialog_tile_data.b                                             ; $00846D | |
    STA <r_start_vram_dma_arg_bank                                              ; $00846F | |
    LDX #bank0A.dialog_tile_data.w                                              ; $008471 | |
    STX <r_start_vram_dma_arg_address                                           ; $008474 | |
    JSL bank15.start_vram_dma                                                   ; $008476 |/
    LDX #$2800.w                                                                ; $00847A |\
    STX <r_start_fixed_vram_dma_arg_vram_target                                 ; $00847D | | Fill the remainder of BG3's tile area with zeroes.
    LDX #$1000.w                                                                ; $00847F | |
    STX <r_start_fixed_vram_dma_arg_bytes                                       ; $008482 | |
    STZ <r_start_fixed_vram_dma_arg_value                                       ; $008484 | |
    JSL bank15.start_fixed_vram_dma                                             ; $008486 |/
    JSL bank15.load_tileset_tiles                                               ; $00848A | Load the tiles for the current tilset into VRAM.
    LDA r_map_properties.fill_tile.w                                            ; $00848E |\
    AND #%01111111.b                                                            ; $008491 | | Fill the tilemap with the map's fill tile.
    JSR _fill_tilemap                                                           ; $008493 |/
    JSL bank15.load_dungeon_palette                                             ; $008496 | Load the appropriate dungeon palette.
    JSL bank15.calculate_alternate_cgram                                        ; $00849A | Calculate the alternate CG-RAM used for flash effects.
    LDA <r_encounter_flag                                                       ; $00849E |\
    BNE +                                                                       ; $0084A0 | | If the encounter flag is not set and there is no cutscene active,
    LDA <r_cutscene_active                                                      ; $0084A2 | | draw the map's title.
    BNE +                                                                       ; $0084A4 | |
    JSR _load_map_title                                                         ; $0084A6 |/
+   STZ <r_exiting_map                                                          ; $0084A9 | Reset the exiting map flag.
    STZ <r_encounter_flag                                                       ; $0084AB | Reset the encounter flag.
    LDA <r_cutscene_active                                                      ; $0084AD |\
    BNE +                                                                       ; $0084AF | | If a cutscene is not active, play the appropriate map song.
    JSR _play_map_song                                                          ; $0084B1 |/
+   LDA <r_ppu_color_subtraction_intensity                                      ; $0084B4 |\ If a color math intensity is set, branch to the code that handles
    BNE ++                                                                      ; $0084B6 |/ the subtraction.
    LDA #%00010001.b                                                            ; $0084B8 |\ Set BG1 and OBJ as the sub screen.
    STA reg_ppu_ts                                                              ; $0084BA |/
    LDA r_map_properties.background_properties.w                                ; $0084BD |\
    LSR A                                                                       ; $0084C0 | | If the low bit of map property 10 is set, enable color addition
    BCC +                                                                       ; $0084C1 | | with the sub screen, with the 1/2 effect on BG1 and BG2.
    LDA #%00000010.b                                                            ; $0084C3 | |
    STA reg_ppu_cgswsel                                                         ; $0084C5 | |
    LDA #%01000011.b                                                            ; $0084C8 | |
    STA reg_ppu_cgadsub                                                         ; $0084CA | |
    JMP +++                                                                     ; $0084CD |/
+   STZ reg_ppu_cgswsel                                                         ; $0084D0 |\
    STZ reg_ppu_cgadsub                                                         ; $0084D3 | | Otherwise, disable color addition.
    JMP +++                                                                     ; $0084D6 |/
++  STZ reg_ppu_ts                                                              ; $0084D9 |\
    LDA #%10000011.b                                                            ; $0084DC | | If $0681 was set, instead enable subtraction on BG1 and BG2, with
    STA reg_ppu_cgadsub                                                         ; $0084DE | | the color selection coming from $0683 and the intensity coming
    LDA <r_ppu_color_subtraction_target                                         ; $0084E1 | | from $0681.
    AND #%11100000.b                                                            ; $0084E3 | |
    ORA <r_ppu_color_subtraction_intensity                                      ; $0084E5 | |
    STA reg_ppu_coldata                                                         ; $0084E7 |/
+++ JSR _copy_dungeon_background_tilemap_to_vram                                ; $0084EA | Copy the dungeon background tilemap to VRAM.
    JSR _copy_dungeon_tilemap_to_vram                                           ; $0084ED | Copy the dungeon tilemap to VRAM.
    JSL bank15.load_dungeon_animated_tiles                                      ; $0084F0 | Load the dungeon's animated tiles.
    JSR _load_waterway_lake_tiles                                               ; $0084F4 | Load the waterway lake tiles.
    JSL bank15.copy_animated_tiles_to_vram                                      ; $0084F7 | Copy animated tiles to VRAM.
    JSR _copy_player_and_whirlpool_field_sprites_to_vram                        ; $0084FB | Copy the player field sprites to VRAM.
    JSR _calculate_background_scroll                                            ; $0084FE | Calculate the initial background scroll values.
    RTS                                                                         ; $008501

; _change_map_overworld ($00:8502)
;
; Sets the current map to the overworld. Does not set the map area variable.
_change_map_overworld:
    JSR _init_map                                                               ; $008502 | Initialize various map-related variables.
    JSR _load_map_outdoor                                                       ; $008505 | Load the outdoor map tile data.
    STZ r_map_plane.w                                                           ; $008508 | Set the plane to zero.
    STZ r_map_area_outdoor.w                                                    ; $00850B | Set the outdoor map area to zero.
    JSR _copy_water_tiles_from_vram                                             ; $00850E | Copy the water tiles from VRAM so they can be modified.
    LDA #:bank14.overworld_palette_data.b                                       ; $008511 |\
    LDX #bank14.overworld_palette_data.w                                        ; $008513 | | Load the overworld palette data to the CG-RAM staging area.
    JSR _load_tile_palettes                                                     ; $008516 |/
    LDA #:bank14.tile_composition_overworld_data.b                              ; $008519 |\
    LDY #bank14.tile_composition_overworld_data.w                               ; $00851B | | Load the overworld tile composition data from $14:8000.
    JSR _load_tile_composition_data                                             ; $00851E |/
    LDX #$0000.w                                                                ; $008521 |\
-   LDA bank14.overworld_tile_property_data.l,X                                 ; $008524 | | Copy the overworld tile property data to RAM.
    STA r_tile_properties.w,X                                                   ; $008528 | |
    INX                                                                         ; $00852B | |
    CPX #bank14._sizeof_overworld_tile_property_data.w                          ; $00852C | |
    BNE -                                                                       ; $00852F |/
    JSR _copy_player_and_outdoor_field_sprites_to_vram                          ; $008531 | Copy the player and outdoor field sprites to VRAM.
    JSR _copy_outdoor_tilemap_to_vram                                           ; $008534 | Copy the overworld tilemap to VRAM.
    JSL bank15.configure_map_hdma                                               ; $008537 | Configure the HDMA for the map perspective effect.
    RTS                                                                         ; $00853B

; _change_map_underworld ($00:853C)
;
; Sets the current map to the underworld. Does not set the map area variable.
_change_map_underworld:
    JSR _init_map                                                               ; $00853C | Initialize various map-related variables.
    JSR _load_map_outdoor                                                       ; $00853F | Load the outdoor map tile data.
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $008542 |\ Set the plane to underworld.
    STA r_map_plane.w                                                           ; $008544 |/
    STZ r_map_area_outdoor.w                                                    ; $008547 | Set the outdoor map area to zero. BUG?
    JSR _copy_magma_tiles_from_vram                                             ; $00854A | Copy the magma tiles from VRAM so they can be modified.
    LDA #:bank14.underworld_palette_data.b                                      ; $00854D |\
    LDX #bank14.underworld_palette_data.w                                       ; $00854F | | Load the underworld palette data to the CG-RAM staging area.
    JSR _load_tile_palettes                                                     ; $008552 |/
    LDA #:bank14.tile_composition_underworld_data.b                             ; $008555 |\
    LDY #bank14.tile_composition_underworld_data.w                              ; $008557 | | Load the underworld tile composition data.
    JSR _load_tile_composition_data                                             ; $00855A |/
    LDX #$0000.w                                                                ; $00855D |\
-   LDA bank14.underworld_tile_property_data.l,X                                ; $008560 | | Copy the underworld tile property data to RAM.
    STA r_tile_properties.w,X                                                   ; $008564 | |
    INX                                                                         ; $008567 | |
    CPX #$0100.w                                                                ; $008568 | |
    BNE -                                                                       ; $00856B |/
    JSR _copy_player_and_outdoor_field_sprites_to_vram                          ; $00856D | Copy the player and outdoor field sprites to VRAM.
    JSR _copy_outdoor_tilemap_to_vram                                           ; $008570 | Copy the underworld tilemap to VRAM.
    RTS                                                                         ; $008573

; _change_map_moon ($00:8574)
;
; Sets the current map to the moon. Does not set the map area variable. Operates
; very similarly to the overworld version, but doesn't copy the nonexistent
; water tiles to RAM, and it does not call the function to configure HDMA.
_change_map_moon:
    JSR _init_map                                                               ; $008574 | Initialize various map-related variables.
    JSR _load_map_outdoor                                                       ; $008577 | Load the outdoor map tile data.
    LDA #MAP_PLANE_MOON.b                                                       ; $00857A |\ Set the plane to the moon.
    STA r_map_plane.w                                                           ; $00857C |/
    LDA #MAP_AREA_MOON.b                                                        ; $00857F |\ Set the outdoor map area to the moon.
    STA r_map_area_outdoor.w                                                    ; $008581 |/
    LDA #:bank14.moon_palette_data.b                                            ; $008584 |\
    LDX #bank14.moon_palette_data.w                                             ; $008586 | | Load the moon palette data to the CG-RAM staging area.
    JSR _load_tile_palettes                                                     ; $008589 |/
    LDA #:bank14.tile_composition_moon_data.b                                   ; $00858C |\
    LDY #bank14.tile_composition_moon_data.w                                    ; $00858E | | Load the moon tile composition data from $14:8A00.
    JSR _load_tile_composition_data                                             ; $008591 |/
    LDX #$0000.w                                                                ; $008594 |\
-   LDA bank14.moon_tile_property_data.l,X                                      ; $008597 | | Copy the moon tile property data to RAM.
    STA r_tile_properties.w,X                                                   ; $00859B | |
    INX                                                                         ; $00859E | |
    CPX #$0100.w                                                                ; $00859F | |
    BNE -                                                                       ; $0085A2 |/
    JSR _copy_player_and_outdoor_field_sprites_to_vram                          ; $0085A4 | Copy the player and outdoor field sprites to VRAM.
    JSR _copy_outdoor_tilemap_to_vram                                           ; $0085A7 | Copy the moon tilemap to VRAM.
    RTS                                                                         ; $0085AA

; _load_map_outdoor ($00:85AB)
;
; Loads an outdoor map and configures the graphics display accordingly. In
; addition, it removes any character's float status, sets the player's facing
; direction to down if not resuming from an encounter and plays the song
; associated with the new map. This function assumes the map area variable has
; already been set.
_load_map_outdoor:
    JSR _remove_float_status                                                    ; $0085AB | Remove float status from all characters.
    STZ <r_exiting_map                                                          ; $0085AE | Reset the exiting map flag.
    LDA <r_encounter_flag                                                       ; $0085B0 |\
    BNE +                                                                       ; $0085B2 | | If the encounter flag is not set, change the player's direction to
    LDA #DIRECTION_DOWN.b                                                       ; $0085B4 | | face down.
    STA r_direction.w                                                           ; $0085B6 | |
+   STZ <r_encounter_flag                                                       ; $0085B9 |/
    LDA #$07.b                                                                  ; $0085BB |\ Set the background mode to mode 7.
    STA reg_ppu_bgmode                                                          ; $0085BD |/
    LDA #%00010001.b                                                            ; $0085C0 |\ Set BG1 and OAM as the main screen.
    STA reg_ppu_tm                                                              ; $0085C2 |/
    STZ reg_ppu_cgswsel                                                         ; $0085C5 | Set fixed color and disable direct color.
    STZ reg_ppu_cgadsub                                                         ; $0085C8 | Disable color addition/subtraction.
    LDA <r_cutscene_active                                                      ; $0085CB |\
    BNE +                                                                       ; $0085CD | | If not in a cut scene, switch to the map's song.
    JSR _play_map_song                                                          ; $0085CF |/
+   JSL bank15.load_map_outdoor_tiles                                           ; $0085D2 | Load the map tiles to VRAM.
    JSL bank15.calculate_alternate_cgram                                        ; $0085D6 | Calculate the alternate CG-RAM palette data.
    RTS                                                                         ; $0085DA

; _remove_float_status ($00:85DB)
;
; Removes float status from the field character records of any characters who
; have it set.
_remove_float_status:
    LDX #$0000.w                                                                ; $0085DB |\
-   LDA r_character_field.1.status_2.w,X                                        ; $0085DE | | Loop through the five field character records, removing float
    AND #STATUS_2_FLOAT.b ~ %11111111                                           ; $0085E1 | | status from any that have it set.
    STA r_character_field.1.status_2.w,X                                        ; $0085E3 | |
    JSR _increment_x_by_64                                                      ; $0085E6 | |
    CPX #$0140.w                                                                ; $0085E9 | |
    BNE -                                                                       ; $0085EC |/
    RTS                                                                         ; $0085EE

; _disable_interrupts ($00:85EF)
;
; Disables NMI, IRQ and joypad reading. Enables forced blanking and sets the
; brightness to zero.
_disable_interrupts:
    LDA #%10000000                                                              ; $0085EF |\ Enable forced blanking and set brightness to 0.
    STA reg_ppu_inidisp                                                         ; $0085F1 |/
    LDA #%00000000                                                              ; $0085F4 |\ Disable NMI, timer interrupts and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $0085F6 |/
    RTS                                                                         ; $0085F9

; _show_title_screen ($00:85FA)
;
; Executes the entire title screen sequence, including music, fade-in, waiting
; for a button press, and fade-out.
;
; The Japanese version of the title screen is more complicated, and utilizes
; palette cycling to create some graphical effects.
_show_title_screen:
    JSR _disable_interrupts                                                     ; $0085FA | Blank the screen and disable interrupts.
    STZ reg_cpu_mdmaen.w                                                        ; $0085FD |\ Disable DMA and H-DMA.
    STZ reg_cpu_hdmaen.w                                                        ; $008600 |/
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $008603 |\
    STA r_play_audio_arg_mode.w                                                 ; $008605 | | Play the Prelude music.
    LDA #AUDIO_TRACK_PRELUDE.b                                                  ; $008608 | |
    STA r_play_audio_arg_track.w                                                ; $00860A | |
    JSL bank04.play_audio                                                       ; $00860D |/
    JSL bank15.init_ppu                                                         ; $008611 | Initialize the PPU.
    LDA #MAP_AREA_DUNGEON.b                                                     ; $008615 |\ Set current map area to 3 (dungeon), which ensures this screen is
    STA r_map_area.w                                                            ; $008617 |/ treated as non-mode 7 by various routines.
.if FF4_REGION == "JAPAN"
    LDA #%00010011.b                                                            ; $00861A |\ Set the main screen to BG1, BG2 and sprites.
    STA reg_ppu_tm.w                                                            ; $00861C |/
    LDA #%00000010.b                                                            ; $00861F |\ Set the sub screen to BG2.
    STA reg_ppu_ts.w                                                            ; $008621 |/
    STA reg_ppu_cgswsel.w                                                       ; $008624 | Set color math to use the sub screen.
    LDA #%01000011.b                                                            ; $008627 |\ Set color math to add 1/2 to BG1 and BG2.
    STA reg_ppu_cgadsub.w                                                       ; $008629 |/
    LDA #1.b                                                                    ; $00862C |\ Set the background mode to 1.
    STA reg_ppu_bgmode.w                                                        ; $00862E |/
    JSR _init_oam                                                               ; $008631 | Initialize the OAM.
.if FF4_EASYTYPE == 1
    LDX #VRAM_PROLOGUE_TILES_BG.w                                               ; $008634 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $008637 | | For the Easytype release, copy the title screen tiles to VRAM with
    LDX #bank08._sizeof_title_screen_tile_data                                  ; $008639 | | a couple of DMA calls.
    STX <r_start_vram_dma_arg_bytes                                             ; $00863C | |
    LDA #:bank08.title_screen_tile_data                                         ; $00863E | |
    STA <r_start_vram_dma_arg_bank                                              ; $008640 | |
    LDX #bank08.title_screen_tile_data.w                                        ; $008642 | |
    STX <r_start_vram_dma_arg_address                                           ; $008645 | |
    JSL bank15.start_vram_dma                                                   ; $008647 | |
    LDX #VRAM_PROLOGUE_TILES_OAM.w                                              ; $00864B | |
    STX <r_start_vram_dma_arg_vram_target                                       ; $00864E | |
    JSL bank15.start_vram_dma                                                   ; $008650 |/
.else
    JSR _copy_title_screen_tiles                                                ; $008634 | Copy the title screen tiles to VRAM.
.endif
    LDA #%10000000.b                                                            ; $008637 |\ Set the VRAM increment to 1 by 1 after writing the high byte.
    STA reg_ppu_vmainc.w                                                        ; $008639 |/
    LDX #$1800.w                                                                ; $00863C |\ Set the VRAM address to $1800.
    STX reg_ppu_vmadd.w                                                         ; $00863F |/
-   LDA #$DF.b                                                                  ; $008642 |\
    STA reg_ppu_vmdatal_write.w                                                 ; $008644 | | Set the tile number for all of BG1, BG2 and BG3 to $DF, to wipe
    STZ reg_ppu_vmdatah_write.w                                                 ; $008647 | | the screen.
    INX                                                                         ; $00864A | |
    CPX #$4000.w                                                                ; $00864B | |
    BNE -                                                                       ; $00864E |/
    LDX #VRAM_PROLOGUE_TILEMAP_BG1.w + 4 * 32                                   ; $008650 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $008653 | | Copy the tilemap for the "FINAL FANTASY IV" portion of the title
.if FF4_EASYTYPE == 1                                                           ;         | | screen to BG1, four rows down.
    LDX #bank08._sizeof_title_screen_tilemap_title_data.w                       ; $008655 | |
.else                                                                           ;         | |
    LDX #bank08._sizeof_title_screen_tilemap_title_bg1_data.w                   ; $008655 | |
.endif                                                                          ;         | |
    STX <r_start_vram_dma_arg_bytes                                             ; $008658 | |
.if FF4_EASYTYPE == 1                                                           ;         | |
    LDX #bank08.title_screen_tilemap_title_data.w                               ; $00865A | |
.else                                                                           ;         | |
    LDX #bank08.title_screen_tilemap_title_bg1_data.w                           ; $00865A | |
.endif                                                                          ;         | |
    STX <r_start_vram_dma_arg_address                                           ; $00865D | |
    JSL bank15.start_vram_dma                                                   ; $00865F |/
    LDX #VRAM_PROLOGUE_TILEMAP_BG2.w + 4 * 32                                   ; $008663 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $008666 | | Repeat for the same portion of BG2.
.if FF4_EASYTYPE == 1                                                           ;         | |
    LDX #bank08.title_screen_tilemap_title_data.w                               ; $008668 | |
.else                                                                           ;         | |
    LDX #bank08.title_screen_tilemap_title_bg2_data.w                           ; $008668 | |
.endif                                                                          ;         | |
    STX <r_start_vram_dma_arg_address                                           ; $00866B | |
    JSL bank15.start_vram_dma                                                   ; $00866D |/
    LDX #0.w                                                                    ; $008671 |\
-   LDA title_screen_copyright_oam_data.l,X                                     ; $008674 | | Copy the copyright OAM data into the OAM mirror to draw the
    STA r_oam.w,X                                                               ; $008678 | | copyright notice.
    INX                                                                         ; $00867B | |
    CPX #_sizeof_title_screen_copyright_oam_data.w                              ; $00867C | |
    BNE -                                                                       ; $00867F |/
    LDY #0.w                                                                    ; $008681 |\
    LDX #bank08.title_screen_tilemap_crystal_bg1_data.w                         ; $008684 | | Copy the tilemap for the crystal to the appropriate location on
    STX <r_copy_title_screen_crystal_row_arg_address                            ; $008687 | | BG1.
-   LDA title_screen_crystal_vram_address_data.w + word.lo,Y                    ; $008689 | |
    STA <r_copy_title_screen_crystal_row_arg_vram_target.lo                     ; $00868C | |
    LDA title_screen_crystal_vram_address_data.w + word.hi,Y                    ; $00868E | |
    STA <r_copy_title_screen_crystal_row_arg_vram_target.hi                     ; $008691 | |
    JSR _copy_title_screen_crystal_row                                          ; $008693 | |
    CPY #_sizeof_title_screen_crystal_vram_address_data.w                       ; $008696 | |
    BNE -                                                                       ; $008699 |/
    LDY #0.w                                                                    ; $00869B |\
    LDX #bank08.title_screen_tilemap_crystal_bg2_data.w                         ; $00869E | | Copy the tilemap for the crystal to the appropriate location on
    STX <r_copy_title_screen_crystal_row_arg_address                            ; $0086A1 | | BG2.
-   LDA title_screen_crystal_vram_address_data.w + word.lo,Y                    ; $0086A3 | |
    STA <r_copy_title_screen_crystal_row_arg_vram_target.lo                     ; $0086A6 | |
    LDA title_screen_crystal_vram_address_data.w + word.hi,Y                    ; $0086A8 | |
    CLC                                                                         ; $0086AB | |
    ADC #$18.b                                                                  ; $0086AC | |
    STA <r_copy_title_screen_crystal_row_arg_vram_target.hi                     ; $0086AE | |
    JSR _copy_title_screen_crystal_row                                          ; $0086B0 | |
    CPY #_sizeof_title_screen_crystal_vram_address_data.w                       ; $0086B3 | |
    BNE -                                                                       ; $0086B6 |/
    LDX #0.w                                                                    ; $0086B8 |\
-   STZ r_cgram_data.w,X                                                        ; $0086BB | | Zero out the CG-RAM mirror to clear the palette.
    INX                                                                         ; $0086BE | |
    CPX #_sizeof_r_cgram_data.w                                                 ; $0086BF | |
    BNE -                                                                       ; $0086C2 |/
    JSL bank15.copy_cgram_to_ppu                                                ; $0086C4 | Copy the CG-RAM data to the PPU.
    LDX #96.w                                                                   ; $0086C8 |\
    STX r_title_screen_japan_tmp_palette_index_text_bg1.w                       ; $0086CB | | Initialize the starting palette indexes. The respective palettes
    LDX #104.w                                                                  ; $0086CE | | won't start being updated until the index is less than 32. The
    STX r_title_screen_japan_tmp_palette_index_text_bg2.w                       ; $0086D1 | | backgrounds update 16 colors, so will update when it reaches 60.
    STX r_title_screen_japan_tmp_palette_index_sprite.w                         ; $0086D4 | | The text will have to wait until it reaches 30. Resulting delays
    LDX #72.w                                                                   ; $0086D7 | | are 48 frames (crystal), 144 frames (BG1 text), 176 frames (BG2
    STX r_title_screen_japan_tmp_palette_index_crystal.w                        ; $0086DA |/  text) and 296 frames (sprites).
    LDX #0.w                                                                    ; $0086DD |\
    STX <r_scroll_bg1_horizontal                                                ; $0086E0 | | Set the BG1 scroll values to zero.
    STX <r_scroll_bg1_vertical                                                  ; $0086E2 |/
.if FF4_EASYTYPE == 1
    STX <r_scroll_bg2_horizontal                                                ; $008701 |\ Set the BG2 horizontal and vertical scroll values to zero.
    STX <r_scroll_bg2_vertical                                                  ; $008703 |/
    LDA #1.b                                                                    ; $008705 |\ Initialize an input flag to 1.
    STA <r_joypad_a_pressed                                                     ; $008707 |/
    STA <r_skip_field_graphic_effects                                           ; $008709 | Tell the NMI handler to skip field graphic effects.
    STZ <r_map_frame_counter                                                    ; $00870B | Initialize the map frame counter to zero.
.else
    INX                                                                         ; $0086E4 |\ Set the BG2 horizontal scroll to 1.
    STX <r_scroll_bg2_horizontal                                                ; $0086E5 |/
    LDX #-1.w                                                                   ; $0086E7 |\ Set the BG2 vertical scroll to -1.
    STX <r_scroll_bg2_vertical                                                  ; $0086EA |/
    LDA #1.b                                                                    ; $0086EC |\ Initialize an input flag to 1.
    STA <r_joypad_a_pressed                                                     ; $0086EE |/
    STZ <r_map_frame_counter                                                    ; $0086F0 | Initialize the map frame counter to zero.
    LDA #1.b                                                                    ; $0086F2 |\ Tell the NMI handler to skip field graphic effects.
    STA <r_skip_field_graphic_effects                                           ; $0086F4 |/
.endif
    LDA #%00001111.b                                                            ; $0086F6 |\ Disable forced blanking and set PPU brightness to maximum.
    STA reg_ppu_inidisp.w                                                       ; $0086F8 |/
    LDA #%10000001.b                                                            ; $0086FB |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $0086FD |/
@loop_start:
-   JSR _wait_for_nmi_complete                                                  ; $008700 | Wait for the next complete NMI.
    INC <r_skip_field_graphic_effects                                           ; $008703 | Tell the NMI handler to skip field graphic effects.
    LDA <r_joypad_pressed_lo                                                    ; $008705 |\
    AND #JOYPAD_L_A.b                                                           ; $008707 | | Loop until the map frame counter mod 8 is zero. If the A button
    BNE +                                                                       ; $008709 | | is not pressed for at least one frame, and then subsequently
    STZ <r_joypad_a_pressed                                                     ; $00870B | | pressed, immediately skip to the end of the function.
    JMP ++                                                                      ; $00870D | |
+   LDA <r_joypad_a_pressed                                                     ; $008710 | |
    BNE ++                                                                      ; $008712 | |
    JMP @done                                                                   ; $008714 | |
++  LDA <r_map_frame_counter                                                    ; $008717 | |
    AND #%00000111.b                                                            ; $008719 | |
    BNE -                                                                       ; $00871B |/
    LDA #16.b                                                                   ; $00871D |\ Initialize a counter to 16.
    STA <r_generic_tmp_2                                                        ; $00871F |/
.if FF4_VERSION == "JAPAN_EASYTYPE"
    LDY #_sizeof_palette.w - 2                                                  ; $008738 | Initialize the Y register to 30.
.else
    LDY #_sizeof_palette.w                                                      ; $008721 | Initialize the Y register to 32.
.endif
    LDX r_title_screen_japan_tmp_palette_index_text_bg1.w                       ; $008724 | Initialize the X register to the current BG1 text index.
-   CPX #_sizeof_palette.w                                                      ; $008727 |\
    BCS +                                                                       ; $00872A | | If the index is less than the size of a palette, copy the
    REP #FLAG_P_ACCUMULATOR                                                     ; $00872C | | corresponding color to the second palette.
    LDA bank08.title_screen_bg1_text_palette_data.l,X                           ; $00872E | |
    STA r_cgram_data.2.w,Y                                                      ; $008732 | |
    TDC                                                                         ; $008735 | |
    XBA                                                                         ; $008736 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $008737 |/
+   DEY                                                                         ; $008739 |\
    DEY                                                                         ; $00873A | | Decrement the indexes by two and loop until all potential 15
    DEX                                                                         ; $00873B | | colors have been copied (the first color is never set, but the
    DEX                                                                         ; $00873C | | loop will execute 16 times).
    DEC <r_generic_tmp_2                                                        ; $00873D | |
    BNE -                                                                       ; $00873F |/
    LDX r_title_screen_japan_tmp_palette_index_text_bg1.w                       ; $008741 |\
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | | Update the BG1 text index by subtracting two to shift one color
    CPX #_sizeof_palette.w - 2                                                  ; $00875B | | next time through the loop.
.else                                                                           ;         | |
    CPX #_sizeof_palette.w                                                      ; $008744 | |
.endif                                                                          ;         | |
    BEQ +                                                                       ; $008747 | |
    DEX                                                                         ; $008749 | |
    DEX                                                                         ; $00874A | |
    STX r_title_screen_japan_tmp_palette_index_text_bg1.w                       ; $00874B |/
+   LDA #16.b                                                                   ; $00874E |\
    STA <r_generic_tmp_2                                                        ; $008750 | | Repeat the above process, except for the BG2 text using its index
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | | and updating the third palette.
    LDY #_sizeof_palette.w - 2                                                  ; $008769 | |
.else                                                                           ;         | |
    LDY #_sizeof_palette.w                                                      ; $008752 | |
.endif                                                                          ;         | |
    LDX r_title_screen_japan_tmp_palette_index_text_bg2.w                       ; $008755 | |
-   CPX #_sizeof_palette.w                                                      ; $008758 | |
    BCS +                                                                       ; $00875B | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $00875D | |
    LDA bank08.title_screen_bg2_text_palette_data.l,X                           ; $00875F | |
    STA r_cgram_data.3.w,Y                                                      ; $008763 | |
    TDC                                                                         ; $008766 | |
    XBA                                                                         ; $008767 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $008768 | |
+   DEX                                                                         ; $00876A | |
    DEX                                                                         ; $00876B | |
    DEY                                                                         ; $00876C | |
    DEY                                                                         ; $00876D | |
    DEC <r_generic_tmp_2                                                        ; $00876E | |
    BNE -                                                                       ; $008770 | |
    LDX r_title_screen_japan_tmp_palette_index_text_bg2.w                       ; $008772 | |
.if FF4_VERSION == "JAPAN_EASYTYPE"                                             ;         | |
    CPX #_sizeof_palette.w - 2                                                  ; $00878C | |
.else                                                                           ;         | |
    CPX #_sizeof_palette.w                                                      ; $008775 | |
.endif                                                                          ;         | |
    BEQ ++                                                                      ; $008778 | |
    DEX                                                                         ; $00877A | |
    DEX                                                                         ; $00877B | |
    STX r_title_screen_japan_tmp_palette_index_text_bg2.w                       ; $00877C |/
    LDA #16.b                                                                   ; $00877F |\
    STA <r_generic_tmp_2                                                        ; $008781 | | Repeat the above process, except for the crystal using its index
    LDY #_sizeof_palette.w                                                      ; $008783 | | and updating the fourth palette.
    LDX r_title_screen_japan_tmp_palette_index_crystal.w                        ; $008786 | |
-   CPX #_sizeof_palette.w                                                      ; $008789 | |
    BCS +                                                                       ; $00878C | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $00878E | |
    LDA bank08.title_screen_crystal_palette_data.l,X                            ; $008790 | |
    STA r_cgram_data.4.w,Y                                                      ; $008794 | |
    TDC                                                                         ; $008797 | |
    XBA                                                                         ; $008798 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $008799 | |
+   DEX                                                                         ; $00879B | |
    DEX                                                                         ; $00879C | |
    DEY                                                                         ; $00879D | |
    DEY                                                                         ; $00879E | |
    DEC <r_generic_tmp_2                                                        ; $00879F | |
    BNE -                                                                       ; $0087A1 | |
    LDX r_title_screen_japan_tmp_palette_index_crystal.w                        ; $0087A3 | |
    CPX #_sizeof_palette.w                                                      ; $0087A6 | |
    BEQ ++                                                                      ; $0087A9 | |
    DEX                                                                         ; $0087AB | |
    DEX                                                                         ; $0087AC | |
    STX r_title_screen_japan_tmp_palette_index_crystal.w                        ; $0087AD |/
++  LDX r_title_screen_japan_tmp_palette_index_sprite.w                         ; $0087B0 | Set the X register to the current sprite palette index.
    CPX #_sizeof_palette.w                                                      ; $0087B3 |\ Skip ahead if the value is 32 or greater.
    BCS +                                                                       ; $0087B6 |/
    TXA                                                                         ; $0087B8 |\
    LSR A                                                                       ; $0087B9 | | Halve the value to reduce the rate of change.
    AND #%11111110.b                                                            ; $0087BA | |
    TAX                                                                         ; $0087BC |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0087BD |\
    LDA bank14.greyscale_palette_data.l,X                                       ; $0087BF | | Set the second color in the palette directly from the ROM value.
    STA r_cgram_data.9.color2.w                                                 ; $0087C3 |/
    LDA bank14.greyscale_palette_data.l,X                                       ; $0087C6 |\
    AND #%0000000000011111.w                                                    ; $0087CA | | Set the third color in the palette to only the red channel.
    STA r_cgram_data.9.color3.w                                                 ; $0087CD | |
    TDC                                                                         ; $0087D0 | |
    XBA                                                                         ; $0087D1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0087D2 |/
+   LDX r_title_screen_japan_tmp_palette_index_sprite.w                         ; $0087D4 |\
    DEX                                                                         ; $0087D7 | | Decrement the sprite palette index by two.
    DEX                                                                         ; $0087D8 | |
    STX r_title_screen_japan_tmp_palette_index_sprite.w                         ; $0087D9 |/
    BEQ +                                                                       ; $0087DC |\ Loop until it reaches zero.
    JMP @loop_start                                                             ; $0087DE |/
+   LDX #0.w                                                                    ; $0087E1 |\
-   LDA r_cgram_data.2.w,X                                                      ; $0087E4 | | Copy the current palette data to another area in memory.
    STA r_title_screen_tmp_palette.w,X                                          ; $0087E7 | |
    INX                                                                         ; $0087EA | |
    CPX #_sizeof_r_title_screen_tmp_palette.w                                   ; $0087EB | |
    BNE -                                                                       ; $0087EE |/
    STZ <r_map_frame_counter                                                    ; $0087F0 | Reset the map frame counter to zero.
--  JSR _wait_for_nmi_complete                                                  ; $0087F2 | Wait for the next complete NMI.
    INC <r_skip_field_graphic_effects                                           ; $0087F5 | Tell the NMI handler to skip field graphic effects.
    LDA <r_joypad_pressed_lo                                                    ; $0087F7 |\
    AND #JOYPAD_L_A.b                                                           ; $0087F9 | | If the A button has been unpressed for at least one frame and is
    BNE +                                                                       ; $0087FB | | subsequently pressed, branch to the done code.
    STZ <r_joypad_a_pressed                                                     ; $0087FD | |
    JMP ++                                                                      ; $0087FF | |
+   LDA <r_joypad_a_pressed                                                     ; $008802 | |
    BNE ++                                                                      ; $008804 | |
    JMP @done                                                                   ; $008806 |/
++  LDX #0.w                                                                    ; $008809 |\
-   LDA r_title_screen_tmp_palette.w,X                                          ; $00880C | | Copy the backed up palette data back to the CG-RAM mirror.
    STA r_cgram_data.2.w,X                                                      ; $00880F | |
    INX                                                                         ; $008812 | |
    CPX #_sizeof_r_title_screen_tmp_palette.w                                   ; $008813 | |
    BNE -                                                                       ; $008816 |/
    LDA <r_map_frame_counter                                                    ; $008818 |\
    LSR A                                                                       ; $00881A | | Move on to the next iteration unless the map frame counter masked
    AND #%01111110.b                                                            ; $00881B | | by $3E is less than 22.
    CMP #22.b                                                                   ; $00881D | |
    BCS --                                                                      ; $00881F |/
    TAY                                                                         ; $008821 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $008822 | | Otherwise, set the color pointed to by that index in the second
    LDA #$FFFF.w                                                                ; $008824 | | and fourth palettes to white for this frame to create a shimmering
    STA r_cgram_data.4.color2.w,Y                                               ; $008827 | | effect.
    STA r_cgram_data.2.color2.w,Y                                               ; $00882A | |
    TDC                                                                         ; $00882D | |
    XBA                                                                         ; $00882E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00882F | |
    JMP --                                                                      ; $008831 |/
@done:
    LDA #$00.b                                                                  ; $008834 |\ Fade out the PPU at one step per frame.
    JSR _ppu_fade_out                                                           ; $008836 |/
    JSR _disable_interrupts                                                     ; $008839 | Blank the screen and disable interrupts.
    RTS                                                                         ; $00883C
.else
    LDA #%00000001                                                              ; $00861A |\ Set BG1 as main screen.
    STA reg_ppu_tm.w                                                            ; $00861C |/
    LDA #%00000001                                                              ; $00861F |\ Set BG1 as sub screen.
    STA reg_ppu_ts.w                                                            ; $008621 |/
    LDA #%00000000                                                              ; $008624 |\
    STA reg_ppu_cgswsel.w                                                       ; $008626 | | Disables BG addition/subtraction and direct color.
    STA reg_ppu_cgadsub.w                                                       ; $008629 |/
    LDA #%00000001                                                              ; $00862C |\ Set BG mode to 8x8, mode 1.
    STA reg_ppu_bgmode.w                                                        ; $00862E |/
    JSR _init_oam                                                               ; $008631 | Initialize the OAM.
    JSR _copy_title_screen_tiles                                                ; $008634 | Copies the title screen tile data to VRAM.
    LDX #$1800.w                                                                ; $008637 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00863A | | This sequence sets up another DMA transfer to copy the title
    LDX #$0800.w                                                                ; $00863C | | screen tile map from ROM to VRAM.
    STX <r_start_vram_dma_arg_bytes                                             ; $00863F | |
    LDX #bank08.title_screen_tilemap_data.w                                     ; $008641 | |
    STX <r_start_vram_dma_arg_address                                           ; $008644 | |
    JSL bank15.start_vram_dma                                                   ; $008646 |/
    LDX #$0000.w                                                                ; $00864A |\
-   LDA bank08.title_screen_palette_data.l,X                                    ; $00864D | | Copy the title screen palette data into the CG-RAM staging area.
    STA r_cgram_data.w,X                                                        ; $008651 | |
    INX                                                                         ; $008654 | |
    CPX #$0100.w                                                                ; $008655 | |
    BNE -                                                                       ; $008658 |/
    LDA #%00000000                                                              ; $00865A |\ Unblank the screen but keep brightness at 0.
    STA reg_ppu_inidisp.w                                                       ; $00865C |/
    LDA #%10000001                                                              ; $00865F |\ Enable NMI and joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $008661 |/
    LDA #$01                                                                    ; $008664 |\ Fade in the display, taking two frames per step.
    JSR _ppu_fade_in                                                            ; $008666 |/
    LDA #$01                                                                    ; $008669 |\ Set a flag to 1.
    STA <r_show_title_screen_wait                                               ; $00866B |/
    STZ <r_map_frame_counter                                                    ; $00866D | Reset the map frame counter to zero.
    LDA #$01                                                                    ; $00866F |\ Tell the NMI handler to skip doing the field graphic effects
    STA <r_skip_field_graphic_effects                                           ; $008671 |/ (animations and palette changes).
-   JSR _wait_for_nmi_complete                                                  ; $008673 |\
    INC <r_skip_field_graphic_effects                                           ; $008676 | | Repeatedly loop until the A button is pressed. This loop must
    LDA <r_joypad_pressed_lo                                                    ; $008678 | | complete at least once before it will allow the program to
    AND #JOYPAD_L_CONFIRM                                                       ; $00867A | | proceed.
    BNE +                                                                       ; $00867C | |
    STZ <r_show_title_screen_wait                                               ; $00867E | |
    JMP -                                                                       ; $008680 | |
+   LDA <r_show_title_screen_wait                                               ; $008683 | |
    BNE -                                                                       ; $008685 |/
    LDA #$01                                                                    ; $008687 |\ Fade out the display, darkening one step every two frames.
    JSR _ppu_fade_out                                                           ; $008689 |/
    JSR _disable_interrupts                                                     ; $00868C | Blank the screen and disable interrupts.
    RTS                                                                         ; $00868F
.endif

.if FF4_VERSION != "JAPAN_EASYTYPE"
; _copy_title_screen_tiles ($00:8690)
;
; Starts a DMA transfer to copy the title screen tile data from ROM to VRAM. The
; Japanese version additionally copies the tile data to the OAM tile area as
; the copyright text is done via sprites.
_copy_title_screen_tiles:
    LDX #VRAM_PROLOGUE_TILES_BG.w                                               ; $008690 |\ Set the target VRAM address to $0000.
    STX <r_start_vram_dma_arg_vram_target                                       ; $008693 |/
    LDX #bank08._sizeof_title_screen_tile_data.w                                ; $008842 |\ Set the number of bytes to copy to the size of the title screen
    STX <r_start_vram_dma_arg_bytes                                             ; $008698 |/ tile data.
    LDA #:bank08.title_screen_tile_data                                         ; $00869A |\ Set the bank number to $08.
    STA <r_start_vram_dma_arg_bank                                              ; $00869C |/
    LDX #bank08.title_screen_tile_data.w                                        ; $00869E |\ Set the source address.
    STX <r_start_vram_dma_arg_address                                           ; $0086A1 |/
    JSL bank15.start_vram_dma                                                   ; $0086A3 | Copy the tiles to VRAM (for backgrounds).
.if FF4_REGION == "JAPAN"
    LDX #VRAM_PROLOGUE_TILES_OAM.w                                              ; $008854 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $008857 | | For the Japanese version, copy the tiles to the OAM tile area.
    JSL bank15.start_vram_dma                                                   ; $008859 |/
.endif
    RTS                                                                         ; $0086A7
.endif

.if FF4_REGION == "JAPAN"
; _copy_title_screen_crystal_row ($00:885E)
;
; Exclusive to the Japanese version, this routine copies eight bytes (four
; tiles) worth of data from the source address in $3D, relative to the start of
; bank $08, to the target VRAM address in $47. The source address is incremented
; by eight to allow for repeated calls by only updating the VRAM address. The
; routine technically copies until the source address mod 8 is zero, so four
; tiles are not assured if called with certain arguments. Increments the Y
; register by two.
_copy_title_screen_crystal_row:
    LDA #%10000000.b                                                            ; $00885E |\ Set the VRAM increment to 1 by 1 after writing the high byte.
    STA reg_ppu_vmainc.w                                                        ; $008860 |/
    LDX <r_copy_title_screen_crystal_row_arg_vram_target                        ; $008863 |\ Set the VRAM address to the passed value.
    STX reg_ppu_vmadd.w                                                         ; $008865 |/
    LDX <r_copy_title_screen_crystal_row_arg_address                            ; $008868 | Load the source address (within bank $08) to the X register.
-   LDA $080000.l,X                                                             ; $00886A |\
    STA reg_ppu_vmdatal_write.w                                                 ; $00886E | | Copy the next word into VRAM.
    LDA $080001.l,X                                                             ; $008871 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $008875 |/
    INX                                                                         ; $008878 |\
    INX                                                                         ; $008879 | | Increment the X register twice and loop until it reaches a
    TXA                                                                         ; $00887A | | multiple of eight.
    AND #%00000111.b                                                            ; $00887B | |
    BNE -                                                                       ; $00887D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00887F |\
    LDA <r_copy_title_screen_crystal_row_arg_address                            ; $008881 | | Add eight to the source address to allow for repeated calls to
    CLC                                                                         ; $008883 | | this routine.
    ADC #8.w                                                                    ; $008884 | |
    STA <r_copy_title_screen_crystal_row_arg_address                            ; $008887 | |
    TDC                                                                         ; $008889 | |
    XBA                                                                         ; $00888A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00888B |/
    INY                                                                         ; $00888D |\ Increment the Y register by two.
    INY                                                                         ; $00888E |/
    RTS                                                                         ; $00888F
.endif

; _clear_vram_bg1_bg2 ($00:86A8)
;
; Given a value in the accumulator, overwrites all of BG1 and the top half of
; BG2 with the provided byte.
_clear_vram_bg1_bg2:
    STA <r_start_fixed_vram_dma_arg_value                                       ; $0086A8 |\
    LDX #$1800.w                                                                ; $0086AA | | Write the provided parameter byte 4096 times to VRAM at $1800.
    STX <r_start_fixed_vram_dma_arg_vram_target                                 ; $0086AD | | This overrwrites the entirely of BG1.
    LDX #$1000.w                                                                ; $0086AF | |
    STX <r_start_fixed_vram_dma_arg_bytes                                       ; $0086B2 | |
    JSL bank15.start_fixed_vram_dma                                             ; $0086B4 |/
    LDX #$3000.w                                                                ; $0086B8 |\
    STX <r_start_fixed_vram_dma_arg_vram_target                                 ; $0086BB | | Write 4096 bytes to $3000. This overwrites half of BG2.
    JSL bank15.start_fixed_vram_dma                                             ; $0086BD |/
    RTS                                                                         ; $0086C1

.if FF4_REGION == "JAPAN"
; title_screen_copyright_oam_data ($00:88AA)
;
; For the Japanese version only, provides the necessary data to copy to the OAM
; to draw the copyright notice at the bottom of the title screen.
title_screen_copyright_oam_data:
    OAM  88, 204, 0, 0, 2, 0, 1, $3C                                            ; $0088AA.88AD
    OAM  96, 204, 0, 0, 2, 0, 1, $3D                                            ; $0088AE.88B1
    OAM 104, 204, 0, 0, 2, 0, 1, $3E                                            ; $0088B2.88B5
    OAM 120, 204, 0, 0, 2, 0, 0, $08                                            ; $0088B6.88B9
    OAM 128, 204, 0, 0, 2, 0, 0, $18                                            ; $0088BA.88BD
    OAM 136, 204, 0, 0, 2, 0, 0, $28                                            ; $0088BE.88C1
.if FF4_EASYTYPE == 1
    OAM 144, 204, 0, 0, 2, 0, 0, $B4                                            ; $0088C2.88C5
    OAM 152, 204, 0, 0, 2, 0, 0, $B5                                            ; $0088C6.88C9
    OAM 160, 204, 0, 0, 2, 0, 0, $B6                                            ; $0088CA.88CD
.else
    OAM 144, 204, 0, 0, 2, 0, 0, $6C                                            ; $0088C2.88C5
    OAM 152, 204, 0, 0, 2, 0, 0, $7C                                            ; $0088C6.88C9
    OAM 160, 204, 0, 0, 2, 0, 0, $8C                                            ; $0088CA.88CD
.endif

; title_screen_crystal_vram_address_data ($00:88CE)
;
; For the Japanese title screen, provides the VRAM address for each row of the
; crystal.
title_screen_crystal_vram_address_data:
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (14 * 32)                              ; $0088CE.88CF
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (15 * 32)                              ; $0088D0.88D1
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (16 * 32)                              ; $0088D2.88D3
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (17 * 32)                              ; $0088D4.88D5
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (18 * 32)                              ; $0088D6.88D7
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (19 * 32)                              ; $0088D8.88D9
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (20 * 32)                              ; $0088DA.88DB
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (21 * 32)                              ; $0088DC.88DD
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (22 * 32)                              ; $0088DE.88DF
    .dw VRAM_PROLOGUE_TILEMAP_BG1 + 14 + (23 * 32)                              ; $0088E0.88E1
.endif

; _increment_indexes_by_four ($00:86C2)
;
; Increments both the X and Y index registers by four.
_increment_indexes_by_four:
    INX                                                                         ; $0086C2
    INX                                                                         ; $0086C3
    INX                                                                         ; $0086C4
    INX                                                                         ; $0086C5
    INY                                                                         ; $0086C6
    INY                                                                         ; $0086C7
    INY                                                                         ; $0086C8
    INY                                                                         ; $0086C9
    RTS                                                                         ; $0086CA

; _outdoor_animate_transition_and_start_battle ($00:86CB)
;
; Animates the outdoor pre-battle transition and starts the battle.
_outdoor_animate_transition_and_start_battle:
    LDA #AUDIO_EFFECT_BATTLE_START.b                                            ; $0086CB |\ Play the battle start sound effect.
    JSR _play_sound_effect                                                      ; $0086CD |/
    LDA #%00000001.b                                                            ; $0086D0 |\ Set BG1 as the main screen.
    STA reg_ppu_tm.w                                                            ; $0086D2 |/
    STZ <r_transition_index                                                     ; $0086D5 | Initialize the transition index to zero.
-   JSR _wait_for_nmi_complete                                                  ; $0086D7 | Wait for the next NMI.
    STZ reg_cpu_hdmaen.w                                                        ; $0086DA |\
    LDA <r_transition_index                                                     ; $0086DD | | Loop through 40 frames, updating the zoom level of the mode 7
    TAX                                                                         ; $0086DF | | effect each frame.
    LDA bank14.outdoor_battle_transition_zoom_data.l,X                          ; $0086E0 | |
    STA <r_zoom_level                                                           ; $0086E4 | |
    JSR _field_effect_zoom_set_mode_7_parameters                                ; $0086E6 | |
    JSR _set_mode_7_transform                                                   ; $0086E9 | |
    INC <r_transition_index                                                     ; $0086EC | |
    LDA <r_transition_index                                                     ; $0086EE | |
    CMP #bank14._sizeof_outdoor_battle_transition_zoom_data.b                   ; $0086F0 | |
    BNE -                                                                       ; $0086F2 |/
    JSR _start_battle                                                           ; $0086F4 | Start the battle.
    RTS                                                                         ; $0086F7

; _animate_transition_and_start_battle ($00:86F8)
;
; Animates the pre-battle transition and starts the battle.
_animate_transition_and_start_battle:
    LDA #AUDIO_EFFECT_BATTLE_START.b                                            ; $0086F8 |\ Play the battle start sound effect.
    JSR _play_sound_effect                                                      ; $0086FA |/
    LDA #%00000011.b                                                            ; $0086FD |\ Set BG1 and BG2 as the main screen.
    STA reg_ppu_tm                                                              ; $0086FF |/
    STZ <r_transition_index                                                     ; $008702 | Initialize the transition index to zero.
-   JSR _wait_for_nmi_complete                                                  ; $008704 | Wait for the next NMI to finish.
    LDA <r_transition_index                                                     ; $008707 |\
    LSR A                                                                       ; $008709 | | Loop through 42 frames, updating the mosaic value to change every
    TAX                                                                         ; $00870A | | two frames.
    LDA battle_transition_mosaic_data.w,X                                       ; $00870B | |
    STA reg_ppu_mosaic                                                          ; $00870E | |
    INC <r_transition_index                                                     ; $008711 | |
    LDA <r_transition_index                                                     ; $008713 | |
    CMP #_sizeof_battle_transition_mosaic_data.b * 2                            ; $008715 | |
    BNE -                                                                       ; $008717 |/
    LDA <r_trapped_chest_item                                                   ; $008719 |\
    BNE +                                                                       ; $00871B | | If not a trapped chest, prepare the formation and background.
    JSR _prepare_battle_formation_and_background                                ; $00871D |/
+   JSR _start_battle                                                           ; $008720 | Start the actual battle.
    RTS                                                                         ; $008723

; battle_transition_mosaic_data ($00:8724)
;
; During the transition to a battle, determines the mosaic settings for each
; successive frame. The mosaic effect is always applied to BG1 and BG2, and the
; size of the mosaic varies.
battle_transition_mosaic_data:
    .db $03                                                                     ; $008724 | $00
    .db $23                                                                     ; $008725 | $01
    .db $43                                                                     ; $008726 | $02
    .db $63                                                                     ; $008727 | $03
    .db $43                                                                     ; $008728 | $04
    .db $23                                                                     ; $008729 | $05
    .db $03                                                                     ; $00872A | $06
    .db $23                                                                     ; $00872B | $07
    .db $43                                                                     ; $00872C | $08
    .db $63                                                                     ; $00872D | $09
    .db $43                                                                     ; $00872E | $0A
    .db $23                                                                     ; $00872F | $0B
    .db $03                                                                     ; $008730 | $0C
    .db $23                                                                     ; $008731 | $0D
    .db $43                                                                     ; $008732 | $0E
    .db $63                                                                     ; $008733 | $0F
    .db $83                                                                     ; $008734 | $10
    .db $A3                                                                     ; $008735 | $11
    .db $C3                                                                     ; $008736 | $12
    .db $E3                                                                     ; $008737 | $13
    .db $F3                                                                     ; $008738 | $14

; _start_battle ($00:8739)
;
; Executes the code necessary to start a battle. After the battle is over,
; additionally handles displaying the spoils dialog and reloading any NPC
; NPC sprites for the map.
_start_battle:
    LDX r_battle_formation.w                                                    ; $008739 |\
    CPX #BATTLE_FORMATION_ZEROMUS_FINAL.w                                       ; $00873C | | If the battle formation is the final Zeromus battle (or the battle
    BCC +                                                                       ; $00873F | | with an ID one higher for some reason), explicitly set the
    CPX #BATTLE_FORMATION_ZEROMUS_FINAL.w + 2                                   ; $008741 | | background to the Zeromus background.
    BCS +                                                                       ; $008744 | |
    LDA #BATTLE_BACKGROUND_ZEROMUS.b                                            ; $008746 | |
    STA r_battle_background.w                                                   ; $008748 |/
.if FF4_VERSION == "JAPAN"
+   LDA r_map_plane.w                                                           ; $00896B |\
    CMP #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $00896E | | For the Japan release, if the map plane is not 1, skip ahead.
    BNE +++                                                                     ; $008970 |/
.else
+   LDA r_map_area.w                                                            ; $00874B |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $00874E | | For all other releases, skip ahead if not a dungeon map or if the
    BNE +++                                                                     ; $008750 | | map plane is zero. This prevents the wrong scripts from being used
    LDA r_map_plane.w                                                           ; $008752 | | on the underworld if the last dungeon map visited was in the range.
    BEQ +++                                                                     ; $008755 |/
.endif
    LDA r_map_id.w                                                              ; $008757 |\
    CMP #$5A.b                                                                  ; $00875A | | If the current map has passed the above area/plane check and if
    BCC +                                                                       ; $00875C | | it has a map ID either between $5A and $5C or $67 and $7E, both
    CMP #$5D.b                                                                  ; $00875E | | inclusive, set the uppermost bit on the formation number, which
    BCS +                                                                       ; $008760 | | toggles the use of the alternate battle scripts.
    JMP ++                                                                      ; $008762 | |
.if FF4_VERSION == "JAPAN"                                                      ;         | | NOTE: The original Japanese release has a flaw that causes the
+   LDA r_map_id.w                                                              ; $008980 | |       wrong scripts to be used on the underworld if the most
    CMP #$67.b                                                                  ; $008983 | |       recently visited dungeon map had an ID in the above range.
.else                                                                           ;         | |
+   CMP #$67.b                                                                  ; $008765 | |
.endif                                                                          ;         | |
    BCC +++                                                                     ; $008767 | |
    CMP #$7F.b                                                                  ; $008769 | |
    BCS +++                                                                     ; $00876B | |
++  LDA r_battle_formation_hi.w                                                 ; $00876D | |
    ORA #BATTLE_FORMATION_USE_ALTERNATE_SCRIPTS.b                               ; $008770 | |
    STA r_battle_formation_hi.w                                                 ; $008772 |/
+++ JSR _disable_interrupts                                                     ; $008775 | Disable interrupts.
    PHP                                                                         ; $008778 | Preserve the value of the processor flags.
    SEI                                                                         ; $008779 | Set the interrupt disable flag.
    JSL bank03.start_battle                                                     ; $00877A | Execute the battle code.
    JSR init_nmi_irq_handlers                                                   ; $00877E | Reset the interrupt handlers to the field handlers.
    PLP                                                                         ; $008781 | Restore the value of the processor flags.
    LDA r_battle_end_status.w                                                   ; $008782 |\
    BPL +                                                                       ; $008785 | | If the battle ended with the party perishing, reinitialize RAM,
    JSL bank15.init_ram                                                         ; $008787 | | set the stack pointer back to $02FF, and jump back to the main
    LDX #$02FF.w                                                                ; $00878B | | program, omitting the title screen and early initialization.
    TXS                                                                         ; $00878E | |
    JMP main_no_title_screen                                                    ; $00878F |/
+   LDA <r_trapped_chest_item                                                   ; $008792 |\
    BEQ +                                                                       ; $008794 | | If the trapped chest item is non-zero, store that as the battle
    STA r_battle_drops.w                                                        ; $008796 | | drop and branch to handle the drop menu, zeroing the trapped chest
    STZ <r_trapped_chest_item                                                   ; $008799 | | item.
    JMP ++                                                                      ; $00879B |/
+   LDA r_battle_drops.w + 0                                                    ; $00879E |\
    ORA r_battle_drops.w + 1                                                    ; $0087A1 | | Otherwise, check the eight drop slots, and if none of them is non-
    ORA r_battle_drops.w + 2                                                    ; $0087A4 | | zero, branch past the drop code.
    ORA r_battle_drops.w + 3                                                    ; $0087A7 | |
    ORA r_battle_drops.w + 4                                                    ; $0087AA | |
    ORA r_battle_drops.w + 5                                                    ; $0087AD | |
    ORA r_battle_drops.w + 6                                                    ; $0087B0 | |
    ORA r_battle_drops.w + 7                                                    ; $0087B3 | |
    BEQ +                                                                       ; $0087B6 |/
++  JSL bank01.menu_spoils                                                      ; $0087B8 | Execute the spoils menu.
    JSR init_nmi_irq_handlers                                                   ; $0087BC | Reinitialize the NMI and IRQ handlers.
+   LDA #%10000000.b                                                            ; $0087BF |\ Set the display to forced blanking.
    STA reg_ppu_inidisp.w                                                       ; $0087C1 |/
    LDA r_map_area.w                                                            ; $0087C4 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $0087C7 | | If the current map is a dungeon map, load the sprites for any NPCs
    BNE +                                                                       ; $0087C9 | | on the map.
    JSR _load_npc_sprites                                                       ; $0087CB |/
+   RTS                                                                         ; $0087CE

; init_nmi_irq_handlers ($00:87CF)
;
; This function initializes the code for the NMI and IRQ handlers, which are
; stored in RAM. They are set to the following code:
;
; nmi_handler:
;    JMP $009085                               ; $000200
;
; irq_handler:
;    JMP $009260                               ; $000204

init_nmi_irq_handlers:
    LDA #$5C                                                                    ; $0087CF |\
    STA r_nmi_handler.w                                                         ; $0087D1 | | Set both handlers to a 4-byte JMP instruction.
    STA r_irq_handler.w                                                         ; $0087D4 |/
    LDX #nmi_handler                                                            ; $0087D7 |\
    STX r_nmi_handler.w + 1                                                     ; $0087DA | | Set the NMI handler JMP target to $009085.
    STZ r_nmi_handler.w + 3                                                     ; $0087DD |/
    LDX #irq_handler                                                            ; $0087E0 |\
    STX r_irq_handler.w + 1                                                     ; $0087E3 | | Set the IRQ handler JMP target to $009260.
    STZ r_irq_handler.w + 3                                                     ; $0087E6 |/
    RTS                                                                         ; $0087E9

; _fade_out_and_disable_interrupts ($00:87EA)
;
; Fades the screen out, disables interrupts and automatic joypad reading, and
; sets forced blanking.
_fade_out_and_disable_interrupts:
    LDA #%00000000.b                                                            ; $0087EA |\ Fade the screen out, changing the brightness once per frame.
    JSR _ppu_fade_out                                                           ; $0087EC |/
    JSR _disable_interrupts                                                     ; $0087EF | Disable interrupts and set forced blanking.
    RTS                                                                         ; $0087F2

; _cleanup_menu_and_reinit_map ($00:87F3)
;
; Handles cleanup from calling a menu and reinitializes various map related
; variables and PPU settings. Fades the screen in and re-enables interrupts.
_cleanup_menu_and_reinit_map:
    LDA r_map_area.w                                                            ; $0087F3 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $0087F6 | | If the current map area is a dungeon, branch ahead slightly.
    BEQ +                                                                       ; $0087F8 |/
    LDA #%00000111.b                                                            ; $0087FA |\
    STA reg_ppu_bgmode.w                                                        ; $0087FC | | Otherwise, set the background mode to 7 and copy the field sprites
    JSR _copy_player_and_outdoor_field_sprites_to_vram                          ; $0087FF | | to VRAM, before branching to the common code.
    JMP ++                                                                      ; $008802 |/
+   LDA #%00001001.b                                                            ; $008805 |\ Set the background mode to 1, with BG3 being the highest priority.
    STA reg_ppu_bgmode.w                                                        ; $008807 |/
    JSR _copy_player_and_whirlpool_field_sprites_to_vram                        ; $00880A | Copy various field sprites to VRAM.
    JSR _load_npc_sprites                                                       ; $00880D | Load the NPC sprites.
    LDA r_map_properties.background_properties.w                                ; $008810 |\
    LSR A                                                                       ; $008813 | | If color math is enabled for this background, set the color math
    BCC ++                                                                      ; $008814 | | for sub screen, for BG1 and BG2, with adding one half.
    LDA #%00000011.b                                                            ; $008816 | |
    STA reg_ppu_cgswsel.w                                                       ; $008818 | |
    LDA #%01000011.b                                                            ; $00881B | |
    STA reg_ppu_cgadsub.w                                                       ; $00881D |/
++  JSL bank15.init_ppu                                                         ; $008820 | Initialize the PPU.
    JSL bank15.get_player_field_sprite_offset                                   ; $008824 |\
    LDA r_character_field.1.id.w,X                                              ; $008828 | | If the currently chosen field sprite is not a valid character,
    BNE +                                                                       ; $00882B | | increment the slot.
    JSL bank15.increment_field_sprite_slot                                      ; $00882D |/
+   JSR _init_oam                                                               ; $008831 | Initialize the OAM.
    LDA #%10000001.b                                                            ; $008834 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $008836 |/
    LDA #0.b                                                                    ; $008839 |\ Fade the PPU in, with one increment per frame.
    JSR _ppu_fade_in                                                            ; $00883B |/
    CLI                                                                         ; $00883E | Enable interrupts.
    RTS                                                                         ; $00883F

; _load_waterway_lake_tiles ($00:8840)
;
; Loads the waterway lake tiles into the lake ocean tiles area of RAM at
; $7F5800 for later modification. This also loads four additional tiles that do
; not seem to be animated.
_load_waterway_lake_tiles:
    LDA #$7F.b                                                                  ; $008840 |\
    PHA                                                                         ; $008842 | | Set the data bank register to $7F.
    PLB                                                                         ; $008843 |/
    LDX #0.w                                                                    ; $008844 |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $008847 |/
--  LDA bank1F.tileset_waterway_lake_data.l,X                                   ; $00884A |\
    STA r_lake_ocean_tiles & $FFFF,Y                                            ; $00884E | | Load the first 16 bytes of the tile.
    INX                                                                         ; $008851 | |
    INY                                                                         ; $008852 | |
    TYA                                                                         ; $008853 | |
    AND #%00001111.b                                                            ; $008854 | |
    BNE --                                                                      ; $008856 |/
-   LDA bank1F.tileset_waterway_lake_data.l,X                                   ; $008858 |\
    STA r_lake_ocean_tiles & $FFFF,Y                                            ; $00885C | | Load the remaining eight bytes, expanding to to 16 bytes in the
    INX                                                                         ; $00885F | | process.
    INY                                                                         ; $008860 | |
    LDA #0.b                                                                    ; $008861 | |
    STA r_lake_ocean_tiles & $FFFF,Y                                            ; $008863 | |
    INY                                                                         ; $008866 | |
    TYA                                                                         ; $008867 | |
    AND #%00001111.b                                                            ; $008868 | |
    BNE -                                                                       ; $00886A |/
    CPY #$0100.w                                                                ; $00886C |\ Loop until all eight tiles have been transferred.
    BNE --                                                                      ; $00886F |/
    LDA #$00.b                                                                  ; $008871 |\
    PHA                                                                         ; $008873 | | Set the data bank register to $00.
    PLB                                                                         ; $008874 |/
    RTS                                                                         ; $008875

; _copy_lake_tiles_to_vram ($00:8876)
;
; If the map uses the waterway tileset, copies data from $7F:5800 to $0430 in
; VRAM, effectively replacing the lake water tiles with whatever was in RAM.
_copy_lake_tiles_to_vram:
    LDA r_map_properties.tileset.w                                              ; $008876 |\
    CMP #TILESET_WATERWAY                                                       ; $008879 | | Only execute this function if the map uses the waterway tileset.
    BEQ +                                                                       ; $00887B | |
    RTS                                                                         ; $00887D |/
+   LDA #%10000000                                                              ; $00887E |\
    STA reg_ppu_vmainc                                                          ; $008880 | | Copy 512 bytes from RAM at $7F:5800 to $0430 in VRAM, which
    JSR _init_dma_bank_0_to_vram                                                ; $008883 | | replaces the data for the lake tiles with data in RAM.
    LDX #$0430.w                                                                ; $008886 | |
    STX reg_ppu_vmadd                                                           ; $008889 | |
    LDA #%00000001                                                              ; $00888C | |
    STA reg_cpu_dmap0                                                           ; $00888E | |
    LDX #r_lake_ocean_tiles.w                                                   ; $008891 | |
    STX reg_cpu_a1t0                                                            ; $008894 | |
    LDA #:r_lake_ocean_tiles                                                    ; $008897 | |
    STA reg_cpu_a1b0                                                            ; $008899 | |
    LDX #$0100.w                                                                ; $00889C | |
    STX reg_cpu_das0                                                            ; $00889F | |
    JSR _enable_dma_0                                                           ; $0088A2 |/
    RTS                                                                         ; $0088A5

; _dungeon_rotate_lake_tiles ($00:88A6)
;
; Rotates the lake tiles used on the waterway tileset. For each pair of two
; tiles, the lines are rotated from left to right within that line.
_dungeon_rotate_lake_tiles:
    LDA <r_map_frame_counter                                                    ; $0088A6 |\
    AND #%00000001.b                                                            ; $0088A8 | | Return if the map frame counter mod 2 is equal to 1.
    BEQ +                                                                       ; $0088AA | |
    RTS                                                                         ; $0088AC |/
+   LDA <r_map_frame_counter                                                    ; $0088AD |\
    AND #%00011110.b                                                            ; $0088AF | | Determine which line of which tile to update by taking the map
    LSR A                                                                       ; $0088B1 | | frame counter such that it cycles through 16 values that update
    TAX                                                                         ; $0088B2 | | once every two frames.
    LDA bank14.lake_tile_line_update_data.l,X                                   ; $0088B3 | |
    ASL A                                                                       ; $0088B7 | |
    TAX                                                                         ; $0088B8 |/
    LDA r_lake_ocean_tiles.l + 0,X                                              ; $0088B9 |\
    STA <r_generic_tmp_3                                                        ; $0088BD | | Rotate the first bitplane of the line.
    LDA r_lake_ocean_tiles.l + 32,X                                             ; $0088BF | |
    JSR _rotate_lake_tile_line                                                  ; $0088C3 | |
    STA r_lake_ocean_tiles.l + 0,X                                              ; $0088C6 | |
    LDA <r_generic_tmp_2                                                        ; $0088CA | |
    STA r_lake_ocean_tiles.l + 32,X                                             ; $0088CC |/
    LDA r_lake_ocean_tiles.l + 1,X                                              ; $0088D0 |\
    STA <r_generic_tmp_3                                                        ; $0088D4 | | Rotate the second bitplane of the line.
    LDA r_lake_ocean_tiles.l + 32 + 1,X                                         ; $0088D6 | |
    JSR _rotate_lake_tile_line                                                  ; $0088DA | |
    STA r_lake_ocean_tiles.l + 1,X                                              ; $0088DD | |
    LDA <r_generic_tmp_2                                                        ; $0088E1 | |
    STA r_lake_ocean_tiles.l + 32 + 1,X                                         ; $0088E3 |/
    LDA r_lake_ocean_tiles.l + 16,X                                             ; $0088E7 |\
    STA <r_generic_tmp_3                                                        ; $0088EB | | Rotate the third bitplane of the line.
    LDA r_lake_ocean_tiles.l + 32 + 16,X                                        ; $0088ED | |
    JSR _rotate_lake_tile_line                                                  ; $0088F1 | |
    STA r_lake_ocean_tiles.l + 16,X                                             ; $0088F4 | |
    LDA <r_generic_tmp_2                                                        ; $0088F8 | |
    STA r_lake_ocean_tiles.l + 32 + 16,X                                        ; $0088FA |/
    RTS                                                                         ; $0088FE

; _rotate_lake_tile_line ($00:88FF)
;
; Given one byte of a lake/ocean tile in $08, and another byte in the
; accumulator, rotates one pixel between the two, with pixels moving from the
; value in the accumulator to $08 and then back to the accumulator. The two
; returned values are returned in the accumulator (corresponds to $08) and in
; $07 (corresponds to the accumulator).
_rotate_lake_tile_line:
    STA <r_generic_tmp_4                                                        ; $0088FF | Store the passed value as a source value.
    STA <r_generic_tmp_2                                                        ; $008901 | Additionally store it as a target value.
    ROR <r_generic_tmp_4                                                        ; $008903 |\
    ROR <r_generic_tmp_3                                                        ; $008905 | | Rotate one pixel from the source to the other parameter, and its
    ROR <r_generic_tmp_2                                                        ; $008907 |/  value rotated to the target.
    LDA <r_generic_tmp_3                                                        ; $008909 | Load the first argument into the accumulator.
    RTS                                                                         ; $00890B

; _init_dma_bank_0_to_vram ($00:890C)
;
; Sets DMA parameters on channel 0 to copy from bank $00 to $2118. Sets no other
; parameters.
_init_dma_bank_0_to_vram:
    STZ reg_cpu_mdmaen                                                          ; $00890C | Reset DMA.
    LDA #$18                                                                    ; $00890F |\ Set the DMA B address to $2118 (VRAM write low).
    STA reg_cpu_bbad0                                                           ; $008911 |/
    STZ reg_cpu_a1b0                                                            ; $008914 | Set the DMA A bank to $00.
    RTS                                                                         ; $008917

; _enable_dma_0 ($00:8918)
;
; Starts the DMA transfer currently configured on channel 0.
_enable_dma_0:
    LDA #$01                                                                    ; $008918 |\ Starts the DMA transfer on channel 0.
    STA reg_cpu_mdmaen                                                          ; $00891A |/
    RTS                                                                         ; $00891D

; _check_encounter ($00:891E)
;
; Updates various variables related to encounter handling, and checks if an
; encounter should occur. If so, sets $0685 to 1. Additionally prepares the
; formation number and battle background.
_check_encounter:
    LDA r_vehicle.w                                                             ; $00891E |\ If the player is using a vehicle, branch to the no encounters code.
    BNE @no_encounters                                                          ; $008921 |/
    LDA <r_tile_properties_current.properties_2                                 ; $008923 |\
    AND #TILE_PROPERTY_2_ENCOUNTERS.b                                           ; $008925 | | Branch to no encounters if the encounters property is not set.
    BEQ @no_encounters                                                          ; $008927 |/
    LDA <r_force_encounter                                                      ; $008929 |\ If an encounter is being forced, branch to the encounter code.
    BNE ++                                                                      ; $00892B |/
    LDA <r_movement_direction                                                   ; $00892D |\
    BEQ @no_encounters                                                          ; $00892F | | If the player wasn't moving or movement calculation is disabled,
    LDA <r_player_movement_calculation_enabled                                  ; $008931 | | branch to no encounters.
    BEQ @no_encounters                                                          ; $008933 |/
    JMP ++                                                                      ; $008935 | Otherwise, branch to the encounter code.
@no_encounters:
    LDA <r_force_encounter                                                      ; $008938 |\
    BEQ +                                                                       ; $00893A | | If an encounter was being forced, play the Indra sound effect as an
    STZ <r_force_encounter                                                      ; $00893C | | error sound.
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $00893E | |
    STA r_play_audio_arg_mode.w                                                 ; $008940 | |
    LDA #AUDIO_EFFECT_INDRA.b                                                   ; $008943 | |
    STA r_play_audio_arg_track.w                                                ; $008945 | |
    JSL bank04.play_audio                                                       ; $008948 |/
+   RTS                                                                         ; $00894C | Either way, return.
++  INC <r_steps_since_battle                                                   ; $00894D | Increment the steps since the last battle.
    INC <r_encounter_index                                                      ; $00894F | Increment the encounter index.
    BNE +                                                                       ; $008951 |\
    LDA r_encounter_seed.w                                                      ; $008953 | | If the encounter index reaches zero, increase the encounter seed
    CLC                                                                         ; $008956 | | by 17.
    ADC #17.b                                                                   ; $008957 | |
    STA r_encounter_seed.w                                                      ; $008959 |/
+   LDA r_map_area.w                                                            ; $00895C |\
    CMP #MAP_AREA_OVERWORLD.b                                                   ; $00895F | | Skip to the next block if not on the overworld map.
    BNE ++                                                                      ; $008961 |/
    LDA r_current_coordinates.y.w                                               ; $008963 |\
    LSR A                                                                       ; $008966 | | Load the encounter rate for this zone of the overworld. The
    LSR A                                                                       ; $008967 | | overworld is divided into 64 zones in a grid of 8 by 8. Each
    AND #%11111000.b                                                            ; $008968 | | coordinate (ranging from 0 to 255) is divided by 32, and then
    STA <r_generic_tmp_1                                                        ; $00896A | | combined into a single index variable.
    LDA r_current_coordinates.x.w                                               ; $00896C | |
    LSR A                                                                       ; $00896F | |
    LSR A                                                                       ; $008970 | |
    LSR A                                                                       ; $008971 | |
    LSR A                                                                       ; $008972 | |
    LSR A                                                                       ; $008973 | |
    CLC                                                                         ; $008974 | |
    ADC <r_generic_tmp_1                                                        ; $008975 | |
    TAX                                                                         ; $008977 | |
    LDA bank0E.overworld_encounter_rate_data.l,X                                ; $008978 | |
    STA <r_generic_tmp_1                                                        ; $00897C |/
    PHX                                                                         ; $00897E |\
    PLY                                                                         ; $00897F | | If an encounter is being forced or if the PRNG data indexed by the
    LDA <r_force_encounter                                                      ; $008980 | | encounter index, plus the current encoutner seed is less than the
    BNE +                                                                       ; $008982 | | encounter rate, continue. Otherwise, return.
    LDA <r_encounter_index                                                      ; $008984 | |
    TAX                                                                         ; $008986 | |
    LDA bank14.prng_data.l,X                                                    ; $008987 | |
    CLC                                                                         ; $00898B | |
    ADC r_encounter_seed.w                                                      ; $00898C | |
    CMP <r_generic_tmp_1                                                        ; $00898F | |
    BCC +                                                                       ; $008991 | |
    RTS                                                                         ; $008993 | |
+   PHY                                                                         ; $008994 | |
    PLX                                                                         ; $008995 |/
    LDA bank0E.overworld_formation_group_data.l,X                               ; $008996 | Load the formation group for this zone and branch ahead.
    JMP @outdoor                                                                ; $00899A | Branch to the outdoor encounter code.
++  CMP #MAP_AREA_UNDERWORLD.b                                                  ; $00899D |\ Skip this next block if not on the underworld map.
    BNE ++                                                                      ; $00899F |/
    LDA <r_force_encounter                                                      ; $0089A1 |\
    BNE +                                                                       ; $0089A3 | | If no encounter is being forced and if the PRNG data indexed by
    LDA <r_encounter_index                                                      ; $0089A5 | | the current encounter index, plus the encounter seed is not less
    TAX                                                                         ; $0089A7 | | than the underworld encounter rate, return.
    LDA bank14.prng_data.l,X                                                    ; $0089A8 | |
    CLC                                                                         ; $0089AC | |
    ADC r_encounter_seed.w                                                      ; $0089AD | |
    CMP bank0E.underworld_encounter_rate_data.l                                 ; $0089B0 | |
    BCC +                                                                       ; $0089B4 | |
    RTS                                                                         ; $0089B6 |/
+   LDA r_current_coordinates.y.w                                               ; $0089B7 |\
    LSR A                                                                       ; $0089BA | | Load the formation group for the current underworld zone.
    LSR A                                                                       ; $0089BB | |
    LSR A                                                                       ; $0089BC | | NOTE: Despite the fact that the underworld map is technically 256
    AND #%11111100.b                                                            ; $0089BD | |       by 256, this code assumes that the map is 128 by 128, as
    STA <r_generic_tmp_1                                                        ; $0089BF | |       that is the only used area.
    LDA r_current_coordinates.x.w                                               ; $0089C1 | |
    LSR A                                                                       ; $0089C4 | |
    LSR A                                                                       ; $0089C5 | |
    LSR A                                                                       ; $0089C6 | |
    LSR A                                                                       ; $0089C7 | |
    LSR A                                                                       ; $0089C8 | |
    CLC                                                                         ; $0089C9 | |
    ADC <r_generic_tmp_1                                                        ; $0089CA | |
    TAX                                                                         ; $0089CC | |
    LDA bank0E.underworld_formation_group_data.l,X                              ; $0089CD |/
    JMP @outdoor                                                                ; $0089D1 | Branch to the outdoor encounter code.
++  CMP #MAP_AREA_MOON.b                                                        ; $0089D4 |\ Branch to the dungeon code if not on the lunar overworld.
    BNE @dungeon                                                                ; $0089D6 |/
    LDA <r_force_encounter                                                      ; $0089D8 |\
    BNE +                                                                       ; $0089DA | | If an encounter is not being forced and if the PRNG data indexed
    LDA <r_encounter_index                                                      ; $0089DC | | by the encounter index, plus the current encounter seed is not
    TAX                                                                         ; $0089DE | | less than the moon encounter rate, return.
    LDA bank14.prng_data.l,X                                                    ; $0089DF | |
    CLC                                                                         ; $0089E3 | |
    ADC r_encounter_seed.w                                                      ; $0089E4 | |
    CMP bank0E.moon_encounter_rate_data.l                                       ; $0089E7 | |
    BCC +                                                                       ; $0089EB | |
    RTS                                                                         ; $0089ED |/
+   STZ <r_generic_tmp_1                                                        ; $0089EE |\
    LDA r_current_coordinates.y.w                                               ; $0089F0 | | Determine the formation group associated with the current zone on
    CMP #32.b                                                                   ; $0089F3 | | the lunar overworld. The lunar overworld is divided into four
    BCC +                                                                       ; $0089F5 | | zones.
    LDA #2.b                                                                    ; $0089F7 | |
    STA <r_generic_tmp_1                                                        ; $0089F9 | |
+   LDA r_current_coordinates.x.w                                               ; $0089FB | |
    CMP #32.b                                                                   ; $0089FE | |
    BCC +                                                                       ; $008A00 | |
    INC <r_generic_tmp_1                                                        ; $008A02 | |
+   LDA <r_generic_tmp_1                                                        ; $008A04 | |
    TAX                                                                         ; $008A06 | |
    LDA bank0E.moon_formation_group_data.l,X                                    ; $008A07 |/
@outdoor:
    JSR _get_formation_offset                                                   ; $008A0B | Get the current formation offset in the chosen formation group.
    STZ <r_generic_tmp_index.hi                                                 ; $008A0E |\
    LDX <r_generic_tmp_index                                                    ; $008A10 | | Load the associated formation ID and save it to the battle
    LDA bank0E.outdoor_formation_data.l,X                                       ; $008A12 | | formation.
    STA r_battle_formation_lo.w                                                 ; $008A16 |/
    LDA r_map_plane.w                                                           ; $008A19 |\
    BEQ +                                                                       ; $008A1C | | Set the high byte of the formation number to 1 if the current
    LDA #1.b                                                                    ; $008A1E | | plane is not the overworld.
+   STA r_battle_formation_hi.w                                                 ; $008A20 |/
    LDA <r_tile_properties_current.properties_2                                 ; $008A23 |\
    AND #TILE_PROPERTY_2_OUTDOOR_BACKGROUND.b                                   ; $008A25 | \ Set the battle background by reading the data from the properties
    TAY                                                                         ; $008A27 | | of the current tile.
    LDA outdoor_tile_battle_background_data.w,Y                                 ; $008A28 | |
    STA r_battle_background.w                                                   ; $008A2B |/
    STZ <r_force_encounter                                                      ; $008A2E | Reset the forced encounter flag.
    LDA #1.b                                                                    ; $008A30 |\ Set the encounter flag to indicate an encounter should occur.
    STA <r_encounter_flag                                                       ; $008A32 |/
    RTS                                                                         ; $008A34
@dungeon:
    LDA r_map_id.w                                                              ; $008A35 |\
    STA <r_generic_tmp_index.lo                                                 ; $008A38 | | Load the encounter rate for the current map.
    LDA r_map_plane.w                                                           ; $008A3A | |
    BEQ +                                                                       ; $008A3D | |
    LDA #1.b                                                                    ; $008A3F | |
+   STA <r_generic_tmp_index.hi                                                 ; $008A41 | |
    LDX <r_generic_tmp_index                                                    ; $008A43 | |
    LDA bank0E.dungeon_encounter_rate_data.l,X                                  ; $008A45 |/
    BEQ +                                                                       ; $008A49 | If it's zero, branch ahead to the no encounters code.
    STA <r_generic_tmp_1                                                        ; $008A4B | Otherwise, save it to a temporary variable.
    LDA <r_force_encounter                                                      ; $008A4D |\
    BNE ++                                                                      ; $008A4F | | If the encounter is forced or if the PRNG data indexed by the
    LDA <r_encounter_index                                                      ; $008A51 | | encounter index, plus the current encounter seed is less than the
    TAX                                                                         ; $008A53 | | encounter rate, branch ahead to handle the encounter.
    LDA bank14.prng_data.l,X                                                    ; $008A54 | |
    CLC                                                                         ; $008A58 | |
    ADC r_encounter_seed.w                                                      ; $008A59 | |
    CMP <r_generic_tmp_1                                                        ; $008A5C | |
    BCC ++                                                                      ; $008A5E |/
+   LDA <r_force_encounter                                                      ; $008A60 |\
    BEQ +                                                                       ; $008A62 | | Otherwise, zero out the force encounter flag and tell the audio
    STZ <r_force_encounter                                                      ; $008A64 | | system to stop sound effects and then return.
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $008A66 | |
    STA r_play_audio_arg_mode.w                                                 ; $008A68 | | This code executes if an encounter was forced on a map with a zero
    STZ r_play_audio_arg_track.w                                                ; $008A6B | | encounter rate.
    JSL bank04.play_audio                                                       ; $008A6E | | TODO: Ensure that's what this sound code actually does.
+   RTS                                                                         ; $008A72 |/
++  LDX <r_generic_tmp_index                                                    ; $008A73 |\
    LDA bank0E.dungeon_formation_group_data.l,X                                 ; $008A75 | | Determine the low byte of the formation by reading from the
    JSR _get_formation_offset                                                   ; $008A79 | | formation group for this map.
    LDX <r_generic_tmp_index                                                    ; $008A7C | |
    LDA bank0E.dungeon_formation_data.l,X                                       ; $008A7E | |
    STA r_battle_formation_lo.w                                                 ; $008A82 |/
    JSR _prepare_battle_formation_and_background                                ; $008A85 | Prepare the battle formation and background.
    STZ <r_force_encounter                                                      ; $008A88 | Reset the force encounter flag.
    LDA #1.b                                                                    ; $008A8A |\ Set the encounter flag.
    STA <r_encounter_flag                                                       ; $008A8C |/
    STZ <r_steps_since_battle                                                   ; $008A8E | Reset the steps since a battle.
    RTS                                                                         ; $008A90

; outdoor_tile_battle_background_data ($00:8A91)
;
; For outdoor tiles, links the background bits in a tile's properties to the
; actual background displayed. While there are three bits, only six entries are
; used.
outdoor_tile_battle_background_data:
    .db BATTLE_BACKGROUND_GRASSLAND                                             ; $008A91 | $00
    .db BATTLE_BACKGROUND_BEACH                                                 ; $008A92 | $01
    .db BATTLE_BACKGROUND_FOREST                                                ; $008A93 | $02
    .db BATTLE_BACKGROUND_DESERT                                                ; $008A94 | $03
    .db BATTLE_BACKGROUND_UNDERWORLD                                            ; $008A95 | $04
    .db BATTLE_BACKGROUND_MOON                                                  ; $008A96 | $05

; _prepare_battle_formation_and_background ($00:8A97)
;
; Adjusts the battle formation by setting the high byte to 1 if the current map
; plane is not in the overworld. Additionally calculates the battle background
; and removes the magnetic property if the Dark Elf has been defeated.
_prepare_battle_formation_and_background:
    LDA r_map_plane.w                                                           ; $008A97 |\
    BEQ +                                                                       ; $008A9A | | If the map plane is anything other than the overworld, set the
    LDA #$01.b                                                                  ; $008A9C | | high byte of the formation number to 1 (to add 256).
+   STA r_battle_formation_hi.w                                                 ; $008A9E |/
    JSR _calculate_battle_background                                            ; $008AA1 | Calculate which battle background to use.
    LDA #PLOT_FLAG_MAGNETIC_FIELD_ACTIVE.b                                      ; $008AA4 |\
    JSR _get_plot_flag                                                          ; $008AA6 | | If the magnetic field is not active, remove any magnetic property
    CMP #0.b                                                                    ; $008AA9 | | the battle background may have.
    BNE +                                                                       ; $008AAB | |
    LDA r_battle_background.w                                                   ; $008AAD | |
    AND #~BATTLE_BACKGROUND_MAGNETIC.b                                          ; $008AB0 | |
    STA r_battle_background.w                                                   ; $008AB2 |/
+   RTS                                                                         ; $008AB5

; _calculate_battle_background ($00:8AB6)
;
; Determines the battle background value based on the current map and tile.
_calculate_battle_background:
    LDA <r_tile_properties_current.properties_2                                 ; $008AB6 |\
    AND #TILE_PROPERTY_2_WATER_BATTLE.b                                         ; $008AB8 | | Shift the current tile's water battle flag to the correct location
    ASL A                                                                       ; $008ABA | | and save it for later use.
    STA <r_calculate_battle_background_tmp                                      ; $008ABB |/
    LDA r_map_properties.flags.w                                                ; $008ABD |\
    AND #MAP_PROPERTIES_FLAGS_ALTERNATE_BATTLE_PALETTE.b                        ; $008AC0 | | Add in the alternate battle palette flag value, shifted to the
    LSR A                                                                       ; $008AC2 | | correct location.
    ORA <r_calculate_battle_background_tmp                                      ; $008AC3 | |
    STA <r_calculate_battle_background_tmp                                      ; $008AC5 |/
    LDA r_map_properties.flags.w                                                ; $008AC7 |\
    AND #MAP_PROPERTIES_FLAGS_BATTLE_BACKGROUND | MAP_PROPERTIES_FLAGS_MAGNETIC ; $008ACA | | Carry over the actual battle background as well as the magnetic
    ORA <r_calculate_battle_background_tmp                                      ; $008ACC | | flag.
    STA r_battle_background.w                                                   ; $008ACE |/
    RTS                                                                         ; $008AD1

; _get_formation_offset ($00:8AD2)
;
; Given a formation group number in the accumulator, returns the offset to the
; current formation. Also handles incrementing the formation index and updating
; the formation seed as necessary.
_get_formation_offset:
    STA <r_generic_tmp_index.lo                                                 ; $008AD2 |\
    STZ <r_generic_tmp_index.hi                                                 ; $008AD4 | | Multiply the passed encounter group number by eight and store it
    ASL <r_generic_tmp_index.lo                                                 ; $008AD6 | | to a temporary variable.
    ROL <r_generic_tmp_index.hi                                                 ; $008AD8 | |
    ASL <r_generic_tmp_index.lo                                                 ; $008ADA | |
    ROL <r_generic_tmp_index.hi                                                 ; $008ADC | |
    ASL <r_generic_tmp_index.lo                                                 ; $008ADE | |
    ROL <r_generic_tmp_index.hi                                                 ; $008AE0 |/
    LDA <r_force_encounter                                                      ; $008AE2 |\ If the encounter is being forced, skip ahead to explictly set the
    BNE +                                                                       ; $008AE4 |/ value instead of using a random value.
    LDA <r_formation_index                                                      ; $008AE6 |\
    TAX                                                                         ; $008AE8 | | Calculate the value by adding the formation seed to the random
    LDA bank14.prng_data.l,X                                                    ; $008AE9 | | value associated with the current index.
    CLC                                                                         ; $008AED | |
    ADC r_formation_seed.w                                                      ; $008AEE |/
    INC <r_formation_index                                                      ; $008AF1 |\
    BNE ++                                                                      ; $008AF3 | | Increment the formation index and if it reaches zero, add 17 to
    LDA r_formation_seed.w                                                      ; $008AF5 | | the seed.
    CLC                                                                         ; $008AF8 | |
    ADC #17.b                                                                   ; $008AF9 | |
    STA r_formation_seed.w                                                      ; $008AFB | |
    JMP ++                                                                      ; $008AFE |/
+   LDA #255.b                                                                  ; $008B01 | Explicitly load the value of 255 if the encounter is forced.
++  LDX <r_generic_tmp_index                                                    ; $008B03 | Set the X register to the previously calculated base index.
    CMP #43.b                                                                   ; $008B05 |\ If the value is less than 43, keep the index as it is.
    BCC +                                                                       ; $008B07 |/
    INX                                                                         ; $008B09 |\
    CMP #86.b                                                                   ; $008B0A | | If the value is 43 to 85, add one to the index.
    BCC +                                                                       ; $008B0C |/
    INX                                                                         ; $008B0E |\
    CMP #129.b                                                                  ; $008B0F | | If the value is 86 to 128, add two to the index.
    BCC +                                                                       ; $008B11 |/
    INX                                                                         ; $008B13 |\
    CMP #172.b                                                                  ; $008B14 | | If the value is 129 to 171, add three to the index.
    BCC +                                                                       ; $008B16 |/
    INX                                                                         ; $008B18 |\
    CMP #204.b                                                                  ; $008B19 | | If the value is 172 to 203, add four to the index.
    BCC +                                                                       ; $008B1B |/
    INX                                                                         ; $008B1D |\
    CMP #236.b                                                                  ; $008B1E | | If the value is 204 to 235, add five to the index.
    BCC +                                                                       ; $008B20 |/
    INX                                                                         ; $008B22 |\
    CMP #252.b                                                                  ; $008B23 | | If the value is 236 to 251, add six to the index.
    BCC +                                                                       ; $008B25 |/
    INX                                                                         ; $008B27 | Otherwise, add seven.
+   STX <r_generic_tmp_index                                                    ; $008B28 | Save the updated index.
    RTS                                                                         ; $008B2A

; _audio_fade_out ($00:8B2B)
;
; Tells the audio subsystem to fade out the audio volume.
_audio_fade_out:
    LDA #AUDIO_MODE_VOLUME_FADE_OUT.b                                           ; $008B2B |\
    STA r_play_audio_arg_mode.w                                                 ; $008B2D | | Set the audio mode to volume fade out and execute.
    JSL bank04.play_audio                                                       ; $008B30 |/
    RTS                                                                         ; $008B34

; _audio_fade_out_slow ($00:8B35)
;
; Tells the audio subsystem to fade out the audio volume slowly.
_audio_fade_out_slow:
    LDA #AUDIO_MODE_VOLUME_FADE_OUT_SLOW.b                                      ; $008B35 |\
    STA r_play_audio_arg_mode.w                                                 ; $008B37 | | Set the audio mode to slow volume fade out and execute.
    JSL bank04.play_audio                                                       ; $008B3A |/
    RTS                                                                         ; $008B3E

; _play_map_song ($00:8B3F)
;
; Determines the appropriate song to play based on the player's current map and
; vehicle and plays it.
_play_map_song:
    LDA r_vehicle.w                                                             ; $008B3F |\
    BEQ +                                                                       ; $008B42 | | If the player is currently operating a vehicle of some type,
    LDA r_vehicle.w                                                             ; $008B44 | | determine the track number by reading data from the vehicle
    TAX                                                                         ; $008B47 | | song data array.
    LDA vehicle_song_data.w,X                                                   ; $008B48 | |
    STA r_play_audio_arg_track.w                                                ; $008B4B | | NOTE: For some reason, this uses mode 3 instead of mode 1. There
    LDA #AUDIO_MODE_NORMAL_2.b                                                  ; $008B4E | |       doesn't seem to be a difference.
    JMP +++                                                                     ; $008B50 |/
+   LDA r_map_area.w                                                            ; $008B53 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $008B56 | | If the player is not operating a vehicle, and is currently on a
    BEQ +                                                                       ; $008B58 | | non-dungeon map, determine the song by loading from the map area
    TAX                                                                         ; $008B5A | | song data array.
    LDA map_area_song_data.w,X                                                  ; $008B5B | |
    JMP ++                                                                      ; $008B5E |/
+   LDA r_map_properties.audio_track.w                                          ; $008B61 | Otherwise, load the track number from the map information array.
++  STA r_play_audio_arg_track.w                                                ; $008B64 |\
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $008B67 | | Call the actual function to play the song.
+++ STA r_play_audio_arg_mode.w                                                 ; $008B69 | |
    JSL bank04.play_audio                                                       ; $008B6C |/
    RTS                                                                         ; $008B70

; map_area_song_data ($00:8B71)
;
; Contains the audio track numbers associated with walking on each separate map
; area, except for dungeons.
map_area_song_data:
    .db AUDIO_TRACK_MAIN_THEME                                                  ; $008B71 | $00: Overworld
    .db AUDIO_TRACK_LAND_OF_DWARVES                                             ; $008B72 | $01: Underworld
    .db AUDIO_TRACK_ANOTHER_MOON                                                ; $008B73 | $02: Moon

; vehicle_song_data ($00:8B74)
;
; Contains the audio track numbers associated with operating each vehicle. The
; value for walking is defined correctly, but it isn't actually read from here.
vehicle_song_data:
    .db AUDIO_TRACK_MAIN_THEME                                                  ; $008B74 | $00: Walking
    .db AUDIO_TRACK_CHOCOBO_CHOCOBO                                             ; $008B75 | $01: Yellow Chocobo
    .db AUDIO_TRACK_SAMBA_DE_CHOCOBO                                            ; $008B76 | $02: Black Chocobo
    .db AUDIO_TRACK_MAIN_THEME                                                  ; $008B77 | $03: Hovercraft
    .db AUDIO_TRACK_THE_AIRSHIP                                                 ; $008B78 | $04: Enterprise
    .db AUDIO_TRACK_THE_AIRSHIP                                                 ; $008B79 | $05: Falcon
    .db AUDIO_TRACK_LUNAR_WHALE                                                 ; $008B7A | $06: Big Whale

; _play_sound_effect ($00:8B7B)
;
; Plays the sound effect identified by the number passed in the accumulator. The
; effect will be played in the center (both left and right) and with a TODO
; parameter.
_play_sound_effect:
    STA r_play_audio_arg_track.w                                                ; $008B7B | Play the track passed in the accumulator.
    LDA #AUDIO_PAN_CENTER.b                                                     ; $008B7E |\ Play the effect in the center.
    STA r_play_audio_arg_pan.w                                                  ; $008B80 |/
    LDA #$FF.b                                                                  ; $008B83 |\ TODO
    STA r_play_audio_arg_unknown.w                                              ; $008B85 |/
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $008B88 |\ Play a sound effect.
    STA r_play_audio_arg_mode.w                                                 ; $008B8A |/
    JSL bank04.play_audio                                                       ; $008B8D | Play the audio.
    RTS                                                                         ; $008B91

; _ppu_fade_in ($00:8B92)
;
; Fades in the display from 0 to max brightness. It takes a single parameter in
; the accumulator, which specifies which bits of a counter that began at zero
; should be zero to step to the next brightness. For example, $01 will result in
; the display being brightened one step every two frames.
_ppu_fade_in:
    STA <r_ppu_fade_tmp_arg                                                     ; $008B92
    STZ <r_ppu_fade_counter                                                     ; $008B94
    STZ <r_ppu_brightness                                                       ; $008B96
-   JSR _wait_for_nmi_complete                                                  ; $008B98
    LDA <r_ppu_brightness                                                       ; $008B9B
    STA reg_ppu_inidisp                                                         ; $008B9D
    INC <r_ppu_fade_counter                                                     ; $008BA0
    LDA <r_ppu_fade_counter                                                     ; $008BA2
    AND <r_ppu_fade_tmp_arg                                                     ; $008BA4
    BNE -                                                                       ; $008BA6
    INC <r_ppu_brightness                                                       ; $008BA8
    LDA <r_ppu_brightness                                                       ; $008BAA
    CMP #$10                                                                    ; $008BAC
    BNE -                                                                       ; $008BAE
    DEC <r_ppu_brightness                                                       ; $008BB0
    RTS                                                                         ; $008BB2

; _ppu_fade_out ($00:8BB3)
;
; Fades the display from max brightness to 0. It takes a single parameter in the
; accumulator, which specifies which bits of a counter that began at zero should
; be zero to step to the next brightness.
_ppu_fade_out:
    STA <r_ppu_fade_tmp_arg                                                     ; $008BB3 |\
    STZ <r_ppu_fade_counter                                                     ; $008BB5 | | Initialize the loop variables.
    LDA #$0F                                                                    ; $008BB7 | |
    STA <r_ppu_brightness                                                       ; $008BB9 |/
-   JSR _wait_for_nmi_complete                                                  ; $008BBB | Wait for the next NMI to execute.
    LDA <r_ppu_brightness                                                       ; $008BBE |\ Set forced blanking and brightness to zero.
    STA reg_ppu_inidisp                                                         ; $008BC0 |/
    LDA r_map_area.w                                                            ; $008BC3 |\
    CMP #MAP_AREA_DUNGEON                                                       ; $008BC6 | | Enable HDMA channels 4 and 5 (for mode 7 effects) if the map area
    BEQ +                                                                       ; $008BC8 | | is not a dungeon.
    LDA #%00110000                                                              ; $008BCA | |
    STA reg_cpu_hdmaen                                                          ; $008BCC |/
+   INC <r_ppu_fade_counter                                                     ; $008BCF |\
    LDA <r_ppu_fade_counter                                                     ; $008BD1 | | Increment the counter and check for a frame that matches the given
    AND <r_ppu_fade_tmp_arg                                                     ; $008BD3 | | parameter.
    BNE -                                                                       ; $008BD5 |/
    DEC <r_ppu_brightness                                                       ; $008BD7 |\
    BPL -                                                                       ; $008BD9 | | Decrement the brightness and continue until 0.
    STZ <r_ppu_brightness                                                       ; $008BDB |/
    RTS                                                                         ; $008BDD

; _wait_for_joypad_clear ($00:8BDE)
;
; Loops until all joypad buttons are unpressed.
_wait_for_joypad_clear:
-   LDA <r_joypad_pressed_lo                                                    ; $008BDE
    BNE -                                                                       ; $008BE0
    LDA <r_joypad_pressed_hi                                                    ; $008BE2
    BNE -                                                                       ; $008BE4
    RTS                                                                         ; $008BE6

; _wait_for_joypad_press ($00:8BE7)
;
; Loops until a joypad button is pressed.
_wait_for_joypad_press:
-   LDA <r_joypad_pressed_lo                                                    ; $008BE7
    BNE +                                                                       ; $008BE9
    LDA <r_joypad_pressed_hi                                                    ; $008BEB
    BEQ -                                                                       ; $008BED
+   RTS                                                                         ; $008BEF

; _copy_ocean_tile_line ($00:8BF0)
;
; Copies a single row of an ocean tile from the area in RAM to VRAM. The proper
; VRAM address of the line should have already been set, and the offset into the
; ocean tile data should be passed in X.
_copy_ocean_tile_line:
    LDA r_lake_ocean_tiles.l,X                                                  ; $008BF0
    STA reg_ppu_vmdatah_write                                                   ; $008BF4
    LDA r_lake_ocean_tiles.l + 1,X                                              ; $008BF7
    STA reg_ppu_vmdatah_write                                                   ; $008BFB
    LDA r_lake_ocean_tiles.l + 2,X                                              ; $008BFE
    STA reg_ppu_vmdatah_write                                                   ; $008C02
    LDA r_lake_ocean_tiles.l + 3,X                                              ; $008C05
    STA reg_ppu_vmdatah_write                                                   ; $008C09
    LDA r_lake_ocean_tiles.l + 4,X                                              ; $008C0C
    STA reg_ppu_vmdatah_write                                                   ; $008C10
    LDA r_lake_ocean_tiles.l + 5,X                                              ; $008C13
    STA reg_ppu_vmdatah_write                                                   ; $008C17
    LDA r_lake_ocean_tiles.l + 6,X                                              ; $008C1A
    STA reg_ppu_vmdatah_write                                                   ; $008C1E
    LDA r_lake_ocean_tiles.l + 7,X                                              ; $008C21
    STA reg_ppu_vmdatah_write                                                   ; $008C25
    RTS                                                                         ; $008C28

; _animate_outdoor_water_tiles ($00:8C29)
;
; If on either the overworld or the underworld, calls the appropriate function
; to animate the water or magma tiles for that map.
_animate_outdoor_water_tiles:
    LDA r_map_area.w                                                            ; $008C29 |\
    BNE +                                                                       ; $008C2C | | If on the overworld, animate the overworld water tiles.
    JMP _animate_overworld_water_tiles                                          ; $008C2E |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $008C31 |\
    BNE +                                                                       ; $008C33 | | If on the underworld, animate the underworld water tiles.
    JMP _animate_underworld_water_tiles                                         ; $008C35 |/
+   RTS                                                                         ; $008C38

; _copy_water_tiles ($00:8C39)
;
; Calls the appropriate subroutine to transfer the animated water tiles from
; RAM to VRAM. This only applies to the overworld and underworld maps.
_copy_water_tiles:
    LDA r_map_area.w                                                            ; $008C39 |\
    BNE +                                                                       ; $008C3C | | If on either the overworld or the underworld, call the relevant
    JMP _copy_overworld_water_tiles                                             ; $008C3E | | function, otherwise return.
+   CMP #MAP_AREA_UNDERWORLD                                                    ; $008C41 | |
    BNE +                                                                       ; $008C43 | |
    JMP _copy_underworld_water_tiles                                            ; $008C45 |/
+   RTS                                                                         ; $008C48

; _copy_overworld_water_tiles ($00:8C49)
;
; Copies ocean and waterfall tiles from a special area in RAM to VRAM. Waterfall
; tiles are copied in their entirety using DMA. Ocean tiles are copied one line
; every other frame. The tiles modified are in VRAM from $2000 to $20FF (ocean)
; and from $1E80 to $1F7F (waterfalls).
_copy_overworld_water_tiles:
    LDA #$80                                                                    ; $008C49 |\ Increment the VRAM address 1 by 1.
    STA reg_ppu_vmainc                                                          ; $008C4B |/
    LDA <r_world_map_frame_counter                                              ; $008C4E |\  Every two frames, change the index used for which row of the tiles
    LSR A                                                                       ; $008C50 | | to cycle.
    AND #$0F                                                                    ; $008C51 |/
    TAX                                                                         ; $008C53 |\
    LDA ocean_cycle_data.w,X                                                    ; $008C54 | | Copy a single ocean tile line from RAM to VRAM.
    TAX                                                                         ; $008C57 | |
    STA reg_ppu_vmaddl                                                          ; $008C58 | |
    LDA #$20                                                                    ; $008C5B | |
    STA reg_ppu_vmaddh                                                          ; $008C5D | |
    JSR _copy_ocean_tile_line                                                   ; $008C60 |/
    LDA <r_world_map_frame_counter                                              ; $008C63 |\
    LSR A                                                                       ; $008C65 | | Set the index again.
    AND #$0F                                                                    ; $008C66 |/
    TAX                                                                         ; $008C68 |\
    LDA ocean_cycle_data.w,X                                                    ; $008C69 | | Copy a line from the next tile.
    CLC                                                                         ; $008C6C | |
    ADC #$40                                                                    ; $008C6D | |
    TAX                                                                         ; $008C6F | |
    STA reg_ppu_vmaddl                                                          ; $008C70 | |
    LDA #$20                                                                    ; $008C73 | |
    STA reg_ppu_vmaddh                                                          ; $008C75 | |
    JSR _copy_ocean_tile_line                                                   ; $008C78 |/
    LDA #$80                                                                    ; $008C7B |\ Set the VRAM increment to 1x1.
    STA reg_ppu_vmainc                                                          ; $008C7D |/
    LDX #$1E80.w                                                                ; $008C80 |\ Set the VRAM address to $1E80.
    STX reg_ppu_vmaddl                                                          ; $008C83 |/
    STZ reg_cpu_mdmaen                                                          ; $008C86 | Reset DMA.
    STZ reg_cpu_dmap0                                                           ; $008C89 | Set DMA to write one address.
    LDA #$19                                                                    ; $008C8C |\ Set the DMA write address to $2119 (VRAM write high byte).
    STA reg_cpu_bbad0                                                           ; $008C8E |/
    LDX #r_waterfall_tiles.w                                                    ; $008C91 |\
    STX reg_cpu_a1t0                                                            ; $008C94 | | Set the DMA read address to $7F5900.
    LDA #:r_waterfall_tiles                                                     ; $008C97 | |
    STA reg_cpu_a1b0                                                            ; $008C99 |/
    LDX #$0100.w                                                                ; $008C9C |\ Copy 256 bytes.
    STX reg_cpu_das0                                                            ; $008C9F |/
    JSR _enable_dma_0                                                           ; $008CA2 | Enable the DMA on channel 0.
    RTS                                                                         ; $008CA5

; _copy_magma_tiles_from_vram ($00:8D4B)
;
; Copies the magma tiles from VRAM to the staging area in RAM at $7F:5800.
_copy_magma_tiles_from_vram:
    LDA #%10000000.b                                                            ; $008CA6 |\ Set the VRAM increment to 1 by 1 on high byte.
    STA reg_ppu_vmainc                                                          ; $008CA8 |/
    LDX #$3800.w                                                                ; $008CAB |\
    STX reg_ppu_vmadd                                                           ; $008CAE | | Copy the four magma tiles from VRAM to RAM, where they can be
    LDA reg_ppu_vmdatah_read                                                    ; $008CB1 | | modified to prepare for the moving magma effect.
    LDX #$0000.w                                                                ; $008CB4 | |
-   LDA reg_ppu_vmdatah_read                                                    ; $008CB7 | |
    STA r_lake_ocean_tiles.l,X                                                  ; $008CBA | |
    INX                                                                         ; $008CBE | |
    CPX #$0100.w                                                                ; $008CBF | |
    BNE -                                                                       ; $008CC2 |/
    RTS                                                                         ; $008CC4

; _animate_underworld_water_tiles ($00:8CC5)
;
; Modifies the mirror of the magma tiles in RAM to produce the animation effect.
; They will be copied later by another routine to VRAM.
_animate_underworld_water_tiles:
    LDA <r_world_map_frame_counter                                              ; $008CC5 |\
    AND #%00000001.b                                                            ; $008CC7 | | Only execute this function on even frames.
    BEQ +                                                                       ; $008CC9 |/
    RTS                                                                         ; $008CCB |\
+   LDA <r_world_map_frame_counter                                              ; $008CCC | | Determine which line of which tile to work on this frame. Add 7 to
    LSR A                                                                       ; $008CCE | | the index to start at the last byte of the line.
    AND #%00001111.b                                                            ; $008CCF | |
    TAX                                                                         ; $008CD1 | |
    LDA ocean_cycle_data.w,X                                                    ; $008CD2 | |
    ORA #%00000111.b                                                            ; $008CD5 | |
    TAX                                                                         ; $008CD7 |/
    LDA r_lake_ocean_tiles.l,X                                                  ; $008CD8 |\ Save the last byte of the line for later use.
    STA <r_animate_underworld_water_tiles_tmp                                   ; $008CDC |/
    LDY #$0007.w                                                                ; $008CDE |\
-   LDA r_lake_ocean_tiles.l - 1,X                                              ; $008CE1 | | Move the remaining seven bytes to the right.
    STA r_lake_ocean_tiles.l,X                                                  ; $008CE5 | |
    DEX                                                                         ; $008CE9 | |
    DEY                                                                         ; $008CEA | |
    BNE -                                                                       ; $008CEB |/
    TXA                                                                         ; $008CED |\
    AND #%11111000.b                                                            ; $008CEE | | Set the new index to the original line index plus 64 + 7 (to move
    CLC                                                                         ; $008CF0 | | to the end of the same line on the next tile).
    ADC #71.b                                                                   ; $008CF1 | |
    TAX                                                                         ; $008CF3 |/
    LDA r_lake_ocean_tiles.l,X                                                  ; $008CF4 |\ Move the last byte of the second tile to the first byte of the
    STA r_lake_ocean_tiles.l - 71,X                                             ; $008CF8 |/ first tile.
    LDY #$0007.w                                                                ; $008CFC |\
-   LDA r_lake_ocean_tiles.l - 1,X                                              ; $008CFF | | Move the remaining seven bytes to the right.
    STA r_lake_ocean_tiles.l,X                                                  ; $008D03 | |
    DEX                                                                         ; $008D07 | |
    DEY                                                                         ; $008D08 | |
    BNE -                                                                       ; $008D09 |/
    TXA                                                                         ; $008D0B |\
    AND #%11111000.b                                                            ; $008D0C | | Put the originally saved byte in the first byte of the second
    TAX                                                                         ; $008D0E | | tile.
    LDA <r_animate_underworld_water_tiles_tmp                                   ; $008D0F | |
    STA r_lake_ocean_tiles.l,X                                                  ; $008D11 |/
    RTS                                                                         ; $008D15

; _copy_underworld_water_tiles ($00:8D16)
;
; Copies ocean (lava) tiles from RAM to VRAM. Similar to the overworld, these
; tiles are copied a single line every other frame. The exact lines to copy are
; determined by an array in ROM. The specific tiles modified live in VRAM from
; $3800 to $38FF.
_copy_underworld_water_tiles:
    LDA #$80                                                                    ; $008D16 |\ Set the VRAM address increment to 1x1.
    STA reg_ppu_vmainc                                                          ; $008D18 |/
    LDA <r_world_map_frame_counter                                              ; $008D1B |\
    LSR A                                                                       ; $008D1D | | Calculate the index from the current frame counter and copy the
    AND #$0F                                                                    ; $008D1E | | appropriate lines from the ocean/lava tiles into VRAM.
    TAX                                                                         ; $008D20 | |
    LDA ocean_cycle_data.w,X                                                    ; $008D21 | |
    TAX                                                                         ; $008D24 | |
    STA reg_ppu_vmaddl                                                          ; $008D25 | |
    LDA #$38                                                                    ; $008D28 | |
    STA reg_ppu_vmaddh                                                          ; $008D2A | |
    JSR _copy_ocean_tile_line                                                   ; $008D2D |/
    LDA <r_world_map_frame_counter                                              ; $008D30 |\
    LSR A                                                                       ; $008D32 | | Repeat the process for the second tile in the pair.
    AND #$0F                                                                    ; $008D33 | |
    TAX                                                                         ; $008D35 | |
    LDA ocean_cycle_data.w,X                                                    ; $008D36 | |
    CLC                                                                         ; $008D39 | |
    ADC #$40                                                                    ; $008D3A | |
    TAX                                                                         ; $008D3C | |
    STA reg_ppu_vmaddl                                                          ; $008D3D | |
    LDA #$38                                                                    ; $008D40 | |
    STA reg_ppu_vmaddh                                                          ; $008D42 | |
    JSR _copy_ocean_tile_line                                                   ; $008D45 |/
    INC <r_world_map_frame_counter                                              ; $008D48 | Increment the frame counter.
    RTS                                                                         ; $008D4A

; _copy_water_tiles_from_vram ($00:8D4B)
;
; Copies the ocean and waterfall tiles from VRAM to the staging area in RAM
; at $7F:5800.
_copy_water_tiles_from_vram:
    LDA #%10000000.b                                                            ; $008D4B |\ Set the VRAM increment to 1 by 1 on high byte.
    STA reg_ppu_vmainc                                                          ; $008D4D |/
    LDX #$2000.w                                                                ; $008D50 |\
    STX reg_ppu_vmadd                                                           ; $008D53 | | Copy the four moving water tiles from VRAM to RAM, where they can
    LDA reg_ppu_vmdatah_read                                                    ; $008D56 | | be modified to prepare for the animated water effect.
    LDX #$0000.w                                                                ; $008D59 | |
-   LDA reg_ppu_vmdatah_read                                                    ; $008D5C | |
    STA r_lake_ocean_tiles.l,X                                                  ; $008D5F | |
    INX                                                                         ; $008D63 | |
    CPX #$0100.w                                                                ; $008D64 | |
    BNE -                                                                       ; $008D67 |/
    LDX #$1E80.w                                                                ; $008D69 |\
    STX reg_ppu_vmadd                                                           ; $008D6C | | Copy the four waterfall tiles from VRAM to RAM.
    LDA reg_ppu_vmdatah_read                                                    ; $008D6F | |
    LDX #$0000.w                                                                ; $008D72 | |
-   LDA reg_ppu_vmdatah_read                                                    ; $008D75 | |
    STA r_waterfall_tiles.l,X                                                   ; $008D78 | |
    INX                                                                         ; $008D7C | |
    CPX #$0100.w                                                                ; $008D7D | |
    BNE -                                                                       ; $008D80 |/
    RTS                                                                         ; $008D82

; _animate_overworld_water_tiles ($00:8D83)
;
; Animates the outdoor water tiles (lakes/oceans and waterfalls) by modifying
; the mirror of the data in RAM. This will then be transferred to VRAM by
; another routine. The other routine does not always copy the entire tile, but
; instead relies on the same data as this one to determine which lines to
; transfer.
_animate_overworld_water_tiles:
    LDA <r_world_map_frame_counter                                              ; $008D83 |\
    AND #%00000001.b                                                            ; $008D85 | | Process lake/ocean tiles on even frames and waterfall tiles on odd
    BEQ +                                                                       ; $008D87 | | frames.
    JMP @waterfall_tiles                                                        ; $008D89 |/
+   LDA <r_world_map_frame_counter                                              ; $008D8C |\
    LSR A                                                                       ; $008D8E | | Determine the current line to work on by taking the low four bits
    AND #%00001111.b                                                            ; $008D8F | | of the frame counter and indexing into the ocean cycle data array.
    TAX                                                                         ; $008D91 | | Set the lower three bits to start and the end of the line.
    LDA ocean_cycle_data.w,X                                                    ; $008D92 | |
    ORA #%00000111.b                                                            ; $008D95 | |
    TAX                                                                         ; $008D97 |/
    LDA r_lake_ocean_tiles.l,X                                                  ; $008D98 |\ Save the last byte of the line.
    STA <r_animate_overworld_water_tiles_tmp                                    ; $008D9C |/
    LDY #$0007.w                                                                ; $008D9E |\
-   LDA r_lake_ocean_tiles.l - 1,X                                              ; $008DA1 | | Move the other 7 bytes of the line one by one toward the end to
    STA r_lake_ocean_tiles.l,X                                                  ; $008DA5 | | create an effect of the water moving rightward.
    DEX                                                                         ; $008DA9 | |
    DEY                                                                         ; $008DAA | |
    BNE -                                                                       ; $008DAB |/
    TXA                                                                         ; $008DAD |\
    AND #%11111000.b                                                            ; $008DAE | | Ensure the low three bits of the index are reset to zero and then
    CLC                                                                         ; $008DB0 | | add 64 + 7 to move to the end of the same line on the next tile.
    ADC #71.b                                                                   ; $008DB1 | |
    TAX                                                                         ; $008DB3 |/
    LDA r_lake_ocean_tiles.l,X                                                  ; $008DB4 |\ Move the last byte of that line to the first byte of the line on
    STA r_lake_ocean_tiles.l - 71,X                                             ; $008DB8 |/ the first tile (to rotate the values between the two tiles).
    LDY #$0007.w                                                                ; $008DBC |\
-   LDA r_lake_ocean_tiles.l - 1,X                                              ; $008DBF | | Move the other seven bytes of the second tile back one byte to
    STA r_lake_ocean_tiles.l,X                                                  ; $008DC3 | | continue the rotation process.
    DEX                                                                         ; $008DC7 | |
    DEY                                                                         ; $008DC8 | |
    BNE -                                                                       ; $008DC9 |/
    TXA                                                                         ; $008DCB |\
    AND #%11111000.b                                                            ; $008DCC | | Reset the index back to the start of the second tile.
    TAX                                                                         ; $008DCE |/
    LDA <r_animate_overworld_water_tiles_tmp                                    ; $008DCF |\ Store the originally saved last byte of the first tile in the first
    STA r_lake_ocean_tiles.l,X                                                  ; $008DD1 |/ byte of the second tile.
@waterfall_tiles:
    LDA <r_world_map_frame_counter                                              ; $008DD5 |\
    AND #%00001111.b                                                            ; $008DD7 | | Determine which tile and column to work based on the world map
    TAX                                                                         ; $008DD9 | | frame counter. Start at the last row of the desired column by
    LDA waterfall_cycle_data.w,X                                                ; $008DDA | | adding 56 (8 bytes * 7 rows).
    CLC                                                                         ; $008DDD | |
    ADC #56.b                                                                   ; $008DDE | |
    TAX                                                                         ; $008DE0 |/
    LDA r_waterfall_tiles.l,X                                                   ; $008DE1 |\ Save the last byte of that column.
    STA <r_animate_overworld_water_tiles_tmp                                    ; $008DE5 |/
    LDY #$0007.w                                                                ; $008DE7 |\
-   LDA r_waterfall_tiles.l - 8,X                                               ; $008DEA | | Shift the pixels of the column down one by one until all of the
    STA r_waterfall_tiles.l,X                                                   ; $008DEE | | remaining seven have been moved.
    TXA                                                                         ; $008DF2 | |
    SEC                                                                         ; $008DF3 | |
    SBC #8.b                                                                    ; $008DF4 | |
    TAX                                                                         ; $008DF6 | |
    DEY                                                                         ; $008DF7 | |
    BNE -                                                                       ; $008DF8 |/
    LDA <r_world_map_frame_counter                                              ; $008DFA |\
    AND #%00001111.b                                                            ; $008DFC | | Determine the base location of the second tile by adding 184 to
    TAX                                                                         ; $008DFE | | the column offset (128 to move two tiles and 56 to get to the last
    LDA waterfall_cycle_data.w,X                                                ; $008DFF | | row).
    CLC                                                                         ; $008E02 | |
    ADC #184.b                                                                  ; $008E03 | |
    TAX                                                                         ; $008E05 |/
    LDA r_waterfall_tiles.l,X                                                   ; $008E06 |\ Move the last byte of the column in this next tile to the first
    STA r_waterfall_tiles.l - 184,X                                             ; $008E0A |/ byte of the first tile.
    LDY #$0007.w                                                                ; $008E0E |\
-   LDA r_waterfall_tiles.l - 8,X                                               ; $008E11 | | Now, move the other seven bytes of the second tile downward within
    STA r_waterfall_tiles.l,X                                                   ; $008E15 | | that tile.
    TXA                                                                         ; $008E19 | |
    SEC                                                                         ; $008E1A | |
    SBC #8.b                                                                    ; $008E1B | |
    TAX                                                                         ; $008E1D | |
    DEY                                                                         ; $008E1E | |
    BNE -                                                                       ; $008E1F |/
    LDA <r_animate_overworld_water_tiles_tmp                                    ; $008E21 |\ Load the initially saved byte and store it in the first byte of the
    STA r_waterfall_tiles.l,X                                                   ; $008E23 |/ second tile.
    LDA <r_world_map_frame_counter                                              ; $008E27 |\
    AND #%00001111.b                                                            ; $008E29 | | These 38 lines are 100% identical to the preceding 38 lines, and
    TAX                                                                         ; $008E2B | | serve to repeat the process again, so each column moves down two
    LDA waterfall_cycle_data.w,X                                                ; $008E2C | | pixels per frame.
    CLC                                                                         ; $008E2F | |
    ADC #56.b                                                                   ; $008E30 | |
    TAX                                                                         ; $008E32 | |
    LDA r_waterfall_tiles.l,X                                                   ; $008E33 | |
    STA <r_animate_overworld_water_tiles_tmp                                    ; $008E37 | |
    LDY #$0007.w                                                                ; $008E39 | |
-   LDA r_waterfall_tiles.l - 8,X                                               ; $008E3C | |
    STA r_waterfall_tiles.l,X                                                   ; $008E40 | |
    TXA                                                                         ; $008E44 | |
    SEC                                                                         ; $008E45 | |
    SBC #8.b                                                                    ; $008E46 | |
    TAX                                                                         ; $008E48 | |
    DEY                                                                         ; $008E49 | |
    BNE -                                                                       ; $008E4A | |
    LDA <r_world_map_frame_counter                                              ; $008E4C | |
    AND #%00001111.b                                                            ; $008E4E | |
    TAX                                                                         ; $008E50 | |
    LDA waterfall_cycle_data.w,X                                                ; $008E51 | |
    CLC                                                                         ; $008E54 | |
    ADC #184.b                                                                  ; $008E55 | |
    TAX                                                                         ; $008E57 | |
    LDA r_waterfall_tiles.l,X                                                   ; $008E58 | |
    STA r_waterfall_tiles.l - 184,X                                             ; $008E5C | |
    LDY #$0007.w                                                                ; $008E60 | |
-   LDA r_waterfall_tiles.l - 8,X                                               ; $008E63 | |
    STA r_waterfall_tiles.l,X                                                   ; $008E67 | |
    TXA                                                                         ; $008E6B | |
    SEC                                                                         ; $008E6C | |
    SBC #8.b                                                                    ; $008E6D | |
    TAX                                                                         ; $008E6F | |
    DEY                                                                         ; $008E70 | |
    BNE -                                                                       ; $008E71 | |
    LDA <r_animate_overworld_water_tiles_tmp                                    ; $008E73 | |
    STA r_waterfall_tiles.l,X                                                   ; $008E75 |/
    INC <r_world_map_frame_counter                                              ; $008E79 | Increment the world map frame counter.
    RTS                                                                         ; $008E7B

; waterfall_cycle_data ($00:8E7C)
;
; Contains the data used to cycle the waterfall tiles. Each byte gives the
; offset for the start of the column to be operated on in a given frame.
waterfall_cycle_data:
    .db $00                                                                     ; $008E7C
    .db $41                                                                     ; $008E7D
    .db $02                                                                     ; $008E7E
    .db $43                                                                     ; $008E7F
    .db $04                                                                     ; $008E80
    .db $45                                                                     ; $008E81
    .db $06                                                                     ; $008E82
    .db $47                                                                     ; $008E83
    .db $40                                                                     ; $008E84
    .db $01                                                                     ; $008E85
    .db $42                                                                     ; $008E86
    .db $03                                                                     ; $008E87
    .db $44                                                                     ; $008E88
    .db $05                                                                     ; $008E89
    .db $46                                                                     ; $008E8A
    .db $07                                                                     ; $008E8B

; ocean_cycle_data ($00:8E8C)
;
; These bytes control the order in which the lines of each ocean tile are cycled
; to produce the moving water effect. The smaller eight addresses are for one
; pair of tiles and the higher eight addresses are for the other pair.
ocean_cycle_data:
    .db $00                                                                         ; $008E8C
    .db $88                                                                         ; $008E8D
    .db $10                                                                         ; $008E8E
    .db $98                                                                         ; $008E8F
    .db $20                                                                         ; $008E90
    .db $A8                                                                         ; $008E91
    .db $30                                                                         ; $008E92
    .db $B8                                                                         ; $008E93
    .db $80                                                                         ; $008E94
    .db $08                                                                         ; $008E95
    .db $90                                                                         ; $008E96
    .db $18                                                                         ; $008E97
    .db $A0                                                                         ; $008E98
    .db $28                                                                         ; $008E99
    .db $B0                                                                         ; $008E9A
    .db $38                                                                         ; $008E9B

; _field_effect_zoom_set_mode_7_parameters ($00:8E9C)
;
; Sets the parameters used by the _set_mode_7_transform routine. The values
; chosen come from _field_effect_swirl_get_sine_value, which returns values on
; a sine curve, scaled to the current zoom level. The scale is set to the value
; at 64, the B argument is set to the value at 0 and the C argument is set to
; the value at 128. These values are shifted by the phase value at $06FB.
; Assuming the phase is zero, this results in the scale being set to the zoom
; level and the B and C parameters being set to zero.
;
; By altering the phase, the values can also be used for a zooming rotation
; effect.
_field_effect_zoom_set_mode_7_parameters:
    LDA #64.b                                                                   ; $008E9C |\
    JSR _field_effect_swirl_get_sine_value                                      ; $008E9E | | Set the mode 7 scale.
    STY <r_set_mode_7_transform_arg_scale                                       ; $008EA1 |/
    LDA #0.b                                                                    ; $008EA3 |\
    JSR _field_effect_swirl_get_sine_value                                      ; $008EA5 | | Set the first mode 7 rotation parameter.
    STY <r_set_mode_7_transform_arg_b                                           ; $008EA8 |/
    LDA #128.b                                                                  ; $008EAA |\
    JSR _field_effect_swirl_get_sine_value                                      ; $008EAC | | Set the second mode 7 rotation parameter.
    STY <r_set_mode_7_transform_arg_c                                           ; $008EAF |/
    RTS                                                                         ; $008EB1

; _field_effect_swirl_get_sine_value ($00:8EB2)
;
; Given a value in the accumulator, determines a sine value for that value plus
; the current 8-bit value in $06FB. Used as part of the field swirl effect.
; The returned value will ultimately range in between +/- the current zoom level
; at $06AD times eight.
_field_effect_swirl_get_sine_value:
    CLC                                                                         ; $008EB2 |\
    ADC r_field_effect_swirl_current_phase.w                                    ; $008EB3 | | Add the parameter to the current phase, which makes the effect
    STA <r_generic_tmp_1                                                        ; $008EB6 |/  rotate faster.
    AND #%01111111.b                                                            ; $008EB8 |\
    ASL A                                                                       ; $008EBA | | Load the sine data for the calculated value and save that as one
    TAX                                                                         ; $008EBB | | of the values to be multiplied.
    LDA bank14.sine_data.l + 0,X                                                ; $008EBC | |
    STA reg_ppu_m7a.w                                                           ; $008EC0 | |
    LDA bank14.sine_data.l + 1,X                                                ; $008EC3 | |
    STA reg_ppu_m7a.w                                                           ; $008EC7 |/
    LDA <r_zoom_level                                                           ; $008ECA |\
    STA reg_ppu_m7b.w                                                           ; $008ECC | | Multiply by the current magnitude of the effect.
    STA reg_ppu_m7b.w                                                           ; $008ECF |/
    LDY reg_ppu_mpym.w                                                          ; $008ED2 |\
    LDA <r_generic_tmp_1                                                        ; $008ED5 | | If the original value was 128-256, negate the result to simulate
    BPL +                                                                       ; $008ED7 | | the second half of the sine wave, which is not provided by the
    REP #FLAG_P_ACCUMULATOR                                                     ; $008ED9 | | sine data. Either way, return the result in the Y register.
    TYA                                                                         ; $008EDB | |
    EOR #$FFFF.w                                                                ; $008EDC | |
    INC A                                                                       ; $008EDF | |
    TAY                                                                         ; $008EE0 | |
    TDC                                                                         ; $008EE1 | |
    XBA                                                                         ; $008EE2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $008EE3 |/
+   RTS                                                                         ; $008EE5

; _set_mode_7_transform ($00:8EE6)
;
; Sets the mode 7 transformation parameters. The A and D parameters are set to
; the 16-bit value in $6E. The B parameter is set to the 16-bit value in $70 and
; the C parameter is set to the 16-bit value in $72.
_set_mode_7_transform:
    LDA <r_set_mode_7_transform_arg_scale.lo                                    ; $008EE6
    STA reg_ppu_m7a                                                             ; $008EE8
    LDA <r_set_mode_7_transform_arg_scale.hi                                    ; $008EEB
    STA reg_ppu_m7a                                                             ; $008EED
    LDA <r_set_mode_7_transform_arg_b.lo                                        ; $008EF0
    STA reg_ppu_m7b                                                             ; $008EF2
    LDA <r_set_mode_7_transform_arg_b.hi                                        ; $008EF5
    STA reg_ppu_m7b                                                             ; $008EF7
    LDA <r_set_mode_7_transform_arg_c.lo                                        ; $008EFA
    STA reg_ppu_m7c                                                             ; $008EFC
    LDA <r_set_mode_7_transform_arg_c.hi                                        ; $008EFF
    STA reg_ppu_m7c                                                             ; $008F01
    LDA <r_set_mode_7_transform_arg_scale.lo                                    ; $008F04
    STA reg_ppu_m7d                                                             ; $008F06
    LDA <r_set_mode_7_transform_arg_scale.hi                                    ; $008F09
    STA reg_ppu_m7d                                                             ; $008F0B
    RTS                                                                         ; $008F0E

; _wait_for_nmi_complete_field ($00:8F0F)
;
; Waits until the NMI handler completes.
_wait_for_nmi_complete_field:
    LDA #$01.b                                                                  ; $008F0F
    STA <r_nmi_status                                                           ; $008F11
-   LDA <r_nmi_status                                                           ; $008F13
    BNE -                                                                       ; $008F15
    JSL bank15.do_nothing_but_return                                            ; $008F17
    INC <r_nmi_status                                                           ; $008F1B
    RTS                                                                         ; $008F1D

; _wait_for_nmi_complete ($00:8F1E)
;
; Waits until the NMI handler completes. Sets the NMI variable that suppresses
; field graphics effects. Suitable for non-field screens (menus, etc.).
_wait_for_nmi_complete:
    LDA #$01                                                                    ; $008F1E |\
    STA <r_skip_field_graphic_effects                                           ; $008F20 | | Wait for the NMI handler to execute. (The NMI handler will zero out
-   LDA <r_skip_field_graphic_effects                                           ; $008F22 | | this variable when it executes.)
    BNE -                                                                       ; $008F24 |/
    JSL bank15.do_nothing_but_return                                            ; $008F26 |
    INC <r_nmi_status                                                           ; $008F2A |
    RTS                                                                         ; $008F2C

; _do_tile_animations ($00:8F2D)
;
; Calls a series of routines that handles the various animated tiles that occur
; mostly in the outdoor maps, but also in dungeons.
_do_tile_animations:
    JSR _wait_for_nmi_complete                                                  ; $008F2D | Waits for the next complete NMI.
    LDA r_map_area.w                                                            ; $008F30 |\
    BNE +                                                                       ; $008F33 | | If the current map area is the overworld, animate the overworld
    JSR _animate_overworld_water_tiles                                          ; $008F35 | | water tiles and copy them to VRAM.
    JSR _copy_overworld_water_tiles                                             ; $008F38 | |
    JMP ++                                                                      ; $008F3B |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $008F3E |\
    BNE ++                                                                      ; $008F40 | | If this is the underworld, animate the magma tiles and copy those
    JSR _animate_underworld_water_tiles                                         ; $008F42 | | to VRAM. Also shift the magma glow colors.
    JSR _copy_underworld_water_tiles                                            ; $008F45 | |
    JSL bank15.set_magma_glow_colors                                            ; $008F48 |/
++  JSL bank15.copy_animated_tiles_to_vram                                      ; $008F4C | Copy animated tiles to VRAM.
    JSL bank15.set_big_whale_light_color                                        ; $008F50 | Set the Big Whale light color.
    JSL bank15.set_tower_of_babil_flash_color                                   ; $008F54 | Set the Tower of Bab-il flash color.
    RTS                                                                         ; $008F58

; _init_oam ($00:8F59)
;
; Initializes the OAM with all sprites set to a Y-coordinate of 240.
_init_oam:
    LDX #0.w                                                                    ; $008F59 |\
    LDA #240.b                                                                  ; $008F5C | | Set each sprite in the OAM to a Y-coordinate of 240.
-   STA r_oam.1.y.w,X                                                           ; $008F5E | |
    INX                                                                         ; $008F61 | |
    INX                                                                         ; $008F62 | |
    INX                                                                         ; $008F63 | |
    INX                                                                         ; $008F64 | |
    CPX #_sizeof_oam_sprite.w * 128                                             ; $008F65 | |
    BNE -                                                                       ; $008F68 |/
    LDX #0.w                                                                    ; $008F6A |\
-   STZ r_oam_hi.w,X                                                            ; $008F6D | | Initialize the high bytes of the OAM to zero.
    INX                                                                         ; $008F70 | |
    CPX #_sizeof_r_oam_hi.w                                                     ; $008F71 | |
    BNE -                                                                       ; $008F74 |/
    RTS                                                                         ; $008F76

; _init_oam_lower ($00:8F77)
;
; Initializes the first half of the OAM with all sprites set to a Y coordinate
; of 240.
_init_oam_lower:
    LDX #$0000.w                                                                ; $008F77
    LDA #240.b                                                                  ; $008F7A
-   STA r_oam.1.y.w,X                                                           ; $008F7C
    INX                                                                         ; $008F7F
    INX                                                                         ; $008F80
    INX                                                                         ; $008F81
    INX                                                                         ; $008F82
    CPX #_sizeof_oam_sprite.w * 64                                              ; $008F83
    BNE -                                                                       ; $008F86
    LDX #$0000.w                                                                ; $008F88
-   STZ r_oam_hi.w,X                                                            ; $008F8B
    INX                                                                         ; $008F8E
    CPX #$0020.w                                                                ; $008F8F
    BNE -                                                                       ; $008F92
    RTS                                                                         ; $008F94

; _load_tile_palettes ($00:8F95)
;
; Given a bank number in the accumulator and an address in the X register,
; copies 256 bytes (an entire set of 8 palettes) from the given address to the
; CG-RAM staging area in RAM. (This will be copied to CG-RAM by the NMI
; handler.)
_load_tile_palettes:
    PHA                                                                         ; $008F95 |\ Set the data bank register to the parameter in the accumulator.
    PLB                                                                         ; $008F96 |/
    LDY #$0000.w                                                                ; $008F97 |\
-   LDA $0000.w,X                                                               ; $008F9A | | Copy 256 bytes from the address passed in the accumulator (bank)
    STA r_cgram_data,Y                                                          ; $008F9D | | and the X register (address) to the primary CG-RAM staging area.
    INX                                                                         ; $008FA0 | |
    INY                                                                         ; $008FA1 | |
    CPY #$0100.w                                                                ; $008FA2 | |
    BNE -                                                                       ; $008FA5 |/
    LDA #$00.b                                                                  ; $008FA7 |\
    PHA                                                                         ; $008FA9 | | Set the data bank register to $00.
    PLB                                                                         ; $008FAA |/
    RTS                                                                         ; $008FAB

_transition_irq_handler:
    LDA <r_irq_index                                                            ; $008FAC |\ Check if this is the first or second IRQ and dispatch accordingly.
    BNE @second_irq                                                             ; $008FAE |/
    LDA <r_transition_index                                                     ; $008FB0 |\
    ASL A                                                                       ; $008FB2 | | Based on the transition index, set the IRQ to trigger again on the
    TAX                                                                         ; $008FB3 | | other side of the window, vertically speaking.
    LDA #$6F.b                                                                  ; $008FB4 | |
    CLC                                                                         ; $008FB6 | |
    ADC bank14.transition_window_data.l + 1,X                                   ; $008FB7 | |
    TAY                                                                         ; $008FBB | |
    STY reg_cpu_vtimel                                                          ; $008FBC |/
    LDA <r_cutscene_active                                                      ; $008FBF |\
    BNE +                                                                       ; $008FC1 | | If currently in a cutscene, use the screen brightness from the
    LDA #%00001111.b                                                            ; $008FC3 | | RAM variable. Otherwise, use full brightness.
    JMP ++                                                                      ; $008FC5 | |
+   LDA <r_ppu_brightness                                                       ; $008FC8 | |
++  LDX #$0003.w                                                                ; $008FCA | |
-   DEX                                                                         ; $008FCD | |
    BNE -                                                                       ; $008FCE | |
    NOP                                                                         ; $008FD0 | |
    STA reg_ppu_inidisp                                                         ; $008FD1 |/
    RTS                                                                         ; $008FD4
@second_irq:
    LDX #$000A.w                                                                ; $008FD5 |\
-   DEX                                                                         ; $008FD8 | | Count down from 10 for some reason. This delay doesn't seem to be
    BNE -                                                                       ; $008FD9 | | necessary in my testing, but that was limited. Afterward, set the
    LDA #%10000000                                                              ; $008FDB | | display to forced blanking and zero brightness. Enable NMI and
    STA reg_ppu_inidisp                                                         ; $008FDD | | joypad reading.
    LDA #%10000001                                                              ; $008FE0 | |
    STA reg_cpu_nmitimen                                                        ; $008FE2 |/
    RTS                                                                         ; $008FE5

; _calculate_transition_effects ($00:8FE6)
;
; Reads the current index in $79 and based on that sets up the timer IRQ for the
; windowing effect and calculates the value used in the mosaic.
_calculate_transition_effects:
    LDA <r_transition_index                                                     ; $008FE6 |\
    ASL A                                                                       ; $008FE8 | | Calculate the index and store it in the X register.
    TAX                                                                         ; $008FE9 |/
    LDA #$6F                                                                    ; $008FEA |\
    SEC                                                                         ; $008FEC | | Based on the current frame of the transition, set the scanline to
    SBC bank14.transition_window_data.l + 1,X                                   ; $008FED | | trigger the timer IRQ.
    TAY                                                                         ; $008FF1 | |
    STY reg_cpu_vtimel                                                          ; $008FF2 |/
    LDA #$80                                                                    ; $008FF5 |\
    SEC                                                                         ; $008FF7 | | Calculate the starting X position and set the appropriate window
    SBC bank14.transition_window_data.l,X                                       ; $008FF8 | | register.
    STA reg_ppu_wh0                                                             ; $008FFC |/
    LDA #$7F                                                                    ; $008FFF |\
    CLC                                                                         ; $009001 | | Calculate the ending X position and set the appropriate window
    ADC bank14.transition_window_data.l,X                                       ; $009002 | | register.
    STA reg_ppu_wh1                                                             ; $009006 |/
    LDA <r_transition_index                                                     ; $009009 |\
    LSR A                                                                       ; $00900B | | Calculate the mosaic value from the transition index. Mosaic
    ASL A                                                                       ; $00900C | | ranges from 0 to 15, and the transition index ranges from 0 to 32
    ASL A                                                                       ; $00900D | | (but never higher than 31 when this code is called), so divide it
    ASL A                                                                       ; $00900E | | by two to get the mosaic value. Shift it four bits to the left and
    ASL A                                                                       ; $00900F | | add three to prepare it to be stored in the PPU mosaic register.
    CLC                                                                         ; $009010 | | The bottom four bits determine which of the four backgrounds have
    ADC #$03                                                                    ; $009011 | | mosaic enabled. The register is actually set at a later time.
    STA r_transition_mosaic.w                                                   ; $009013 |/
    LDA #$A1                                                                    ; $009016 |\ Set the CPU to enable NMI, vertical timer IRQ, and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $009018 |/
    LDA #$80                                                                    ; $00901B |\ Set the PPU to force blank and brightness zero.
    STA reg_ppu_inidisp                                                         ; $00901D |/
    RTS                                                                         ; $009020

; _do_out_transition ($00:9021)
;
; Executes the part of the transition that occurs when exiting the map. The
; actual rendering is handled by the NMI and IRQ handlers, but this routine
; loops and increases the index used in those renderings.
_do_out_transition:
    LDA #$01.b                                                                  ; $009021 |\ Indicate that a transition is active.
    STA <r_transition_active                                                    ; $009023 |/
    LDA #%00000111.b                                                            ; $009025 |\
    STA reg_ppu_tm                                                              ; $009027 | | Set BG1, BG2 and BG3 as main screens and BG1 as sub screen.
    LDA #%00000001.b                                                            ; $00902A | |
    STA reg_ppu_ts                                                              ; $00902C |/
    STZ <r_map_frame_counter                                                    ; $00902F | Reset the map frame counter to zero.
    STZ <r_transition_index                                                     ; $009031 | Set the transition index to zero.
    LDA #%10000001.b                                                            ; $009033 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $009035 |/
    CLI                                                                         ; $009038 | Enable interrupts.
--  JSR _wait_for_nmi_complete_field                                            ; $009039 | Wait for the next NMI. Timer interrupts will be reenabled.
-   LDA <r_irq_index                                                            ; $00903C |\
    CMP #$02.b                                                                  ; $00903E | | Wait until after the second IRQ handler.
    BNE -                                                                       ; $009040 |/
    INC <r_transition_index                                                     ; $009042 |\
    LDA <r_transition_index                                                     ; $009044 | | Keep incrementing the transition index and repeating the loop
    CMP #$20.b                                                                  ; $009046 | | until it reaches 32 and the out transition is complete.
    BNE --                                                                      ; $009048 |/
    RTS                                                                         ; $00904A

; _do_in_transition ($00:904B)
;
; Executes the part of the transition that occurs when entering the map. The
; actual rendering is handled by the NMI and IRQ handlers, but this routine
; loops and decreases the index used in those renderings.
_do_in_transition:
    LDA #$01.b                                                                  ; $00904B |\ Indicate that a transition is active.
    STA <r_transition_active                                                    ; $00904D |/
    STZ <r_map_frame_counter                                                    ; $00904F | Reset the map frame counter to zero.
    LDA #31.b                                                                   ; $009051 |\ Initialize the transition index to 31.
    STA <r_transition_index                                                     ; $009053 |/
    LDA #%10000000.b                                                            ; $009055 |\ Set forced blanking and brightness to zero.
    STA reg_ppu_inidisp                                                         ; $009057 |/
    LDA #%10000001.b                                                            ; $00905A |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00905C |/
    CLI                                                                         ; $00905F | Enable interrupts.
--  JSR _wait_for_nmi_complete_field                                            ; $009060 | Wait for the next NMI. Timer interrupts will be reenabled.
-   LDA <r_irq_index                                                            ; $009063 |\
    CMP #$02.b                                                                  ; $009065 | | Wait until after the second IRQ handler.
    BNE -                                                                       ; $009067 |/
    DEC <r_transition_index                                                     ; $009069 |\ Decrement the transition index and repeat until it passes zero.
    BPL --                                                                      ; $00906B |/
    STZ <r_transition_active                                                    ; $00906D | Unflag the active transition.
    LDA <r_cutscene_active                                                      ; $00906F |\
    BNE +                                                                       ; $009071 | | If a cutscene is active, set the brightness to the value stored
    LDA #$0F.b                                                                  ; $009073 | | in the PPU brightness variable. Otherwise, set maximum brightness.
    JMP ++                                                                      ; $009075 | |
+   LDA <r_ppu_brightness                                                       ; $009078 | |
++  STA reg_ppu_inidisp                                                         ; $00907A |/
    RTS                                                                         ; $00907D

; UNUSED_CODE_00907E ($00:907E)
;
; This apparently unused code appears to multiply by 64.
UNUSED_CODE_00907E:
    ASL A                                                                       ; $00907E
    ASL A                                                                       ; $00907F
    ASL A                                                                       ; $009080
    ASL A                                                                       ; $009081
    ASL A                                                                       ; $009082
    ASL A                                                                       ; $009083
    RTS                                                                         ; $009084

; nmi_handler ($00:9085)
;
; This function is ultimately called for every generated NMI.
nmi_handler:
    PHP                                                                         ; $009085 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $009086 | | Preserve the contents of numerous registers.
    PHA                                                                         ; $009088 | |
    PHX                                                                         ; $009089 | |
    PHY                                                                         ; $00908A | |
    PHB                                                                         ; $00908B | |
    PHD                                                                         ; $00908C | |
    LDA #$0000                                                                  ; $00908D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $009090 |/
    LDA reg_cpu_rdnmi                                                           ; $009092 |\ Reset the NMI flag.
    LDA reg_cpu_rdnmi                                                           ; $009095 |/
    STZ reg_cpu_mdmaen                                                          ; $009098 |\ Disable DMA and H-DMA.
    STZ reg_cpu_hdmaen                                                          ; $00909B |/
    LDX #$0600                                                                  ; $00909E |\
    PHX                                                                         ; $0090A1 | | Set the direct register to $0600.
    PLD                                                                         ; $0090A2 |/
    LDA #$00                                                                    ; $0090A3 |\
    PHA                                                                         ; $0090A5 | | Set the data bank register to $00.
    PLB                                                                         ; $0090A6 |/
    STZ <r_irq_index                                                            ; $0090A7 | Zero out the IRQ index.
    JSL bank15.copy_oam_to_ppu                                                  ; $0090A9 | Transfer the current OAM data to the PPU.
    LDA <r_enable_flash_palette                                                 ; $0090AD |\
    BEQ +                                                                       ; $0090AF | | Load the alternate CG-RAM data if the flash palette is enabled.
    JSR _copy_alternate_cgram_to_ppu                                            ; $0090B1 | |
    STZ <r_enable_flash_palette                                                 ; $0090B4 | |
    JMP ++                                                                      ; $0090B6 |/
+   JSL bank15.copy_cgram_to_ppu                                                ; $0090B9 | Copy palette data to PPU.
++  JSL bank15.configure_map_hdma                                               ; $0090BD | Configure the map DMA (for mode 7 effects).
    LDA <r_skip_field_graphic_effects                                           ; $0090C1 |\
    BEQ +                                                                       ; $0090C3 | | If field graphic effects are disabled, skip ahead.
    STZ <r_skip_field_graphic_effects                                           ; $0090C5 | |
    JMP @next_section                                                           ; $0090C7 |/
+   LDA <r_transition_active                                                    ; $0090CA |\
    BEQ +                                                                       ; $0090CC | | If there is currently a transition in progress, calculate the
    JSR _calculate_transition_effects                                           ; $0090CE | | effects and skip the next section of code.
    JMP @next_section                                                           ; $0090D1 |/
+   LDA r_map_area.w                                                            ; $0090D4 |\
    CMP #MAP_AREA_DUNGEON                                                       ; $0090D7 | | If the current map area is a dungeon, move to the appropriate
    BNE +                                                                       ; $0090D9 | | range of code.
    JMP @map_area_dungeon                                                       ; $0090DB |/
+   JSR _copy_water_tiles                                                       ; $0090DE | Copy the animated water tiles from RAM to VRAM.
    LDA <r_map_frame_counter                                                    ; $0090E1
    LSR                                                                         ; $0090E3
    BCC +                                                                       ; $0090E4
    JMP ++                                                                      ; $0090E6
+   LDA <r_tilemap_dirty                                                        ; $0090E9
    BEQ +                                                                       ; $0090EB
    STZ <r_tilemap_dirty                                                        ; $0090ED
    JSR _copy_tilemap_changes_to_vram                                           ; $0090EF
+   JSL bank15.set_big_whale_light_color                                        ; $0090F2
    JSL bank15.set_tower_of_babil_flash_color                                   ; $0090F6
    JSL bank15.set_magma_glow_colors                                            ; $0090FA
    JMP @next_section                                                           ; $0090FE
++  LDA <r_tilemap_dirty                                                        ; $009101
    BEQ +                                                                       ; $009103
    STZ <r_tilemap_dirty                                                        ; $009105
    JSR _copy_tilemap_changes_to_vram                                           ; $009107
+   JSL bank15.copy_player_field_sprite_to_vram                                 ; $00910A
    JMP @next_section                                                           ; $00910E
@map_area_dungeon:
    LDA <r_tilemap_dirty                                                        ; $009111
    BEQ +                                                                       ; $009113
    STZ <r_tilemap_dirty                                                        ; $009115
    JSR _copy_dungeon_tilemap_changes_to_vram                                   ; $009117
+   JSL bank15.copy_tile_change_to_vram_if_pending                              ; $00911A
    JSR _copy_open_large_door_to_vram_if_pending                                ; $00911E
    JSR _draw_map_title_if_pending                                              ; $009121
    JSR _erase_map_title_if_pending                                             ; $009124
    JSR _erase_dialog_if_pending                                                ; $009127
    JSR _draw_dialog_if_pending                                                 ; $00912A
    LDA <r_upper_dialog_height                                                  ; $00912D |\
    BEQ +                                                                       ; $00912F | | Set the timers for any visible upper dialog.
    JSR _set_upper_dialog_timer                                                 ; $009131 |/
+   LDA <r_lower_dialog_height                                                  ; $009134 |\
    BEQ +                                                                       ; $009136 | | Set the timers for any visible lower dialog.
    JSR _set_lower_dialog_timer                                                 ; $009138 |/
+   LDA <r_map_frame_counter                                                    ; $00913B |\
    LSR                                                                         ; $00913D | | Determine if the frame counter is even or odd and dispatch
    BCC ++                                                                      ; $00913E | | accordingly.
    JMP +                                                                       ; $009140 |/
+   JSR _draw_upper_dialog_text_if_pending                                      ; $009143 |\
    JSR _draw_lower_dialog_text_if_pending                                      ; $009146 | | On odd frames, draw any pending dialog text and set the palettes
    JSL bank15.set_glowing_light_colors                                         ; $009149 | | for any glowing light effects.
    JMP @next_section                                                           ; $00914D |/
++  JSL bank15.copy_player_field_sprite_to_vram                                 ; $009150 |\
    JSR _copy_lake_tiles_to_vram                                                ; $009154 | | On even frames, handle the animated lake tiles as well as other
    JSL bank15.copy_animated_tiles_to_vram                                      ; $009157 | | animated tiles.
    JMP @next_section                                                           ; $00915B |/
@next_section:
    LDA <r_change_map_area_arg_modify_effects                                   ; $00915E |\
    CMP #MAP_EFFECTS_FADE_IN_PENDING.b                                          ; $009160 | | If a fade in is pending, increase the PPU brightness by one step.
    BNE +                                                                       ; $009162 | |
    INC <r_ppu_brightness                                                       ; $009164 | |
    LDA <r_ppu_brightness                                                       ; $009166 | |
    STA reg_ppu_inidisp                                                         ; $009168 |/
    CMP #%00001111.b                                                            ; $00916B |\
    BNE +                                                                       ; $00916D | | If the value reaches maximum, reset the effect flag.
    STZ <r_change_map_area_arg_modify_effects                                   ; $00916F |/
+   JSR _calculate_background_scroll                                            ; $009171 | Calculate the BG2 scroll registers.
    LDA <r_poisoned_character_count                                             ; $009174 |\
    BEQ +                                                                       ; $009176 | | If at least one character is poinsed, a transition is not active,
    LDA <r_transition_active                                                    ; $009178 | | a cutscene is not active, the player is not using a vehicle, and
    BNE +                                                                       ; $00917A | | if movement is currently in progress, activate the mosaic effect
    LDA <r_cutscene_active                                                      ; $00917C | | based on the movement frame counter on BG1 and BG2.
    BNE +                                                                       ; $00917E | |
    LDA r_vehicle.w                                                             ; $009180 | |
    BNE +                                                                       ; $009183 | |
    LDA <r_movement_frame_counter                                               ; $009185 | |
    AND #%00001100                                                              ; $009187 | |
    ASL                                                                         ; $009189 | |
    ASL                                                                         ; $00918A | |
    ORA #%00000011                                                              ; $00918B | |
    STA <r_transition_mosaic                                                    ; $00918D |/
+   LDA <r_transition_mosaic                                                    ; $00918F |\ Copy the mosaic value into the PPU register.
    STA reg_ppu_mosaic                                                          ; $009191 |/
    STZ <r_nmi_handler_tmp                                                      ; $009194 |\
    LDA <r_shaking                                                              ; $009196 | | If the shaking variable is set, choose whether to add or subtract
    BEQ +                                                                       ; $009198 | | an offset of 1 from the horizontal scroll registers by pulling a
    LDA #1.b                                                                    ; $00919A | | random number and seeing if it is even or odd.
    STA <r_nmi_handler_tmp                                                      ; $00919C | |
    JSR _get_field_rng                                                          ; $00919E | |
    AND #%00000001                                                              ; $0091A1 | |
    BNE ++                                                                      ; $0091A3 |/
+   LDA <r_scroll_bg1_horizontal_lo                                             ; $0091A5 |\
    CLC                                                                         ; $0091A7 | | Set the horizontal scroll registers based on the values stored in
    ADC <r_nmi_handler_tmp                                                      ; $0091A8 | | RAM. If the shaking variable was set, an extra offset will be
    STA reg_ppu_bg1h0fs                                                         ; $0091AA | | added to the values.
    LDA <r_scroll_bg1_horizontal_hi                                             ; $0091AD | |
    ADC #0.b                                                                    ; $0091AF | |
    STA reg_ppu_bg1h0fs                                                         ; $0091B1 | |
    LDA <r_scroll_bg2_horizontal_lo                                             ; $0091B4 | |
    CLC                                                                         ; $0091B6 | |
    ADC <r_nmi_handler_tmp                                                      ; $0091B7 | |
    STA reg_ppu_bg2h0fs                                                         ; $0091B9 | |
    LDA <r_scroll_bg2_horizontal_hi                                             ; $0091BC | |
    ADC #0.b                                                                    ; $0091BE | |
    STA reg_ppu_bg2h0fs                                                         ; $0091C0 | |
    JMP @vertical_scroll                                                        ; $0091C3 |/
++  LDA <r_scroll_bg1_horizontal_lo                                             ; $0091C6 |\
    SEC                                                                         ; $0091C8 | | On the other hand, in half the shaking cases, the extra value will
    SBC <r_nmi_handler_tmp                                                      ; $0091C9 | | be subtracted to help amplify the shaking effect.
    STA reg_ppu_bg1h0fs                                                         ; $0091CB | |
    LDA <r_scroll_bg1_horizontal_hi                                             ; $0091CE | |
    SBC #0.b                                                                    ; $0091D0 | |
    STA reg_ppu_bg1h0fs                                                         ; $0091D2 | |
    LDA <r_scroll_bg2_horizontal_lo                                             ; $0091D5 | |
    SEC                                                                         ; $0091D7 | |
    SBC <r_nmi_handler_tmp                                                      ; $0091D8 | |
    STA reg_ppu_bg2h0fs                                                         ; $0091DA | |
    LDA <r_scroll_bg2_horizontal_hi                                             ; $0091DD | |
    SBC #0.b                                                                    ; $0091DF | |
    STA reg_ppu_bg2h0fs                                                         ; $0091E1 |/
@vertical_scroll:
    LDA <r_scroll_bg1_vertical_lo                                               ; $0091E4 |\
    STA reg_ppu_bg1v0fs                                                         ; $0091E6 | | Transfer the vertical scroll register values to the actual vertical
    LDA <r_scroll_bg1_vertical_hi                                               ; $0091E9 | | scroll registers.
    STA reg_ppu_bg1v0fs                                                         ; $0091EB | |
    LDA <r_scroll_bg2_vertical_lo                                               ; $0091EE | |
    STA reg_ppu_bg2v0fs                                                         ; $0091F0 | |
    LDA <r_scroll_bg2_vertical_hi                                               ; $0091F3 | |
    STA reg_ppu_bg2v0fs                                                         ; $0091F5 |/
    LDA <r_scroll_bg1_horizontal_lo                                             ; $0091F8 |\
    CLC                                                                         ; $0091FA | | Calculate the mode 7 X coordinate to the current scroll location
    ADC #120.b                                                                  ; $0091FB | | plus approximately half the screen.
    STA <r_scroll_m7x_lo                                                        ; $0091FD | |
    LDA <r_scroll_bg1_horizontal_hi                                             ; $0091FF | |
    ADC #0.b                                                                    ; $009201 | |
    STA <r_scroll_m7x_hi                                                        ; $009203 |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $009205 |\
    CLC                                                                         ; $009207 | | Calculate the mode 7 Y coordinate similarly to the X coordinate.
    ADC #120.b                                                                  ; $009208 | |
    STA <r_scroll_m7y_lo                                                        ; $00920A | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00920C | |
    ADC #0.b                                                                    ; $00920E | |
    STA <r_scroll_m7y_hi                                                        ; $009210 |/
    LDA <r_scroll_m7x_lo                                                        ; $009212 |\
    STA reg_ppu_m7x                                                             ; $009214 | | Actually set the mode 7 origin coordinates.
    LDA <r_scroll_m7x_hi                                                        ; $009217 | |
    STA reg_ppu_m7x                                                             ; $009219 | |
    LDA <r_scroll_m7y_lo                                                        ; $00921C | |
    STA reg_ppu_m7y                                                             ; $00921E | |
    LDA <r_scroll_m7y_hi                                                        ; $009221 | |
    STA reg_ppu_m7y                                                             ; $009223 |/
    LDA r_map_area.w                                                            ; $009226 |\
    CMP #MAP_AREA_DUNGEON                                                       ; $009229 | | If the current map is not a dungeon map, enable HDMA on channels
    BEQ +                                                                       ; $00922B | | 4 and 5.
    LDA #%00110000.b                                                            ; $00922D | |
    STA reg_cpu_hdmaen                                                          ; $00922F |/
+   JSL bank01.joypad_disable_multi                                             ; $009232 | Disable the multi joypad flag.
    INC <r_map_frame_counter                                                    ; $009236 | Increment the map frame counter.
    INC r_frame_counter.w                                                       ; $009238 | Increment the frame counter.
    INC r_game_time.frames.w                                                    ; $00923B |\
    LDA r_game_time.frames.w                                                    ; $00923E | | Increment the in-game timer.
    CMP #60.b                                                                   ; $009241 | |
    BCC +                                                                       ; $009243 | |
    STZ r_game_time.frames.w                                                    ; $009245 | |
    INC r_game_time.seconds_lo.w                                                ; $009248 | |
    BNE +                                                                       ; $00924B | |
    INC r_game_time.seconds_md.w                                                ; $00924D | |
    BNE +                                                                       ; $009250 | |
    INC r_game_time.seconds_hi.w                                                ; $009252 |/
+   STZ <r_nmi_status                                                           ; $009255 | Reset the NMI status flag.
    REP #FLAG_P_ACCUMULATOR                                                     ; $009257 |\
    PLD                                                                         ; $009259 | | Restore the various registers.
    PLB                                                                         ; $00925A | |
    PLY                                                                         ; $00925B | |
    PLX                                                                         ; $00925C | |
    PLA                                                                         ; $00925D | |
    PLP                                                                         ; $00925E |/
    RTI                                                                         ; $00925F

; irq_handler ($00:9260)
;
; This function is ultimately called for every generated IRQ.
irq_handler:
    PHP                                                                         ; $009260 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $009261 | | Preserve the contents of various registers.
    PHA                                                                         ; $009263 | |
    PHX                                                                         ; $009264 | |
    PHY                                                                         ; $009265 | |
    PHB                                                                         ; $009266 | |
    PHD                                                                         ; $009267 | |
    LDA #$0000                                                                  ; $009268 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00926B |/
    LDX #$0600                                                                  ; $00926D |\
    PHX                                                                         ; $009270 | | Set the direct register to $0600.
    PLD                                                                         ; $009271 |/
    LDA #$00                                                                    ; $009272 |\
    PHA                                                                         ; $009274 | | Set the data bank register to $00.
    PLB                                                                         ; $009275 |/
    LDA reg_cpu_timeup                                                          ; $009276 | Reset the IRQ timer register.
    LDA <r_transition_active                                                    ; $009279 |\
    BEQ +                                                                       ; $00927B | | If a transition is currently active, call the transition IRQ
    JSR _transition_irq_handler                                                 ; $00927D | | handler.
    JMP ++                                                                      ; $009280 |/
+   LDA <r_upper_dialog_height                                                  ; $009283 |\
    BEQ +                                                                       ; $009285 | | If upper dialog height is greater than zero, call the upper dialog
    JSR _upper_dialog_irq_handler                                               ; $009287 | | IRQ handler.
    JMP ++                                                                      ; $00928A |/
+   LDA <r_lower_dialog_height                                                  ; $00928D |\
    BEQ ++                                                                      ; $00928F | | If lower dialog height is greater than zero, call the lower dialog
    JSR _lower_dialog_irq_handler                                               ; $009291 | | IRQ handler.
    JMP ++                                                                      ; $009294 |/
++  INC <r_irq_index                                                            ; $009297 | Increment the IRQ index.
    REP #FLAG_P_ACCUMULATOR                                                     ; $009299 |\
    PLD                                                                         ; $00929B | | Restore the contents of various registers.
    PLB                                                                         ; $00929C | |
    PLY                                                                         ; $00929D | |
    PLX                                                                         ; $00929E | |
    PLA                                                                         ; $00929F | |
    PLP                                                                         ; $0092A0 |/
    RTI                                                                         ; $0092A1 |

; _draw_outdoor_field_sprites ($00:92A2)
;
; Calls numerous functions to draw the player field sprite and the field sprites
; for all the vehicles.
_draw_outdoor_field_sprites:
    JSL bank15.draw_outdoor_field_sprite_player                                 ; $0092A2 | Field sprite
    JSL bank15.draw_field_sprite_yellow_chocobo                                 ; $0092A6 | Chocobo related
    JSL bank15.draw_field_sprite_black_chocobo                                  ; $0092AA | Black Chocobo related
    JSL bank15.draw_field_sprite_hovercraft                                     ; $0092AE | Hovercraft
    JSL bank15.draw_field_sprite_enterprise                                     ; $0092B2 | Enterprise
    JSL bank15.draw_field_sprite_falcon                                         ; $0092B6 | Falcon
    JSL bank15.draw_field_sprite_big_whale                                      ; $0092BA | Big Whale
    JSL bank15.draw_field_sprite_ship                                           ; $0092BE | Ship
    LDA #PLOT_FLAG_TANKS_AT_BABIL.b                                             ; $0092C2 |\
    JSR _get_plot_flag                                                          ; $0092C4 | | If the value of plot flag $3E is non-zero, draw tanks next to the
    CMP #$00.b                                                                  ; $0092C7 | | Tower of Bab-il.
    BEQ +                                                                       ; $0092C9 | |
    JSL bank15.draw_field_sprite_tanks                                          ; $0092CB |/
+   RTS                                                                         ; $0092CF

; init_cecil ($00:92D0)
;
; Initializes Cecil with his default stats and equipment. In addition, triggers
; a complete initialization of the in-battle character records and derived
; stats. Derived stats for any non-Cecil characters will be incorrect.
init_cecil:
    LDX #$0000.w                                                                ; $0092D0 |\
    LDY #$0000.w                                                                ; $0092D3 | | Copies the first 20 bytes to the character record.
-   LDA bank0F.initial_stats_data.l,X                                           ; $0092D6 | |
    STA r_character_field,Y                                                     ; $0092DA | |
    INX                                                                         ; $0092DD | |
    INY                                                                         ; $0092DE | |
    CPY #$0014.w                                                                ; $0092DF | |
    BNE -                                                                       ; $0092E2 |/
    LDY #$0000.w                                                                ; $0092E4 |\
-   LDA bank0F.initial_stats_data.l,X                                           ; $0092E7 | | Copies the next three bytes to a different location in the record.
    STA r_character_field.1.critical_rate,Y                                     ; $0092EB | |
    INX                                                                         ; $0092EE | |
    INY                                                                         ; $0092EF | |
    CPY #$0003.w                                                                ; $0092F0 | |
    BNE -                                                                       ; $0092F3 |/
    LDY #$0000.w                                                                ; $0092F5 |\
-   LDA bank0F.initial_stats_data.l,X                                           ; $0092F8 | | Copy the next nine bytes to yet another location in the record.
    STA r_character_field.1.experience_lo,Y                                     ; $0092FC | |
    INX                                                                         ; $0092FF | |
    INY                                                                         ; $009300 | |
    CPY #$0009.w                                                                ; $009301 | |
    BNE -                                                                       ; $009304 |/
    LDY #$0000.w                                                                ; $009306 |\
    STY <r_load_initial_arg_target_index                                        ; $009309 | | Load Cecil's initial equipment to his character record.
    JSR _load_initial_equipment_cecil                                           ; $00930B |/
    LDA #$00.b                                                                  ; $00930E |\ Calculate the character stats for slot 0. This is silly since the
    JSL bank03.calculate_character_stats                                        ; $009310 |/ previous function call just called this.
    RTS                                                                         ; $009314

; _animate_flight_to_underworld ($00:9315)
;
; Animates the airship flying from the overworld to the underworld.
_animate_flight_to_underworld:
    LDA #DIRECTION_LEFT.b                                                       ; $009315 |\ Set the direction to left.
    STA r_direction.w                                                           ; $009317 |/
    LDA #31.b                                                                   ; $00931A |\ Initialize the transition index to 31.
    STA <r_transition_index                                                     ; $00931C |/
-   JSR _do_tile_animations                                                     ; $00931E | Wait for NMI and do any tile animations.
    LDA <r_transition_index                                                     ; $009321 |\ Set the zoom level to the current transition index.
    STA <r_zoom_level                                                           ; $009323 |/
    LDA r_vehicle.w                                                             ; $009325 |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $009328 | | If the vehicle is the Enterprise, decrement the enterprise
    BNE +                                                                       ; $00932A | | altitude.
    DEC <r_enterprise_altitude                                                  ; $00932C | |
    LDA <r_enterprise_altitude                                                  ; $00932E | |
    JMP ++                                                                      ; $009330 |/
+   DEC <r_falcon_altitude                                                      ; $009333 |\ Otherwise, decrement the Falcon altitude.
    LDA <r_falcon_altitude                                                      ; $009335 |/
++  JSL bank15.set_zoom_palette                                                 ; $009337 | Set the zoom palette using that altitude.
    JSR _init_oam                                                               ; $00933B |\
    JSL bank15.draw_field_sprite_enterprise                                     ; $00933E | | Redraw the Enterprise and Falcon sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $009342 |/
    DEC <r_transition_index                                                     ; $009346 |\
    LDA <r_transition_index                                                     ; $009348 | | Decrement the transition index and loop until it reaches 16.
    CMP #16.b                                                                   ; $00934A | |
    BCS -                                                                       ; $00934C |/
    LDA #31.b                                                                   ; $00934E |\ Set the transition index to 31 again.
    STA <r_transition_index                                                     ; $009350 |/
-   LDA #31.b                                                                   ; $009352 |\
    SEC                                                                         ; $009354 | | Determine the phase from the current transition index.
    SBC <r_transition_index                                                     ; $009355 | |
    TAX                                                                         ; $009357 | |
    LDA bank14.airship_swirl_phase_data.l,X                                     ; $009358 | |
    STA r_field_effect_swirl_current_phase.w                                    ; $00935C |/
    LDA <r_transition_index                                                     ; $00935F |\ Set the zoom level for the current frame.
    STA <r_zoom_level                                                           ; $009361 |/
    JSR _wait_for_nmi_complete                                                  ; $009363 | Wait for the next NMI.
    STZ reg_cpu_hdmaen.w                                                        ; $009366 | Disable HDMA.
    JSR _field_effect_zoom_set_mode_7_parameters                                ; $009369 |\ Set the mode 7 parameters for the current frame.
    JSR _set_mode_7_transform                                                   ; $00936C |/
    JSR _set_ppu_brightness                                                     ; $00936F | Set the PPU brightness.
    JSL bank15.draw_field_sprite_enterprise                                     ; $009372 |\ Draw the Enterprise and Falcon sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $009376 |/
    DEC <r_transition_index                                                     ; $00937A |\
    LDA <r_transition_index                                                     ; $00937C | | Loop until the transition index goes negative.
    BPL -                                                                       ; $00937E |/
    LDA #113.b                                                                  ; $009380 |\
    STA r_current_coordinates.x.w                                               ; $009382 | | Set the current coordinates to 113, 16.
    LDA #16.b                                                                   ; $009385 | |
    STA r_current_coordinates.y.w                                               ; $009387 |/
    LDA #MAP_AREA_UNDERWORLD.b                                                  ; $00938A |\
    STA r_map_area.w                                                            ; $00938C | | Set the map area and plane for the underworld.
    STA r_map_plane.w                                                           ; $00938F |/
    LDA r_vehicle.w                                                             ; $009392 |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $009395 | | If flying the Enterprise, update the Enterprise plane. If the
    BNE +                                                                       ; $009397 | | hovercraft is hooked, update its plane as well.
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $009399 | |
    STA r_enterprise_plane.w                                                    ; $00939B | |
    LDA r_hovercraft_hooked.w                                                   ; $00939E | |
    BEQ ++                                                                      ; $0093A1 | |
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $0093A3 | |
    STA r_hovercraft_plane.w                                                    ; $0093A5 | |
    JMP ++                                                                      ; $0093A8 |/
+   LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $0093AB |\ Otherwise, update the Falcon plane.
    STA r_falcon_plane.w                                                        ; $0093AD |/
++  JSR _change_map_underworld                                                  ; $0093B0 | Change the map to the underworld.
    LDA #16.b                                                                   ; $0093B3 |\ Set the zoom palette to normal.
    JSL bank15.set_zoom_palette                                                 ; $0093B5 |/
    LDA #DIRECTION_LEFT.b                                                       ; $0093B9 |\ Set the direction to left.
    STA r_direction.w                                                           ; $0093BB |/
    LDA #%10000001.b                                                            ; $0093BE |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $0093C0 |/
    LDA #0.b                                                                    ; $0093C3 |\ Set PPU brightness to zero.
    STA reg_ppu_inidisp.w                                                       ; $0093C5 |/
    LDA #32.b                                                                   ; $0093C8 |\ Set the zoom level to airship flight.
    STA <r_zoom_level                                                           ; $0093CA |/
    LDA #47.b                                                                   ; $0093CC |\ Initialize the transition index to 47.
    STA <r_transition_index                                                     ; $0093CE |/
-   JSR _do_tile_animations                                                     ; $0093D0 | Wait for the NMI and do the tile animations.
    LDA #47.b                                                                   ; $0093D3 |\
    SEC                                                                         ; $0093D5 | | Set the PPU brightness to increase by one step per frame until it
    SBC <r_transition_index                                                     ; $0093D6 | | reaches maximum.
    CMP #16.b                                                                   ; $0093D8 | |
    BCS +                                                                       ; $0093DA | |
    STA reg_ppu_inidisp.w                                                       ; $0093DC |/
+   LDA <r_transition_index                                                     ; $0093DF |\
    TAX                                                                         ; $0093E1 | | If flying the Enterprise, update the Enterprise altitude.
    LDA r_vehicle.w                                                             ; $0093E2 | |
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $0093E5 | |
    BNE +                                                                       ; $0093E7 | |
    LDA bank14.airship_underworld_transition_altitude_data.l,X                  ; $0093E9 | |
    STA <r_enterprise_altitude                                                  ; $0093ED | |
    JMP ++                                                                      ; $0093EF |/
+   LDA bank14.airship_underworld_transition_altitude_data.l,X                  ; $0093F2 |\ Otherwise, update the Falcon altitude.
    STA <r_falcon_altitude                                                      ; $0093F6 |/
++  JSL bank15.draw_field_sprite_enterprise                                     ; $0093F8 |\ Redraw the Falcon and Enterprise sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $0093FC |/
    DEC <r_transition_index                                                     ; $009400 |\
    LDA <r_transition_index                                                     ; $009402 | | Decrement the transition index and loop until it goes negative.
    CMP #-1.b                                                                   ; $009404 | |
    BNE -                                                                       ; $009406 |/
    RTS                                                                         ; $009408

; _animate_flight_from_underworld ($00:9409)
;
; Animates the trip from the underworld to the overworld via the Agart mountain.
; If the relevant plot flags are set, also animates the Agart mountain opening.
_animate_flight_from_underworld:
    JSR _animate_rising_airship                                                 ; $009409 | Animate the airship rising.
    LDA #PLOT_FLAG_AGART_MOUNTAIN_OPEN.b                                        ; $00940C |\
    JSR _get_plot_flag                                                          ; $00940E | | Skip to the end if the Agart mountain is already open.
    CMP #0.b                                                                    ; $009411 | |
    BNE +                                                                       ; $009413 |/
    LDA #PLOT_FLAG_FALCON_DRILL_INSTALLED.b                                     ; $009415 |\
    JSR _get_plot_flag                                                          ; $009417 | | Skip the animation unless the drill is installed.
    CMP #0.b                                                                    ; $00941A | |
    BEQ +                                                                       ; $00941C |/
    LDA #1.b                                                                    ; $00941E |\
    STA <r_cutscene_active                                                      ; $009420 | | Animate the Agart mountain opening.
    LDA #EVENT_INDEX_AGART_OPENING_AIRSHIP.b                                    ; $009422 | |
    JSR _decode_event                                                           ; $009424 | |
    STZ <r_cutscene_active                                                      ; $009427 |/
+   JSR _animate_agart_exit_swirl                                               ; $009429 | Animate the exit swirl for the Agart mountain.
    RTS                                                                         ; $00942C

; _animate_rising_airship ($00:942D)
;
; Animates the airship rising toward the top of the screen, fading the screen
; out to black after 48 increments.
_animate_rising_airship:
    LDA #DIRECTION_LEFT.b                                                       ; $00942D |\ Set the direction to left.
    STA r_direction.w                                                           ; $00942F |/
    LDA #0.b                                                                    ; $009432 |\ Initialize the transition index to zero.
    STA <r_transition_index                                                     ; $009434 |/
-   JSR _do_tile_animations                                                     ; $009436 | Wait for NMI and do any tile animations.
    LDA #47.b                                                                   ; $009439 |\
    SEC                                                                         ; $00943B | | Set the PPU brightness based on the current transition index. Dims
    SBC <r_transition_index                                                     ; $00943C | | the screen as the value approaches 47.
    CMP #16.b                                                                   ; $00943E | |
    BCS +                                                                       ; $009440 | |
    STA reg_ppu_inidisp.w                                                       ; $009442 |/
+   LDA <r_transition_index                                                     ; $009445 |\
    TAX                                                                         ; $009447 | | If flying the Enterprise, set the Enterprise altitude.
    LDA r_vehicle.w                                                             ; $009448 | |
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $00944B | |
    BNE +                                                                       ; $00944D | |
    LDA bank14.airship_underworld_transition_altitude_data.l,X                  ; $00944F | |
    STA <r_enterprise_altitude                                                  ; $009453 | |
    JMP ++                                                                      ; $009455 |/
+   LDA bank14.airship_underworld_transition_altitude_data.l,X                  ; $009458 |\ Otherwise, set the Falcon altitude.
    STA <r_falcon_altitude                                                      ; $00945C |/
++  JSR _init_oam                                                               ; $00945E | Initialize the OAM.
    JSL bank15.draw_field_sprite_enterprise                                     ; $009461 |\ Redraw the Enterprise and Falcon sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $009465 |/
    INC <r_transition_index                                                     ; $009469 |\
    LDA <r_transition_index                                                     ; $00946B | | Increment the transition index and loop until it reaches 48.
    CMP #48.b                                                                   ; $00946D | |
    BNE -                                                                       ; $00946F |/
    RTS                                                                         ; $009471

; _animate_agart_exit_swirl ($00:9472)
;
; Animates the exit swirl for the Agart mountain.
_animate_agart_exit_swirl:
    LDA #106.b                                                                  ; $009472 |\
    STA r_current_coordinates.x.w                                               ; $009474 | | Set the current coordinates to 106, 212.
    LDA #212.b                                                                  ; $009477 | |
    STA r_current_coordinates.y.w                                               ; $009479 |/
    LDA #MAP_AREA_OVERWORLD.b                                                   ; $00947C |\
    STA r_map_area.w                                                            ; $00947E | | Set the map area and plane to the overworld.
    STA r_map_plane.w                                                           ; $009481 |/
    LDA r_vehicle.w                                                             ; $009484 |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $009487 | | Update the planes of the appropriate vehicles to the overworld.
    BNE +                                                                       ; $009489 | | The Enterprise if flying the Enterprise, the hovercraft if
    STZ r_enterprise_plane.w                                                    ; $00948B | | currently hooked by the Enterprise, and the Falcon if flying the
    LDA r_hovercraft_hooked.w                                                   ; $00948E | | Falcon.
    BEQ ++                                                                      ; $009491 | |
    STZ r_hovercraft_plane.w                                                    ; $009493 | |
    JMP ++                                                                      ; $009496 | |
+   STZ r_falcon_plane.w                                                        ; $009499 |/
++  JSR _change_map_overworld                                                   ; $00949C | Change the map to the overworld.
    LDA #DIRECTION_LEFT.b                                                       ; $00949F |\ Set the direction to left.
    STA r_direction.w                                                           ; $0094A1 |/
    LDA #%10000001.b                                                            ; $0094A4 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $0094A6 |/
    STZ <r_transition_index                                                     ; $0094A9 | Initialize the transition index to zero.
    LDA r_vehicle.w                                                             ; $0094AB |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $0094AE | | Set the altitude of the current airship to zero.
    BNE +                                                                       ; $0094B0 | |
    STZ <r_enterprise_altitude                                                  ; $0094B2 | |
    JMP @loop_start                                                             ; $0094B4 | |
+   STZ <r_falcon_altitude                                                      ; $0094B7 |/
@loop_start:
    JSR _wait_for_nmi_complete                                                  ; $0094B9 | Wait for the next NMI.
    STZ reg_cpu_hdmaen.w                                                        ; $0094BC | Disable HDMA.
    LDA #32.b                                                                   ; $0094BF |\
    SEC                                                                         ; $0094C1 | | Set the current swirl phase based on the transition index.
    SBC <r_transition_index                                                     ; $0094C2 | |
    TAX                                                                         ; $0094C4 | |
    LDA bank14.airship_swirl_phase_data.l,X                                     ; $0094C5 | |
    STA r_field_effect_swirl_current_phase.w                                    ; $0094C9 |/
    LDA <r_transition_index                                                     ; $0094CC |\ Set the zoom level based on the current transition index.
    STA <r_zoom_level                                                           ; $0094CE |/
    JSR _field_effect_zoom_set_mode_7_parameters                                ; $0094D0 |\ Set the mode 7 transform for the current frame.
    JSR _set_mode_7_transform                                                   ; $0094D3 |/
    JSR _set_ppu_brightness                                                     ; $0094D6 | Set the PPU brightness.
    JSL bank15.draw_field_sprite_enterprise                                     ; $0094D9 |\ Update the Enterprise and Falcon sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $0094DD |/
    INC <r_transition_index                                                     ; $0094E1 |\
    LDA <r_transition_index                                                     ; $0094E3 | | Increment the transition index and loop until it reaches 32.
    CMP #32.b                                                                   ; $0094E5 | |
    BNE @loop_start                                                             ; $0094E7 |/
    LDA #17.b                                                                   ; $0094E9 |\ Set the transition index to 17.
    STA <r_transition_index                                                     ; $0094EB |/
    STA <r_zoom_level                                                           ; $0094ED | Set the zoom level.
-   JSR _do_tile_animations                                                     ; $0094EF | Wait for NMI and do tile animations.
    LDA <r_transition_index                                                     ; $0094F2 |\ Set the zoom level based on the transition index.
    STA <r_zoom_level                                                           ; $0094F4 |/
    LDA r_vehicle.w                                                             ; $0094F6 |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $0094F9 | | If flying the Enterprise, increment the Enterprise altitude.
    BNE +                                                                       ; $0094FB | |
    INC <r_enterprise_altitude                                                  ; $0094FD | |
    LDA <r_enterprise_altitude                                                  ; $0094FF | |
    JMP ++                                                                      ; $009501 |/
+   INC <r_falcon_altitude                                                      ; $009504 |\ Otherwise, increment the Falcon altitude.
    LDA <r_falcon_altitude                                                      ; $009506 |/
++  JSL bank15.set_zoom_palette                                                 ; $009508 | Set the zoom palette.
    JSL bank15.draw_field_sprite_enterprise                                     ; $00950C |\ Update the Enterprise and Falcon field sprites.
    JSL bank15.draw_field_sprite_falcon                                         ; $009510 |/
    INC <r_transition_index                                                     ; $009514 |\
    LDA <r_transition_index                                                     ; $009516 | | Increment the transition index and loop until it reaches 33.
    CMP #33.b                                                                   ; $009518 | |
    BNE -                                                                       ; $00951A |/
    RTS                                                                         ; $00951C

; _copy_outdoor_field_sprites_to_vram ($00:951D)
;
; Copies several field sprites to VRAM, mostly those used outdoors. In
; particular, it copies the chocobo sprites from bank $1B, the entire set of
; field sprites from bank $1C, and the generic field sprite palette data used
; in rendering most of these sprites.
_copy_outdoor_field_sprites_to_vram:
    LDX #$4200.w                                                                ; $00951D |\
    STX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $009520 | | Copy the sprite data for the chocobo from ROM to VRAM. The size is
    LDX #bank1B._sizeof_field_sprite_chocobo_data.w * 2 / 3                     ; $009522 | | calculated by multiplying the size of the data in bytes by 16/12
    STX <r_copy_3bpp_to_vram_arg_words                                          ; $009525 | | first to determine the expanded size, and then divided by two to
    LDX #bank1B.field_sprite_chocobo_data.w                                     ; $009527 | | determine the word count. The fraction has been simplified to 2/3.
    STX <r_copy_3bpp_to_vram_arg_address                                        ; $00952A | |
    LDA #:bank1B.field_sprite_chocobo_data.b                                    ; $00952C | |
    STA <r_copy_3bpp_to_vram_arg_bank                                           ; $00952E | |
    JSL bank15.copy_3bpp_to_vram                                                ; $009530 |/
    LDX #$4300.w                                                                ; $009534 |\
    STX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $009537 | | Copy various sprites from ROM to VRAM. This section of code copies
    LDX #$1D00.w                                                                ; $009539 | | $1D00 words. TODO: This copies beyond what appears to be obvious
    STX <r_copy_3bpp_to_vram_arg_words                                          ; $00953C | | sprites, so figure out what additional data is being copied and
    LDX #bank1C.field_sprite_data.w                                             ; $00953E | | why.
    STX <r_copy_3bpp_to_vram_arg_address                                        ; $009541 | |
    LDA #:bank1C.field_sprite_data.b                                            ; $009543 | |
    STA <r_copy_3bpp_to_vram_arg_bank                                           ; $009545 | |
    JSL bank15.copy_3bpp_to_vram                                                ; $009547 |/
    LDY #$0000.w                                                                ; $00954B |\
    LDX #$0000.w                                                                ; $00954E | | Copy the generic field sprite palettes from ROM to the CG-RAM
--  LDA bank0D.generic_field_sprite_palette_data.l,X                            ; $009551 | | staging area. These are four palettes starting at the 13th
    STA r_cgram_data.13,Y                                                       ; $009555 | | palette.
    INX                                                                         ; $009558 | |
    INY                                                                         ; $009559 | |
    TYA                                                                         ; $00955A | |
    AND #%00001111.b                                                            ; $00955B | |
    BNE --                                                                      ; $00955D |/
-   LDA #$00.b                                                                  ; $00955F |\
    STA r_cgram_data.13,Y                                                       ; $009561 | | Since they are only 8-color palettes, the remaining 8 colors are
    INY                                                                         ; $009564 | | all filled in with black.
    TYA                                                                         ; $009565 | |
    AND #%00001111.b                                                            ; $009566 | |
    BNE -                                                                       ; $009568 | |
    CPY #$0080.w                                                                ; $00956A | |
    BNE --                                                                      ; $00956D |/
    JSL bank15.copy_whirlpool_field_sprites_to_vram                             ; $00956F | TODO: Identify the purpose of this function.
    RTS                                                                         ; $009573

; _copy_player_and_outdoor_field_sprites_to_vram ($00:9574)
;
; Copies various field sprites to VRAM including the player field sprite and
; various outdoor field sprites.
_copy_player_and_outdoor_field_sprites_to_vram:
    LDA #$01.b                                                                  ; $009574 |\
    STA <r_player_field_sprite_dirty                                            ; $009576 | | Force copy the player field sprite to VRAM.
    JSL bank15.copy_player_field_sprite_to_vram                                 ; $009578 |/
    JSL bank15.load_player_field_sprite_palettes                                ; $00957C | Copy the player field sprite palettes to VRAM.
    JSR _copy_outdoor_field_sprites_to_vram                                     ; $009580 | Copy various mostly outdoor field sprites and palettes to VRAM.
    RTS                                                                         ; $009583

; _copy_player_and_whirlpool_field_sprites_to_vram ($00:9584)
;
; Copies various field sprites to VRAM including the player field sprite and
; the whirlpool sprites.
_copy_player_and_whirlpool_field_sprites_to_vram:
    LDA #1.b                                                                    ; $009584 |\
    STA <r_player_field_sprite_dirty                                            ; $009586 | | Force copy the player field sprite to VRAM.
    JSL bank15.copy_player_field_sprite_to_vram                                 ; $009588 |/
    JSL bank15.load_player_field_sprite_palettes                                ; $00958C | Copy the player field sprite palettes to VRAM.
    JSL bank15.copy_whirlpool_field_sprites_to_vram                             ; $009590 | Copy the whirlpool sprites to VRAM.
    RTS                                                                         ; $009594

; _do_walking_poison ($00:9595)
;
; Checks the five characters for poison, and if they are poisoned, reduces their
; HP by one. If any characters are poisoned, it also plays the poison sound
; effect.
_do_walking_poison:
    STZ <r_poisoned_character_count                                             ; $009595 | Set the count of poisoned characters to zero.
    LDA r_vehicle.w                                                             ; $009597 |\ If the player is using a vehicle, poison is not applied.
    BNE @done                                                                   ; $00959A |/
    LDX #$0000.w                                                                ; $00959C |\
-   LDA r_character_field.1.id.w,X                                              ; $00959F | | Skip this slot if empty.
    BEQ ++                                                                      ; $0095A2 |/
    LDA r_character_field.1.status_1.w,X                                        ; $0095A4 |\
    AND #STATUS_1_POISON.b                                                      ; $0095A7 | | Skip this slot if not poisoned.
    BEQ ++                                                                      ; $0095A9 |/
    INC <r_poisoned_character_count                                             ; $0095AB | Increment the poisoned character count.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0095AD |\
    LDA r_character_field.1.hp.w,X                                              ; $0095AF | | If the character has zero HP, skip this slot.
    BEQ +                                                                       ; $0095B2 |/
    SEC                                                                         ; $0095B4 |\
    SBC #$0001.w                                                                ; $0095B5 | | Subtract 1 from the character's HP and make sure it doesn't go any
    STA r_character_field.1.hp.w,X                                              ; $0095B8 | | lower than that.
    CMP #$0001.w                                                                ; $0095BB | |
    BCS +                                                                       ; $0095BE | |
    LDA #$0001.w                                                                ; $0095C0 | |
    STA r_character_field.1.hp.w,X                                              ; $0095C3 |/
+   LDA #$0000.w                                                                ; $0095C6 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0095C9 | | Loop through all five character slots.
++  JSR _increment_x_by_64                                                      ; $0095CB | |
    CPX #_sizeof_character_field.w * 5                                          ; $0095CE | |
    BNE -                                                                       ; $0095D1 |/
    LDA <r_poisoned_character_count                                             ; $0095D3 |\
    BEQ @done                                                                   ; $0095D5 | | If there are poisoned characters play the poison sound effect. The
    LDA <r_cutscene_active                                                      ; $0095D7 | | sound effect is disabled during cutscenes.
    BNE @done                                                                   ; $0095D9 | |
    LDA #AUDIO_EFFECT_WALK_POISON.b                                             ; $0095DB | |
    JSR _play_sound_effect                                                      ; $0095DD |/
@done:
    RTS                                                                         ; $0095E0

; _do_walking_damage ($00:95E1)
;
; If the current tile is a damage tile, checks for any character without the
; float status and reduces their HP by fifty. If any characters are affected,
; the damage sound effect is played.
_do_walking_damage:
    STZ <r_damaged_character_count                                              ; $0095E1 | Zero out the damaged character count.
    LDA <r_tile_properties_current.properties_2                                 ; $0095E3 |\
    AND #TILE_PROPERTY_2_DAMAGE.b                                               ; $0095E5 | | Return if the current tile is not a damage tile.
    BEQ @done                                                                   ; $0095E7 |/
    LDX #$0000.w                                                                ; $0095E9 | Initialize the character index to zero.
-   LDA r_character_field.1.id.w,X                                              ; $0095EC |\ Skip any further checks if this character slot is empty.
    BEQ +++                                                                     ; $0095EF |/
    LDA r_character_field.1.status_1.w,X                                        ; $0095F1 |\ Skip any further checks if the character in this slot is dead.
    BMI +++                                                                     ; $0095F4 |/
    LDA r_character_field.1.status_2.w,X                                        ; $0095F6 |\
    AND #STATUS_2_FLOAT.b                                                       ; $0095F9 | | Skip the rest if the character has float status.
    BNE +++                                                                     ; $0095FB |/
    INC <r_damaged_character_count                                              ; $0095FD | Increment the damaged character count.
    REP #FLAG_P_ACCUMULATOR                                                     ; $0095FF |\
    LDA r_character_field.1.hp.w,X                                              ; $009601 | | Subtract 50 from the character's HP.
    BEQ ++                                                                      ; $009604 | |
    SEC                                                                         ; $009606 | |
    SBC #50.w                                                                   ; $009607 | |
    STA r_character_field.1.hp.w,X                                              ; $00960A |/
    BEQ +                                                                       ; $00960D |\
    BCS ++                                                                      ; $00960F | | If the character's HP has dropped to zero or below, set it to one.
+   LDA #$0001.w                                                                ; $009611 | |
    STA r_character_field.1.hp.w,X                                              ; $009614 |/
++  LDA #$0000.w                                                                ; $009617 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00961A | | Increment the index and loop until all five slots have been
+++ JSR _increment_x_by_64                                                      ; $00961C | | checked.
    CPX #_sizeof_character_field.w * 5                                          ; $00961F | |
    BNE -                                                                       ; $009622 |/
@done:
    LDA <r_damaged_character_count                                              ; $009624 |\
    BEQ +                                                                       ; $009626 | | If at least one character was affected by the damage tile, play
    LDA #AUDIO_EFFECT_WALK_DAMAGE.b                                             ; $009628 | | the damage sound effect.
    JSR _play_sound_effect                                                      ; $00962A |/
+   RTS                                                                         ; $00962D

; _field_handle_a_button_press ($00:962E)
;
; Handles the A button press in the field, including closing the map title,
; opening treasure and talking to NPCs.
_field_handle_a_button_press:
    LDA <r_cutscene_active                                                      ; $00962E |\ Skip this function if a cutscene is active.
    BNE ++                                                                      ; $009630 |/
    LDA <r_scroll_bg1_horizontal_lo                                             ; $009632 |\
    AND #%00001111.b                                                            ; $009634 | | Skip this function if the horizontal scroll mod 16 isn't zero.
    BNE ++                                                                      ; $009636 |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $009638 |\
    AND #$0F.b                                                                  ; $00963A | | Skip this function if the vertical scroll mod 16 isn't zero.
    BNE ++                                                                      ; $00963C |/
    LDA <r_joypad_pressed_lo                                                    ; $00963E |\
    AND #JOYPAD_L_A.b                                                           ; $009640 | | Return unless the A button is pressed.
    BNE +                                                                       ; $009642 | |
    RTS                                                                         ; $009644 |/
+   LDA <r_joypad_a_pressed                                                     ; $009645 |\
    BEQ +                                                                       ; $009647 | | Return if this A button press has already been handled.
    RTS                                                                         ; $009649 |/
+   INC <r_joypad_a_pressed                                                     ; $00964A | Increment the flag that indicates this has been handled.
    LDA <r_map_title_erase_pending                                              ; $00964C |\
    BNE +                                                                       ; $00964E | | Set the map title erase pending flag if not set.
    INC <r_map_title_erase_pending                                              ; $009650 |/
+   JSR _check_facing_treasure                                                  ; $009652 | Check for a treasure being faced.
    JSR _check_facing_npc                                                       ; $009655 | Check for an NPC being faced.
++  RTS                                                                         ; $009658

; _check_facing_treasure ($00:9659)
;
; If the current tile being faced has its trigger bit set, dispatches to check
; if that tile has a trigger associated with it, and executes it if so.
_check_facing_treasure:
    LDA r_direction.w                                                           ; $009659 |\
    BNE +                                                                       ; $00965C | | If the current facing direction is up, jump to check the treasure
    LDA <r_tile_properties_up.properties_2                                      ; $00965E | | trigger for the tile one tile upward if the tile has the trigger
    BPL @done                                                                   ; $009660 | | bit set. Otherwise, jump to be done.
    LDA r_current_coordinates.x.w                                               ; $009662 | |
    STA <r_generic_arg_x_lo                                                     ; $009665 | |
    LDA r_current_coordinates.y.w                                               ; $009667 | |
    DEC A                                                                       ; $00966A | |
    STA <r_generic_arg_y_lo                                                     ; $00966B | |
    JMP _check_treasure_trigger                                                 ; $00966D |/
+   LDA r_direction.w                                                           ; $009670 |\
    CMP #DIRECTION_RIGHT.b                                                      ; $009673 | | If the facing direction is to the right, jump to check the
    BNE +                                                                       ; $009675 | | treasure trigger for the tile to the right if the tile has the
    LDA <r_tile_properties_right.properties_2                                   ; $009677 | | trigger bit set. Otherwise, jump to be done.
    BPL @done                                                                   ; $009679 | |
    LDA r_current_coordinates.x.w                                               ; $00967B | |
    INC A                                                                       ; $00967E | |
    STA <r_generic_arg_x_lo                                                     ; $00967F | |
    LDA r_current_coordinates.y.w                                               ; $009681 | |
    STA <r_generic_arg_y_lo                                                     ; $009684 | |
    JMP _check_treasure_trigger                                                 ; $009686 |/
+   LDA r_direction.w                                                           ; $009689 |\
    CMP #DIRECTION_DOWN.b                                                       ; $00968C | | If the facing direction is down, jump to check the treasure
    BNE +                                                                       ; $00968E | | trigger for the downward tile if the tile has the trigger bit set.
    LDA <r_tile_properties_down.properties_2                                    ; $009690 | | Otherwise, jump to be done.
    BPL @done                                                                   ; $009692 | |
    LDA r_current_coordinates.x.w                                               ; $009694 | |
    STA <r_generic_arg_x_lo                                                     ; $009697 | |
    LDA r_current_coordinates.y.w                                               ; $009699 | |
    INC A                                                                       ; $00969C | |
    STA <r_generic_arg_y_lo                                                     ; $00969D | |
    JMP _check_treasure_trigger                                                 ; $00969F |/
+   LDA <r_tile_properties_left.properties_2                                    ; $0096A2 |\
    BPL @done                                                                   ; $0096A4 | | Otherwise, the direction must be left, so jump to check the
    LDA r_current_coordinates.x.w                                               ; $0096A6 | | treasure trigger for the left tile if the tile has the trigger bit
    DEC A                                                                       ; $0096A9 | | set.
    STA <r_generic_arg_x_lo                                                     ; $0096AA | |
    LDA r_current_coordinates.y.w                                               ; $0096AC | |
    STA <r_generic_arg_y_lo                                                     ; $0096AF | |
    JMP _check_treasure_trigger                                                 ; $0096B1 |/
@done:
    RTS                                                                         ; $0096B4

; _check_treasure_trigger ($00:96B5)
;
; Given a set of coordinates for a potential treasure in $0C and $0E, determines
; if there is a treasure trigger for that tile, and if so, executes it.
_check_treasure_trigger:
    LDA r_map_treasure_count.w                                                  ; $0096B5 |\
    BNE +                                                                       ; $0096B8 | | Return if the map has no treasures.
    RTS                                                                         ; $0096BA |/
+   JSR _get_current_trigger_offset                                             ; $0096BB | Get the current trigger offset.
    LDY #0.w                                                                    ; $0096BE | Initialize the Y register to zero.
    LDX <r_generic_tmp_index                                                    ; $0096C1 | Set the X register to the trigger offset for the map.
-   LDA bank15.dungeon_trigger_data.l + trigger.x,X                             ; $0096C3 |\
    CMP <r_generic_arg_x_lo                                                     ; $0096C7 | | If the trigger coordinates match the passed coordinates, jump to
    BNE +                                                                       ; $0096C9 | | handle the trigger and return.
    LDA bank15.dungeon_trigger_data.l + trigger.y,X                             ; $0096CB | |
    CMP <r_generic_arg_y_lo                                                     ; $0096CF | |
    BNE +                                                                       ; $0096D1 | |
    JMP _handle_treasure_trigger                                                ; $0096D3 |/
+   INX                                                                         ; $0096D6 |\
    INX                                                                         ; $0096D7 | | Increment the X register by 5 to move to the next trigger.
    INX                                                                         ; $0096D8 | |
    INX                                                                         ; $0096D9 | |
    INX                                                                         ; $0096DA |/
    INY                                                                         ; $0096DB |\
    TYA                                                                         ; $0096DC | | Increment the current treasure index and loop until reaching the
    CMP r_map_treasure_count.w                                                  ; $0096DD | | map treasure count.
    BNE -                                                                       ; $0096E0 |/
    RTS                                                                         ; $0096E2

; _handle_treasure_trigger ($00:96E3)
;
; Given an offset to a trigger in the X register and the index of the trigger
; within the current map in the Y register, handles the faced treasure chest.
_handle_treasure_trigger:
    STX <r_generic_tmp_index_2                                                  ; $0096E3 | Store the trigger offset in a temporary variable.
    TYA                                                                         ; $0096E5 |\
    CLC                                                                         ; $0096E6 | | Calculate the treasure index and set that treasure as open.
    ADC r_map_properties.treasure_index.w                                       ; $0096E7 | |
    STA r_check_treasure_open_arg_index.w                                       ; $0096EA | |
    JSR _set_treasure_open                                                      ; $0096ED |/
    CMP #0.b                                                                    ; $0096F0 |\
    BEQ +                                                                       ; $0096F2 | | If it was already open, display an "Empty" dialog box and return.
    JMP _display_empty_if_facing_open_treasure                                  ; $0096F4 |/
+   LDA r_direction.w                                                           ; $0096F7 |\
    TAX                                                                         ; $0096FA | | Skip the next block if the faced tile is not a closed treasure
    LDA r_tile_up.w,X                                                           ; $0096FB | | chest tile.
    CMP #TILE_TREASURE_CLOSED.b                                                 ; $0096FE | |
    BNE +                                                                       ; $009700 |/
    LDA <r_generic_arg_x_lo                                                     ; $009702 |\
    STA <r_generic_tmp_index.lo                                                 ; $009704 | | Replace the tile on the tilemap with the open treasure chest tile.
    LDA <r_generic_arg_y_lo                                                     ; $009706 | |
    STA <r_generic_tmp_index.hi                                                 ; $009708 | |
    LDX <r_generic_tmp_index                                                    ; $00970A | |
    LDA #TILE_TREASURE_OPEN.b                                                   ; $00970C | |
    STA r_tilemap_data.l,X                                                      ; $00970E |/
    JSR _calculate_dungeon_vram_address                                         ; $009712 |\ Calculate the VRAM address of the changed tiles in the tilemap.
    STX r_tile_change_vram_address.w                                            ; $009715 |/
    JSR _load_open_treasure_chest_tiles                                         ; $009718 | Set up the replacement tiles.
    LDA #AUDIO_EFFECT_TREASURE_CHEST.b                                          ; $00971B |\ Play the treasure chest opening sound effect.
    JSR _play_sound_effect                                                      ; $00971D |/
    LDA #1.b                                                                    ; $009720 |\ Flag the configured tile change as pending.
    STA <r_tile_change_pending                                                  ; $009722 |/
    LDA #MESSAGE_BANK_1_LO_FOUND_ITEM_CHEST.b                                   ; $009724 |\
    STA <r_show_message_id                                                      ; $009726 | | Load the ID for the found item in chest message and branch ahead.
    JMP ++                                                                      ; $009728 |/
+   LDA #MESSAGE_BANK_1_LO_FOUND_ITEM_OTHER.b                                   ; $00972B |\
    STA <r_show_message_id                                                      ; $00972D | | If the tile wasn't a closed treasure chest, play the generic
    LDA #AUDIO_EFFECT_RECEIVE_ITEM.b                                            ; $00972F | | receive item sound effect and load the found item message ID.
    JSR _play_sound_effect                                                      ; $009731 |/
++  LDX <r_generic_tmp_index_2                                                  ; $009734 |\
    LDA bank15.dungeon_trigger_data.l + trigger.param2,X                        ; $009736 | | Load the second two parameter bytes and save them to temporary
    STA <r_generic_tmp_4                                                        ; $00973A | | variables.
    LDA bank15.dungeon_trigger_data.l + trigger.param3,X                        ; $00973C | |
    STA <r_generic_tmp_3                                                        ; $009740 |/
    LDA <r_generic_tmp_4                                                        ; $009742 |\
    AND #%01000000.b                                                            ; $009744 | | If bit 6 in the second parameter is not set, skip the next block.
    BEQ +                                                                       ; $009746 |/
    LDA <r_generic_tmp_3                                                        ; $009748 |\ Store the third parameter as the trapped chest item.
    STA <r_trapped_chest_item                                                   ; $00974A |/
    LDA r_map_plane.w                                                           ; $00974C |\
    ASL A                                                                       ; $00974F | | Multiply the map plane by 32 and store the result in a temporary
    ASL A                                                                       ; $009750 | | variable.
    ASL A                                                                       ; $009751 | |
    ASL A                                                                       ; $009752 | |
    ASL A                                                                       ; $009753 | |
    STA <r_generic_tmp_3                                                        ; $009754 |/
    LDA <r_generic_tmp_4                                                        ; $009756 |\
    AND #%00011111.b                                                            ; $009758 | | To that value, add the low five bits of the second parameter and
    CLC                                                                         ; $00975A | | the base formation value of $1C0 to determine the final formation.
    ADC <r_generic_tmp_3                                                        ; $00975B | |
    CLC                                                                         ; $00975D | |
    ADC #$C0.b                                                                  ; $00975E | |
    STA r_battle_formation_lo.w                                                 ; $009760 | |
    LDA #$01.b                                                                  ; $009763 | |
    STA r_battle_formation_hi.w                                                 ; $009765 |/
    JSR _calculate_battle_background                                            ; $009768 | Calculate the battle background.
    LDA #1.b                                                                    ; $00976B |\ Set the encounter flag.
    STA <r_encounter_flag                                                       ; $00976D |/
    LDA #MESSAGE_BANK_1_LO_MONSTERS.b                                           ; $00976F |\
    STA <r_show_message_id                                                      ; $009771 | | Display the "Monsters" dialog and return.
    JSR _load_message_bank_1_lo_offset                                          ; $009773 | |
    JSR _show_upper_dialog                                                      ; $009776 | |
    JSR _close_upper_dialog                                                     ; $009779 | |
    RTS                                                                         ; $00977C |/
+   LDA <r_generic_tmp_4                                                        ; $00977D |\
    AND #%10000000.b                                                            ; $00977F | | If the high bit is set on the second parameter byte, set the
    BEQ +                                                                       ; $009781 | | current item to the third parameter byte, display the found item
    LDA <r_generic_tmp_3                                                        ; $009783 | | dialog and add the item to the inventory.
    STA r_current_item.w                                                        ; $009785 | |
    JSR _load_message_bank_1_lo_offset                                          ; $009788 | |
    JSR _show_upper_dialog                                                      ; $00978B | |
    JSR _close_upper_dialog                                                     ; $00978E | |
    JSR _inventory_add_item                                                     ; $009791 | |
    RTS                                                                         ; $009794 |/
+   INC <r_show_message_id                                                      ; $009795 | Increment the message ID to show the GP message.
    LDA <r_generic_tmp_3                                                        ; $009797 |\
    AND #%01111111.b                                                            ; $009799 | | Set the first multiplication argument to the low seven bits of the
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $00979B | | third parameter.
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $00979D |/
    LDA <r_generic_tmp_3                                                        ; $00979F |\
    AND #%10000000.b                                                            ; $0097A1 | | If the high bit of the third parameter is set, set the second
    BNE +                                                                       ; $0097A3 | | argument to 1000. Otherwise, set it to 10.
    LDX #10.w                                                                   ; $0097A5 | |
    JMP ++                                                                      ; $0097A8 | |
+   LDX #1000.w                                                                 ; $0097AB | |
++  STX <r_bank15_math_multiply_16bit_arg_2                                     ; $0097AE |/
    JSL bank15.math_multiply_16bit                                              ; $0097B0 | Multiply the two values.
    JSR _transfer_format_number_arg_to_current_number                           ; $0097B4 | Transfer the result to the current number value.
    JSR _add_party_gp                                                           ; $0097B7 | Add the value to the party's GP.
    JSR _load_message_bank_1_lo_offset                                          ; $0097BA |\
    JSR _show_upper_dialog                                                      ; $0097BD | | Display the dialog.
    JSR _close_upper_dialog                                                     ; $0097C0 |/
    RTS                                                                         ; $0097C3

; _display_empty_if_facing_open_treasure ($00:97C4)
;
; If facing an open treasure chest, displays an "Empty" dialog.
_display_empty_if_facing_open_treasure:
    LDA r_direction.w                                                           ; $0097C4 |\
    TAX                                                                         ; $0097C7 | | If the tile in the facing direction is an open treasure chest,
    LDA r_tile_up.w,X                                                           ; $0097C8 | | display the "Empty" dialog.
    CMP #TILE_TREASURE_OPEN.b                                                   ; $0097CB | |
    BNE +                                                                       ; $0097CD | |
    LDA #MESSAGE_BANK_1_LO_EMPTY.b                                              ; $0097CF | |
    STA <r_show_message_id                                                      ; $0097D1 | |
    JSR _load_message_bank_1_lo_offset                                          ; $0097D3 | |
    JSR _show_upper_dialog                                                      ; $0097D6 | |
    JSR _close_upper_dialog                                                     ; $0097D9 |/
+   RTS                                                                         ; $0097DC

; _add_party_gp ($00:97DD)
;
; Given a 24-bit value in $30, adds that value to the party's GP and caps the
; result at 9,999,999. The parameter location is the same as that which is used
; as a result by bank15.math_multiply_16bit.
_add_party_gp:
    LDA r_party_gp.lo.w                                                         ; $0097DD |\
    CLC                                                                         ; $0097E0 | | Add the passed value to the party's GP.
    ADC <r_add_party_gp_arg.lo                                                  ; $0097E1 | |
    STA r_party_gp.lo.w                                                         ; $0097E3 | |
    LDA r_party_gp.md.w                                                         ; $0097E6 | |
    ADC <r_add_party_gp_arg.md                                                  ; $0097E9 | |
    STA r_party_gp.md.w                                                         ; $0097EB | |
    LDA r_party_gp.hi.w                                                         ; $0097EE | |
    ADC <r_add_party_gp_arg.hi                                                  ; $0097F1 | |
    STA r_party_gp.hi.w                                                         ; $0097F3 |/
    CMP #$98.b                                                                  ; $0097F6 |\
    BCC +                                                                       ; $0097F8 | | If the result is greater than 9,999,999, replace it explicitly
    LDA r_party_gp.md.w                                                         ; $0097FA | | with that maximum value.
    CMP #$96.b                                                                  ; $0097FD | |
    BCC +                                                                       ; $0097FF | |
    LDA r_party_gp.lo.w                                                         ; $009801 | |
    CMP #$7F.b                                                                  ; $009804 | |
    BCC +                                                                       ; $009806 | |
    LDA #$7F.b                                                                  ; $009808 | |
    STA r_party_gp.lo.w                                                         ; $00980A | |
    LDA #$96.b                                                                  ; $00980D | |
    STA r_party_gp.md.w                                                         ; $00980F | |
    LDA #$98.b                                                                  ; $009812 | |
    STA r_party_gp.hi.w                                                         ; $009814 |/
+   RTS                                                                         ; $009817

; _inventory_add_item ($00:9818)
;
; Given an 8-bit item ID in $08FB, attempts to add that item to the inventory
; (with a count of 10 if it's an arrow, and 1 otherwise). If no slots are
; available, the post-battle drop screen will be displayed.
_inventory_add_item:
    LDA #1.b                                                                    ; $009818 |\ Initially set the count of the item to one.
    STA <r_generic_tmp_1                                                        ; $00981A |/
    LDA r_current_item.w                                                        ; $00981C |\
    CMP #ITEM_FIRST_ARMOR.b                                                     ; $00981F | | If the item is an arrow, change the count to ten.
    BCS @start                                                                  ; $009821 | |
    CMP #ITEM_FIRST_ARROW.b                                                     ; $009823 | |
    BCC @start                                                                  ; $009825 | |
    LDA #10.b                                                                   ; $009827 | |
    STA <r_generic_tmp_1                                                        ; $009829 |/
@start:
    LDY #0.w                                                                    ; $00982B | Initialize the Y register to zero.
-   LDA r_inventory.1.id.w,Y                                                    ; $00982E |\
    CMP r_current_item.w                                                        ; $009831 | | If the item in this slot is the same as the item being received
    BNE +                                                                       ; $009834 | | and if it's count is not 99, branch to the later code.
    LDA r_inventory.1.count.w,Y                                                 ; $009836 | |
    CMP #99.b                                                                   ; $009839 | |
    BNE @existing                                                               ; $00983B |/
+   INY                                                                         ; $00983D |\
    INY                                                                         ; $00983E | | Loop until the entire inventory has been checked.
    CPY #_sizeof_r_inventory.w                                                  ; $00983F | |
    BNE -                                                                       ; $009842 |/
    LDY #0.w                                                                    ; $009844 | Initialize the Y register to zero.
-   LDA r_inventory.1.id.w,Y                                                    ; $009847 |\ If the current inventory spot is empty, branch ahead to put the
    BEQ @empty                                                                  ; $00984A |/ item there.
    INY                                                                         ; $00984C |\
    INY                                                                         ; $00984D | | Loop until the entire inventory has been scanned.
    CPY #_sizeof_r_inventory.w                                                  ; $00984E | |
    BEQ +                                                                       ; $009851 | |
    JMP -                                                                       ; $009853 |/
+   LDA r_current_item.w                                                        ; $009856 |\
    STA r_battle_drops.w + 0                                                    ; $009859 | | Put the received item in the first dropped item slot, and set the
    STZ r_battle_drops.w + 1                                                    ; $00985C | | other dropped slots to empty.
    STZ r_battle_drops.w + 2                                                    ; $00985F | |
    STZ r_battle_drops.w + 3                                                    ; $009862 | |
    STZ r_battle_drops.w + 4                                                    ; $009865 | |
    STZ r_battle_drops.w + 5                                                    ; $009868 | |
    STZ r_battle_drops.w + 6                                                    ; $00986B | |
    STZ r_battle_drops.w + 7                                                    ; $00986E |/
    LDA #%00000000.b                                                            ; $009871 |\ Fade out the PPU at one step per frame.
    JSR _ppu_fade_out                                                           ; $009873 |/
    JSL bank01.menu_spoils                                                      ; $009876 | Execute the spoils menu.
    JSR init_nmi_irq_handlers                                                   ; $00987A | Reinitialize the interrupt handlers.
    LDX #0.w                                                                    ; $00987D |\
-   STZ r_battle_drops.w,X                                                      ; $009880 | | Zero out the drops array.
    INX                                                                         ; $009883 | |
    CPX #_sizeof_r_battle_drops.w                                               ; $009884 | |
    BNE -                                                                       ; $009887 |/
    JSL bank15.init_ppu                                                         ; $009889 | Reinitialize the PPU.
    LDA #1.b                                                                    ; $00988D |\
    STA <r_disable_map_title                                                    ; $00988F | | Disable the map title and resume the previous dungeon map.
    JSR _change_map_dungeon_resume                                              ; $009891 |/
    JSR _load_npc_sprites                                                       ; $009894 | Load the NPC sprites for this map.
    CLI                                                                         ; $009897 | Enable interrupts.
    LDA #%10000001.b                                                            ; $009898 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00989A |/
    JSL bank15.draw_dungeon_field_sprite_player                                 ; $00989D | Draw the player field sprite.
    JSR _draw_field_sprite_npcs                                                 ; $0098A1 | Draw the NPC field sprites.
    LDA #%00000000.b                                                            ; $0098A4 |\ Fade in the PPU, increasing the brightness once per frame.
    JSR _ppu_fade_in                                                            ; $0098A6 |/
    RTS                                                                         ; $0098A9
@empty:
    LDA r_current_item.w                                                        ; $0098AA |\ Set the item ID in this slot.
    STA r_inventory.1.id.w,Y                                                    ; $0098AD |/
@existing:
    LDA r_inventory.1.count.w,Y                                                 ; $0098B0 |\
    CLC                                                                         ; $0098B3 | | Add the count to the original item count.
    ADC <r_generic_tmp_1                                                        ; $0098B4 |/
    CMP #100.b                                                                  ; $0098B6 |\
    BCC +                                                                       ; $0098B8 | | If the new count is 100 or greater, save the excess count to the
    SEC                                                                         ; $0098BA | | count variable, update the count of this slot to 99, and then jump
    SBC #99.b                                                                   ; $0098BB | | back to try again.
    STA <r_generic_tmp_1                                                        ; $0098BD | |
    LDA #99.b                                                                   ; $0098BF | |
    STA r_inventory.1.count.w,Y                                                 ; $0098C1 | |
    JMP @start                                                                  ; $0098C4 |/
+   STA r_inventory.1.count.w,Y                                                 ; $0098C7 | Otherwise, simply store the updated count.
    RTS                                                                         ; $0098CA

; _load_open_treasure_chest_tiles ($00:98CB)
;
; Loads the open treasure chest tiles and stores them in the values at $0700 to
; prepare to change a tile from closed to open.
_load_open_treasure_chest_tiles:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0098CB
    LDA r_tile_composition_data_dungeon_upper_left.l + (TILE_TREASURE_OPEN * 2) ; $0098CD
    STA r_tile_change_tile_1.w                                                  ; $0098D1
    LDA r_tile_composition_data_dungeon_upper_right.l + ($77 * 2)               ; $0098D4
    STA r_tile_change_tile_2.w                                                  ; $0098D8
    LDA r_tile_composition_data_dungeon_lower_left.l + ($77 * 2)                ; $0098DB
    STA r_tile_change_tile_3.w                                                  ; $0098DF
    LDA r_tile_composition_data_dungeon_lower_right.l + ($77 * 2)               ; $0098E2
    STA r_tile_change_tile_4.w                                                  ; $0098E6
    LDA #0.w                                                                    ; $0098E9
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0098EC
    RTS                                                                         ; $0098EE

; _check_treasure_open ($00:98EF)
;
; Given a treasure index in $08FC, returns 1 in the accumulator if the treasure
; is open and 0 if the treasure is closed. Each map plane has its own set of
; treasures.
_check_treasure_open:
    JSR _get_treasure_indexes                                                   ; $0098EF | Get the index and bit number for the treasure.
    LDA r_treasure_status.w,X                                                   ; $0098F2 |\ Load the correct byte.
    STA <r_check_treasure_open_tmp                                              ; $0098F5 |/
-   LSR <r_check_treasure_open_tmp                                              ; $0098F7 |\
    DEY                                                                         ; $0098F9 | | Shift bits until reaching the correct bit.
    BNE -                                                                       ; $0098FA |/
    LDA #$00.b                                                                  ; $0098FC |\ Add the carry bit into a zeroed accumulator.
    ADC #$00.b                                                                  ; $0098FE |/
    RTS                                                                         ; $009900

; _set_treasure_open ($00:9901)
;
; Given a treasure index in $08FC, sets that treasure's status bit to indicate
; that it is open. If the treasure was already opened, 1 is returned. Otherwise,
; 0 is returned.
_set_treasure_open:
    JSR _get_treasure_indexes                                                   ; $009901 | Get the index and bit number for the treasure.
    LDA #1.b                                                                    ; $009904 |\
-   DEY                                                                         ; $009906 | | Shift a 1 until it's in the indicated bit number and save the
    BEQ +                                                                       ; $009907 | | result to a temporary variable.
    ASL A                                                                       ; $009909 | |
    JMP -                                                                       ; $00990A | |
+   STA <r_generic_tmp_1                                                        ; $00990D |/
    LDA r_treasure_status.w,X                                                   ; $00990F |\
    AND <r_generic_tmp_1                                                        ; $009912 | | Extract only the status bit for that treasure to another variable.
    STA <r_generic_tmp_2                                                        ; $009914 |/
    BNE +                                                                       ; $009916 |\
    LDA r_treasure_status.w,X                                                   ; $009918 | | If the bit is not already set, add in the value to set the bit.
    CLC                                                                         ; $00991B | |
    ADC <r_generic_tmp_1                                                        ; $00991C | |
    STA r_treasure_status.w,X                                                   ; $00991E |/
+   LDA <r_generic_tmp_2                                                        ; $009921 | Set the accumulator to zero if the treasure was closed.
    RTS                                                                         ; $009923

; _get_treasure_indexes ($00:9924)
;
; Given the index of a treasure in $08FC, returns the index and bit number of
; that treasure in the treasure status array at $7E12A0. The values are returned
; in the X and Y register, respectively.
_get_treasure_indexes:
    LDA r_check_treasure_open_arg_index.w                                       ; $009924 |\
    LSR A                                                                       ; $009927 | | Set the X register to the correct byte number (the treasure index
    LSR A                                                                       ; $009928 | | divided by eight).
    LSR A                                                                       ; $009929 | |
    TAX                                                                         ; $00992A |/
    LDA r_map_plane.w                                                           ; $00992B |\
    BEQ +                                                                       ; $00992E | | Add 32 to the X register if the current map plane is not zero, to
    TXA                                                                         ; $009930 | | use the underworld/moon set of treasures.
    CLC                                                                         ; $009931 | |
    ADC #32.b                                                                   ; $009932 | |
    TAX                                                                         ; $009934 |/
+   LDA r_check_treasure_open_arg_index.w                                       ; $009935 |\
    AND #%00000111.b                                                            ; $009938 | | Set the Y register to the bit number of the treasure.
    INC A                                                                       ; $00993A | |
    TAY                                                                         ; $00993B |/
    RTS                                                                         ; $00993C

; _get_current_trigger_offset ($00:993D)
;
; Reads the current map ID from $1701 and $1702 and uses that to load the
; offset into the trigger data relative to $15:8300. Returns the 16-bit offset
; at $063D.
_get_current_trigger_offset:
    LDA r_map_id.w                                                              ; $00993D |\
    STA <r_get_current_trigger_offset_result_lo                                 ; $009940 | | Set the base index to the current map ID.
    STZ <r_get_current_trigger_offset_result_hi                                 ; $009942 |/
    ASL <r_get_current_trigger_offset_result_lo                                 ; $009944 |\ Multiply the index by two, as each entry has two bytes.
    ROL <r_get_current_trigger_offset_result_hi                                 ; $009946 |/
    LDA r_map_plane.w                                                           ; $009948 |\
    BEQ +                                                                       ; $00994B | | If the map plane is non-zero, increment the index by $200.
    INC <r_get_current_trigger_offset_result_hi                                 ; $00994D | |
    INC <r_get_current_trigger_offset_result_hi                                 ; $00994F |/
+   LDX <r_get_current_trigger_offset_result                                    ; $009951 |\
    LDA bank15.dungeon_trigger_offset_data.l,X                                  ; $009953 | | Read the offset from the array and set the result variable.
    STA <r_get_current_trigger_offset_result_lo                                 ; $009957 | |
    LDA bank15.dungeon_trigger_offset_data.l + 1,X                              ; $009959 | |
    STA <r_get_current_trigger_offset_result_hi                                 ; $00995D |/
    RTS                                                                         ; $00995F

; _replace_open_treasure_tiles ($00:9960)
;
; Replaces any treasure chest tiles on the current map with open treasure chest
; tiles if the associated treasure is open.
_replace_open_treasure_tiles:
    LDA r_map_treasure_count.w                                                  ; $009960 |\
    BNE +                                                                       ; $009963 | | If the current map has no treasure, skip this function.
    RTS                                                                         ; $009965 |/
+   JSR _get_current_trigger_offset                                             ; $009966 | Get the offset into the trigger data for the current map.
    LDY #$0000.w                                                                ; $009969 | Initialize the Y register to zero.
-   LDX <r_get_current_trigger_offset_result                                    ; $00996C | Set the X register to the trigger offset.
    TYA                                                                         ; $00996E |\
    CLC                                                                         ; $00996F | | For the current treasure index, determine whether or not it is
    ADC r_map_properties.treasure_index.w                                       ; $009970 | | currently open.
    STA r_check_treasure_open_arg_index.w                                       ; $009973 | |
    PHY                                                                         ; $009976 | |
    JSR _check_treasure_open                                                    ; $009977 | |
    PLY                                                                         ; $00997A |/
    CMP #$00.b                                                                  ; $00997B |\
    BEQ +                                                                       ; $00997D | | If the treasure is open, read the coordinates for the associated
    LDX <r_get_current_trigger_offset_result                                    ; $00997F | | trigger. If there is a treasure chest tile ($78) at that spot,
    LDA bank15.dungeon_trigger_data.l,X                                         ; $009981 | | replace it with an open treasure chest tile ($77).
    STA <r_replace_open_treasure_tiles_tmp_lo                                   ; $009985 | |
    LDA bank15.dungeon_trigger_data.l + 1,X                                     ; $009987 | |
    STA <r_replace_open_treasure_tiles_tmp_hi                                   ; $00998B | |
    LDX <r_replace_open_treasure_tiles_tmp_lo                                   ; $00998D | |
    LDA r_tilemap_data.l,X                                                      ; $00998F | |
    CMP #$78.b                                                                  ; $009993 | |
    BNE +                                                                       ; $009995 | |
    LDA #$77.b                                                                  ; $009997 | |
    STA r_tilemap_data.l,X                                                      ; $009999 |/
+   LDX <r_get_current_trigger_offset_result                                    ; $00999D |\
    INX                                                                         ; $00999F | | Add five to the X register, as each trigger entry consists of five
    INX                                                                         ; $0099A0 | | bytes.
    INX                                                                         ; $0099A1 | |
    INX                                                                         ; $0099A2 | |
    INX                                                                         ; $0099A3 | |
    STX <r_get_current_trigger_offset_result                                    ; $0099A4 |/
    INY                                                                         ; $0099A6 |\
    TYA                                                                         ; $0099A7 | | Increment Y and continue looping until all of the treasures on
    CMP r_map_treasure_count.w                                                  ; $0099A8 | | this map have been processed.
    BEQ +                                                                       ; $0099AB | |
    JMP -                                                                       ; $0099AD |/
+   RTS                                                                         ; $0099B0

; _handle_dungeon_triggers ($00:99B1)
;
; Handles any trigger for the current tile. Also handles the message when
; landing on a save point.
_handle_dungeon_triggers:
    STZ <r_map_changed_by_trigger                                               ; $0099B1 | Reset the map changed by trigger flag.
    LDA <r_movement_direction                                                   ; $0099B3 |\
    BNE +                                                                       ; $0099B5 | | Set the movement frame counter to zero if no movement direction.
    STZ <r_movement_frame_counter                                               ; $0099B7 |/
+   LDA <r_movement_speed                                                       ; $0099B9 |\
    TAX                                                                         ; $0099BB | | If currently in the middle of movement, disable the flag that
    LDA <r_movement_frame_counter                                               ; $0099BC | | allows the calculation of the player's movement and return.
    AND movement_speed_frame_counter_mask_data.w,X                              ; $0099BE | |
    BEQ +                                                                       ; $0099C1 | |
    STZ <r_player_movement_calculation_enabled                                  ; $0099C3 | |
    RTS                                                                         ; $0099C5 |/
+   LDA #1.b                                                                    ; $0099C6 |\ Otherwise, enable that flag.
    STA <r_player_movement_calculation_enabled                                  ; $0099C8 |/
    JSR _update_current_tile_properties                                         ; $0099CA | Update the current tile properties.
    LDA <r_tile_properties_current.properties_1                                 ; $0099CD |\
    AND #TILE_PROPERTY_1_DUNGEON_SAVING_ENABLED.b                               ; $0099CF | | If saving is enabled on this tile, set the saving enabled flag.
    STA r_saving_enabled.w                                                      ; $0099D1 |/
    LDA r_current_coordinates.x.w                                               ; $0099D4 |\
    BMI +                                                                       ; $0099D7 | | If either the X or Y coordinate is less than zero or greater than
    CMP #32.b                                                                   ; $0099D9 | | 31, set the flag to indicate that the map is being exited and
    BCS +                                                                       ; $0099DB | | return.
    LDA r_current_coordinates.y.w                                               ; $0099DD | |
    BMI +                                                                       ; $0099E0 | |
    CMP #32.b                                                                   ; $0099E2 | |
    BCC ++                                                                      ; $0099E4 | |
+   INC <r_exiting_map                                                          ; $0099E6 | |
    RTS                                                                         ; $0099E8 |/
++  LDA <r_tile_properties_current.properties_2                                 ; $0099E9 |\
    BMI +                                                                       ; $0099EB | | If the current tile is not a trigger, if the current tile is not a
    LDA <r_tile_properties_current.properties_2                                 ; $0099ED | | return tile and if it's not a save point, enable triggers and
    AND #TILE_PROPERTY_2_RETURN.b                                               ; $0099EF | | return.
    BNE +                                                                       ; $0099F1 | |
    LDA <r_tile_properties_current.properties_1                                 ; $0099F3 | |
    AND #TILE_PROPERTY_1_DUNGEON_SAVING_ENABLED.b                               ; $0099F5 | |
    BNE +                                                                       ; $0099F7 | |
    LDA #1.b                                                                    ; $0099F9 | |
    STA <r_enable_triggers                                                      ; $0099FB | |
    RTS                                                                         ; $0099FD |/
+   LDA <r_enable_triggers                                                      ; $0099FE |\
    BNE +                                                                       ; $009A00 | | If triggers are not enabled, skip the rest of the function.
    RTS                                                                         ; $009A02 |/
+   STZ <r_enable_triggers                                                      ; $009A03 | Disable triggers.
    LDA <r_tile_properties_current.properties_1                                 ; $009A05 |\
    AND #TILE_PROPERTY_1_DUNGEON_SAVING_ENABLED.b                               ; $009A07 | | If saving is enabled on this tile, show the save point event
    BEQ +                                                                       ; $009A09 | | before returning.
    LDA #1.b                                                                    ; $009A0B | |
    STA <r_cutscene_active                                                      ; $009A0D | |
    LDA #EVENT_INDEX_SAVE_POINT.b                                               ; $009A0F | |
    JSR _decode_event                                                           ; $009A11 | |
    STZ <r_cutscene_active                                                      ; $009A14 | |
    RTS                                                                         ; $009A16 |/
+   LDA <r_tile_properties_current.properties_2                                 ; $009A17 |\
    BMI +                                                                       ; $009A19 | | If the current tile is not a trigger tile, set the exiting map
    INC <r_exiting_map                                                          ; $009A1B | | flag and return. (Only true for return tiles at this point.)
    RTS                                                                         ; $009A1D |/
+   LDA r_map_id.w                                                              ; $009A1E |\
    STA <r_generic_tmp_index.lo                                                 ; $009A21 | | Determine the offset for the triggers for this map.
    STZ <r_generic_tmp_index.hi                                                 ; $009A23 | |
    ASL <r_generic_tmp_index.lo                                                 ; $009A25 | |
    ROL <r_generic_tmp_index.hi                                                 ; $009A27 | |
    LDA r_map_plane.w                                                           ; $009A29 | |
    BEQ +                                                                       ; $009A2C | |
    INC <r_generic_tmp_index.hi                                                 ; $009A2E | |
    INC <r_generic_tmp_index.hi                                                 ; $009A30 | |
+   LDX <r_generic_tmp_index                                                    ; $009A32 | |
    LDA bank15.dungeon_trigger_offset_data.l + 0,X                              ; $009A34 | |
    STA <r_generic_tmp_index.lo                                                 ; $009A38 | |
    LDA bank15.dungeon_trigger_offset_data.l + 1,X                              ; $009A3A | |
    STA <r_generic_tmp_index.hi                                                 ; $009A3E |/
    LDX <r_generic_tmp_index                                                    ; $009A40 |\
-   LDA bank15.dungeon_trigger_data.l + trigger.x,X                             ; $009A42 | | Scan memory five bytes at a time until finding a trigger that has
    CMP r_current_coordinates.x.w                                               ; $009A46 | | matching coordinates.
    BNE +                                                                       ; $009A49 | |
    LDA bank15.dungeon_trigger_data.l + trigger.y,X                             ; $009A4B | | NOTE: If the player is able to access an unexpected trigger for
    CMP r_current_coordinates.y.w                                               ; $009A4F | |       which no trigger has been specified, this will scan memory
    BEQ ++                                                                      ; $009A52 | |       indefinitely until it finds matching coordinates. This is
+   INX                                                                         ; $009A54 | |       the trick behind the inventory warp of the NoCW speedrun.
    INX                                                                         ; $009A55 | |
    INX                                                                         ; $009A56 | |
    INX                                                                         ; $009A57 | |
    INX                                                                         ; $009A58 | |
    JMP -                                                                       ; $009A59 |/
++  LDA bank15.dungeon_trigger_data.l + trigger.param1,X                        ; $009A5C |\
    CMP #TRIGGER_EVENT.b                                                        ; $009A60 | | If the first parameter of the trigger is $FF, execute the second
    BNE +                                                                       ; $009A62 | | parameter of the trigger as a conditional event and return.
    LDA bank15.dungeon_trigger_data.l + trigger.param2,X                        ; $009A64 | |
    JSR _execute_conditional_event                                              ; $009A68 | |
    RTS                                                                         ; $009A6B |/
+   JSR _push_map_history                                                       ; $009A6C | Otherwise, push the current map to the map history.
    LDA bank15.dungeon_trigger_data.l + trigger.param1,X                        ; $009A6F |\
    CMP #MAP_ID_OVERWORLD.b                                                     ; $009A73 | | Skip this next block if the first parameter (map ID) is >= $FB.
    BCS +                                                                       ; $009A75 |/
    STA r_map_id.w                                                              ; $009A77 | Set the parameter as the new map ID.
    LDA bank15.dungeon_trigger_data.l + trigger.param2,X                        ; $009A7A |\
    AND #%00111111.b                                                            ; $009A7E | | Set the X coordinate from the low six bits of parameter 2.
    STA r_current_coordinates.x.w                                               ; $009A80 |/
    LDA bank15.dungeon_trigger_data.l + trigger.param2,X                        ; $009A83 |\
    AND #%11000000.b                                                            ; $009A87 | | Set the direction from the high two bits of the second parameter.
    LSR A                                                                       ; $009A89 | |
    LSR A                                                                       ; $009A8A | |
    LSR A                                                                       ; $009A8B | |
    LSR A                                                                       ; $009A8C | |
    LSR A                                                                       ; $009A8D | |
    LSR A                                                                       ; $009A8E | |
    STA r_direction.w                                                           ; $009A8F |/
    LDA bank15.dungeon_trigger_data.l + trigger.param3,X                        ; $009A92 |\ Set the Y coordinate from the third parameter.
    STA r_current_coordinates.y.w                                               ; $009A96 |/
    JSR _do_out_transition                                                      ; $009A99 | Animate the out transition.
    LDA #MAP_AREA_DUNGEON.b                                                     ; $009A9C |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $009A9E |/
    INC <r_map_changed_by_trigger                                               ; $009AA1 |\ Set the map changed by trigger flag.
    RTS                                                                         ; $009AA3 |/
+   PHX                                                                         ; $009AA4 |\
    JSR _audio_fade_out                                                         ; $009AA5 | | Fade the audio out and animate the out transition.
    JSR _do_out_transition                                                      ; $009AA8 | |
    PLX                                                                         ; $009AAB |/
    LDA bank15.dungeon_trigger_data.l + trigger.param1,X                        ; $009AAC |\
    SEC                                                                         ; $009AB0 | | Set the map area by subtracting $FB from the first parameter.
    SBC #MAP_ID_OVERWORLD.b                                                     ; $009AB1 | |
    STA r_map_area.w                                                            ; $009AB3 |/
    LDA bank15.dungeon_trigger_data.l + trigger.param2,X                        ; $009AB6 |\
    STA r_current_coordinates.x.w                                               ; $009ABA | | Set the X and Y coordinates from the second and third parameters,
    LDA bank15.dungeon_trigger_data.l + trigger.param3,X                        ; $009ABD | | respectively.
    STA r_current_coordinates.y.w                                               ; $009AC1 |/
    INC <r_map_changed_by_trigger                                               ; $009AC4 | Set the map changed by trigger flag.
    LDX #0.w                                                                    ; $009AC6 |\ Reset the map history index to zero.
    STX r_map_history_index.w                                                   ; $009AC9 |/
    RTS                                                                         ; $009ACC

; _push_map_history ($00:9ACD)
;
; Pushes the current map ID and current X and Y coordinates to the map history
; stack. This function is one potential source of the infamous 64-door
; hierarchy glitch. The map history stack has enough room to hold up to 64
; entries. When it reaches this limit, the game simply sets the index to 0,
; wrapping around back to the bottom of the stack. This has two problems: 1) it
; overwrites the ultimate return map, making it impossible for the player to
; return to the overworld. 2) It ignores the possibility of players having
; access to a return door, which will decrement the index to $FFFD, which is
; definitely out of range.
_push_map_history:
    PHX                                                                         ; $009ACD | Preserve the contents of the X register.
    LDX r_map_history_index.w                                                   ; $009ACE |\
    LDA r_map_area.w                                                            ; $009AD1 | | If the current map is a dungeon map, the map ID is stored directly
    CMP #MAP_AREA_DUNGEON.b                                                     ; $009AD4 | | on the map history stack. Meanwhile, the X coordinate byte on the
    BNE +                                                                       ; $009AD6 | | stack is used to store both the current X coordinate (in the lower
    LDA r_map_id.w                                                              ; $009AD8 | | six bits) as well as the player's current facing direction in the
    STA r_map_history.1.map_id.w,X                                              ; $009ADB | | upper two bits.
    LDA r_direction.w                                                           ; $009ADE | |
    ASL A                                                                       ; $009AE1 | |
    ASL A                                                                       ; $009AE2 | |
    ASL A                                                                       ; $009AE3 | |
    ASL A                                                                       ; $009AE4 | |
    ASL A                                                                       ; $009AE5 | |
    ASL A                                                                       ; $009AE6 | |
    CLC                                                                         ; $009AE7 | |
    ADC r_current_coordinates.x.w                                               ; $009AE8 | |
    STA r_map_history.1.x.w,X                                                   ; $009AEB | |
    JMP ++                                                                      ; $009AEE |/
+   LDA r_map_area.w                                                            ; $009AF1 |\
    CLC                                                                         ; $009AF4 | | On the other hand, if map is not a dungeon map (overworld,
    ADC #MAP_ID_OVERWORLD.b                                                     ; $009AF5 | | underworld or moon), a special map ID is stored on the stack
    STA r_map_history.1.map_id.w,X                                              ; $009AF7 | | instead that refers to the current map. The X coordinate is also
    LDA r_current_coordinates.x.w                                               ; $009AFA | | stored, but the direction information is lost.
    STA r_map_history.1.x.w,X                                                   ; $009AFD |/
++  LDA r_current_coordinates.y.w                                               ; $009B00 |\ Regardless of map area, store the Y coordinate in the map history.
    STA r_map_history.1.y.w,X                                                   ; $009B03 |/
    INX                                                                         ; $009B06 |\
    INX                                                                         ; $009B07 | | Increment the X register by 3. If this value reaches $C0 (64 * 3),
    INX                                                                         ; $009B08 | | the value is reset to 0. BUG: This results in the stack wrapping
    CPX #$00C0.w                                                                ; $009B09 | | back to the beginning, making it impossible for the player to ever
    BCC +                                                                       ; $009B0C | | reach the overworld and enabling the 64-door hierarchy glitch.
    LDX #$0000.w                                                                ; $009B0E | |
+   STX r_map_history_index.w                                                   ; $009B11 |/
    PLX                                                                         ; $009B14 | Restore the contents of the X register.
    RTS                                                                         ; $009B15

; _handle_outdoor_triggers ($00:9B16)
;
; Handles outdoor triggers. Sets $06CD to 1 if a map change occurs. Animates the
; out transition, but nothing else.
_handle_outdoor_triggers:
    STZ <r_map_changed_by_trigger                                               ; $009B16 | Reset the map changed by trigger flag.
    LDA <r_movement_direction                                                   ; $009B18 |\
    BNE +                                                                       ; $009B1A | | If not moving, reset the movement frame counter.
    STZ <r_movement_frame_counter                                               ; $009B1C |/
+   LDA <r_movement_speed                                                       ; $009B1E |\
    TAX                                                                         ; $009B20 | | If the movement frame counter masked by the speed-associated mask
    LDA <r_movement_frame_counter                                               ; $009B21 | | is not zero, disable player movement calculation and return.
    AND movement_speed_frame_counter_mask_data.w,X                              ; $009B23 | |
    BEQ +                                                                       ; $009B26 | |
    STZ <r_player_movement_calculation_enabled                                  ; $009B28 | |
    RTS                                                                         ; $009B2A |/
+   LDA #1.b                                                                    ; $009B2B |\ Enable player movement calculation.
    STA <r_player_movement_calculation_enabled                                  ; $009B2D |/
    JSR _update_current_tile_properties                                         ; $009B2F | Update the current tile properties.
    STZ r_saving_enabled.w                                                      ; $009B32 |\
    LDA r_vehicle.w                                                             ; $009B35 | | Enable saving unless on a vehicle.
    BNE +                                                                       ; $009B38 | |
    INC r_saving_enabled.w                                                      ; $009B3A |/
+   LDA r_vehicle.w                                                             ; $009B3D |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $009B40 | | If the current vehicle is the Enterprise, if it's at maximum
    BNE ++                                                                      ; $009B42 | | altitude, and if the map area is the overworld, execute the
    LDA r_enterprise_altitude.w                                                 ; $009B44 | | overworld Enterprise conditional event.
    CMP #16.b                                                                   ; $009B47 | |
    BNE ++                                                                      ; $009B49 | |
    LDA r_map_area.w                                                            ; $009B4B | |
    CMP #MAP_AREA_OVERWORLD.b                                                   ; $009B4E | |
    BNE +                                                                       ; $009B50 | |
    LDA #CONDITIONAL_EVENT_ENTERPRISE_OVERWORLD.b                               ; $009B52 | |
    JMP @execute_conditional_event                                              ; $009B54 |/
+   LDA r_map_area.w                                                            ; $009B57 |\
    CMP #MAP_AREA_UNDERWORLD.b                                                  ; $009B5A | | If the vehicle is the Enterprise, if it's at maximum altitude and
    BNE ++                                                                      ; $009B5C | | if the current map area is the Underworld, execute the underworld
    LDA #CONDITIONAL_EVENT_ENTERPRISE_UNDERWORLD.b                              ; $009B5E | | Enterprise conditional event.
    JMP @execute_conditional_event                                              ; $009B60 |/
++  LDA <r_tile_properties_current.properties_2                                 ; $009B63 |\
    BMI +                                                                       ; $009B65 | | If the current tile is not a trigger, enable triggers and return.
    LDA #1.b                                                                    ; $009B67 | |
    STA <r_enable_triggers                                                      ; $009B69 | |
    RTS                                                                         ; $009B6B |/
+   LDA r_vehicle.w                                                             ; $009B6C |\
    BEQ +                                                                       ; $009B6F | | Return if on a vehicle.
    RTS                                                                         ; $009B71 |/
+   LDA <r_enable_triggers                                                      ; $009B72 |\
    BNE +                                                                       ; $009B74 | | Return if triggers are disabled.
    RTS                                                                         ; $009B76 |/
+   STZ <r_enable_triggers                                                      ; $009B77 |\
    LDA r_map_area.w                                                            ; $009B79 | | Load the offset for the triggers for this map.
    ASL A                                                                       ; $009B7C | |
    TAX                                                                         ; $009B7D | |
.if FF4_EASYTYPE != 1                                                           ;         | |
    LDA bank15.outdoor_trigger_offset_data.l + word.lo,X                        ; $009D9E | |
    STA <r_generic_tmp_index.lo                                                 ; $009DA2 | |
    LDA bank15.outdoor_trigger_offset_data.l + word.hi,X                        ; $009DA4 | |
.else                                                                           ;         | |
    LDA bank19.outdoor_trigger_offset_data.l + word.lo,X                        ; $009B7E | |
    STA <r_generic_tmp_index.lo                                                 ; $009B82 | |
    LDA bank19.outdoor_trigger_offset_data.l + word.hi,X                        ; $009B84 | |
.endif                                                                          ;         | |
    STA <r_generic_tmp_index.hi                                                 ; $009B88 |/
    LDX <r_generic_tmp_index                                                    ; $009B8A |\
.if FF4_EASYTYPE != 1                                                           ;         | | Search through memory until finding a trigger that has matching
-   LDA bank15.outdoor_trigger_data.l + trigger.x,X                             ; $009DAC | | coordinates.
.else                                                                           ;         | |
-   LDA bank19.outdoor_trigger_data.l + trigger.x,X                             ; $009B8C | | NOTE: As with the dungeon triggers, this will keep searching
.endif                                                                          ;         | |       forever until a trigger is found. However, by default, there
    CMP r_current_coordinates.x.w                                               ; $009B90 | |       are no accessible outdoor trigger tiles without associated
    BNE +                                                                       ; $009B93 | |       triggers. It's possible clever use of the 64 door glitch
.if FF4_EASYTYPE != 1                                                           ;         | |       could work around this.
    LDA bank15.outdoor_trigger_data.l + trigger.y,X                             ; $009DB5 | |
.else                                                                           ;         | |
    LDA bank19.outdoor_trigger_data.l + trigger.y,X                             ; $009B95 | |
.endif                                                                          ;         | |
    CMP r_current_coordinates.y.w                                               ; $009B99 | |
    BEQ ++                                                                      ; $009B9C | |
+   INX                                                                         ; $009B9E | |
    INX                                                                         ; $009B9F | |
    INX                                                                         ; $009BA0 | |
    INX                                                                         ; $009BA1 | |
    INX                                                                         ; $009BA2 | |
    JMP -                                                                       ; $009BA3 |/
.if FF4_EASYTYPE != 1
++  LDA bank15.outdoor_trigger_data.l + trigger.param1,X                        ; $009DC6 |\
.else                                                                           ;         | | If the first parameter is $FF, fall through to execute the second
++  LDA bank19.outdoor_trigger_data.l + trigger.param1,X                        ; $009BA6 | | parameter as a conditional event.
.endif                                                                          ;         | |
    CMP #TRIGGER_EVENT.b                                                        ; $009BAA | |
    BNE +                                                                       ; $009BAC | |
.if FF4_EASYTYPE != 1                                                           ;         | |
    LDA bank15.outdoor_trigger_data.l + trigger.param2,X                        ; $009DCE | |
.else                                                                           ;         | |
    LDA bank19.outdoor_trigger_data.l + trigger.param2,X                        ; $009BAE |/
.endif
@execute_conditional_event:
    JSR _execute_conditional_event                                              ; $009BB2 |\ Execute the conditional event and return.
    RTS                                                                         ; $009BB5 |/
+   PHX                                                                         ; $009BB6 | Preserve the value in the X register.
    LDX r_map_history_index.w                                                   ; $009BB7 | Set the X register to the map history index.
    LDA r_map_area.w                                                            ; $009BBA |\
    BEQ +                                                                       ; $009BBD | | Set the map plane to zero if the map area is the overworld and 1
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $009BBF | | otherwise.
+   STA r_map_plane.w                                                           ; $009BC1 |/
    LDA r_map_area.w                                                            ; $009BC4 |\
    CLC                                                                         ; $009BC7 | | Set the map history map ID to the map area plus $FB.
    ADC #MAP_ID_OVERWORLD.b                                                     ; $009BC8 | |
    STA r_map_history.1.map_id.w,X                                              ; $009BCA |/
    LDA r_current_coordinates.x.l & $FFFF                                       ; $009BCD |\ Set the X coordinate in the map history index.
    STA r_map_history.1.x.w,X                                                   ; $009BD1 |/
    LDA r_current_coordinates.y.w                                               ; $009BD4 |\ Set the Y coordinate in the map history index.
    STA r_map_history.1.y.w,X                                                   ; $009BD7 |/
    INX                                                                         ; $009BDA |\
    INX                                                                         ; $009BDB | | Increment the map history index by three. If it reaches the limit,
    INX                                                                         ; $009BDC | | reset it back to zero.
    CPX #MAP_HISTORY_ENTRY_LIMIT.w * _sizeof_map_history_entry                  ; $009BDD | |
    BCC +                                                                       ; $009BE0 | | NOTE: This is technically a bug, but overworld maps should never
    LDX #0.w                                                                    ; $009BE2 | |       be in a position where the index is this high.
+   STX r_map_history_index.w                                                   ; $009BE5 |/
    PLX                                                                         ; $009BE8 | Restore the X register.
.if FF4_EASYTYPE != 1
    LDA bank15.outdoor_trigger_data.l + trigger.param1,X                        ; $009E09 |\ Set the map ID to the first parameter.
    STA r_map_id.w                                                              ; $009E0D |/
    LDA bank15.outdoor_trigger_data.l + trigger.param2,X                        ; $009E10 |\
    AND #%00111111.b                                                            ; $009E14 | | Set the X coordinate to the low six bits of the second parameter.
    STA r_current_coordinates.x.w                                               ; $009E16 |/
    LDA bank15.outdoor_trigger_data.l + trigger.param3,X                        ; $009E19 |\ Set the Y coordinate to the third parameter.
    STA r_current_coordinates.y.w                                               ; $009E1D |/
    LDA bank15.outdoor_trigger_data.l + trigger.param2,X                        ; $009E20 | Load the byte for the next section.
.else
    LDA bank19.outdoor_trigger_data.l + trigger.param1,X                        ; $009BE9 |\ Set the map ID to the first parameter.
    STA r_map_id.w                                                              ; $009BED |/
    LDA bank19.outdoor_trigger_data.l + trigger.param2,X                        ; $009BF0 |\
    AND #%00111111.b                                                            ; $009BF4 | | Set the X coordinate to the low six bits of the second parameter.
    STA r_current_coordinates.x.w                                               ; $009BF6 |/
    LDA bank19.outdoor_trigger_data.l + trigger.param3,X                        ; $009BF9 |\ Set the Y coordinate to the third parameter.
    STA r_current_coordinates.y.w                                               ; $009BFD |/
    LDA bank19.outdoor_trigger_data.l + trigger.param2,X                        ; $009C00 | Load the byte for the next section.
.endif
    AND #%11000000.b                                                            ; $009C04 |\
    LSR A                                                                       ; $009C06 | | Set the direction from the high two bits of the second parameter.
    LSR A                                                                       ; $009C07 | |
    LSR A                                                                       ; $009C08 | |
    LSR A                                                                       ; $009C09 | |
    LSR A                                                                       ; $009C0A | |
    LSR A                                                                       ; $009C0B | |
    STA r_direction.w                                                           ; $009C0C |/
    JSR _audio_fade_out                                                         ; $009C0F | Fade out the audio.
    JSR _do_out_transition                                                      ; $009C12 | Animate the out transition.
    INC <r_map_changed_by_trigger                                               ; $009C15 | Set the map changed by trigger flag.
    LDA #MAP_AREA_DUNGEON.b                                                     ; $009C17 |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $009C19 |/
    RTS                                                                         ; $009C1C

; _check_vehicle_change ($00:9C1D)
;
; If the player is currently pressing the confirm button (A by default), do a
; series of checks: First, handle the overworld/underworld airship transition if
; appropriate. Next, attempt to land the current vehicle. Finally, attempt to
; board a vehicle at the same coordinates.
_check_vehicle_change:
    LDA <r_joypad_pressed_lo                                                    ; $009C1D |\
    AND #JOYPAD_L_CONFIRM.b                                                     ; $009C1F | | If the confirm button is not being pressed or if the flag that
    BEQ +                                                                       ; $009C21 | | indicates the A button press has already been handled is set,
    LDA <r_joypad_a_pressed                                                     ; $009C23 | | return.
    BEQ ++                                                                      ; $009C25 | |
+   RTS                                                                         ; $009C27 |/
++  INC <r_joypad_a_pressed                                                     ; $009C28 | Increment the A button pressed flag.
    LDA #PLOT_FLAG_FALCON_DRILL_INSTALLED.b                                     ; $009C2A |\
    JSR _get_plot_flag                                                          ; $009C2C | | Skip checking the status of the Agart mountain if the drill is
    CMP #$00.b                                                                  ; $009C2F | | installed.
    BNE +                                                                       ; $009C31 |/
    LDA #PLOT_FLAG_AGART_MOUNTAIN_OPEN.b                                        ; $009C33 |\
    JSR _get_plot_flag                                                          ; $009C35 | | If the Agart mountain is closed, skip to the next section of code.
    CMP #$00.b                                                                  ; $009C38 | |
    BEQ @next                                                                   ; $009C3A |/
+   LDA r_vehicle.w                                                             ; $009C3C |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $009C3F | | If the current vehicle isn't the Enterprise or Falcon, skip to the
    BEQ +                                                                       ; $009C41 | | next section of code.
    CMP #VEHICLE_FALCON.b                                                       ; $009C43 | |
    BNE @next                                                                   ; $009C45 |/
+   LDA r_map_area.w                                                            ; $009C47 |\
    BNE +                                                                       ; $009C4A | | If the current map area is the overworld and the X coordinate is
    LDA r_current_coordinates.x.w                                               ; $009C4C | | between 105 and 107 and the Y coordinate is between 211 and 213
    CMP #105.b                                                                  ; $009C4F | | (above the Agart mountain), move to the relevant section of code.
    BCC @next                                                                   ; $009C51 | | Otherwise, abort and head to the next section.
    CMP #108.b                                                                  ; $009C53 | |
    BCS @next                                                                   ; $009C55 | |
    LDA r_current_coordinates.y.w                                               ; $009C57 | |
    CMP #211.b                                                                  ; $009C5A | |
    BCC @next                                                                   ; $009C5C | |
    CMP #214.b                                                                  ; $009C5E | |
    BCS @next                                                                   ; $009C60 | |
    JMP ++                                                                      ; $009C62 |/
+   LDA r_map_area.w                                                            ; $009C65 |\
    CMP #MAP_AREA_UNDERWORLD.b                                                  ; $009C68 | | Do the same check, except for the underworld. The X coordinate
    BNE @next                                                                   ; $009C6A | | should be between 112 and 114 and the Y coordinate should be
    LDA r_current_coordinates.x.w                                               ; $009C6C | | between 15 and 17.
    CMP #112.b                                                                  ; $009C6F | |
    BCC @next                                                                   ; $009C71 | |
    CMP #115.b                                                                  ; $009C73 | |
    BCS @next                                                                   ; $009C75 | |
    LDA r_current_coordinates.y.w                                               ; $009C77 | |
    CMP #15.b                                                                   ; $009C7A | |
    BCC @next                                                                   ; $009C7C | |
    CMP #18.b                                                                   ; $009C7E | |
    BCS @next                                                                   ; $009C80 |/
++  LDA #1.b                                                                    ; $009C82 |\
    STA <r_agart_traversal_pending                                              ; $009C84 | | Set a flag to indicate the Agart traversal is pending and return.
    RTS                                                                         ; $009C86 |/
@next:
    LDA r_vehicle.w                                                             ; $009C87 |\
    BEQ @vehicle_none                                                           ; $009C8A | | If the current vehicle is the yellow chocobo, attempt to dismount
    CMP #VEHICLE_YELLOW_CHOCOBO.b                                               ; $009C8C | | the chocobo.
    BNE +                                                                       ; $009C8E | |
    JMP _dismount_yellow_chocobo                                                ; $009C90 |/
+   CMP #VEHICLE_BLACK_CHOCOBO.b                                                ; $009C93 |\
    BNE +                                                                       ; $009C95 | | If the black chocobo, attempt to land.
    JMP _land_black_chocobo                                                     ; $009C97 |/
+   CMP #VEHICLE_HOVERCRAFT.b                                                   ; $009C9A |\
    BNE +                                                                       ; $009C9C | | If the hovercraft, attempt to land.
    JMP _land_hovercraft                                                        ; $009C9E |/
+   CMP #VEHICLE_ENTERPRISE.b                                                   ; $009CA1 |\
    BNE +                                                                       ; $009CA3 | | If the Enterprise, attempt to land.
    JMP _land_enterprise                                                        ; $009CA5 |/
+   CMP #VEHICLE_FALCON.b                                                       ; $009CA8 |\
    BNE +                                                                       ; $009CAA | | If the Falcon, attempt to land.
    JMP _land_falcon                                                            ; $009CAC |/
+   CMP #VEHICLE_BIG_WHALE.b                                                    ; $009CAF |\
    BNE +                                                                       ; $009CB1 | | If the Big Whale, attempt to land.
    JMP _land_big_whale                                                         ; $009CB3 |/
+   RTS                                                                         ; $009CB6
@vehicle_none:
    STZ r_saving_enabled.w                                                      ; $009CB7 | Disable saving.
    LDA <r_movement_direction                                                   ; $009CBA |\
    BEQ +                                                                       ; $009CBC | | If the player is currently moving, return.
    RTS                                                                         ; $009CBE |/
+   LDA r_map_plane.w                                                           ; $009CBF |\
    CMP #MAP_PLANE_OVERWORLD.b                                                  ; $009CC2 | | If the player is on the overworld, the yellow chocobo is active,
    BNE +                                                                       ; $009CC4 | | and the current coordinates match the yellow chocobo's
    LDA r_yellow_chocobo_status.w                                               ; $009CC6 | | coordinates, ride the yellow chocobo.
    BEQ +                                                                       ; $009CC9 | |
    LDX r_current_coordinates.w                                                 ; $009CCB | |
    CPX r_yellow_chocobo_coordinates.w                                          ; $009CCE | |
    BNE +                                                                       ; $009CD1 | |
    JMP _ride_yellow_chocobo                                                    ; $009CD3 |/
+   LDA r_map_plane.w                                                           ; $009CD6 |\
    CMP #MAP_PLANE_OVERWORLD.b                                                  ; $009CD9 | | If the player is on the overworld, the black chocobo is active,
    BNE +                                                                       ; $009CDB | | and the current coordinates match the black chocobo's coordinates,
    LDA r_black_chocobo_status.w                                                ; $009CDD | | ride the black chocobo.
    BEQ +                                                                       ; $009CE0 | |
    LDX r_current_coordinates.w                                                 ; $009CE2 | |
    CPX r_black_chocobo_coordinates.w                                           ; $009CE5 | |
    BNE +                                                                       ; $009CE8 | |
    JMP _ride_black_chocobo                                                     ; $009CEA |/
+   LDA r_map_plane.w                                                           ; $009CED |\
    CMP r_hovercraft_plane.w                                                    ; $009CF0 | | If the player is on the same plane as the hovercraft, the
    BNE +                                                                       ; $009CF3 | | hovercraft is active, and the hovercraft's coordinates match the
    LDA r_hovercraft_status.w                                                   ; $009CF5 | | player's coordinates, ride the hovercraft.
    BEQ +                                                                       ; $009CF8 | |
    LDX r_current_coordinates.w                                                 ; $009CFA | |
    CPX r_hovercraft_coordinates.w                                              ; $009CFD | |
    BNE +                                                                       ; $009D00 | |
    JMP _board_hovercraft                                                       ; $009D02 |/
+   LDA r_map_plane.w                                                           ; $009D05 |\
    CMP r_enterprise_plane.w                                                    ; $009D08 | | If the player is on the same plane as the Enterprise, the
    BNE +                                                                       ; $009D0B | | Enterprise is active, and the Enterprise coordinates match the
    LDA r_enterprise_status.w                                                   ; $009D0D | | player's coordinates, ride the Enterprise.
    BEQ +                                                                       ; $009D10 | |
    LDX r_current_coordinates.w                                                 ; $009D12 | |
    CPX r_enterprise_coordinates.w                                              ; $009D15 | |
    BNE +                                                                       ; $009D18 | |
    JMP _board_enterprise                                                       ; $009D1A |/
+   LDA r_map_plane.w                                                           ; $009D1D |\
    CMP r_falcon_plane.w                                                        ; $009D20 | | If the player is on the same plane as the Falcon, the Falcon
    BNE +                                                                       ; $009D23 | | is active, and the Falcon coordinates match the player's
    LDA r_falcon_status.w                                                       ; $009D25 | | coordinates, ride the Falcon.
    BEQ +                                                                       ; $009D28 | |
    LDX r_current_coordinates.w                                                 ; $009D2A | |
    CPX r_falcon_coordinates.w                                                  ; $009D2D | |
    BNE +                                                                       ; $009D30 | |
    JMP _board_falcon                                                           ; $009D32 |/
+   LDA r_map_plane.w                                                           ; $009D35 |\
    CMP r_big_whale_plane.w                                                     ; $009D38 | | If the player in on the same plane as the Big Whale, the Big Whale
    BNE +                                                                       ; $009D3B | | is active, and the Big Whale's coordinates match the player's
    LDA r_big_whale_status.w                                                    ; $009D3D | | coordinates, board the Big Whale.
    BEQ +                                                                       ; $009D40 | |
    LDX r_current_coordinates.w                                                 ; $009D42 | |
    CPX r_big_whale_coordinates.w                                               ; $009D45 | |
    BNE +                                                                       ; $009D48 | |
    JMP _board_big_whale                                                        ; $009D4A |/
+   RTS                                                                         ; $009D4D

; _update_current_tile_properties ($00:9D4E)
;
; Updates the tile numbers and properties for the current tile and the tiles to
; the north, east, south and west in RAM.
_update_current_tile_properties:
    LDA r_current_coordinates.x.w                                               ; $009D4E |\
    STA <r_get_tile_properties_arg_x                                            ; $009D51 | | Get the tile number and tile properties for the tile above the
    LDA r_current_coordinates.y.w                                               ; $009D53 | | current location and store the values in the appropriate
    DEC A                                                                       ; $009D56 | | locations.
    STA <r_get_tile_properties_arg_y                                            ; $009D57 | |
    JSR _get_tile_properties                                                    ; $009D59 | |
    LDX <r_get_tile_properties_result_properties                                ; $009D5C | |
    STX <r_tile_properties_up                                                   ; $009D5E | |
    LDA <r_get_tile_properties_result_tile                                      ; $009D60 | |
    STA r_tile_up.w                                                             ; $009D62 |/
    INC <r_get_tile_properties_arg_y                                            ; $009D65 |\
    DEC <r_get_tile_properties_arg_x                                            ; $009D67 | | Repeat the process with the tile to the left of the current
    JSR _get_tile_properties                                                    ; $009D69 | | location.
    LDX <r_get_tile_properties_result_properties                                ; $009D6C | |
    STX <r_tile_properties_left                                                 ; $009D6E | |
    LDA <r_get_tile_properties_result_tile                                      ; $009D70 | |
    STA r_tile_left.w                                                           ; $009D72 |/
    INC <r_get_tile_properties_arg_x                                            ; $009D75 |\
    JSR _get_tile_properties                                                    ; $009D77 | | Repeat with the tile at the current location.
    LDX <r_get_tile_properties_result_properties                                ; $009D7A | |
    STX <r_tile_properties_current                                              ; $009D7C | |
    LDA <r_get_tile_properties_result_tile                                      ; $009D7E | |
    STA r_tile_current.w                                                        ; $009D80 |/
    INC <r_get_tile_properties_arg_x                                            ; $009D83 |\
    JSR _get_tile_properties                                                    ; $009D85 | | Repeat with the tile to the right of the current location.
    LDX <r_get_tile_properties_result_properties                                ; $009D88 | |
    STX <r_tile_properties_right                                                ; $009D8A | |
    LDA <r_get_tile_properties_result_tile                                      ; $009D8C | |
    STA r_tile_right.w                                                          ; $009D8E |/
    INC <r_get_tile_properties_arg_y                                            ; $009D91 |\
    DEC <r_get_tile_properties_arg_x                                            ; $009D93 | | Repeat with the tile below the current location.
    JSR _get_tile_properties                                                    ; $009D95 | |
    LDX <r_get_tile_properties_result_properties                                ; $009D98 | |
    STX <r_tile_properties_down                                                 ; $009D9A | |
    LDA <r_get_tile_properties_result_tile                                      ; $009D9C | |
    STA r_tile_down.w                                                           ; $009D9E |/
    RTS                                                                         ; $009DA1

; _get_tile_properties ($00:9DA2)
;
; Given an X and Y coordinate in $061A and $061B, respectively, returns the tile
; number found at that coordinate in $0606 and the 16-bit tile property data in
; $061E. If the given coordinates are out of range on a dungeon map, will
; instead return either $0000 or $0007 depending on the value of $0FDF.
_get_tile_properties:
    LDA r_map_area.w                                                            ; $009DA2 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $009DA5 | | If the current map is not a dungeon map, simply take the Y
    BEQ +                                                                       ; $009DA7 | | coordinate mod 64 and move on to the next part of the function.
    LDA <r_get_tile_properties_arg_y                                            ; $009DA9 | |
    AND #%00111111.b                                                            ; $009DAB | |
    JMP +++                                                                     ; $009DAD |/
+   LDA <r_get_tile_properties_arg_x                                            ; $009DB0 |\
    BMI +                                                                       ; $009DB2 | | Otherwise, check if the X or Y coordinates is either negative or
    CMP #32.b                                                                   ; $009DB4 | | greater than or equal to 32. If none of these is true, move on to
    BCS +                                                                       ; $009DB6 | | the next part of the function.
    LDA <r_get_tile_properties_arg_y                                            ; $009DB8 | |
    BMI +                                                                       ; $009DBA | |
    CMP #32.b                                                                   ; $009DBC |/
    BCC ++                                                                      ; $009DBE |\
+   LDA r_map_properties.fill_tile.w                                            ; $009DC0 | | If the X or Y coordinate is out of range and the fill tile is
    BPL +                                                                       ; $009DC3 | | impassable, return $0000 as the tile properties, which won't
    LDX #$0000.w                                                                ; $009DC5 | | allow the user to pass.
    STX <r_get_tile_properties_result_properties                                ; $009DC8 | |
    RTS                                                                         ; $009DCA |/
+   LDX #$0007.w                                                                ; $009DCB |\
    STX <r_get_tile_properties_result_properties                                ; $009DCE | | If the coordinates are out of range otherwise, return $0007.
    RTS                                                                         ; $009DD0 |/
++  LDA <r_get_tile_properties_arg_y                                            ; $009DD1 |\
+++ STA <r_get_tile_properties_tmp_tile_index_hi                                ; $009DD3 | | Load the tile number by calculating the index from the X and Y
    LDA <r_get_tile_properties_arg_x                                            ; $009DD5 | | coordinates and loading it from the tile data array.
    STA <r_get_tile_properties_tmp_tile_index_lo                                ; $009DD7 | |
    LDX <r_get_tile_properties_tmp_tile_index                                   ; $009DD9 | |
    LDA r_tilemap_data.l,X                                                      ; $009DDB | |
    STA <r_get_tile_properties_result_tile                                      ; $009DDF |/
    STA <r_get_tile_properties_tmp_property_index_lo                            ; $009DE1 |\
    STZ <r_get_tile_properties_tmp_property_index_hi                            ; $009DE3 | | Using the tile number as an index, load the tile property bytes
    ASL <r_get_tile_properties_tmp_property_index_lo                            ; $009DE5 | | from the tile properties array.
    ROL <r_get_tile_properties_tmp_property_index_hi                            ; $009DE7 | |
    LDX <r_get_tile_properties_tmp_property_index                               ; $009DE9 | |
    LDA r_tile_properties.1.properties_1.w,X                                    ; $009DEB | |
    STA <r_get_tile_properties_result_properties_lo                             ; $009DEE | |
    LDA r_tile_properties.1.properties_2.w,X                                    ; $009DF0 | |
    STA <r_get_tile_properties_result_properties_hi                             ; $009DF3 |/
    RTS                                                                         ; $009DF5

; _wait_for_frame_divisible_by_four ($00:9DF6)
;
; Waits until $067A has a value that is divisible evenly by four. Until then, it
; handles drawing outdoor field sprites and doing tile animations. It also sets
; the player's direction to left.
_wait_for_frame_divisible_by_four:
    LDA #DIRECTION_LEFT.b                                                       ; $009DF6 |\ Set the player's current direction to face left.
    STA r_direction.w                                                           ; $009DF8 |/
-   JSR _init_oam                                                               ; $009DFB | Re-initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $009DFE | Draw all outdoor field sprites.
    JSR _do_tile_animations                                                     ; $009E01 | Do any relevant tile animations.
    LDA <r_map_frame_counter                                                    ; $009E04 |\
    AND #%00000011.b                                                            ; $009E06 | | Repeat this until the frame counter mod 4 is zero.
    BNE -                                                                       ; $009E08 |/
    RTS                                                                         ; $009E0A

; _wait_for_frame_divisible_by_eight ($00:9E0B)
;
; Waits until $067A has a value that is divisible evenly by eight. Until then,
; it handles drawing outdoor field sprites and doing tile animations. It also
; sets the player's direction to left.
_wait_for_frame_divisible_by_eight:
    LDA #DIRECTION_LEFT.b                                                       ; $009E0B |\ Set the player's current direction to left.
    STA r_direction.w                                                           ; $009E0D |/
-   JSR _init_oam                                                               ; $009E10 | Re-initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $009E13 | Draw all outdoor field sprites.
    JSR _do_tile_animations                                                     ; $009E16 | Do any relevant tile animations.
    LDA <r_map_frame_counter                                                    ; $009E19 |\
    AND #%00000111.b                                                            ; $009E1B | | Repeat this until the frame counter mod 8 is zero.
    BNE -                                                                       ; $009E1D |/
    RTS                                                                         ; $009E1F

; _ride_yellow_chocobo ($00:9E20)
;
; Sets the current vehicle to the yellow chocobo, sets the appropriate movement
; speed and triggers a change in the current song.
_ride_yellow_chocobo:
    LDA #VEHICLE_YELLOW_CHOCOBO.b                                               ; $009E20 |\ Set the current vehicle to the yellow chocobo.
    STA r_vehicle.w                                                             ; $009E22 |/
    STA <r_movement_speed                                                       ; $009E25 | Set the movement speed to 1.
    JSR _play_map_song                                                          ; $009E27 | Play the appropriate song.
    RTS                                                                         ; $009E2A

; _ride_black_chocobo ($00:9E2B)
;
; Sets the current vehicle to the black chocobo if the new ride count is 1, sets
; the appropriate movement speed, and changes the map song. This function falls
; through to the next one which raises the black chocobo.
_ride_black_chocobo:
    INC r_black_chocobo_count.w                                                 ; $009E2B | Increment the black chocobo ride count.
    LDA r_black_chocobo_count.w                                                 ; $009E2E |\
    CMP #1.b                                                                    ; $009E31 | | If this is the first ride, set the black chocobo's forest
    BNE +                                                                       ; $009E33 | | coordinates to the current coordinates (as we must be at chocobo
    LDA r_current_coordinates.x.w                                               ; $009E35 | | forest).
    STA r_black_chocobo_forest_coordinates.x.w                                  ; $009E38 | |
    LDA r_current_coordinates.y.w                                               ; $009E3B | |
    STA r_black_chocobo_forest_coordinates.y.w                                  ; $009E3E |/
+   LDA #VEHICLE_BLACK_CHOCOBO.b                                                ; $009E41 |\ Set the current vehicle to the black chocobo.
    STA r_vehicle.w                                                             ; $009E43 |/
    STA <r_movement_speed                                                       ; $009E46 | Set the vehicle speed to the black chocobo speed.
    JSR _play_map_song                                                          ; $009E48 | Play the appropriate song.

; _raise_black_chocobo ($00:9E4B)
;
; Raises a black chocobo in altitude from zero to sixteen. An increase occurs
; every four frames.
_raise_black_chocobo:
    STZ <r_transition_index                                                     ; $009E4B |\
    STZ <r_black_chocobo_altitude                                               ; $009E4D | | Increase the black chocobo's altitude by 1 every four frames
-   JSR _wait_for_frame_divisible_by_four                                       ; $009E4F | | until it reaches 16.
    INC <r_black_chocobo_altitude                                               ; $009E52 | |
    INC <r_transition_index                                                     ; $009E54 | |
    LDA <r_transition_index                                                     ; $009E56 | |
    CMP #$10.b                                                                  ; $009E58 | |
    BNE -                                                                       ; $009E5A |/
    RTS                                                                         ; $009E5C

; _dismount_yellow_chocobo ($00:9E5D)
;
; Dismounts the player from the yellow chocobo and handles the chocobo leaving
; animation, as well as resetting the sprites, various variables, and changing
; the song to the one associated with the current map.
_dismount_yellow_chocobo:
    LDA <r_tile_properties_current.properties_1                                 ; $009E5D |\
    AND #TILE_PROPERTY_1_OUTDOOR_CAN_WALK.b                                     ; $009E5F | | Return if the current tile is not suitable for walking.
    BNE +                                                                       ; $009E61 | |
    RTS                                                                         ; $009E63 |/
+   JSR _audio_fade_out                                                         ; $009E64 | Fade out the audio.
    LDA #YELLOW_CHOCOBO_STATUS_LEAVING.b                                        ; $009E67 |\ Set the yellow chocobo's status to leaving.
    STA r_yellow_chocobo_status.w                                               ; $009E69 |/
    LDA #112.b                                                                  ; $009E6C |\
    STA r_yellow_chocobo_coordinates.x.w                                        ; $009E6E | | Set the yellow chocobo's pixel coordinates to 112,112.
    STA r_yellow_chocobo_coordinates.y.w                                        ; $009E71 |/
    LDA #DIRECTION_RIGHT.b                                                      ; $009E74 |\ Set the facing direction to right.
    STA r_direction.w                                                           ; $009E76 |/
    LDA #2.b                                                                    ; $009E79 |\ Set the chocobo's X coordinate delta to 2.
    STA <r_dismount_yellow_chocobo_delta_x                                      ; $009E7B |/
    JSR _get_field_rng                                                          ; $009E7D |\
    LSR A                                                                       ; $009E80 | | With a 50% probability, change the chocobo's direction to left and
    BCC +                                                                       ; $009E81 | | change the X coordinate delta to -2.
    LDA #DIRECTION_LEFT.b                                                       ; $009E83 | |
    STA r_direction.w                                                           ; $009E85 | |
    LDA <r_dismount_yellow_chocobo_delta_x                                      ; $009E88 | |
    EOR #%11111111.b                                                            ; $009E8A | |
    INC A                                                                       ; $009E8C | |
    STA <r_dismount_yellow_chocobo_delta_x                                      ; $009E8D |/
+   LDA #2.b                                                                    ; $009E8F |\
    STA <r_dismount_yellow_chocobo_delta_y                                      ; $009E91 | | With 50% probability, set the initial Y coordinate delta to either
    JSR _get_field_rng                                                          ; $009E93 | | 2 or -2.
    LSR A                                                                       ; $009E96 | |
    BCC +                                                                       ; $009E97 | |
    LDA <r_dismount_yellow_chocobo_delta_y                                      ; $009E99 | |
    EOR #%11111111.b                                                            ; $009E9B | |
    INC A                                                                       ; $009E9D | |
    STA <r_dismount_yellow_chocobo_delta_y                                      ; $009E9E |/
+   STZ r_vehicle.w                                                             ; $009EA0 | Set the vehicle to no vehicle.
-   JSR _wait_for_nmi_complete_field                                            ; $009EA3 | Wait for the next frame.
    JSR _get_field_rng                                                          ; $009EA6 |\
    CMP #16.b                                                                   ; $009EA9 | | With a 16/256 probability, change the vertical direction of the
    BCS +                                                                       ; $009EAB | | leaving chocobo.
    LDA <r_dismount_yellow_chocobo_delta_y                                      ; $009EAD | |
    EOR #%11111111.b                                                            ; $009EAF | |
    INC A                                                                       ; $009EB1 | |
    STA <r_dismount_yellow_chocobo_delta_y                                      ; $009EB2 |/
+   LDA r_yellow_chocobo_coordinates.x.w                                        ; $009EB4 |\
    CLC                                                                         ; $009EB7 | | Add the X coordinate delta to the chocobo's X coordinate. If it
    ADC <r_dismount_yellow_chocobo_delta_x                                      ; $009EB8 | | reaches either 0 or 240, exit the loop.
    STA r_yellow_chocobo_coordinates.x.w                                        ; $009EBA | |
    BEQ +                                                                       ; $009EBD | |
    CMP #240.b                                                                  ; $009EBF | |
    BEQ +                                                                       ; $009EC1 |/
    LDA r_yellow_chocobo_coordinates.y.w                                        ; $009EC3 |\
    CLC                                                                         ; $009EC6 | | Add the Y coordinate delta to the chocobo's Y coordinate. If it
    ADC <r_dismount_yellow_chocobo_delta_y                                      ; $009EC7 | | reaches either 0 or 240, exit the loop.
    STA r_yellow_chocobo_coordinates.y.w                                        ; $009EC9 | |
    BEQ +                                                                       ; $009ECC | |
    CMP #240.b                                                                  ; $009ECE | |
    BEQ +                                                                       ; $009ED0 |/
    LDA #VEHICLE_YELLOW_CHOCOBO.b                                               ; $009ED2 |\
    STA r_vehicle.w                                                             ; $009ED4 | | Draw the yellow chocobo and player sprites and then return to the
    JSL bank15.draw_field_sprite_yellow_chocobo                                 ; $009ED7 | | start of the loop.
    STZ r_vehicle.w                                                             ; $009EDB | |
    JSL bank15.draw_outdoor_field_sprite_player                                 ; $009EDE | |
    JMP -                                                                       ; $009EE2 |/
+   JSR _wait_for_nmi_complete_field                                            ; $009EE5 | Wait for a frame to pass.
    JSR _init_oam                                                               ; $009EE8 | Re-initialize the OAM.
    STZ r_vehicle.w                                                             ; $009EEB | Set the current vehicle to nothing.
    STZ r_yellow_chocobo_status.w                                               ; $009EEE | Set the yellow chocobo status to inactive.
    JSR _draw_outdoor_field_sprites                                             ; $009EF1 | Draw the outdoor field sprites.
    JSR _wait_for_nmi_complete_field                                            ; $009EF4 | Wait for another frame.
    STZ <r_movement_speed                                                       ; $009EF7 | Set the movement speed to lowest.
    STZ <r_movement_frame_counter                                               ; $009EF9 | Set the movement frame counter to zero.
    INC r_saving_enabled.w                                                      ; $009EFB | Enable saving.
    JSR _play_map_song                                                          ; $009EFE | Play the song associated with the current map.
    RTS                                                                         ; $009F01

; _land_black_chocobo ($00:9F02)
;
; Goes through the sequence necessary to land the black chocobo. It lowers the
; chocobo's altitude every four frames. If the current tile is inappropriate for
; landing, it will then raise the altitude again and return. Afterward, it sets
; various status variables.
_land_black_chocobo:
    STZ <r_transition_index                                                     ; $009F02 |\
-   JSR _wait_for_frame_divisible_by_four                                       ; $009F04 | | Decrease the black chocobo's altitude by one every four frames
    DEC <r_black_chocobo_altitude                                               ; $009F07 | | until this has been done 16 times.
    INC <r_transition_index                                                     ; $009F09 | |
    LDA <r_transition_index                                                     ; $009F0B | |
    CMP #$10.b                                                                  ; $009F0D | |
    BNE -                                                                       ; $009F0F |/
    LDA <r_tile_properties_current.properties_1                                 ; $009F11 |\
    AND #TILE_PROPERTY_1_OUTDOOR_FOREST.b                                       ; $009F13 | | If the black chocobo can't land here, reraise the chocobo back to
    BNE +                                                                       ; $009F15 | | altitude.
    JMP _raise_black_chocobo                                                    ; $009F17 |/
+   STZ r_vehicle.w                                                             ; $009F1A | Set the current vehicle to none.
    STZ <r_movement_speed                                                       ; $009F1D | Set the movement speed to lowest.
    STZ <r_movement_frame_counter                                               ; $009F1F | Reset the movement frame counter.
    LDA #DIRECTION_DOWN.b                                                       ; $009F21 |\ Set the current direction to down.
    STA r_direction.w                                                           ; $009F23 |/
    LDX r_current_coordinates.w                                                 ; $009F26 |\ Transfer the current X and Y coordinates to the black chocobo X and
    STX r_black_chocobo_coordinates.w                                           ; $009F29 |/ Y coordinates.
    LDA r_black_chocobo_count.w                                                 ; $009F2C |\
    CMP #2.b                                                                    ; $009F2F | | If this is the second time the black chocobo has been flown, reset
    BNE +                                                                       ; $009F31 | | the counter and set the black chocobo to inactive. (The chocobo
    STZ r_black_chocobo_count.w                                                 ; $009F33 | | has returned to the forest.)
    STZ r_black_chocobo_status.w                                                ; $009F36 |/
+   JSR _play_map_song                                                          ; $009F39 | Play the song associated with the current map.
    INC r_saving_enabled.w                                                      ; $009F3C | Enable saving.
    RTS                                                                         ; $009F3F

; _board_ship ($00:9F40)
;
; Sets the current vehicle to the ship and sets the movement speed accordingly.
_board_ship:
    LDA #VEHICLE_SHIP.b                                                         ; $009F40 |\ Set the current vehicle to the ship.
    STA r_vehicle.w                                                             ; $009F42 |/
    LDA #MOVEMENT_SPEED_SHIP.b                                                  ; $009F45 |\ Set the movement speed to the ship movement speed.
    STA <r_movement_speed                                                       ; $009F47 |/
    RTS                                                                         ; $009F49

; _board_hovercraft ($00:9F4A)
;
; Sets the current vehicle to the hovercraft and animates its rising. If the
; cutscene active flag is set, a random smoke explosion will be animated prior
; to raising the hovercraft.
_board_hovercraft:
    LDA #VEHICLE_HOVERCRAFT.b                                                   ; $009F4A |\ Set the vehicle to the hovercraft.
    STA r_vehicle.w                                                             ; $009F4C |/
    LDA #MOVEMENT_SPEED_HOVERCRAFT.b                                            ; $009F4F |\ Set the movement speed to 1.
    STA <r_movement_speed                                                       ; $009F51 |/
    LDA r_map_plane.w                                                           ; $009F53 |\ Set the hovercraft plane to the current map plane.
    STA r_hovercraft_plane.w                                                    ; $009F56 |/
    LDA #DIRECTION_LEFT.b                                                       ; $009F59 |\ Set the current direction to left.
    STA r_direction.w                                                           ; $009F5B |/
    LDA <r_cutscene_active                                                      ; $009F5E |\
    BEQ +                                                                       ; $009F60 | | If this is part of a cutscene, animate a random smoke explosion.
    JSR _animate_random_smoke_explosion                                         ; $009F62 |/
+   JSR _play_map_song                                                          ; $009F65 | Play the correct song for this map.
    STZ <r_transition_index                                                     ; $009F68 |\
    STZ <r_hovercraft_altitude                                                  ; $009F6A | | Increment the hovercraft altitude once every eight frames until it
-   JSR _wait_for_frame_divisible_by_eight                                      ; $009F6C | | reaches its maximum.
    INC <r_hovercraft_altitude                                                  ; $009F6F | |
    INC <r_transition_index                                                     ; $009F71 | |
    LDA <r_transition_index                                                     ; $009F73 | |
    CMP #$04.b                                                                  ; $009F75 | |
    BNE -                                                                       ; $009F77 |/
    RTS                                                                         ; $009F79

; _animate_random_smoke_explosion ($00:9F7A)
;
; Animates a small random smoke explosion at the center of the screen.
_animate_random_smoke_explosion:
    LDA #$10.b                                                                  ; $009F7A |\ The explosion should have four simultaneous sprites.
    STA r_draw_explosion_arg_count.w                                            ; $009F7C |/
    LDA #$03.b                                                                  ; $009F7F |\
    STA r_draw_explosion_arg_width.w                                            ; $009F81 | | The width and height should both be as small as possible.
    LDA #$03.b                                                                  ; $009F84 | |
    STA r_draw_explosion_arg_height.w                                           ; $009F86 |/
    LDX #$7070.w                                                                ; $009F89 |\ Set the coordinates of the explosion to 112,112.
    STX r_draw_explosion_arg_coordinates.w                                      ; $009F8C |/
    LDX #$0028.w                                                                ; $009F8F |\ The explosion will go for $28 cycles.
    STX r_draw_explosion_arg_cycles.w                                           ; $009F92 |/
    LDA #$06.b                                                                  ; $009F95 |\ Use palette 6 (really 7 because this is smoke).
    STA r_draw_explosion_arg_palette.w                                          ; $009F97 |/
    LDA #$02.b                                                                  ; $009F9A |\ Use $02 to get smoke.
    STA r_draw_explosion_arg_smoke.w                                            ; $009F9C |/
    JSR _init_explosion                                                         ; $009F9F | Initialize the explosion palette and explosion data.
-   JSR _do_tile_animations                                                     ; $009FA2 | Animate tiles.
    JSR _draw_explosion                                                         ; $009FA5 | Draw the actual explosion.
    LDX r_draw_explosion_arg_cycles.w                                           ; $009FA8 |\
    CPX #$0008.w                                                                ; $009FAB | | If the cycle is less than 8, suppress the creation of new
    BCS +                                                                       ; $009FAE | | explosions and draw outdoor field sprites.
    LDA #$01.b                                                                  ; $009FB0 | |
    STA <r_draw_explosion_arg_suppress_new                                      ; $009FB2 | |
    JSR _draw_outdoor_field_sprites                                             ; $009FB4 |/
+   LDX r_draw_explosion_arg_cycles.w                                           ; $009FB7 |\
    CPX #$0000.w                                                                ; $009FBA | | Keep going until the cycle count reaches zero.
    BNE -                                                                       ; $009FBD |/
    RTS                                                                         ; $009FBF

; _land_hovercraft ($00:9FC0)
;
; Checks to see if the tile is appropriate for landing the hovercraft. If so,
; goes through the landing sequence.
_land_hovercraft:
    LDA <r_tile_properties_current.properties_1                                 ; $009FC0 |\
    AND #TILE_PROPERTY_1_OUTDOOR_CAN_WALK.b                                     ; $009FC2 | | Check to see if the current tile is appropriate for landing the
    BNE +                                                                       ; $009FC4 | | hovercraft.
    RTS                                                                         ; $009FC6 |/
+   STZ <r_transition_index                                                     ; $009FC7 |\
-   JSR _wait_for_frame_divisible_by_eight                                      ; $009FC9 | | Lower the hovercraft by one pixel every 8 frames until it has
    DEC <r_hovercraft_altitude                                                  ; $009FCC | | dropped four pixels.
    INC <r_transition_index                                                     ; $009FCE | |
    LDA <r_transition_index                                                     ; $009FD0 | |
    CMP #4.b                                                                    ; $009FD2 | |
    BNE -                                                                       ; $009FD4 |/
    STZ r_vehicle.w                                                             ; $009FD6 | Set the vehicle to none.
    STZ <r_movement_speed                                                       ; $009FD9 | Set the movement speed to lowest.
    STZ <r_movement_frame_counter                                               ; $009FDB | Zero the movement frame counter.
    LDA #DIRECTION_DOWN.b                                                       ; $009FDD |\ Set the current direction to down.
    STA r_direction.w                                                           ; $009FDF |/
    LDA r_map_plane.w                                                           ; $009FE2 |\ Set the hovercraft's map plane to the current map plane.
    STA r_hovercraft_plane.w                                                    ; $009FE5 |/
    LDX r_current_coordinates.w                                                 ; $009FE8 |\ Transfer the current coordinates to the hovercraft's coordinates.
    STX r_hovercraft_coordinates.w                                              ; $009FEB |/
    JSR _play_map_song                                                          ; $009FEE | Play the song associated with the current map.
    INC r_saving_enabled.w                                                      ; $009FF1 | Enable saving.
    RTS                                                                         ; $009FF4

; _board_enterprise ($00:9FF5)
;
; Sets the vehicle to the Enterprise, unless bit 2 of plot flag 7 is set.
_board_enterprise:
    LDA r_plot_flags.7.w                                                        ; $009FF5 |\
    AND #PLOT_FLAG_7_ENTERPRISE_DISABLED.b                                      ; $009FF8 | | If the Enterprise disabled plot flag is set, skip boarding.
    BEQ +                                                                       ; $009FFA | |
    RTS                                                                         ; $009FFC |/
+   LDA #VEHICLE_ENTERPRISE.b                                                   ; $009FFD |\ Set the Enterprise as the vehicle.
    STA r_vehicle.w                                                             ; $009FFF |/
    LDA #$03.b                                                                  ; $00A002 |\
    STA <r_movement_speed                                                       ; $00A004 | | Set the movement speed to 3 and the direction to left.
    STA r_direction.w                                                           ; $00A006 |/
    LDA <r_cutscene_active                                                      ; $00A009 |\
    BEQ ++                                                                      ; $00A00B | | If this is a cutscene and airship activation effects are disabled,
    LDA <r_disable_airship_activation_effects                                   ; $00A00D | | simply set the zoom level to maximum, set the altitude to maximum
    BEQ +                                                                       ; $00A00F | | and return.
    LDA #$20.b                                                                  ; $00A011 | |
    STA <r_zoom_level                                                           ; $00A013 | |
    LDA #$10.b                                                                  ; $00A015 | |
    STA <r_enterprise_altitude                                                  ; $00A017 | |
    JSL bank15.set_zoom_palette                                                 ; $00A019 | |
    LDA #$0F.b                                                                  ; $00A01D | |
    STA r_airship_animation_speed.w                                             ; $00A01F | |
    RTS                                                                         ; $00A022 |/
+   JSR _animate_random_smoke_explosion                                         ; $00A023 |\
    LDA #$20.b                                                                  ; $00A026 | | Otherwise, if this is a cutscene, draw a random smoke explosion,
    STA <r_transition_index                                                     ; $00A028 | | set the transition index to $20 and set the airship animation
    LDA #$0F.b                                                                  ; $00A02A | | speed, then move on to the next part.
    STA r_airship_animation_speed.w                                             ; $00A02C | |
    JMP _raise_enterprise                                                       ; $00A02F |/
++  JSR _play_map_song                                                          ; $00A032 |\ Otherwise, play the map song and set the transition index to zero.
    STZ <r_transition_index                                                     ; $00A035 |/ Fall through to the next function.

; _raise_enterprise ($00:A037)
;
; Executes the sequence to raise the Enterprise from ground level to its normal
; position in the skies.
_raise_enterprise:
    STZ <r_map_frame_counter                                                    ; $00A037 | Set the map frame counter to zero.
    STZ <r_enterprise_altitude                                                  ; $00A039 | Set the Enterprise altitude to zero.
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A03B |\
    LDA <r_transition_index                                                     ; $00A03E | | Wait four frames, then check the current transition index and
    CMP #$20.b                                                                  ; $00A040 | | branch accordingly.
    BCS +                                                                       ; $00A042 |/
    LSR A                                                                       ; $00A044 |\
    STA r_airship_animation_speed.w                                             ; $00A045 | | If the transition index is less than 32, set the airship animation
    INC <r_transition_index                                                     ; $00A048 | | speed to half the index and loop.
    JMP -                                                                       ; $00A04A |/
+   INC <r_enterprise_altitude                                                  ; $00A04D |\
    LDA <r_enterprise_altitude                                                  ; $00A04F | | Otherwise, increase the Enterprise's altitude, and set the zoom
    CLC                                                                         ; $00A051 | | level to the altitude plus 16. Set the zoom palette based on the
    ADC #16.b                                                                   ; $00A052 | | current altitude and then increment the transition index.
    STA <r_zoom_level                                                           ; $00A054 | |
    LDA <r_enterprise_altitude                                                  ; $00A056 | | Continue looping until the transition index reaches $30.
    JSL bank15.set_zoom_palette                                                 ; $00A058 | |
    INC <r_transition_index                                                     ; $00A05C | |
    LDA <r_transition_index                                                     ; $00A05E | |
    CMP #$30.b                                                                  ; $00A060 | |
    BNE -                                                                       ; $00A062 |/
    RTS                                                                         ; $00A064

; _board_falcon ($00:A065)
;
; Sets the current vehicle to the Falcon.
_board_falcon:
    LDA #VEHICLE_FALCON.b                                                       ; $00A065 |\ Sets the vehicle to the Falcon.
    STA r_vehicle.w                                                             ; $00A067 |/
    LDA #3.b                                                                    ; $00A06A |\
    STA <r_movement_speed                                                       ; $00A06C | | Sets the movement speed to 3 and the direction to left.
    STA r_direction.w                                                           ; $00A06E |/
    LDA <r_cutscene_active                                                      ; $00A071 |\
    BEQ ++                                                                      ; $00A073 | | If this is a cutscene and airship activation effects are disabled,
    LDA <r_disable_airship_activation_effects                                   ; $00A075 | | set the zoom level and other parameters as if the airship is
    BEQ +                                                                       ; $00A077 | | already at altitude and return.
    LDA #$20.b                                                                  ; $00A079 | |
    STA <r_zoom_level                                                           ; $00A07B | |
    LDA #$10.b                                                                  ; $00A07D | |
    STA <r_falcon_altitude                                                      ; $00A07F | |
    JSL bank15.set_zoom_palette                                                 ; $00A081 | |
    LDA #$0F.b                                                                  ; $00A085 | |
    STA r_airship_animation_speed.w                                             ; $00A087 | |
    RTS                                                                         ; $00A08A |/
+   JSR _animate_random_smoke_explosion                                         ; $00A08B |\
    LDA #$20.b                                                                  ; $00A08E | | Otherwise, if a cutscene is active, animate a random smoke
    STA <r_transition_index                                                     ; $00A090 | | explosion before raising the vehicle.
    LDA #$0F.b                                                                  ; $00A092 | |
    STA r_airship_animation_speed.w                                             ; $00A094 | |
    JMP _raise_falcon                                                           ; $00A097 |/
++  JSR _play_map_song                                                          ; $00A09A | Change the map song if appropriate.
    STZ <r_transition_index                                                     ; $00A09D | Set the transition index to zero and fall through.

; _raise_falcon ($00:A09F)
;
; Raises the Falcon from an altitude of zero to maximum altitude.
_raise_falcon:
    STZ <r_map_frame_counter                                                    ; $00A09F | Set the map frame counter to zero.
    STZ <r_falcon_altitude                                                      ; $00A0A1 | Set the Falcon altitude to zero.
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A0A3 | Wait for four frames.
    LDA <r_transition_index                                                     ; $00A0A6 |\
    CMP #$20.b                                                                  ; $00A0A8 | | If the current transition index is less than 32, set the airship
    BCS +                                                                       ; $00A0AA | | animation speed to half the index, increment the index, and loop.
    LSR A                                                                       ; $00A0AC | |
    STA r_airship_animation_speed.w                                             ; $00A0AD | |
    INC <r_transition_index                                                     ; $00A0B0 | |
    JMP -                                                                       ; $00A0B2 |/
+   INC <r_falcon_altitude                                                      ; $00A0B5 |\
    LDA <r_falcon_altitude                                                      ; $00A0B7 | | Otherwise, increase the Falcon altitude, set the new zoom level,
    CLC                                                                         ; $00A0B9 | | set the appropriate zoom palette and increment the index. Once the
    ADC #$10.b                                                                  ; $00A0BA | | index reaches $30, return.
    STA <r_zoom_level                                                           ; $00A0BC | |
    LDA <r_falcon_altitude                                                      ; $00A0BE | |
    JSL bank15.set_zoom_palette                                                 ; $00A0C0 | |
    INC <r_transition_index                                                     ; $00A0C4 | |
    LDA <r_transition_index                                                     ; $00A0C6 | |
    CMP #$30.b                                                                  ; $00A0C8 | |
    BNE -                                                                       ; $00A0CA |/
    RTS                                                                         ; $00A0CC

; _board_big_whale ($00:A0CD)
;
; Plays the Big Whale song and executes the event to board the Big Whale.
_board_big_whale:
    LDA #AUDIO_TRACK_LUNAR_WHALE.b                                              ; $00A0CD |\
    STA r_play_audio_arg_track.w                                                ; $00A0CF | | Play the Big Whale music.
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $00A0D2 | |
    STA r_play_audio_arg_mode.w                                                 ; $00A0D4 | |
    JSL bank04.play_audio                                                       ; $00A0D7 |/
    LDA #CONDITIONAL_EVENT_INDEX_BOARD_BIG_WHALE.b                              ; $00A0DB |\ Execute the event to board the Big Whale.
    JSR _execute_conditional_event                                              ; $00A0DD |/
    RTS                                                                         ; $00A0E0

; _activate_big_whale ($00:A0E1)
;
; Activates the Big Whale. For most vehicles, boarding and activation are the
; same, but for the Big Whale, you must first board the vehicle and then access
; the controls to activate it. If $06E1 is set, the raising process will be
; skipped, and the Big Whale will start at altitude. Otherwise, it will initiate
; the raising process and fall through to the next function.
_activate_big_whale:
    LDA #VEHICLE_BIG_WHALE.b                                                    ; $00A0E1 |\ Set the current vehicle to the Big Whale.
    STA r_vehicle.w                                                             ; $00A0E3 |/
    LDA #MOVEMENT_SPEED_BIG_WHALE.b                                             ; $00A0E6 |\ Set the movement speed to the Big Whale speed.
    STA <r_movement_speed                                                       ; $00A0E8 |/
    LDA <r_disable_airship_activation_effects                                   ; $00A0EA |\
    BEQ +                                                                       ; $00A0EC | | If $06E1 is non-zero, immediately set the zoom level to maximum,
    LDA #$30.b                                                                  ; $00A0EE | | set the Big Whale altitude to maximum, set the appropriate zoom
    STA <r_zoom_level                                                           ; $00A0F0 | | palette, and set the airship animation speed to $0F.
    LDA #$20.b                                                                  ; $00A0F2 | |
    STA <r_big_whale_altitude                                                   ; $00A0F4 | |
    LSR A                                                                       ; $00A0F6 | |
    JSL bank15.set_zoom_palette                                                 ; $00A0F7 | |
    LDA #$0F.b                                                                  ; $00A0FB | |
    STA r_airship_animation_speed.w                                             ; $00A0FD | |
    RTS                                                                         ; $00A100 |/
+   JSR _play_map_song                                                          ; $00A101 |\ Otherwise, play the appropriate song, set the transition index to
    STZ <r_transition_index                                                     ; $00A104 |/ zero, and fall through to _raise_big_whale below.

; _raise_big_whale ($00:A106)
;
; Animates the Big Whale rising from the ground to flight level. In addition,
; if $06C3 is set, it executes the travel between the earth and moon.
_raise_big_whale:
    STZ <r_map_frame_counter                                                    ; $00A106 | Set the map frame counter to zero.
    STZ <r_big_whale_altitude                                                   ; $00A108 | set the Big Whale altitude to zero.
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A10A |\
    LDA <r_transition_index                                                     ; $00A10D | | Until the transition index reaches $20, increment the index and
    CMP #$20.b                                                                  ; $00A10F | | set the airship animation speed to the index divided by two.
    BCS +                                                                       ; $00A111 | |
    LSR A                                                                       ; $00A113 | |
    STA r_airship_animation_speed.w                                             ; $00A114 | |
    INC <r_transition_index                                                     ; $00A117 | |
    JMP -                                                                       ; $00A119 |/
+   INC <r_big_whale_altitude                                                   ; $00A11C |\ Now, increase the Big Whale altitude by two.
    INC <r_big_whale_altitude                                                   ; $00A11E |/
    LDA <r_big_whale_altitude                                                   ; $00A120 |\
    CLC                                                                         ; $00A122 | | Set the zoom level to the altitude plus $10.
    ADC #$10.b                                                                  ; $00A123 | |
    STA <r_zoom_level                                                           ; $00A125 |/
    LDA <r_big_whale_altitude                                                   ; $00A127 |\
    LSR A                                                                       ; $00A129 | | Set the zoom palette based on the altitude divided by two.
    JSL bank15.set_zoom_palette                                                 ; $00A12A |/
    INC <r_transition_index                                                     ; $00A12E |\
    LDA <r_transition_index                                                     ; $00A130 | | Repeat this loop unitl the transition index reaches $30.
    CMP #$30.b                                                                  ; $00A132 | |
    BNE -                                                                       ; $00A134 |/
    LDA r_do_earth_moon_travel.w                                                ; $00A136 |\
    BNE +                                                                       ; $00A139 | | If not doing the earth moon travel, return as we're done.
    RTS                                                                         ; $00A13B |/
+   STZ r_do_earth_moon_travel.w                                                ; $00A13C |\
    LDA r_map_area.w                                                            ; $00A13F | | Determine which direction we're going.
    BEQ _big_whale_earth_to_moon                                                ; $00A142 | |
    JMP _big_whale_moon_to_earth                                                ; $00A144 |/

; _big_whale_earth_to_moon ($00:A147)
;
; Animates the Big Whale traveling from the earth to the moon.
_big_whale_earth_to_moon:
    LDX r_current_coordinates.w                                                 ; $00A147 |\ Save the current coordinates as the Big Whale earth coordinates.
    STX r_big_whale_earth_coordinates.w                                         ; $00A14A |/
    JSR _big_whale_depart_earth_moon                                            ; $00A14D | Animate the departure from the planet map.
    LDX #-104.w                                                                 ; $00A150 |\
    STX <r_scroll_bg1_horizontal                                                ; $00A153 | | Animate the actual travel from planet to planet.
    JSR _draw_moon_sprite                                                       ; $00A155 | |
    JSR _animate_origin_planet_receding                                         ; $00A158 | |
    LDX #$0198.w                                                                ; $00A15B | |
    STX <r_scroll_bg1_horizontal                                                ; $00A15E | |
    JSR _draw_moon_sprite                                                       ; $00A160 | |
    JSR _animate_destination_planet_approaching                                 ; $00A163 |/
    LDA #MAP_AREA_MOON.b                                                        ; $00A166 |\
    STA r_map_area.w                                                            ; $00A168 | | Set the new map are and plane to match the moon.
    STA r_big_whale_plane.w                                                     ; $00A16B | |
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $00A16E | |
    STA r_map_plane.w                                                           ; $00A170 |/
    LDX r_big_whale_moon_coordinates.w                                          ; $00A173 |\ Set the current coordinates to the saved Big Whale moon
    STX r_current_coordinates.w                                                 ; $00A176 |/ coordinates.
    JSR _change_map_moon                                                        ; $00A179 | Change the current map to the moon.
    LDA #$10.b                                                                  ; $00A17C |\ Set the correct zoom palette.
    JSL bank15.set_zoom_palette                                                 ; $00A17E |/
    LDA #$81.b                                                                  ; $00A182 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00A184 |/
    LDA #$30.b                                                                  ; $00A187 |\ Set the zoom level for the Big Whale at altitude.
    STA <r_zoom_level                                                           ; $00A189 |/
    JSR _lower_big_whale_high                                                   ; $00A18B | Lower the Big Whale from the top of the screen to flight level.
    LDX #$0000.w                                                                ; $00A18E |\ Reset the map history index.
    STX r_map_history_index.w                                                   ; $00A191 |/
    RTS                                                                         ; $00A194

; _big_whale_moon_to_earth ($00:A195)
;
; Animates the Big Whale flying from the moon to earth.
_big_whale_moon_to_earth:
    LDX r_current_coordinates.w                                                 ; $00A195 |\
    STX r_big_whale_moon_coordinates.w                                          ; $00A198 | | This does the same thing as above, except with the earth and moon
    JSR _big_whale_depart_earth_moon                                            ; $00A19B | | reversed.
    LDX #$0198.w                                                                ; $00A19E | |
    STX <r_scroll_bg1_horizontal                                                ; $00A1A1 | |
    JSR _draw_earth_sprite                                                      ; $00A1A3 | |
    JSR _animate_origin_planet_receding                                         ; $00A1A6 | |
    LDX #-104.w                                                                 ; $00A1A9 | |
    STX <r_scroll_bg1_horizontal                                                ; $00A1AC | |
    JSR _draw_earth_sprite                                                      ; $00A1AE | |
    JSR _animate_destination_planet_approaching                                 ; $00A1B1 | |
    LDA #%10000000.b                                                            ; $00A1B4 | |
    STA reg_ppu_inidisp                                                         ; $00A1B6 | |
    STZ reg_cpu_nmitimen                                                        ; $00A1B9 | |
    LDA #MAP_AREA_OVERWORLD.b                                                   ; $00A1BC | |
    STA r_map_area.w                                                            ; $00A1BE | |
    STA r_map_plane.w                                                           ; $00A1C1 | |
    STA r_big_whale_plane.w                                                     ; $00A1C4 | |
    LDX r_big_whale_earth_coordinates.w                                         ; $00A1C7 | |
    STX r_current_coordinates.w                                                 ; $00A1CA | |
    JSR _change_map_overworld                                                   ; $00A1CD | |
    LDA #$10.b                                                                  ; $00A1D0 | |
    JSL bank15.set_zoom_palette                                                 ; $00A1D2 | |
    LDA #%10000001.b                                                            ; $00A1D6 | |
    STA reg_cpu_nmitimen                                                        ; $00A1D8 | |
    LDA #$30.b                                                                  ; $00A1DB | |
    STA <r_zoom_level                                                           ; $00A1DD | |
    JSR _lower_big_whale_high                                                   ; $00A1DF | |
    LDX #$0000.w                                                                ; $00A1E2 | |
    STX r_map_history_index.w                                                   ; $00A1E5 |/
    RTS                                                                         ; $00A1E8

; _big_whale_depart_earth_moon ($00:A1E9)
;
; Executes the sequence for the Big Whale to leave the earth or moon. Raises the
; Big Whale from flight altitude, fades the screen out, and loads the graphical
; data necessary for the earth/moon transition. It does not execute the
; transition.
_big_whale_depart_earth_moon:
    JSR _raise_big_whale_high                                                   ; $00A1E9 | Raise the Big Whale from flight altitude to the top of the screen.
    LDA #$80.b                                                                  ; $00A1EC |\ Set forced blanking with brightness at zero.
    STA reg_ppu_inidisp                                                         ; $00A1EE |/
    STZ reg_cpu_nmitimen                                                        ; $00A1F1 | Disable NMI, timer interrupts, and joypad reading.
    STZ reg_cpu_hdmaen                                                          ; $00A1F4 | Disable any HDMA.
    LDA #$32.b                                                                  ; $00A1F7 |\
    STA <r_start_fixed_vram_dma_arg_value                                       ; $00A1F9 | | Use DMA to fill the background section of VRAM with nothing but
    LDX #$0000.w                                                                ; $00A1FB | | $32, which will be an empty tile once the moon tiles are loaded.
    STX <r_start_fixed_vram_dma_arg_vram_target                                 ; $00A1FE | |
    LDX #$8000.w                                                                ; $00A200 | |
    STX <r_start_fixed_vram_dma_arg_bytes                                       ; $00A203 | |
    JSL bank15.start_fixed_vram_dma                                             ; $00A205 |/
    LDA #MAP_AREA_MOON.b                                                        ; $00A209 |\
    STA r_map_area.w                                                            ; $00A20B | | Set the map area to the moon and load the map tiles.
    JSL bank15.load_map_outdoor_tiles                                           ; $00A20E |/
    JSR _load_earth_moon_transition_sprites                                     ; $00A212 |\ Load the earth/moon transition sprites, backgrounds and palette.
    JSR _load_earth_moon_transition_background                                  ; $00A215 |/
    RTS                                                                         ; $00A218

; _lower_big_whale_high ($00:A219)
;
; Animates the lowering of the Big Whale from the top of the screen to standard
; flight level, increasing the screen brightness from zero as it leaves the top.
_lower_big_whale_high:
    STZ <r_transition_index                                                     ; $00A219 | Set the transition index to zero.
    LDA #TILE_PROPERTY_1_OUTDOOR_BLACK_CHOCOBO.b                                ; $00A21B |\ Set the black chocobo bit on the current tile.
    STA <r_tile_properties_current.properties_1                                 ; $00A21D |/ TODO: What is the purpose of setting this bit?
-   JSR _set_big_whale_high_altitude                                            ; $00A21F | Set the Big Whale's altitude.
    JSR _draw_outdoor_field_sprites                                             ; $00A222 | Draw outdoor field sprites.
    JSR _wait_for_nmi_complete                                                  ; $00A225 | Wait for the next frame.
    JSR _set_ppu_brightness                                                     ; $00A228 | Set the PPU brightness if appropriate.
    INC <r_transition_index                                                     ; $00A22B |\
    CMP #bank14._sizeof_big_whale_altitude_data.b                               ; $00A22D | | Increment the index until it reaches $28.
    BNE -                                                                       ; $00A22F |/
    RTS                                                                         ; $00A231

; _raise_big_whale_high ($00:A232)
;
; Animates the raising of the Big Whale from standard flight level to the top
; of the screen, lowering the screen brightness to zero as it approaches the
; top.
_raise_big_whale_high:
    LDA #bank14._sizeof_big_whale_altitude_data.b                               ; $00A232 |\ Initialize the index to the maximum value.
    STA <r_transition_index                                                     ; $00A234 |/
-   JSR _set_big_whale_high_altitude                                            ; $00A236 | Set the Big Whale's altitude.
    JSR _draw_outdoor_field_sprites                                             ; $00A239 | Draw outdoor field sprites.
    JSR _wait_for_nmi_complete                                                  ; $00A23C | Wait for the next frame.
    JSR _set_ppu_brightness                                                     ; $00A23F | Set the PPU brightness if appropriate.
    DEC <r_transition_index                                                     ; $00A242 |\ Update the index and loop until it reaches zero.
    BNE -                                                                       ; $00A244 |/
    RTS                                                                         ; $00A246

; _animate_origin_planet_receding ($00:A247)
;
; During the transition between earth and moon on the Big Whale, this function
; animates the initial part of the planet-traveling animation where the origin
; planet fills the screen and then recedes off the bottom of the screen (as if
; the player were leaving and passing over it).
_animate_origin_planet_receding:
    JSR _draw_random_stars                                                      ; $00A247 | Draw a random starfield.
    LDX #-104.w                                                                 ; $00A24A |\ Set the BG1 vertical scroll value to -104.
    STX <r_scroll_bg1_vertical                                                  ; $00A24D |/
    STZ <r_set_mode_7_transform_arg_b.lo                                        ; $00A24F |\
    STZ <r_set_mode_7_transform_arg_b.hi                                        ; $00A251 | | Set the mode 7 rotation parameters to zero.
    STZ <r_set_mode_7_transform_arg_c.lo                                        ; $00A253 | |
    STZ <r_set_mode_7_transform_arg_c.hi                                        ; $00A255 |/
    LDA #%10000001.b                                                            ; $00A257 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00A259 |/
    LDA #%00001111.b                                                            ; $00A25C |\ Set the PPU to full brightness.
    STA reg_ppu_inidisp                                                         ; $00A25E |/
    LDA #$00.b                                                                  ; $00A261 |\ Initialize the index to zero.
    STA <r_transition_index                                                     ; $00A263 |/
-   JSR _wait_for_nmi_complete                                                  ; $00A265 | Wait for a complete frame.
    STZ reg_cpu_hdmaen                                                          ; $00A268 | Disable HDMA.
    LDA <r_transition_index                                                     ; $00A26B |\
    LSR A                                                                       ; $00A26D | | Set the mode 7 scaling parameter to the transition index divided
    LSR A                                                                       ; $00A26E | | by four plus 9.
    CLC                                                                         ; $00A26F | |
    ADC #9.b                                                                    ; $00A270 | |
    STA <r_set_mode_7_transform_arg_scale.lo                                    ; $00A272 | |
    STZ <r_set_mode_7_transform_arg_scale.hi                                    ; $00A274 |/
    JSR _set_mode_7_transform                                                   ; $00A276 | Set the mode 7 parameters.
    LDA <r_transition_index                                                     ; $00A279 |\
    AND #%00000111.b                                                            ; $00A27B | | On frames evenly divisible by eight, subtract one from the
    BNE +                                                                       ; $00A27D | | vertical scroll register to move the background down.
    LDA <r_scroll_bg1_vertical_lo                                               ; $00A27F | |
    SEC                                                                         ; $00A281 | |
    SBC #$01.b                                                                  ; $00A282 | |
    STA <r_scroll_bg1_vertical_lo                                               ; $00A284 | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00A286 | |
    SBC #$00.b                                                                  ; $00A288 | |
    STA <r_scroll_bg1_vertical_hi                                               ; $00A28A |/
+   JSR _set_ppu_brightness                                                     ; $00A28C | Set the PPU brightness according to the current transition index.
    JSR _draw_random_stars                                                      ; $00A28F | Draw random stars.
    INC <r_transition_index                                                     ; $00A292 |\
    LDA <r_transition_index                                                     ; $00A294 | | Increment the transition index, and loop until it reaches $60.
    CMP #$60.b                                                                  ; $00A296 | |
    BNE -                                                                       ; $00A298 |/
    LDA #$5F.b                                                                  ; $00A29A |\ Reset the transition index to $5F.
    STA <r_transition_index                                                     ; $00A29C |/
-   JSR _wait_for_nmi_complete                                                  ; $00A29E | Wait for the next frame completion.
    STZ reg_cpu_hdmaen                                                          ; $00A2A1 | Disable HDMA.
    LDA <r_transition_index                                                     ; $00A2A4 |\
    LSR A                                                                       ; $00A2A6 | | Set the mode 7 scaling parameter to the transition index divided
    LSR A                                                                       ; $00A2A7 | | by four plus 9.
    CLC                                                                         ; $00A2A8 | |
    ADC #9.b                                                                    ; $00A2A9 | |
    STA <r_set_mode_7_transform_arg_scale.lo                                    ; $00A2AB | |
    STZ <r_set_mode_7_transform_arg_scale.hi                                    ; $00A2AD | |
    JSR _set_mode_7_transform                                                   ; $00A2AF |/
    LDA <r_transition_index                                                     ; $00A2B2 |\
    AND #%00000111.b                                                            ; $00A2B4 | | On frames divisible by eight, subtract one from the vertical
    BNE +                                                                       ; $00A2B6 | | scroll register.
    LDA <r_scroll_bg1_vertical_lo                                               ; $00A2B8 | |
    SEC                                                                         ; $00A2BA | |
    SBC #$01.b                                                                  ; $00A2BB | |
    STA <r_scroll_bg1_vertical_lo                                               ; $00A2BD | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00A2BF | |
    SBC #$00.b                                                                  ; $00A2C1 | |
    STA <r_scroll_bg1_vertical_hi                                               ; $00A2C3 |/
+   JSR _draw_random_stars                                                      ; $00A2C5 | Draw a random starfield.
    DEC <r_transition_index                                                     ; $00A2C8 |\
    LDA <r_transition_index                                                     ; $00A2CA | | Decrement the transition index and loop until it wraps back to
    CMP #$FF.b                                                                  ; $00A2CC | | $FF.
    BNE -                                                                       ; $00A2CE |/
    RTS                                                                         ; $00A2D0

; _animate_destination_planet_approaching ($00:A2D1)
;
; Animate the second half of the interplanet travel animation, where the
; destination planet grows in the screen until it is very large and the screen
; fades out.
_animate_destination_planet_approaching:
    LDX #-104.w                                                                 ; $00A2D1 |\ Set the vertical scroll register to -104 (to center the planet).
    STX <r_scroll_bg1_vertical                                                  ; $00A2D4 |/
    LDA #$DF.b                                                                  ; $00A2D6 |\ Set the initial transition index to $DF.
    STA <r_transition_index                                                     ; $00A2D8 |/
-   JSR _wait_for_nmi_complete                                                  ; $00A2DA | Wait for the next frame.
    STZ reg_cpu_hdmaen                                                          ; $00A2DD | Disable HDMA.
    LDA <r_transition_index                                                     ; $00A2E0 |\
    STA <r_set_mode_7_transform_arg_scale.lo                                    ; $00A2E2 | | Set the mode 7 scaling parameter to double the transition index,
    STZ <r_set_mode_7_transform_arg_scale.hi                                    ; $00A2E4 | | which will cause it to go down by 2 every frame, slowly having
    ASL <r_set_mode_7_transform_arg_scale.lo                                    ; $00A2E6 | | the planet fill the screen.
    ROL <r_set_mode_7_transform_arg_scale.hi                                    ; $00A2E8 | |
    JSR _set_mode_7_transform                                                   ; $00A2EA |/
    JSR _set_ppu_brightness                                                     ; $00A2ED | Set the appropriate PPU brightness (dims as index approaches zero).
    JSR _draw_random_stars                                                      ; $00A2F0 | Draw a random starfield.
    DEC <r_transition_index                                                     ; $00A2F3 |\
    LDA <r_transition_index                                                     ; $00A2F5 | | Decrement the transition index until we've processed the value of
    CMP #$FF.b                                                                  ; $00A2F7 | | zero.
    BNE -                                                                       ; $00A2F9 |/
    RTS                                                                         ; $00A2FB

; _set_big_whale_high_altitude ($00:A2FC)
;
; Sets the Big Whale's altitude based on the current value of $0679. Only valid
; for values from 1 to 40.
_set_big_whale_high_altitude:
    LDA #bank14._sizeof_big_whale_altitude_data.b                               ; $00A2FC |\
    SEC                                                                         ; $00A2FE | | Determine the index by subtracting the transition index from the
    SBC <r_transition_index                                                     ; $00A2FF | | size of the data.
    TAX                                                                         ; $00A301 |/
    LDA bank14.big_whale_altitude_data.l,X                                      ; $00A302 |\ Sets the Big Whale's new altitude based on that index.
    STA <r_big_whale_altitude                                                   ; $00A306 |/
    RTS                                                                         ; $00A308

; _set_ppu_brightness ($00:A309)
;
; Based on the value of $0679, sets the PPU's brightness. Accepts values from 0
; to 15.
_set_ppu_brightness:
    LDA <r_transition_index                                                     ; $00A309 |\
    CMP #$10.b                                                                  ; $00A30B | | If the transition index is less than 16, set the display
    BCS +                                                                       ; $00A30D | | brightness to that value.
    STA reg_ppu_inidisp                                                         ; $00A30F |/
+   RTS                                                                         ; $00A312

; _draw_moon_sprite ($00:A313)
;
; Draws the small moon sprite to the center of the screen.
_draw_moon_sprite:
    LDX #$0000.w                                                                ; $00A313 |\
-   LDA bank14.moon_sprite_oam_data.l,X                                         ; $00A316 | | Copy the 16 bytes from ROM to the OAM staging area.
    STA r_oam.w,X                                                               ; $00A31A | |
    INX                                                                         ; $00A31D | |
    CPX #bank14._sizeof_moon_sprite_oam_data.w                                  ; $00A31E | |
    BNE -                                                                       ; $00A321 |/
    RTS                                                                         ; $00A323

; _draw_earth_sprite ($00:A324)
;
; Draws the small earth sprite to the center of the screen.
_draw_earth_sprite:
    LDX #$0000.w                                                                ; $00A324 |\
-   LDA bank14.earth_sprite_oam_data.l,X                                        ; $00A327 | | Copy the 16 bytes from ROM to the OAM staging area.
    STA r_oam.w,X                                                               ; $00A32B | |
    INX                                                                         ; $00A32E | |
    CPX #bank14._sizeof_earth_sprite_oam_data.w                                 ; $00A32F | |
    BNE -                                                                       ; $00A332 |/
    RTS                                                                         ; $00A334

; _load_earth_moon_transition_sprites ($00:A335)
;
; Loads the sprites and palettes used during the earth/moon transition on the
; Big Whale.
_load_earth_moon_transition_sprites:
    LDX #$4000.w                                                                ; $00A335 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00A338 | | Use a DMA transfer to transfer the data for the earth and moon
    LDX #bank1E._sizeof_sprite_earth_moon_data.w                                ; $00A33A | | sprites from ROM to the OAM name table.
    STX <r_start_vram_dma_arg_bytes                                             ; $00A33D | |
    LDA #:bank1E.sprite_earth_moon_data.b                                       ; $00A33F | |
    STA <r_start_vram_dma_arg_bank                                              ; $00A341 | |
    LDX #bank1E.sprite_earth_moon_data.w                                        ; $00A343 | |
    STX <r_start_vram_dma_arg_address                                           ; $00A346 | |
    JSL bank15.start_vram_dma                                                   ; $00A348 |/
    LDX #$0000.w                                                                ; $00A34C |\
-   LDA bank1E.earth_moon_transition_palette_data.l,X                           ; $00A34F | | Copy the palette data used for the earth/moon transition to
    STA r_cgram_data.1.w,X                                                      ; $00A353 | | palettes 1 (for the backgrounds) and 9 (for the sprites).
    STA r_cgram_data.9.w,X                                                      ; $00A356 | |
    INX                                                                         ; $00A359 | |
    CPX #bank1E._sizeof_earth_moon_transition_palette_data.w                    ; $00A35A | |
    BNE -                                                                       ; $00A35D |/
    RTS                                                                         ; $00A35F

; _draw_random_stars ($00:A360)
;
; In theory, draws random stars by configuring all but the first four OAM
; entries as the star tile with random colors and positions. The limitations of
; the game's RNG limit the effectiveness.
_draw_random_stars:
    LDY #$0010.w                                                                ; $00A360 |\ Initialize the indexes.
    LDX #$0000.w                                                                ; $00A363 |/
-   JSR _get_field_rng                                                          ; $00A366 |\ Set the X coordinate to a random value.
    STA r_oam.1.x,Y                                                             ; $00A369 |/
    JSR _get_field_rng                                                          ; $00A36C |\ Set the Y coordinate to a random value.
    STA r_oam.1.y,Y                                                             ; $00A36F |/
    LDA #$2F.b                                                                  ; $00A372 |\
    STA r_oam.1.tile,Y                                                          ; $00A374 | | Set the tile number to $12F (a tile with a single pixel at the top
    JSR _get_field_rng                                                          ; $00A377 | | left). Set the palette to a random value from 0 to 7.
    AND #%00000111.b                                                            ; $00A37A | |
    ASL A                                                                       ; $00A37C | |
    ORA #%00000001.b                                                            ; $00A37D | |
    STA r_oam.1.flags,Y                                                         ; $00A37F |/
    INX                                                                         ; $00A382 |\
    INX                                                                         ; $00A383 | | Increment the indexes and loop until the OAM is full.
    INY                                                                         ; $00A384 | |
    INY                                                                         ; $00A385 | |
    INY                                                                         ; $00A386 | |
    INY                                                                         ; $00A387 | |
    CPY #$0200.w                                                                ; $00A388 | |
    BNE -                                                                       ; $00A38B |/
    RTS                                                                         ; $00A38D

; _load_earth_moon_transition_background ($00:A38E)
;
; Loads the background used during the earth/moon transition. Two 32x32 areas
; are set in VRAM, one with the earth and the other with the moon.
_load_earth_moon_transition_background:
    LDA #$70.b                                                                  ; $00A38E |\ Set the base tile number to $70.
    STA <r_load_earth_moon_transition_background_value                          ; $00A390 |/
    STZ reg_ppu_vmainc                                                          ; $00A392 | Set the VRAM address to increment 1x1, low byte.
    LDX #$0000.w                                                                ; $00A395 |\ Set the initial VRAM address to zero.
    STX <r_load_earth_moon_transition_background_index                          ; $00A398 |/
--  LDX <r_load_earth_moon_transition_background_index                          ; $00A39A |\ Set the VRAM address for the next row of tiles.
    STX reg_ppu_vmadd                                                           ; $00A39C |/
-   LDA <r_load_earth_moon_transition_background_value                          ; $00A39F |\
    STA reg_ppu_vmdatal_write                                                   ; $00A3A1 | | For each row of tiles, increment the value, write it to the next
    INC <r_load_earth_moon_transition_background_value                          ; $00A3A4 | | VRAM address, and then move on once this has been done four times.
    LDA <r_load_earth_moon_transition_background_value                          ; $00A3A6 | |
    AND #%00000011.b                                                            ; $00A3A8 | |
    BNE -                                                                       ; $00A3AA |/
    LDA <r_load_earth_moon_transition_background_index_lo                       ; $00A3AC |\
    CLC                                                                         ; $00A3AE | | To prepare for the next row, add 128 to the VRAM address to get to
    ADC #128.b                                                                  ; $00A3AF | | the next row. Once four rows have been copied, move on.
    STA <r_load_earth_moon_transition_background_index_lo                       ; $00A3B1 | |
    LDA <r_load_earth_moon_transition_background_index_hi                       ; $00A3B3 | |
    ADC #$00.b                                                                  ; $00A3B5 | |
    STA <r_load_earth_moon_transition_background_index_hi                       ; $00A3B7 | |
    CMP #$02.b                                                                  ; $00A3B9 | |
    BNE --                                                                      ; $00A3BB |/
    LDA #$80.b                                                                  ; $00A3BD |\ Update the initial tile value to $80 for the next set of tiles.
    STA <r_load_earth_moon_transition_background_value                          ; $00A3BF |/
    STZ reg_ppu_vmainc                                                          ; $00A3C1 |\
    LDX #$0040.w                                                                ; $00A3C4 | | Repeat the above process to do the second set of tiles. This set
    STX <r_load_earth_moon_transition_background_index                          ; $00A3C7 | | is for the moon.
--  LDX <r_load_earth_moon_transition_background_index                          ; $00A3C9 | |
    STX reg_ppu_vmadd                                                           ; $00A3CB | |
-   LDA <r_load_earth_moon_transition_background_value                          ; $00A3CE | |
    STA reg_ppu_vmdatal_write                                                   ; $00A3D0 | |
    INC <r_load_earth_moon_transition_background_value                          ; $00A3D3 | |
    LDA <r_load_earth_moon_transition_background_value                          ; $00A3D5 | |
    AND #%00000011.b                                                            ; $00A3D7 | |
    BNE -                                                                       ; $00A3D9 | |
    LDA <r_load_earth_moon_transition_background_index_lo                       ; $00A3DB | |
    CLC                                                                         ; $00A3DD | |
    ADC #$80.b                                                                  ; $00A3DE | |
    STA <r_load_earth_moon_transition_background_index_lo                       ; $00A3E0 | |
    LDA <r_load_earth_moon_transition_background_index_hi                       ; $00A3E2 | |
    ADC #$00.b                                                                  ; $00A3E4 | |
    STA <r_load_earth_moon_transition_background_index_hi                       ; $00A3E6 | |
    CMP #$02.b                                                                  ; $00A3E8 | |
    BNE --                                                                      ; $00A3EA |/
    RTS                                                                         ; $00A3EC

; _land_enterprise ($00:A3ED)
;
; Executes a number of sequences related to the Enterprise, but primarily is the
; routine that lands the Enterprise. Additionally handles dispatching to the
; hooking and unhooking the hovercraft routines.
_land_enterprise:
    LDA r_hovercraft_hooked.w                                                   ; $00A3ED |\ If the hovercraft is currently hooked, branch to that handler.
    BNE @hovercraft_hooked                                                      ; $00A3F0 |/
    LDA #PLOT_FLAG_HOOK_INSTALLED.b                                             ; $00A3F2 |\
    JSR _get_plot_flag                                                          ; $00A3F4 | | If the hook is installed and the hovercraft coordinates match the
    CMP #$00.b                                                                  ; $00A3F7 | | current coordinates, execute the routine to hook the hovercraft.
    BNE +                                                                       ; $00A3F9 | | Afterward, return.
    JMP @land                                                                   ; $00A3FB | |
+   LDA r_enterprise_plane.w                                                    ; $00A3FE | |
    CMP r_hovercraft_plane.w                                                    ; $00A401 | |
    BNE @land                                                                   ; $00A404 | |
    LDX r_hovercraft_coordinates.w                                              ; $00A406 | |
    CPX r_current_coordinates.w                                                 ; $00A409 | |
    BNE @land                                                                   ; $00A40C | |
    JSR _hook_hovercraft                                                        ; $00A40E | |
    RTS                                                                         ; $00A411 |/
@hovercraft_hooked:
    LDA r_falcon_plane.w                                                        ; $00A412 |\
    CMP r_map_plane.w                                                           ; $00A415 | | Skip lowering the hovercraft if the Falcon is currently at the
    BNE +                                                                       ; $00A418 | | same coordinates.
    LDX r_current_coordinates.w                                                 ; $00A41A | |
    CPX r_falcon_coordinates.w                                                  ; $00A41D | |
    BEQ ++                                                                      ; $00A420 |/
+   LDA r_big_whale_plane.w                                                     ; $00A422 |\
    CMP r_map_plane.w                                                           ; $00A425 | | Also skip lowering the hovercraft if the Big Whale is at the same
    BNE +                                                                       ; $00A428 | | coordinates.
    LDX r_current_coordinates.w                                                 ; $00A42A | |
    CPX r_big_whale_coordinates.w                                               ; $00A42D | |
    BEQ ++                                                                      ; $00A430 |/
+   LDA <r_tile_properties_current.properties_1                                 ; $00A432 |\
    AND #TILE_PROPERTY_1_OUTDOOR_HOVERCRAFT.b                                   ; $00A434 | | Check if the current tile is appropriate for landing the
    BEQ ++                                                                      ; $00A436 | | hovercraft.
    JSR _unhook_hovercraft                                                      ; $00A438 |/
++  RTS                                                                         ; $00A43B
@land:
    LDA #$30.b                                                                  ; $00A43C |\
    STA <r_transition_index                                                     ; $00A43E | | Set the initial transition index to 48 and intialize other values.
    STZ <r_map_frame_counter                                                    ; $00A440 |/
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A442 | Wait for the next frame divisible by four.
    LDA <r_transition_index                                                     ; $00A445 |\
    CMP #$21.b                                                                  ; $00A447 | | If the transition index is >= 33, simply lower the Enterprise.
    BCS @lower                                                                  ; $00A449 |/
    LDA <r_tile_properties_current.properties_2                                 ; $00A44B |\
    AND #TILE_PROPERTY_2_OUTDOOR_AIRSHIP_LAND.b                                 ; $00A44D | | If the tile is not appropriate for landing the Enterprise, raise
    BNE +                                                                       ; $00A44F | | the Enterprise back to altitude and return.
    JMP _raise_enterprise                                                       ; $00A451 |/
+   LDX r_hovercraft_coordinates.w                                              ; $00A454 |\
    CPX r_current_coordinates.w                                                 ; $00A457 | | If the hovercraft is at the current location, cancel the landing.
    BNE +                                                                       ; $00A45A | | BUG: This doesn't check the plane, so you can't land at these
    JMP _raise_enterprise                                                       ; $00A45C |/       coordinates in the underworld either.
+   LDA r_falcon_plane.w                                                        ; $00A45F |\
    CMP r_enterprise_plane.w                                                    ; $00A462 | | Cancel the landing if the Falcon is in the same location.
    BNE +                                                                       ; $00A465 | |
    LDX r_falcon_coordinates.w                                                  ; $00A467 | |
    CPX r_current_coordinates.w                                                 ; $00A46A | |
    BNE +                                                                       ; $00A46D | |
    JMP _raise_enterprise                                                       ; $00A46F | |
+   LDA r_big_whale_plane.w                                                     ; $00A472 |/
    CMP r_enterprise_plane.w                                                    ; $00A475 |\
    BNE +                                                                       ; $00A478 | | Cancel the landing if the Big Whale is at the same location.
    LDX r_big_whale_coordinates.w                                               ; $00A47A | |
    CPX r_current_coordinates.w                                                 ; $00A47D | |
    BNE +                                                                       ; $00A480 | |
    JMP _raise_enterprise                                                       ; $00A482 |/
+   LDA <r_transition_index                                                     ; $00A485 |\
    LSR A                                                                       ; $00A487 | | Set the airship animation speed to half the transition index,
    STA r_airship_animation_speed.w                                             ; $00A488 | | decrement the index twice, and continue until the index is zero.
    DEC <r_transition_index                                                     ; $00A48B | |
    DEC <r_transition_index                                                     ; $00A48D | |
    BNE -                                                                       ; $00A48F |/
    STZ r_vehicle.w                                                             ; $00A491 | Set the vehicle to none.
    STZ <r_movement_speed                                                       ; $00A494 | Set the movement speed to the lowest.
    STZ <r_movement_frame_counter                                               ; $00A496 | Zero out the movement frame counter.
    LDA #DIRECTION_DOWN.b                                                       ; $00A498 |\ Set the direction to down.
    STA r_direction.w                                                           ; $00A49A |/
    LDX r_current_coordinates.w                                                 ; $00A49D |\ Set the Enterprise coordinates to the current coordinates.
    STX r_enterprise_coordinates.w                                              ; $00A4A0 |/
    LDA r_map_plane.w                                                           ; $00A4A3 |\ Set the Enterprise plane to the current plane.
    STA r_enterprise_plane.w                                                    ; $00A4A6 |/
    JSR _play_map_song                                                          ; $00A4A9 | Play the song associated with the current map.
    INC r_saving_enabled.w                                                      ; $00A4AC | Enable saving.
    RTS                                                                         ; $00A4AF
@lower:
    DEC <r_enterprise_altitude                                                  ; $00A4B0 | Decrease the Enterprise altitude.
    LDA <r_enterprise_altitude                                                  ; $00A4B2 |\
    CLC                                                                         ; $00A4B4 | | Set the zoom level to the altitude plus $10.
    ADC #$10.b                                                                  ; $00A4B5 | |
    STA <r_zoom_level                                                           ; $00A4B7 |/
    LDA <r_enterprise_altitude                                                  ; $00A4B9 |\ Set the appropriate zoom palettes.
    JSL bank15.set_zoom_palette                                                 ; $00A4BB |/
    DEC <r_transition_index                                                     ; $00A4BF |\ Decrement the transition index and loop.
    JMP -                                                                       ; $00A4C1 |/

; hook_height_data ($00:A4C4)
;
; The height (length) of the hook during each frame of the hook extension
; animation.
hook_height_data:
    .db 0                                                                       ; $00A4C4
    .db 1                                                                       ; $00A4C5
    .db 2                                                                       ; $00A4C6
    .db 3                                                                       ; $00A4C7
    .db 4                                                                       ; $00A4C8
    .db 5                                                                       ; $00A4C9
    .db 6                                                                       ; $00A4CA
    .db 7                                                                       ; $00A4CB
    .db 7                                                                       ; $00A4CC
    .db 6                                                                       ; $00A4CD
    .db 5                                                                       ; $00A4CE
    .db 4                                                                       ; $00A4CF
    .db 3                                                                       ; $00A4D0
    .db 2                                                                       ; $00A4D1
    .db 1                                                                       ; $00A4D2
    .db 0                                                                       ; $00A4D3

; _unhook_hovercraft ($00:A4D4)
;
; Executes the sequence to unhook the hovercraft from the Enterprise. Does not
; have any safety checks, and will happily lower the hovercraft anywhere.
_unhook_hovercraft:
    LDA #DIRECTION_LEFT.b                                                       ; $00A4D4 |\ Set the current direction to left.
    STA r_direction.w                                                           ; $00A4D6 |/
    STZ <r_map_frame_counter                                                    ; $00A4D9 | Zero out the map frame counter.
    STZ <r_transition_index                                                     ; $00A4DB | Initialize the transition index.
-   JSR _init_oam                                                               ; $00A4DD | Re-initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $00A4E0 | Draw the outdoor field sprites.
    LDA <r_transition_index                                                     ; $00A4E3 |\
    LSR A                                                                       ; $00A4E5 | | Update the hook height based on the transition index. The height
    LSR A                                                                       ; $00A4E6 | | updates every four frames.
    TAX                                                                         ; $00A4E7 | |
    LDA hook_height_data.w,X                                                    ; $00A4E8 | |
    STA r_hook_height.w                                                         ; $00A4EB |/
    JSR _do_tile_animations                                                     ; $00A4EE | Do any tile animations.
    INC <r_transition_index                                                     ; $00A4F1 |\
    LDA <r_transition_index                                                     ; $00A4F3 | | Repeat until the first 32 frames have passed.
    CMP #$20.b                                                                  ; $00A4F5 | |
    BNE +                                                                       ; $00A4F7 |/
    STZ r_hovercraft_hooked.w                                                   ; $00A4F9 | Set the hovercraft as not hooked.
    LDA r_map_plane.w                                                           ; $00A4FC |\ Set the hovercraft plane to the current plane.
    STA r_hovercraft_plane.w                                                    ; $00A4FF |/
    LDX r_current_coordinates.w                                                 ; $00A502 |\ Set the hovercraft coordinates to the current coordinates.
    STX r_hovercraft_coordinates.w                                              ; $00A505 |/
+   LDA <r_transition_index                                                     ; $00A508 |\
    CMP #$40.b                                                                  ; $00A50A | | Repeat until 64 frames have passed in total.
    BNE -                                                                       ; $00A50C |/
    RTS                                                                         ; $00A50E

; _hook_hovercraft ($00:A50F)
;
; Executes the sequence of hooking the hovercraft to the Enterprise.
_hook_hovercraft:
    LDA #DIRECTION_LEFT.b                                                       ; $00A50F |\ Set the direction to left.
    STA r_direction.w                                                           ; $00A511 |/
    STZ <r_map_frame_counter                                                    ; $00A514 | Zero out the map frame counter.
    STZ <r_transition_index                                                     ; $00A516 | Zero out the transition index.
-   JSR _init_oam                                                               ; $00A518 | Re-initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $00A51B | Draw outdoor field sprites.
    LDA <r_transition_index                                                     ; $00A51E |\
    LSR A                                                                       ; $00A520 | | Determine the new hook height by indexing the data. The height
    LSR A                                                                       ; $00A521 | | changes every 4 frames.
    TAX                                                                         ; $00A522 | |
    LDA hook_height_data.w,X                                                    ; $00A523 | |
    STA r_hook_height.w                                                         ; $00A526 |/
    JSR _do_tile_animations                                                     ; $00A529 | Handle any tile animations.
    INC <r_transition_index                                                     ; $00A52C |\
    LDA <r_transition_index                                                     ; $00A52E | | Repeat for 32 frames.
    CMP #$20.b                                                                  ; $00A530 | |
    BNE +                                                                       ; $00A532 |/
    INC r_hovercraft_hooked.w                                                   ; $00A534 | Set the hovercraft as being hooked.
+   CMP #$40.b                                                                  ; $00A537 |\ Continue another 32 frames until the hook returns.
    BNE -                                                                       ; $00A539 |/
    RTS                                                                         ; $00A53B

; _land_falcon ($00:A53C)
;
; Executes the sequence necessary to land the Falcon. Will reject the landing if
; the necessary conditions aren't met.
_land_falcon:
    LDA #$30.b                                                                  ; $00A53C |\
    STA <r_transition_index                                                     ; $00A53E | | Initialize variables.
    STZ <r_map_frame_counter                                                    ; $00A540 |/
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A542 | Wait four frames.
    LDA <r_transition_index                                                     ; $00A545 |\
    CMP #$21.b                                                                  ; $00A547 | | If the transition index is >= 33, simply lower the Falcon.
    BCS ++                                                                      ; $00A549 |/
    LDA <r_tile_properties_current.properties_2                                 ; $00A54B |\
    AND #TILE_PROPERTY_2_OUTDOOR_AIRSHIP_LAND.b                                 ; $00A54D | | If the current tile isn't suitable for landing, cancel the
    BNE +                                                                       ; $00A54F | | landing.
    JMP _raise_falcon                                                           ; $00A551 |/
+   LDX r_hovercraft_coordinates.w                                              ; $00A554 |\
    CPX r_current_coordinates.w                                                 ; $00A557 | | Cancel the landing if the hovercraft is parked in the same
    BNE +                                                                       ; $00A55A | | location. BUG: Same bug as with the Enterprise routine.
    JMP _raise_falcon                                                           ; $00A55C |/
+   LDA r_enterprise_plane.w                                                    ; $00A55F |\
    CMP r_falcon_plane.w                                                        ; $00A562 | | Cancel the landing if the Enterprise is parked in the same spot.
    BNE +                                                                       ; $00A565 | |
    LDX r_enterprise_coordinates.w                                              ; $00A567 | |
    CPX r_current_coordinates.w                                                 ; $00A56A | |
    BNE +                                                                       ; $00A56D | |
    JMP _raise_falcon                                                           ; $00A56F |/
+   LDA r_big_whale_plane.w                                                     ; $00A572 |\
    CMP r_falcon_plane.w                                                        ; $00A575 | | Cancel the landing if the Big Whale is parked in the same spot.
    BNE +                                                                       ; $00A578 | |
    LDX r_big_whale_coordinates.w                                               ; $00A57A | |
    CPX r_current_coordinates.w                                                 ; $00A57D | |
    BNE +                                                                       ; $00A580 | |
    JMP _raise_falcon                                                           ; $00A582 |/
+   LDA <r_transition_index                                                     ; $00A585 |\
    LSR A                                                                       ; $00A587 | | Loop until the transition index is zero, setting the airship
    STA r_airship_animation_speed.w                                             ; $00A588 | | animation speed based on half the index.
    DEC <r_transition_index                                                     ; $00A58B | |
    DEC <r_transition_index                                                     ; $00A58D | |
    BNE -                                                                       ; $00A58F |/
    STZ r_vehicle.w                                                             ; $00A591 | Set the current vehicle to none.
    STZ <r_movement_speed                                                       ; $00A594 | Set the movement speed to lowest.
    STZ <r_movement_frame_counter                                               ; $00A596 | Zero out the movement frame counter.
    LDA #DIRECTION_DOWN.b                                                       ; $00A598 |\ Set the current direction to down.
    STA r_direction.w                                                           ; $00A59A |/
    LDX r_current_coordinates.w                                                 ; $00A59D |\ Transfer the current coordinates to the Falcon coordinates.
    STX r_falcon_coordinates.w                                                  ; $00A5A0 |/
    LDA r_map_plane.w                                                           ; $00A5A3 |\ Transfer the current plane to the Falcon plane.
    STA r_falcon_plane.w                                                        ; $00A5A6 |/
    JSR _play_map_song                                                          ; $00A5A9 | Play the song associated with the current map.
    INC r_saving_enabled.w                                                      ; $00A5AC | Enable saving.
    RTS                                                                         ; $00A5AF |
++  DEC <r_falcon_altitude                                                      ; $00A5B0 |\
    LDA <r_falcon_altitude                                                      ; $00A5B2 | | If the transition index was 33 or greater, lower the altitude of
    CLC                                                                         ; $00A5B4 | | the Falcon until it reaches the ground, making sure to set the
    ADC #$10.b                                                                  ; $00A5B5 | | zoom level and zoom palette as we go.
    STA <r_zoom_level                                                           ; $00A5B7 | |
    LDA <r_falcon_altitude                                                      ; $00A5B9 | |
    JSL bank15.set_zoom_palette                                                 ; $00A5BB | |
    DEC <r_transition_index                                                     ; $00A5BF | |
    JMP -                                                                       ; $00A5C1 |/

; _land_big_whale ($00:A5C4)
;
; Executes the sequence necessary to land the Big Whale.
_land_big_whale:
    LDA #$2F.b                                                                  ; $00A5C4 |\ Set the initial transition index to $2F.
    STA <r_transition_index                                                     ; $00A5C6 |/
    STZ <r_map_frame_counter                                                    ; $00A5C8 | Set the map frame counter to zero.
-   JSR _wait_for_frame_divisible_by_four                                       ; $00A5CA | Wait for a frame divisible by four.
    LDA <r_transition_index                                                     ; $00A5CD |\
    CMP #$20.b                                                                  ; $00A5CF | | If the transition index is >= $20, simply lower the Big Whale.
    BCS @lower                                                                  ; $00A5D1 |/
    LDA <r_tile_properties_current.properties_2                                 ; $00A5D3 |\
    AND #TILE_PROPERTY_2_OUTDOOR_AIRSHIP_LAND.b                                 ; $00A5D5 | | If the tile isn't suitable for Big Whale landing, cancel the
    BNE +                                                                       ; $00A5D7 | | landing.
    JMP _raise_big_whale                                                        ; $00A5D9 |/
+   LDX r_hovercraft_coordinates.w                                              ; $00A5DC |\
    CPX r_current_coordinates.w                                                 ; $00A5DF | | If the hovercraft is in the way, cancel the landing.
    BNE +                                                                       ; $00A5E2 | | BUG: Same bug as with the Enterprise and Falcon.
    JMP _raise_big_whale                                                        ; $00A5E4 |/
+   LDA r_enterprise_plane.w                                                    ; $00A5E7 |\
    CMP r_big_whale_plane.w                                                     ; $00A5EA | | If the Enterprise is in the way, cancel the landing.
    BNE +                                                                       ; $00A5ED | |
    LDX r_enterprise_coordinates.w                                              ; $00A5EF | |
    CPX r_current_coordinates.w                                                 ; $00A5F2 | |
    BNE +                                                                       ; $00A5F5 | |
    JMP _raise_big_whale                                                        ; $00A5F7 |/
+   LDA r_falcon_plane.w                                                        ; $00A5FA |\
    CMP r_big_whale_plane.w                                                     ; $00A5FD | | If the Falcon is in the way, cancel the landing.
    BNE +                                                                       ; $00A600 | |
    LDX r_falcon_coordinates.w                                                  ; $00A602 | |
    CPX r_current_coordinates.w                                                 ; $00A605 | |
    BNE +                                                                       ; $00A608 | |
    JMP _raise_big_whale                                                        ; $00A60A |/
+   LDA <r_transition_index                                                     ; $00A60D |\
    LSR A                                                                       ; $00A60F | | Loop, decrementing the index until it reaches zero. Set the
    STA r_airship_animation_speed.w                                             ; $00A610 | | airship animation speed to the index divided by two.
    DEC <r_transition_index                                                     ; $00A613 | |
    BNE -                                                                       ; $00A615 |/
    STZ r_vehicle.w                                                             ; $00A617 | Set the vehicle to no vehicle.
    STZ <r_movement_speed                                                       ; $00A61A | Set the movement speed to lowest.
    STZ <r_movement_frame_counter                                               ; $00A61C | Zero the movement frame counter.
    LDA #DIRECTION_DOWN.b                                                       ; $00A61E |\ Set the direction to down.
    STA r_direction.w                                                           ; $00A620 |/
    LDA r_map_area.w                                                            ; $00A623 |\ Set the Big Whale plane.
    STA r_big_whale_plane.w                                                     ; $00A626 |/
    LDX r_current_coordinates.w                                                 ; $00A629 |\ Set the Big Whale coordinates to the current coordinates.
    STX r_big_whale_coordinates.w                                               ; $00A62C |/
    LDA <r_cutscene_active                                                      ; $00A62F |\
    BNE +                                                                       ; $00A631 | | If a cutscene is not currently active, execute the event to
    LDA #CONDITIONAL_EVENT_BIG_WHALE_CONSOLE.b                                  ; $00A633 | | switch to the Big Whale, with the player at the console.
    JSR _execute_conditional_event                                              ; $00A635 |/
+   INC r_saving_enabled.w                                                      ; $00A638 | Enable saving.
    RTS                                                                         ; $00A63B
@lower:
    DEC <r_big_whale_altitude                                                   ; $00A63C |\ Decrease the altitude by two.
    DEC <r_big_whale_altitude                                                   ; $00A63E |/
    LDA <r_big_whale_altitude                                                   ; $00A640 |\
    CLC                                                                         ; $00A642 | | Set the zoom level and zoom palette. Return to the start of the
    ADC #$10.b                                                                  ; $00A643 | | loop after decrementing the index.
    STA <r_zoom_level                                                           ; $00A645 | |
    LDA <r_big_whale_altitude                                                   ; $00A647 | |
    LSR A                                                                       ; $00A649 | |
    JSL bank15.set_zoom_palette                                                 ; $00A64A | |
    DEC <r_transition_index                                                     ; $00A64E | |
    JMP -                                                                       ; $00A650 |/

; _do_outdoor_movement ($00:A653)
;
; Based on the set movement direction, adjusts the scroll register values and
; current coordinates to apply the actual movement for this frame.
_do_outdoor_movement:
    LDA <r_movement_direction                                                   ; $00A653 |\
    BNE +                                                                       ; $00A655 | | This function only applies if there is a movement direction.
    JMP @done                                                                   ; $00A657 |/
+   LDA <r_damaged_character_count                                              ; $00A65A |\
    BEQ +                                                                       ; $00A65C | | If there is at least one character affected by damage tiles,
    LDA <r_movement_frame_counter                                               ; $00A65E | | enable the flash palette if the movement frame counter mod 16
    AND #%00001000.b                                                            ; $00A660 | | has a value of 0 through 7.
    BNE +                                                                       ; $00A662 | |
    INC <r_enable_flash_palette                                                 ; $00A664 |/
+   INC <r_movement_frame_counter                                               ; $00A666 | Increment the movement frame counter.
    LDA <r_movement_speed                                                       ; $00A668 |\ Set the X register to the movement speed.
    TAX                                                                         ; $00A66A |/
    LDA <r_movement_direction                                                   ; $00A66B |\
    CMP #MOVEMENT_DIRECTION_UP.b                                                ; $00A66D | | The next block applies if the movement direction is up.
    BNE +                                                                       ; $00A66F |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $00A671 |\
    STA <r_do_outdoor_movement_tmp                                              ; $00A673 | | Update the scroll register by subtracting the correct number of
    SEC                                                                         ; $00A675 | | pixels. The final value is taken mod 2048.
    SBC movement_speed_pixels_per_frame_data.w,X                                ; $00A676 | |
    STA <r_scroll_bg1_vertical_lo                                               ; $00A679 | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00A67B | |
    SBC #0.b                                                                    ; $00A67D | |
    AND #%00000111.b                                                            ; $00A67F | |
    STA <r_scroll_bg1_vertical_hi                                               ; $00A681 |/
    LDA <r_do_outdoor_movement_tmp                                              ; $00A683 |\
    AND #%00001111.b                                                            ; $00A685 | | The original value of the scroll register mod 16 is then also
    SEC                                                                         ; $00A687 | | subtracted from to determine if the boundary between coordinates
    SBC movement_speed_pixels_per_frame_data.w,X                                ; $00A688 | | was crossed, and if so, the Y coordinate is decremented, and
    BCS @done_proxy                                                             ; $00A68B | | then a mask is applied depending on the current map area to
    LDA r_map_area_outdoor.w                                                    ; $00A68D | | keep it in the proper range.
    TAX                                                                         ; $00A690 | |
    LDA r_current_coordinates.y.w                                               ; $00A691 | |
    DEC A                                                                       ; $00A694 | |
    AND map_area_coordinate_mask_data.w,X                                       ; $00A695 | |
    STA r_current_coordinates.y.w                                               ; $00A698 | |
    JMP @done                                                                   ; $00A69B |/
+   CMP #MOVEMENT_DIRECTION_RIGHT.b                                             ; $00A69E |\
    BNE +                                                                       ; $00A6A0 | | This version applies in case of moving right. It operates on the
    LDA <r_scroll_bg1_horizontal_lo                                             ; $00A6A2 | | horizontal scroll register value and increments the X coordinate
    CLC                                                                         ; $00A6A4 | | if the scroll register mod 16 is equal to zero.
    ADC movement_speed_pixels_per_frame_data.w,X                                ; $00A6A5 | |
    STA <r_scroll_bg1_horizontal_lo                                             ; $00A6A8 | |
    LDA <r_scroll_bg1_horizontal_hi                                             ; $00A6AA | |
    ADC #0.b                                                                    ; $00A6AC | |
    AND #%00000111.b                                                            ; $00A6AE | |
    STA <r_scroll_bg1_horizontal_hi                                             ; $00A6B0 | |
    LDA <r_scroll_bg1_horizontal_lo                                             ; $00A6B2 | |
    AND #%00001111.b                                                            ; $00A6B4 | |
    BNE @done                                                                   ; $00A6B6 | |
    LDA r_map_area_outdoor.w                                                    ; $00A6B8 | |
    TAX                                                                         ; $00A6BB | |
    LDA r_current_coordinates.x.w                                               ; $00A6BC | |
    INC A                                                                       ; $00A6BF | |
    AND map_area_coordinate_mask_data.w,X                                       ; $00A6C0 | |
    STA r_current_coordinates.x.w                                               ; $00A6C3 |/
@done_proxy:
    JMP @done                                                                   ; $00A6C6 |\
+   CMP #MOVEMENT_DIRECTION_DOWN.b                                              ; $00A6C9 | | Handle moving down.
    BNE +                                                                       ; $00A6CB | |
    LDA <r_scroll_bg1_vertical_lo                                               ; $00A6CD | |
    CLC                                                                         ; $00A6CF | |
    ADC movement_speed_pixels_per_frame_data.w,X                                ; $00A6D0 | |
    STA <r_scroll_bg1_vertical_lo                                               ; $00A6D3 | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00A6D5 | |
    ADC #0.b                                                                    ; $00A6D7 | |
    AND #%00000111.b                                                            ; $00A6D9 | |
    STA <r_scroll_bg1_vertical_hi                                               ; $00A6DB | |
    LDA <r_scroll_bg1_vertical_lo                                               ; $00A6DD | |
    AND #%00001111.b                                                            ; $00A6DF | |
    BNE @done                                                                   ; $00A6E1 | |
    LDA r_map_area_outdoor.w                                                    ; $00A6E3 | |
    TAX                                                                         ; $00A6E6 | |
    LDA r_current_coordinates.y.w                                               ; $00A6E7 | |
    INC A                                                                       ; $00A6EA | |
    AND map_area_coordinate_mask_data.w,X                                       ; $00A6EB | |
    STA r_current_coordinates.y.w                                               ; $00A6EE | |
    JMP @done                                                                   ; $00A6F1 |/
+   CMP #MOVEMENT_DIRECTION_LEFT.b                                              ; $00A6F4 |\
    BNE @done                                                                   ; $00A6F6 | | Handle moving left.
    LDA <r_scroll_bg1_horizontal_lo                                             ; $00A6F8 | |
    STA <r_do_outdoor_movement_tmp                                              ; $00A6FA | |
    SEC                                                                         ; $00A6FC | |
    SBC movement_speed_pixels_per_frame_data.w,X                                ; $00A6FD | |
    STA <r_scroll_bg1_horizontal_lo                                             ; $00A700 | |
    LDA <r_scroll_bg1_horizontal_hi                                             ; $00A702 | |
    SBC #0.b                                                                    ; $00A704 | |
    AND #%00000111.b                                                            ; $00A706 | |
    STA <r_scroll_bg1_horizontal_hi                                             ; $00A708 | |
    LDA <r_do_outdoor_movement_tmp                                              ; $00A70A | |
    AND #%00001111.b                                                            ; $00A70C | |
    SEC                                                                         ; $00A70E | |
    SBC movement_speed_pixels_per_frame_data.w,X                                ; $00A70F | |
    BCS @done                                                                   ; $00A712 | |
    LDA r_map_area_outdoor.w                                                    ; $00A714 | |
    TAX                                                                         ; $00A717 | |
    LDA r_current_coordinates.x.w                                               ; $00A718 | |
    DEC A                                                                       ; $00A71B | |
    AND map_area_coordinate_mask_data.w,X                                       ; $00A71C | |
    STA r_current_coordinates.x.w                                               ; $00A71F |/
@done:
    RTS                                                                         ; $00A722

; _calculate_dungeon_movement_direction ($00:A723)
;
; Based on the joypad and various state variables, determines the movement
; direction, handles poison damage and damage tiles, and loads any new rows of
; tiles as necessary.
_calculate_dungeon_movement_direction:
    LDA <r_player_movement_calculation_enabled                                  ; $00A723 |\
    BNE +                                                                       ; $00A725 | | Only execute this if player movement calculation is enabled.
    JMP @done                                                                   ; $00A727 |/
+   STZ <r_enable_flash_palette                                                 ; $00A72A | Unset any use of the flash palette.
    JSR _update_current_tile_properties                                         ; $00A72C | Update the tile properties for the current and adjacent tiles.
    LDA <r_cutscene_active                                                      ; $00A72F |\
    BEQ +                                                                       ; $00A731 | | If a cutscene is active, replace the pressed joypad variables with
    LDA <r_joypad_cutscene_lo                                                   ; $00A733 | | the cutscene joypad variables.
    STA <r_joypad_pressed_lo                                                    ; $00A735 | |
    LDA <r_joypad_cutscene_hi                                                   ; $00A737 | |
    STA <r_joypad_pressed_hi                                                    ; $00A739 |/
+   LDA <r_tile_properties_current.properties_1                                 ; $00A73B |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A73D | | If the current tile is not a bridge, update the current map layer
    BNE +                                                                       ; $00A73F | | to the layers of the current tile.
    LDA <r_tile_properties_current.properties_1                                 ; $00A741 | |
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $00A743 | |
    STA <r_current_map_layer                                                    ; $00A745 |/
+   JSR _clear_player_sprite_position                                           ; $00A747 | Clear the player sprite position if appropriate.
    LDA <r_tile_properties_current.properties_1                                 ; $00A74A |\
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $00A74C | | Set a special version of our current layer with the bridge bit set
    CLC                                                                         ; $00A74E | | which is used for certain operations.
    ADC #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A74F | |
    STA <r_current_map_layer_bridge                                             ; $00A751 |/
    LDA <r_joypad_pressed_hi                                                    ; $00A753 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $00A755 | | If right is pressed on the joypad (or faked), set the movement
    BEQ ++                                                                      ; $00A757 | | direction to right and check if the direction is blocked. If not,
    LDA <r_disable_direction_change                                             ; $00A759 | | branch accordingly. Fall through if it is. If direction changing
    BNE +                                                                       ; $00A75B | | is not disabled, also change the regular direction.
    LDA #DIRECTION_RIGHT.b                                                      ; $00A75D | |
    STA r_direction.w                                                           ; $00A75F | |
+   LDA #MOVEMENT_DIRECTION_RIGHT.b                                             ; $00A762 | |
    STA r_facing_movement_direction.w                                           ; $00A764 | |
    JSR _check_direction_blocked                                                ; $00A767 | |
    CMP #0.b                                                                    ; $00A76A | |
    BEQ @not_blocked                                                            ; $00A76C |/
++  LDA <r_joypad_pressed_hi                                                    ; $00A76E |\
    AND #JOYPAD_H_LEFT.b                                                        ; $00A770 | | Repeat the above check, except with left instead of right.
    BEQ ++                                                                      ; $00A772 | |
    LDA <r_disable_direction_change                                             ; $00A774 | |
    BNE +                                                                       ; $00A776 | |
    LDA #DIRECTION_LEFT.b                                                       ; $00A778 | |
    STA r_direction.w                                                           ; $00A77A | |
+   LDA #MOVEMENT_DIRECTION_LEFT.b                                              ; $00A77D | |
    STA r_facing_movement_direction.w                                           ; $00A77F | |
    JSR _check_direction_blocked                                                ; $00A782 | |
    CMP #0.b                                                                    ; $00A785 | |
    BEQ @not_blocked                                                            ; $00A787 |/
++  LDA <r_joypad_pressed_hi                                                    ; $00A789 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $00A78B | | Repeat again with down.
    BEQ ++                                                                      ; $00A78D | |
    LDA <r_disable_direction_change                                             ; $00A78F | |
    BNE +                                                                       ; $00A791 | |
    LDA #DIRECTION_DOWN.b                                                       ; $00A793 | |
    STA r_direction.w                                                           ; $00A795 | |
+   LDA #MOVEMENT_DIRECTION_DOWN.b                                              ; $00A798 | |
    STA r_facing_movement_direction.w                                           ; $00A79A | |
    JSR _check_direction_blocked                                                ; $00A79D | |
    CMP #0.b                                                                    ; $00A7A0 | |
    BEQ @not_blocked                                                            ; $00A7A2 |/
++  LDA <r_joypad_pressed_hi                                                    ; $00A7A4 |\
    AND #JOYPAD_H_UP.b                                                          ; $00A7A6 | | Repeat again with up.
    BEQ ++                                                                      ; $00A7A8 | |
    LDA <r_disable_direction_change                                             ; $00A7AA | |
    BNE +                                                                       ; $00A7AC | |
    LDA #DIRECTION_UP.b                                                         ; $00A7AE | |
    STA r_direction.w                                                           ; $00A7B0 | |
+   LDA #MOVEMENT_DIRECTION_UP.b                                                ; $00A7B3 | |
    STA r_facing_movement_direction.w                                           ; $00A7B5 | |
    JSR _check_direction_blocked                                                ; $00A7B8 | |
    CMP #0.b                                                                    ; $00A7BB | |
    BEQ @not_blocked                                                            ; $00A7BD |/
++  STZ <r_movement_direction                                                   ; $00A7BF |\
    JSR _set_player_sprite_position                                             ; $00A7C1 | | If no direction worked, set the movent direction to none and set
    LDA <r_cutscene_active                                                      ; $00A7C4 | | the player sprite position. If a cutscene is active, jump to a
    BNE +++                                                                     ; $00A7C6 | | later part of the code, otherwise we're done.
    JMP @done                                                                   ; $00A7C8 |/
@not_blocked:
    LDA <r_event_complete                                                       ; $00A7CB |\ If an event completed, branch to skip updating the sprite and
    BNE ++                                                                      ; $00A7CD |/ title.
    LDA r_facing_movement_direction.w                                           ; $00A7CF |\ Set the movement direction to the facing movement direction.
    STA <r_movement_direction                                                   ; $00A7D2 |/
    JSR _set_player_sprite_position                                             ; $00A7D4 | Set the new player sprite position.
    LDA <r_map_title_erase_pending                                              ; $00A7D7 |\
    BNE +                                                                       ; $00A7D9 | | Flag any map title for erasure.
    INC <r_map_title_erase_pending                                              ; $00A7DB |/
+   LDA <r_cutscene_active                                                      ; $00A7DD |\
    BEQ ++                                                                      ; $00A7DF | | It a cutscene is active, skip to nearly the end.
+++ JMP @skip_opening_doors                                                     ; $00A7E1 |/
++  LDA <r_movement_direction                                                   ; $00A7E4 |\
    LSR A                                                                       ; $00A7E6 | | Skip the door opening animation if moving left or right.
    BCC @skip_opening_doors                                                     ; $00A7E7 |/  BUG: It is possible to enter doors from the left or right.
    CMP #MOVEMENT_DIRECTION_UP.b >> 1                                           ; $00A7E9 |\ If the movement direction is down, skip to the next section.
    BNE ++                                                                      ; $00A7EB |/
    LDA r_tile_up.w                                                             ; $00A7ED |\
    CMP #$70.b                                                                  ; $00A7F0 | | Skip opening the doors unless the adjacent tile is $70 or $71.
    BEQ +                                                                       ; $00A7F2 | |
    CMP #$71.b                                                                  ; $00A7F4 | |
    BNE @skip_opening_doors                                                     ; $00A7F6 |/
+   LDA r_current_coordinates.y.w                                               ; $00A7F8 |\
    DEC A                                                                       ; $00A7FB | | Open the door on the tile above.
    STA <r_generic_arg_y_lo                                                     ; $00A7FC | |
    JSR _open_door                                                              ; $00A7FE | |
    JMP @skip_opening_doors                                                     ; $00A801 |/
++  LDA r_tile_down.w                                                           ; $00A804 |\
    CMP #$70.b                                                                  ; $00A807 | | Skip opening the doors if we're moving down and the tile is
    BEQ +                                                                       ; $00A809 | | anything but $70 or $71.
    CMP #$71.b                                                                  ; $00A80B | |
    BNE @skip_opening_doors                                                     ; $00A80D |/
+   LDA r_current_coordinates.y.w                                               ; $00A80F |\
    INC A                                                                       ; $00A812 | | Open the door on the tile below.
    STA <r_generic_arg_y_lo                                                     ; $00A813 | |
    JSR _open_door                                                              ; $00A815 |/
@skip_opening_doors:
    JSR _do_walking_poison                                                      ; $00A818 | Apply any poison effects.
    JSR _do_walking_damage                                                      ; $00A81B | Apply damage tile effects.
    JSR _update_dungeon_pending_tiles                                           ; $00A81E | Update the pending tiles based on the movement.
@done:
    RTS                                                                         ; $00A821

; _open_door ($00:A822)
;
; The target Y coordinate must already be set in $060E. The current X coordinate
; will be read from $1706, and the variables necessary to open the door at
; those coordinates will be set. The actual opening will be handled by another
; routine.
_open_door:
    LDA r_current_coordinates.x.w                                               ; $00A822 |\ Set the X coordinate parameter.
    STA <r_generic_arg_x_lo                                                     ; $00A825 |/
    JSR _calculate_dungeon_vram_address                                         ; $00A827 |\ Calculate the target VRAM address and set the tile change VRAM
    STX r_tile_change_vram_address.w                                            ; $00A82A |/ address.
    JSR _load_open_door_tiles                                                   ; $00A82D | Load the open door tiles.
    LDA #AUDIO_EFFECT_SMALL_DOOR.b                                              ; $00A830 |\ Play the door opening sound effect.
    JSR _play_sound_effect                                                      ; $00A832 |/
    LDA #$01.b                                                                  ; $00A835 |\ Flag that a tile change is pending.
    STA <r_tile_change_pending                                                  ; $00A837 |/
    RTS                                                                         ; $00A839

; _check_direction_blocked ($00:A83A)
;
; Intended to be called on dungeon maps, determines if the direction set in the
; facing movement direction is a valid direction to travel. Returns zero in the
; accumulator if the direction is not blocked, and one if it is. It will be
; blocked if blocked by an NPC or if the map layers do not match up
; appropriately. Roughly, you can pass if the current tile and adjacent tile
; share one of the layer bits or if one of the tiles is a bridge tile. There
; are additional nuances, however.
_check_direction_blocked:
    LDA <r_cutscene_active                                                      ; $00A83A |\
    BEQ +                                                                       ; $00A83C | | If a cutscene is active, return zero.
    LDA #$00.b                                                                  ; $00A83E | |
    RTS                                                                         ; $00A840 |/
+   JSR _get_adjacent_npc                                                       ; $00A841 | Get the placement number of the adjacent NPC, if any.
    CMP #$00.b                                                                  ; $00A844 |\ Return one if there is an adjacent NPC.
    BNE @done                                                                   ; $00A846 |/
    LDA r_facing_movement_direction.w                                           ; $00A848 |\ Calculate the tile properties index based on the facing movement
    ASL A                                                                       ; $00A84B |/ direction.
    TAY                                                                         ; $00A84C | Transfer it to the Y register.
    LDA <r_tile_properties_current.properties_1                                 ; $00A84D |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A84F | | If the current tile is not a bridge, branch to different code.
    BEQ +                                                                       ; $00A851 |/
    LDA r_tile_properties_current.properties_1,Y                                ; $00A853 |\
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $00A856 | | If the current tile is a bridge and the current layer matches the
    AND <r_current_map_layer                                                    ; $00A858 | | adjacent tile's layer, return zero.
    BEQ ++                                                                      ; $00A85A | |
    LDA #$00.b                                                                  ; $00A85C | |
    RTS                                                                         ; $00A85E |/
+   LDA r_tile_properties_current.properties_1,Y                                ; $00A85F |\
    AND <r_current_map_layer_bridge                                             ; $00A862 | | If the current tile is not a bridge and the adjacent tile is a
    BEQ @done                                                                   ; $00A864 | | a bridge or matches the current tile's layer, return zero.
    LDA #$00.b                                                                  ; $00A866 | |
    RTS                                                                         ; $00A868 |/
++  LDA r_tile_properties_current.properties_1,Y                                ; $00A869 |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A86C | | If the current tile is a bridge and the current layer does not
    BEQ @done                                                                   ; $00A86E | | match the adjacent tile's layer and the adjacent tile is a
    LDA #$00.b                                                                  ; $00A870 | | bridge, return zero.
    RTS                                                                         ; $00A872 |/
@done:
    LDA #$01.b                                                                  ; $00A873 | Otherwise, return one.
    RTS                                                                         ; $00A875

; _get_adjacent_npc ($00:A876)
;
; Using the current facing movement direction and map layer, determines if there
; is an NPC in the adjacent tile. If so, returns the NPC placement number plus
; $80 (from the sprite positioning array). Otherwise, returns zero.
_get_adjacent_npc:
    LDA r_facing_movement_direction.w                                           ; $00A876 |\
    TAY                                                                         ; $00A879 | | Calculate two indexes based on the facing movement direction: X
    ASL A                                                                       ; $00A87A | | for tile properties for the adjacent tile, and Y for coordinate
    TAX                                                                         ; $00A87B |/  deltas.
    LDA <r_tile_properties_current.properties_1,X                               ; $00A87C |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A87E | | Return zero if the adjacent tile is a bridge tile and the player
    BEQ +                                                                       ; $00A880 | | is not currently on layer 1. (So the player will pass under the
    LDA <r_current_map_layer                                                    ; $00A882 | | bridge.)
    CMP #TILE_PROPERTY_1_DUNGEON_LAYER_1.b                                      ; $00A884 | |
    BEQ +                                                                       ; $00A886 | |
    LDA #$00.b                                                                  ; $00A888 | |
    RTS                                                                         ; $00A88A |/
+   PHX                                                                         ; $00A88B | Save the value of the X register.
    LDA r_current_coordinates.x.w                                               ; $00A88C |\
    CLC                                                                         ; $00A88F | | Return zero if the adjacent tile is out of bounds horizontally.
    ADC x_coordinate_delta_data,Y                                               ; $00A890 | |
    STA <r_generic_arg_x_lo                                                     ; $00A893 | |
    CMP #32.b                                                                   ; $00A895 | |
    BCS +                                                                       ; $00A897 |/
    LDA r_current_coordinates.y.w                                               ; $00A899 |\
    CLC                                                                         ; $00A89C | | Return zero if the adjacent tile is out of bounds vertically.
    ADC y_coordinate_delta_data,Y                                               ; $00A89D | |
    STA <r_generic_arg_y_lo                                                     ; $00A8A0 | |
    CMP #32.b                                                                   ; $00A8A2 | |
    BCS +                                                                       ; $00A8A4 |/
    JSR _get_field_sprite_positioning_index                                     ; $00A8A6 |\
    LDX <r_generic_tmp_index                                                    ; $00A8A9 | | If there is an NPC in the adjacent tile, save the value as the
    LDA r_field_sprite_positioning.l,X                                          ; $00A8AB | | pushed NPC and also return the value in the accumulator.
    BPL +                                                                       ; $00A8AF | |
    STA <r_pushed_npc_index                                                     ; $00A8B1 | |
    JMP ++                                                                      ; $00A8B3 |/
+   LDA #$00.b                                                                  ; $00A8B6 |\ Return zero otherwise and restore the X register for some reason.
++  PLX                                                                         ; $00A8B8 |/
    RTS                                                                         ; $00A8B9

; _set_player_sprite_position ($00:A8BA)
;
; Based on the current coordinates and the movement direction, this function
; sets the player sprite's value in the field sprite positioning array if the
; target tile is not a bridge or if the player will end up on top of that
; bridge.
_set_player_sprite_position:
    LDA <r_movement_direction                                                   ; $00A8BA |\
    ASL A                                                                       ; $00A8BC | | Calculate Y register by multiplying the movement direction by two.
    TAY                                                                         ; $00A8BD |/
    LDA r_tile_properties_current.properties_1,Y                                ; $00A8BE |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A8C1 | | Skip this function if the adjacent tile is a bridge with a
    BEQ +                                                                       ; $00A8C3 | | different layer from the player's current layer. (Only set the
    LDA r_tile_properties_current.properties_1,Y                                ; $00A8C5 | | sprite position if the player will end up on top of the bridge.)
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $00A8C8 | |
    AND <r_current_map_layer                                                    ; $00A8CA | |
    BEQ ++                                                                      ; $00A8CC |/
+   LDA <r_movement_direction                                                   ; $00A8CE |\ Calculate the delta data index as simply the movement direction.
    TAY                                                                         ; $00A8D0 |/
    LDA r_current_coordinates.x.w                                               ; $00A8D1 |\
    CLC                                                                         ; $00A8D4 | | Calculate the target X coordinate.
    ADC x_coordinate_delta_data,Y                                               ; $00A8D5 | |
    STA <r_generic_arg_x_lo                                                     ; $00A8D8 |/
    LDA r_current_coordinates.y.w                                               ; $00A8DA |\
    CLC                                                                         ; $00A8DD | | Calculate the target Y coordinate.
    ADC y_coordinate_delta_data,Y                                               ; $00A8DE | |
    STA <r_generic_arg_y_lo                                                     ; $00A8E1 |/
    LDA #$FF.b                                                                  ; $00A8E3 | Set the target value to $FF.
    STA <r_copy_field_sprite_to_vram_arg_slot                                   ; $00A8E5 |\ Update the field sprite positioning array.
    JSR _update_field_sprite_positioning                                        ; $00A8E7 |/
++  RTS                                                                         ; $00A8EA

; x_coordinate_delta_data ($00:A8EB)
;
; For each movement direction, contains the change to the X coordinate to find
; the tile in the given direction.
x_coordinate_delta_data:
    .db  0                                                                      ; $00A8EB | $00: No Movement
    .db  0                                                                      ; $00A8EC | $01: Up
    .db  1                                                                      ; $00A8ED | $02: Right
    .db  0                                                                      ; $00A8EE | $03: Down
    .db -1                                                                      ; $00A8EF | $04: Left

; y_coordinate_delta_data ($00:A8F0)
;
; For each movement direction, contains the change to the Y coordinate to find
; the tile in the given direction.
y_coordinate_delta_data:
    .db  0                                                                      ; $00A8F0 | $00: No Movement
    .db -1                                                                      ; $00A8F1 | $01: Up
    .db  0                                                                      ; $00A8F2 | $02: Right
    .db  1                                                                      ; $00A8F3 | $03: Down
    .db  0                                                                      ; $00A8F4 | $04: Left

; _clear_player_sprite_position ($00:A8F5)
;
; Clears the player sprite position in the sprite positioning array. This only
; occurs if the current tile is not a bridge or if the player is on top of the
; bridge.
_clear_player_sprite_position:
    LDA <r_tile_properties_current.properties_1                                 ; $00A8F5 |\
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $00A8F7 | | If the current tile is not a bridge, always clear the sprite.
    BEQ +                                                                       ; $00A8F9 |/
    LDA <r_tile_properties_current.properties_1                                 ; $00A8FB |\
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1.b | TILE_PROPERTY_1_DUNGEON_LAYER_2    ; $00A8FD | | Otherwise, only clear the sprite if the current layer and the tile
    AND <r_current_map_layer                                                    ; $00A8FF | | layer match. (In other words, we're on the bridge.)
    BEQ ++                                                                      ; $00A901 |/
+   LDA r_current_coordinates.x.w                                               ; $00A903 |\
    STA <r_generic_arg_x_lo                                                     ; $00A906 | | Clear the sprite position.
    LDA r_current_coordinates.y.w                                               ; $00A908 | |
    STA <r_generic_arg_y_lo                                                     ; $00A90B | |
    JSR _clear_sprite_position                                                  ; $00A90D |/
++  RTS                                                                         ; $00A910

; _calculate_dungeon_vram_address ($00:A911)
;
; Given an 8-bit X coordinate in $060C and an 8-bit Y coordinate in $060E,
; calculates the dungeon map VRAM address for that tile in the tilemap and
; returns it in the X register.
_calculate_dungeon_vram_address:
    LDA <r_generic_arg_y_lo                                                     ; $00A911 |\
    AND #%00001111.b                                                            ; $00A913 | | Initially set the VRAM address to the Y coordinate mod 16 times
    STA <r_calculate_dungeon_vram_address_index_hi                              ; $00A915 | | 64.
    STZ <r_calculate_dungeon_vram_address_index_lo                              ; $00A917 | |
    LSR <r_calculate_dungeon_vram_address_index_hi                              ; $00A919 | |
    ROR <r_calculate_dungeon_vram_address_index_lo                              ; $00A91B | |
    LSR <r_calculate_dungeon_vram_address_index_hi                              ; $00A91D | |
    ROR <r_calculate_dungeon_vram_address_index_lo                              ; $00A91F |/
    LDA <r_generic_arg_x_lo                                                     ; $00A921 |\
    AND #%00001111.b                                                            ; $00A923 | | Add the X coordinate mod 16.
    ASL A                                                                       ; $00A925 | |
    CLC                                                                         ; $00A926 | |
    ADC <r_calculate_dungeon_vram_address_index_lo                              ; $00A927 | |
    STA <r_calculate_dungeon_vram_address_index_lo                              ; $00A929 |/
    LDA <r_calculate_dungeon_vram_address_index_hi                              ; $00A92B |\
    CLC                                                                         ; $00A92D | | Add $1800, which is the base address.
    ADC #$18.b                                                                  ; $00A92E | |
    STA <r_calculate_dungeon_vram_address_index_hi                              ; $00A930 |/
    LDA <r_generic_arg_x_lo                                                     ; $00A932 |\
    AND #%00010000.b                                                            ; $00A934 | | If the X coordinate is 16 or greater, add $400 to the address to
    BEQ +                                                                       ; $00A936 | | switch to the second part of the tilemap.
    LDA <r_calculate_dungeon_vram_address_index_hi                              ; $00A938 | |
    CLC                                                                         ; $00A93A | |
    ADC #$04.b                                                                  ; $00A93B | |
    STA <r_calculate_dungeon_vram_address_index_hi                              ; $00A93D |/
+   LDX <r_calculate_dungeon_vram_address_index                                 ; $00A93F | Return the result in the X register.
    RTS                                                                         ; $00A941

; _load_open_door_tiles ($00:A942)
;
; Loads the four tiles for an open door to $0700, $0702, $0704 and $0706. The
; open door tile is assumed to be $6F.
_load_open_door_tiles:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00A942 |\
    LDA r_tile_composition_data_dungeon_upper_left.l + ($6F * 2)                ; $00A944 | | Load the four subtiles of the open door tile to RAM. The open door
    STA r_tile_change_tile_1.w                                                  ; $00A948 | | tile number is hard coded as $6F.
    LDA r_tile_composition_data_dungeon_upper_right.l + ($6F * 2)               ; $00A94B | |
    STA r_tile_change_tile_2.w                                                  ; $00A94F | |
    LDA r_tile_composition_data_dungeon_lower_left.l + ($6F * 2)                ; $00A952 | |
    STA r_tile_change_tile_3.w                                                  ; $00A956 | |
    LDA r_tile_composition_data_dungeon_lower_right.l + ($6F * 2)               ; $00A959 | |
    STA r_tile_change_tile_4.w                                                  ; $00A95D | |
    LDA #$0000.w                                                                ; $00A960 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00A963 |/
    RTS                                                                         ; $00A965

; _calculate_outdoor_movement_direction ($00:A966)
;
; Based on the joypad and various state variables, determines the movement
; direction, handles poison damage, and loads any new rows of tiles as
; necessary. Also handles the automatic flight of the black chocobo back to its
; home forest.
_calculate_outdoor_movement_direction:
    LDA <r_player_movement_calculation_enabled                                  ; $00A966 |\
    BNE +                                                                       ; $00A968 | | Only execute if player movement calculation is enabled.
    RTS                                                                         ; $00A96A |/
+   JSR _update_current_tile_properties                                         ; $00A96B | Update properties of nearby tiles.
    LDA <r_cutscene_active                                                      ; $00A96E |\
    BEQ +                                                                       ; $00A970 | | If a cutscene is currently active, replace the joypad variables
    LDA <r_joypad_cutscene_lo                                                   ; $00A972 | | with the cutscene-specific joypad variables.
    STA <r_joypad_pressed_lo                                                    ; $00A974 | |
    LDA <r_joypad_cutscene_hi                                                   ; $00A976 | |
    STA <r_joypad_pressed_hi                                                    ; $00A978 |/
+   LDA <r_tile_properties_current.properties_1                                 ; $00A97A |\
    AND #TILE_PROPERTY_1_OUTDOOR_CAN_WALK | TILE_PROPERTY_1_OUTDOOR_PLATEAU.b   ; $00A97C | | Set the map layer based on the walk and plateau properties.
    STA <r_current_map_layer                                                    ; $00A97E |/
    LDA r_black_chocobo_count.w                                                 ; $00A980 |\
    CMP #2.b                                                                    ; $00A983 | | If this isn't the second time on the black chocobo, skip auto-fly.
    BNE @manual                                                                 ; $00A985 |/
    LDA r_current_coordinates.x.w                                               ; $00A987 |\
    SEC                                                                         ; $00A98A | | If the black chocobo forest is to the right of the current
    SBC r_black_chocobo_forest_coordinates.x.w                                  ; $00A98B | | coordinates, set the direction to right.
    BEQ ++                                                                      ; $00A98E | |
    BPL +                                                                       ; $00A990 | |
    LDA #DIRECTION_RIGHT.b                                                      ; $00A992 | |
    STA r_direction.w                                                           ; $00A994 | |
    INC A                                                                       ; $00A997 | |
    JMP @next                                                                   ; $00A998 |/
+   LDA #DIRECTION_LEFT.b                                                       ; $00A99B |\
    STA r_direction.w                                                           ; $00A99D | | If the black chocobo forest is to the left, set the direction to
    INC A                                                                       ; $00A9A0 | | the left.
    JMP @next                                                                   ; $00A9A1 |/
++  LDA r_current_coordinates.y.w                                               ; $00A9A4 |\
    SEC                                                                         ; $00A9A7 | | If the black chocobo forest is to the south, set the direction to
    SBC r_black_chocobo_forest_coordinates.y.w                                  ; $00A9A8 | | down.
    BEQ ++                                                                      ; $00A9AB | |
    BPL +                                                                       ; $00A9AD | |
    LDA #DIRECTION_DOWN.b                                                       ; $00A9AF | |
    STA r_direction.w                                                           ; $00A9B1 | |
    INC A                                                                       ; $00A9B4 | |
    JMP @next                                                                   ; $00A9B5 |/
+   LDA #$00.b                                                                  ; $00A9B8 |\
    STA r_direction.w                                                           ; $00A9BA | | If the forest is to the north, set the direction to up.
    INC A                                                                       ; $00A9BD | |
    JMP @next                                                                   ; $00A9BE |/
++  LDA #JOYPAD_L_CONFIRM.b                                                     ; $00A9C1 |\ If the black chocobo forest is below us, fake a confirm button
    STA <r_joypad_pressed_lo                                                    ; $00A9C3 |/ press.
    STZ <r_joypad_a_pressed                                                     ; $00A9C5 | Unset the joypad A pressed flag to allow the vehicle change to go.
@manual:
    JSR _check_vehicle_change                                                   ; $00A9C7 | Handle a vehicle change if appropriate.
    LDA <r_joypad_pressed_hi                                                    ; $00A9CA |\
    AND #JOYPAD_H_DPAD.b                                                        ; $00A9CC | | If no directional buttons are pressed, skip this next section.
    BEQ @not_moving                                                             ; $00A9CE |/
    AND #JOYPAD_H_RIGHT.b                                                       ; $00A9D0 |\
    BEQ +                                                                       ; $00A9D2 | | If right is pressed, set the direction to right and move to the
    LDA #DIRECTION_RIGHT.b                                                      ; $00A9D4 | | next section.
    JMP ++                                                                      ; $00A9D6 |/
+   LDA <r_joypad_pressed_hi                                                    ; $00A9D9 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $00A9DB | | If left is pressed, set the direction to left.
    BEQ +                                                                       ; $00A9DD | |
    LDA #DIRECTION_LEFT.b                                                       ; $00A9DF | |
    JMP ++                                                                      ; $00A9E1 |/
+   LDA <r_joypad_pressed_hi                                                    ; $00A9E4 |\
    AND #JOYPAD_H_DOWN.b                                                        ; $00A9E6 | | If down is pressed, set the direction to down.
    BEQ +                                                                       ; $00A9E8 | |
    LDA #DIRECTION_DOWN.b                                                       ; $00A9EA | |
    JMP ++                                                                      ; $00A9EC |/
+   LDA #DIRECTION_UP.b                                                         ; $00A9EF |\ Otherwise, the direction is set to up.
++  STA r_direction.w                                                           ; $00A9F1 |/
    INC A                                                                       ; $00A9F4 |\ Set the movement direction by adding one.
    STA r_facing_movement_direction.w                                           ; $00A9F5 |/
    ASL A                                                                       ; $00A9F8 |\ Set the X register to movement direction times two, as each tile
    TAX                                                                         ; $00A9F9 |/ has two bytes.
    LDA <r_cutscene_active                                                      ; $00A9FA |\ If this is a cutscene, skip any of the tile-related checks and
    BNE @next_load_direction                                                    ; $00A9FC |/ simply use the facing movement direction as gospel.
    LDA r_map_area.w                                                            ; $00A9FE |\
    CMP #MAP_AREA_UNDERWORLD.b                                                  ; $00AA01 | | The next block only applies in the underworld.
    BNE ++                                                                      ; $00AA03 |/
    LDA r_vehicle.w                                                             ; $00AA05 |\
    CMP #VEHICLE_FALCON.b                                                       ; $00AA08 | | If the current vehicle is the Falcon and bit 1 of plot flag 8 is
    BNE +                                                                       ; $00AA0A | | set, assume the vehicle is the yellow chocobo for the next part of
    LDA r_plot_flags.8.w                                                        ; $00AA0C | | the function.
    AND #PLOT_FLAG_8_FALCON_MAGMA.b                                             ; $00AA0F | |
    BEQ ++                                                                      ; $00AA11 | |
    LDA #VEHICLE_YELLOW_CHOCOBO.b                                               ; $00AA13 | |
    JMP +++                                                                     ; $00AA15 |/
+   CMP #VEHICLE_ENTERPRISE.b                                                   ; $00AA18 |\
    BNE ++                                                                      ; $00AA1A | | Do the same thing for the Enterprise, except using bit 3 of plot
    LDA r_plot_flags.2.w                                                        ; $00AA1C | | flag 2.
    AND #PLOT_FLAG_2_ENTERPRISE_MAGMA.b                                         ; $00AA1F | |
    BEQ ++                                                                      ; $00AA21 | |
    LDA #VEHICLE_YELLOW_CHOCOBO.b                                               ; $00AA23 | |
    JMP +++                                                                     ; $00AA25 |/
++  LDA r_vehicle.w                                                             ; $00AA28 | Otherwise, just load the actual current vehicle.
    BEQ +                                                                       ; $00AA2B |\
+++ TAY                                                                         ; $00AA2D | | If the player is using a vehicle, check if the tile in the
    LDA <r_tile_properties_current.properties_1,X                               ; $00AA2E | | movement direction allows the current vehicle to pass. If not,
    AND vehicle_tile_property_mask_data.w,Y                                     ; $00AA30 | | cancel the movement.
    BEQ @not_moving                                                             ; $00AA33 | |
    JMP ++                                                                      ; $00AA35 |/
+   LDA <r_tile_properties_current.properties_1,X                               ; $00AA38 |\
    AND #TILE_PROPERTY_1_OUTDOOR_PLATEAU | TILE_PROPERTY_1_OUTDOOR_CAN_WALK.b   ; $00AA3A | | Only allow movement if the current layer matches at least one of
    AND <r_current_map_layer                                                    ; $00AA3C | | the layer bits of the target tile.
    BEQ @not_moving                                                             ; $00AA3E |/
++  JSR _check_direction_vehicle_blocking                                       ; $00AA40 |\
    LDA <r_check_direction_vehicle_blocking_result                              ; $00AA43 | | If another vehicle blocks the direction, cancel the movement.
    BEQ @next_load_direction                                                    ; $00AA45 |/
@not_moving:
    STZ <r_movement_direction                                                   ; $00AA47 |\ Set the movement direction to no movement and return.
    RTS                                                                         ; $00AA49 |/
@next_load_direction:
    LDA r_facing_movement_direction.w                                           ; $00AA4A | Load the facing movement direction to the accumulator.
@next:
    STA <r_movement_direction                                                   ; $00AA4D | Set the actual movement direction.
    JSR _do_walking_poison                                                      ; $00AA4F | Calculate poison damage and play the sound effect.
    LDA r_current_coordinates.y.w                                               ; $00AA52 |\
    STA r_load_outdoor_tilemap_row_arg_y.w                                      ; $00AA55 | | Load the next tilemap row.
    JSR _load_outdoor_tilemap_row                                               ; $00AA58 |/
    JSR _update_outdoor_pending_tiles                                           ; $00AA5B | Update the pending tiles with any new tiles.
    RTS                                                                         ; $00AA5E

; _check_direction_vehicle_blocking ($00:AA5F)
;
; With a given facing movement direction, determines if the current vehicle can
; pass onto the next tile depending on any other vehicle that is currently
; parked there. In particular, the yellow chocobo and hovercraft are restricted
; from passing onto the hovercraft, black chocobo, or any airship.
;
; BUG: This code does not check map plane whatsoever, so you are also blocked
;      from passing onto a tile if the coordinates match, even if the other
;      vehicle is on another plane.
_check_direction_vehicle_blocking:
    LDA r_facing_movement_direction.w                                           ; $00AA5F |\
    TAX                                                                         ; $00AA62 | | Calculate the target X and Y coordinates based on the current X
    LDA r_current_coordinates.x.w                                               ; $00AA63 | | and Y coordinates and the facing movement direction.
    CLC                                                                         ; $00AA66 | |
    ADC x_coordinate_delta_data.w,X                                             ; $00AA67 | |
    STA <r_generic_arg_x_lo                                                     ; $00AA6A | |
    LDA r_current_coordinates.y.w                                               ; $00AA6C | |
    CLC                                                                         ; $00AA6F | |
    ADC y_coordinate_delta_data.w,X                                             ; $00AA70 | |
    STA <r_generic_arg_y_lo                                                     ; $00AA73 |/
    STZ <r_check_direction_vehicle_blocking_result                              ; $00AA75 | Set the result initially to zero.
    LDA r_vehicle.w                                                             ; $00AA77 |\
    BNE +                                                                       ; $00AA7A | | If not using a vehicle, return. Walking is never blocked.
    RTS                                                                         ; $00AA7C |/
+   CMP #VEHICLE_YELLOW_CHOCOBO.b                                               ; $00AA7D |\
    BNE +                                                                       ; $00AA7F | | If the current vehicle is the yellow chocobo and the hovercraft is
    LDA <r_generic_arg_x_lo                                                     ; $00AA81 | | at the same coordinates, set the result to 1 and return.
    CMP r_hovercraft_coordinates.x.w                                            ; $00AA83 | |
    BNE +                                                                       ; $00AA86 | |
    LDA <r_generic_arg_y_lo                                                     ; $00AA88 | |
    CMP r_hovercraft_coordinates.y.w                                            ; $00AA8A | |
    BNE +                                                                       ; $00AA8D | |
    INC <r_check_direction_vehicle_blocking_result                              ; $00AA8F | |
    RTS                                                                         ; $00AA91 |/
+   LDA r_vehicle.w                                                             ; $00AA92 |\
    CMP #VEHICLE_BLACK_CHOCOBO.b                                                ; $00AA95 | | Only continue if the current vehicle is the yellow chocobo or
    BEQ @done                                                                   ; $00AA97 | | hovercraft.
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $00AA99 | |
    BCS @done                                                                   ; $00AA9B |/
    LDA r_black_chocobo_count.w                                                 ; $00AA9D |\
    BNE +                                                                       ; $00AAA0 | | If the black chocobo count is zero, check the black chocobo
    LDA <r_generic_arg_x_lo                                                     ; $00AAA2 | | coordinates and set the result to 1 if it matches the target
    CMP r_black_chocobo_coordinates.x.w                                         ; $00AAA4 | | coordinates.
    BNE +                                                                       ; $00AAA7 | |
    LDA <r_generic_arg_y_lo                                                     ; $00AAA9 | | BUG: This should probably check if the black chocobo count is NOT
    CMP r_black_chocobo_coordinates.y.w                                         ; $00AAAB | |      zero, but here we are. The only time this will trigger is
    BNE +                                                                       ; $00AAAE | |      when no black chocobo is on the map, and the checked
    INC <r_check_direction_vehicle_blocking_result                              ; $00AAB0 | |      coordinates will at best be a chocobo forest.
    RTS                                                                         ; $00AAB2 |/
+   LDA <r_generic_arg_x_lo                                                     ; $00AAB3 |\
    CMP r_enterprise_coordinates.x.w                                            ; $00AAB5 | | Return 1 if the Enterprise coordinates match the target
    BNE +                                                                       ; $00AAB8 | | coordinates.
    LDA <r_generic_arg_y_lo                                                     ; $00AABA | |
    CMP r_enterprise_coordinates.y.w                                            ; $00AABC | |
    BNE +                                                                       ; $00AABF | |
    INC <r_check_direction_vehicle_blocking_result                              ; $00AAC1 | |
    RTS                                                                         ; $00AAC3 |/
+   LDA <r_generic_arg_x_lo                                                     ; $00AAC4 |\
    CMP r_falcon_coordinates.x.w                                                ; $00AAC6 | | Return 1 if the Falcon coordinates match the target coordinates.
    BNE +                                                                       ; $00AAC9 | |
    LDA <r_generic_arg_y_lo                                                     ; $00AACB | |
    CMP r_falcon_coordinates.y.w                                                ; $00AACD | |
    BNE +                                                                       ; $00AAD0 | |
    INC <r_check_direction_vehicle_blocking_result                              ; $00AAD2 | |
    RTS                                                                         ; $00AAD4 |/
+   LDA <r_generic_arg_x_lo                                                     ; $00AAD5 |\
    CMP r_big_whale_coordinates.x.w                                             ; $00AAD7 | | Return 1 if the Big Whale coordinates match the target
    BNE @done                                                                   ; $00AADA | | coordinates.
    LDA <r_generic_arg_y_lo                                                     ; $00AADC | |
    CMP r_big_whale_coordinates.y.w                                             ; $00AADE | |
    BNE @done                                                                   ; $00AAE1 | |
    INC <r_check_direction_vehicle_blocking_result                              ; $00AAE3 |/
@done:
    RTS                                                                         ; $00AAE5

; vehicle_tile_property_mask_data ($00:AAE6)
;
; For each vehicle, provides the mask that must be checked on a tile to
; determine if the vehicle can travel on that tile.
vehicle_tile_property_mask_data:
    .db TILE_PROPERTY_1_OUTDOOR_CAN_WALK                                        ; $00AAE6 | $00: No Vehicle (but unused)
    .db TILE_PROPERTY_1_OUTDOOR_YELLOW_CHOCOBO                                  ; $00AAE7 | $01: Yellow Chocobo
    .db TILE_PROPERTY_1_OUTDOOR_BLACK_CHOCOBO                                   ; $00AAE8 | $02: Black Chocobo
    .db TILE_PROPERTY_1_OUTDOOR_HOVERCRAFT                                      ; $00AAE9 | $03: Hovercraft
    .db TILE_PROPERTY_1_OUTDOOR_AIRSHIP                                         ; $00AAEA | $04: Enterprise
    .db TILE_PROPERTY_1_OUTDOOR_AIRSHIP                                         ; $00AAEB | $05: Falcon
    .db TILE_PROPERTY_1_OUTDOOR_BIG_WHALE                                       ; $00AAEC | $06: Big Whale

; map_area_coordinate_mask_data ($00:AAED)
;
; For each outdoor map area, defines the mask to apply to coordinates to keep
; them in range.
map_area_coordinate_mask_data:
    .db %11111111                                                               ; $00AAED | $00: Overworld
    .db %01111111                                                               ; $00AAEE | $01: Underworld
    .db %00111111                                                               ; $00AAEF | $02: Moon

; movement_speed_frame_counter_mask_data ($00:AAF0)
;
; For each movement speed, determines the mask to apply to the frame counter to
; determine if this frame is an even tile traversal.
movement_speed_frame_counter_mask_data:
    .db %00001111                                                               ; $00AAF0 | $00
    .db %00000111                                                               ; $00AAF1 | $01
    .db %00000011                                                               ; $00AAF2 | $02
    .db %00000001                                                               ; $00AAF3 | $03

; movement_speed_pixels_per_frame_data
;
; For each vehicle speed, contains the number of pixels to move per frame.
; Equal to two to the given power.
movement_speed_pixels_per_frame_data:
    .db 1                                                                       ; $00AAF4 | $00
    .db 2                                                                       ; $00AAF5 | $01
    .db 4                                                                       ; $00AAF6 | $02
    .db 8                                                                       ; $00AAF7 | $03

; _inn_draw_party_gp_window ($00:AAF8)
;
; Draws the party GP window to BG3, including drawing the actual party GP.
_inn_draw_party_gp_window:
    JSR _wait_for_nmi_complete_field                                            ; $00AAF8 | Wait for the next NMI to be complete.
    LDA #%10000000.b                                                            ; $00AAFB |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA reg_ppu_vmainc.w                                                        ; $00AAFD |/
    JSR _init_dma_bank_0_to_vram                                                ; $00AB00 |\
    LDA #%00000001.b                                                            ; $00AB03 | | Initialize DMA channel 0 for a transfer from bank 0 to VRAM.
    STA reg_cpu_dmap0.w                                                         ; $00AB05 |/
    LDA #:bank14.tilemap_inn_dialog_party_gp_row_1_data.b                       ; $00AB08 |\
    STA reg_cpu_a1b0.w                                                          ; $00AB0A | | Copy the first row of the tilemap to VRAM.
    LDX #bank14.tilemap_inn_dialog_party_gp_row_1_data.w                        ; $00AB0D | |
    STX reg_cpu_a1t0.w                                                          ; $00AB10 | |
    LDX #VRAM_INN_PARTY_GP_WINDOW.w + 0 * 32                                    ; $00AB13 | |
    STX reg_ppu_vmadd.w                                                         ; $00AB16 | |
    LDX #bank14._sizeof_tilemap_inn_dialog_party_gp_row_1_data.w                ; $00AB19 | |
    STX reg_cpu_das0.w                                                          ; $00AB1C | |
    JSR _enable_dma_0                                                           ; $00AB1F |/
    LDX #VRAM_INN_PARTY_GP_WINDOW.w + 1 * 32                                    ; $00AB22 |\
    STX reg_ppu_vmadd.w                                                         ; $00AB25 | | Copy the second row of the tilemap to VRAM.
    STZ reg_cpu_mdmaen.w                                                        ; $00AB28 | |
    LDX #bank14.tilemap_inn_dialog_party_gp_row_2_data.w                        ; $00AB2B | |
    STX reg_cpu_a1t0.w                                                          ; $00AB2E | |
    LDX #bank14._sizeof_tilemap_inn_dialog_party_gp_row_2_data.w                ; $00AB31 | |
    STX reg_cpu_das0.w                                                          ; $00AB34 | |
    JSR _enable_dma_0                                                           ; $00AB37 |/
    LDX #VRAM_INN_PARTY_GP_WINDOW.w + 2 * 32                                    ; $00AB3A |\
    STX reg_ppu_vmadd.w                                                         ; $00AB3D | | Copy the third row of the tilemap to VRAM.
    STZ reg_cpu_mdmaen.w                                                        ; $00AB40 | |
    LDX #bank14.tilemap_inn_dialog_party_gp_row_3_data.w                        ; $00AB43 | |
    STX reg_cpu_a1t0.w                                                          ; $00AB46 | |
    LDX #bank14._sizeof_tilemap_inn_dialog_party_gp_row_3_data.w                ; $00AB49 | |
    STX reg_cpu_das0.w                                                          ; $00AB4C | |
    JSR _enable_dma_0                                                           ; $00AB4F |/
    LDX #VRAM_INN_PARTY_GP_WINDOW.w + 3 * 32                                    ; $00AB52 |\
    STX reg_ppu_vmadd.w                                                         ; $00AB55 | | Copy the fourth row of the tilemap to VRAM.
    STZ reg_cpu_mdmaen.w                                                        ; $00AB58 | |
    LDX #bank14.tilemap_inn_dialog_party_gp_row_4_data.w                        ; $00AB5B | |
    STX reg_cpu_a1t0.w                                                          ; $00AB5E | |
    LDX #bank14._sizeof_tilemap_inn_dialog_party_gp_row_4_data.w                ; $00AB61 | |
    STX reg_cpu_das0.w                                                          ; $00AB64 | |
    JSR _enable_dma_0                                                           ; $00AB67 |/
    LDX #VRAM_INN_PARTY_GP_WINDOW.w + 2 * 32 + 1                                ; $00AB6A |\ Set the VRAM address to the second row of blank tiles.
    STX reg_ppu_vmadd.w                                                         ; $00AB6D |/
    STZ <r_generic_tmp_5                                                        ; $00AB70 | Initialize the leading zero flag to zero.
    LDX #0.w                                                                    ; $00AB72 | Initialize the X register to zero.
-   LDA r_format_number_result.w,X                                              ; $00AB75 |\
    CMP #TILE_MENU_NUMBER_BASE.b                                                ; $00AB78 | | If the value of the current digit is zero, if this isn't the last
    BNE +                                                                       ; $00AB7A | | digit, and if a non-zero value hasn't already been seen, change
    CPX #_sizeof_r_format_number_result.w - 1                                   ; $00AB7C | | the tile to a blank tile.
    BEQ +                                                                       ; $00AB7F | |
    LDA <r_generic_tmp_5                                                        ; $00AB81 | |
    BNE ++                                                                      ; $00AB83 | |
    LDA #TILE_MENU_WINDOW_BLANK.b                                               ; $00AB85 | |
    JMP +++                                                                     ; $00AB87 |/
+   INC <r_generic_tmp_5                                                        ; $00AB8A | Set the non-zero tile seen flag (unless the tile was just changed to
++  LDA r_format_number_result.w,X                                              ; $00AB8C | a blank or if it was already set).
+++ STA reg_ppu_vmdatal_write.w                                                 ; $00AB8F |\
    LDA #%00100000.b                                                            ; $00AB92 | | Write the tile and the flags for priority 1.
    STA reg_ppu_vmdatah_write.w                                                 ; $00AB94 |/
    INX                                                                         ; $00AB97 |\
    CPX #_sizeof_r_format_number_result.w                                       ; $00AB98 | | Loop until all eight digits have been written.
    BNE -                                                                       ; $00AB9B |/
    RTS                                                                         ; $00AB9D

; _inn_erase_party_gp_window ($00:AB9E)
;
; Erases the window that contains the party GP while visiting an Inn.
_inn_erase_party_gp_window:
    JSR _wait_for_nmi_complete_field                                            ; $00AB9E | Wait for the next complete NMI.
    LDA #%10000000.b                                                            ; $00ABA1 |\ Set the VRAM increment to 1 by 1 after two bytes.
    STA reg_ppu_vmainc.w                                                        ; $00ABA3 |/
    JSR _init_dma_bank_0_to_vram                                                ; $00ABA6 | Initialize DMA channel 0 to copy from bank 0 to VRAM.
    LDA #%00001001.b                                                            ; $00ABA9 |\ Configure the DMA for a fixed transfer, writing two bytes.
    STA reg_cpu_dmap0.w                                                         ; $00ABAB |/
    STZ r_start_fixed_vram_dma_arg_value.w                                      ; $00ABAE |\
    LDX #r_start_fixed_vram_dma_arg_value.w                                     ; $00ABB1 | | Initialize the fixed value to zero and set it in the DMA.
    STX reg_cpu_a1t0.w                                                          ; $00ABB4 |/
    LDX #VRAM_INN_PARTY_GP_WINDOW.w - 18                                        ; $00ABB7 |\ Set the VRAM address to the start of the first line of the party GP
    STX reg_ppu_vmadd.w                                                         ; $00ABBA |/ window.
    LDX #(32 * 4 * 2).w                                                         ; $00ABBD |\ Configure the DMA to erase four lines.
    STX reg_cpu_das0.w                                                          ; $00ABC0 |/
    JSR _enable_dma_0                                                           ; $00ABC3 | Execute the DMA to erase the dialog.
    RTS                                                                         ; $00ABC6

; _dialog_yes_no_execute ($00:ABC7)
;
; Displays a yes/no dialog and keeps control until the dialog is closed. The
; result of the dialog is ultimately stored in $06DB.
_dialog_yes_no_execute:
    STZ <r_yes_no_dialog_height                                                 ; $00ABC7 | Set the yes/no dialog height to zero.
-   JSR _wait_for_nmi_complete                                                  ; $00ABC9 | Wait for the next completed NMI.
    JSR _set_upper_dialog_timer                                                 ; $00ABCC | Set the dialog IRQ timer.
    JSR _dialog_yes_no_draw_current_line                                        ; $00ABCF | Update the dialog for the current height.
    INC <r_yes_no_dialog_height                                                 ; $00ABD2 |\
    LDA <r_yes_no_dialog_height                                                 ; $00ABD4 | | Increment the dialog height and loop until it reaches 6.
    CMP #6.b                                                                    ; $00ABD6 | | NOTE: The bottom row is not counted, so the height is actually 7.
    BNE -                                                                       ; $00ABD8 |/
    LDA #1.b                                                                    ; $00ABDA |\ Initialize the A button pressed flag to 1.
    STA <r_joypad_a_pressed                                                     ; $00ABDC |/
    STZ <r_dialog_cursor_coordinates.y                                          ; $00ABDE | Set the dialog cursor Y coordinate to zero.
@loop_start:
    JSR _wait_for_nmi_complete                                                  ; $00ABE0 | Wait for the next completed NMI.
    JSR _set_upper_dialog_timer                                                 ; $00ABE3 | Set the dialog IRQ timer.
    JSL bank15.joypad_filter_unpressed_buttons                                  ; $00ABE6 | Set the button flags to zero if the buttons are not pressed.
    LDA <r_joypad_pressed_lo                                                    ; $00ABEA |\
    AND #JOYPAD_L_A.b                                                           ; $00ABEC | | If the A button is pressed and if the A button flag is not set as
    BEQ +                                                                       ; $00ABEE | | pressed, branch to close the dialog. The flag is set once at the
    LDA <r_joypad_a_pressed                                                     ; $00ABF0 | | start and again if this test passes. This prevents a held down A
    BNE +                                                                       ; $00ABF2 | | button from triggering the close without at least one frame of the
    INC <r_joypad_a_pressed                                                     ; $00ABF4 | | button not being pressed.
    JMP _dialog_yes_no_close                                                    ; $00ABF6 |/
+   LDA <r_joypad_pressed_hi                                                    ; $00ABF9 |\
    AND #JOYPAD_H_B.b                                                           ; $00ABFB | | Repeat the same process for the B button. The major difference
    BEQ +                                                                       ; $00ABFD | | here is that the flag is not preset to one, so it's possible for
    LDA <r_joypad_b_pressed                                                     ; $00ABFF | | the dialog close to trigger on the first frame. The cursor Y
    BNE +                                                                       ; $00AC01 | | coordinate is explicitly set to 1, as the B button is treated as
    INC <r_joypad_b_pressed                                                     ; $00AC03 | | a cancel.
    LDA #1.b                                                                    ; $00AC05 | |
    STA <r_dialog_cursor_coordinates.y                                          ; $00AC07 | |
    JMP _dialog_yes_no_close                                                    ; $00AC09 |/
+   LDA <r_joypad_repeat_hi                                                     ; $00AC0C |\
    AND #JOYPAD_H_UP.b | JOYPAD_H_DOWN                                          ; $00AC0E | | If neither up nor down are currently pressed, loop again.
    BEQ @loop_start                                                             ; $00AC10 |/
    LDA <r_dialog_cursor_coordinates.y                                          ; $00AC12 |\
    EOR #%00000001.b                                                            ; $00AC14 | | Flip the lowest bit of the Y coordinate to move the cursor.
    STA <r_dialog_cursor_coordinates.y                                          ; $00AC16 |/
    LDX #$28C4.w                                                                ; $00AC18 |\ Set the current VRAM address to the location of the tile in front
    STX reg_ppu_vmadd.w                                                         ; $00AC1B |/ of Yes.
    LDA <r_dialog_cursor_coordinates.y                                          ; $00AC1E |\
    BNE +                                                                       ; $00AC20 | | Write tile $14 if the cursor coordinate is set to 0. Otherwise,
    LDA #$14.b                                                                  ; $00AC22 | | write a blank tile.
    JMP ++                                                                      ; $00AC24 | |
+   LDA #$FF.b                                                                  ; $00AC27 | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $00AC29 | |
    LDA #$20.b                                                                  ; $00AC2C | |
    STA reg_ppu_vmdatah_write.w                                                 ; $00AC2E |/
    LDX #$2904.w                                                                ; $00AC31 |\ Set the current VRAM address to the location of the tile in front
    STX reg_ppu_vmadd.w                                                         ; $00AC34 |/ of No.
    LDA <r_dialog_cursor_coordinates.y                                          ; $00AC37 |\
    BEQ +                                                                       ; $00AC39 | | Write tile $14 if the cursor coordinate is set to 1. Otherwise,
    LDA #$14.b                                                                  ; $00AC3B | | write a blank tile.
    JMP ++                                                                      ; $00AC3D | |
+   LDA #$FF.b                                                                  ; $00AC40 | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $00AC42 | |
    LDA #$20.b                                                                  ; $00AC45 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $00AC47 |/
    JSR _play_cursor_sound_effect_and_delay                                     ; $00AC4A | Play a cursor sound effect and delay 7 frames.
    JMP @loop_start                                                             ; $00AC4D

; _dialog_yes_no_close ($00:AC50)
;
; Closes the yes/no dialog. Stores the current value of the cursor Y coordinate
; at $06DB.
_dialog_yes_no_close:
    JSR _play_cursor_sound_effect                                               ; $00AC50 | Play a cursor sound effect.
    LDA <r_dialog_cursor_coordinates.y                                          ; $00AC53 |\ Transfer the current Y coordinate to the result.
    STA <r_yes_no_dialog_result                                                 ; $00AC55 |/
    DEC <r_yes_no_dialog_height                                                 ; $00AC57 |\
-   JSR _wait_for_nmi_complete                                                  ; $00AC59 | |
    JSR _set_upper_dialog_timer                                                 ; $00AC5C | | Close the dialog by repeatedly decreasing the height and drawing
    JSR _dialog_yes_no_draw_current_line                                        ; $00AC5F | | the current line as if it were the last.
    DEC <r_yes_no_dialog_height                                                 ; $00AC62 | | BUG: When selecting no, the cursor will appear next to yes for one
    BPL -                                                                       ; $00AC64 |/       frame during the closing process.
    JSR _wait_for_nmi_complete                                                  ; $00AC66 | Wait for the next frame.
    JSR _set_upper_dialog_timer                                                 ; $00AC69 | Set the dialog IRQ timer.
    LDA <r_generic_tmp_index.lo                                                 ; $00AC6C |\
    SEC                                                                         ; $00AC6E | | Decrement the VRAM address by one line and explicitly draw a blank
    SBC #32.b                                                                   ; $00AC6F | | line to erase the bottom of the dialog.
    STA <r_generic_tmp_index.lo                                                 ; $00AC71 | |
    LDA <r_generic_tmp_index.hi                                                 ; $00AC73 | |
    SBC #0.b                                                                    ; $00AC75 | |
    STA <r_generic_tmp_index.hi                                                 ; $00AC77 | |
    JSR _dialog_yes_no_draw_blank_line                                          ; $00AC79 |/
    LDA <r_generic_tmp_index.lo                                                 ; $00AC7C |\
    SEC                                                                         ; $00AC7E | | Decrement the VRAM address by one line and explicitly draw a blank
    SBC #32.b                                                                   ; $00AC7F | | line to erase the top of the dialog.
    STA <r_generic_tmp_index.lo                                                 ; $00AC81 | |
    LDA <r_generic_tmp_index.hi                                                 ; $00AC83 | |
    SBC #0.b                                                                    ; $00AC85 | |
    STA <r_generic_tmp_index.hi                                                 ; $00AC87 | |
    JSR _dialog_yes_no_draw_blank_line                                          ; $00AC89 |/
    RTS                                                                         ; $00AC8C

; _dialog_yes_no_draw_current_line ($00:AC8D)
;
; Given the current height of the yes/no dialog in $06DC, draws that line and
; the bottom line to the next line. By calling this repeatedly with an
; increasing height value, the entire dialog can be animated opening. Similarly,
; by calling it with a decreasing height value, the dialog can be made to close.
_dialog_yes_no_draw_current_line:
    LDA #%10000000.b                                                            ; $00AC8D |\ Set the VRAM increment to 1 by 1 after writing two bytes.
    STA reg_ppu_vmainc.w                                                        ; $00AC8F |/
    JSR _init_dma_bank_0_to_vram                                                ; $00AC92 |\
    LDA #%00000001.b                                                            ; $00AC95 | | Configure DMA channel 0 to transfer from bank 0 to VRAM.
    STA reg_cpu_dmap0.w                                                         ; $00AC97 |/
    LDX #16.w                                                                   ; $00AC9A |\ Configure the DMA to transfer 16 bytes (eight tiles).
    STX reg_cpu_das0.w                                                          ; $00AC9D |/
    LDA #:bank14.tilemap_yes_no_dialog_data.b                                   ; $00ACA0 |\ Set the source bank for the DMA transfers to $14.
    STA reg_cpu_a1b0.w                                                          ; $00ACA2 |/
    LDA <r_yes_no_dialog_height                                                 ; $00ACA5 |\
    ASL A                                                                       ; $00ACA7 | | Set the DMA source address to the tilemap data for this row of the
    ASL A                                                                       ; $00ACA8 | | dialog.
    ASL A                                                                       ; $00ACA9 | |
    ASL A                                                                       ; $00ACAA | |
    CLC                                                                         ; $00ACAB | |
    ADC #<bank14.tilemap_yes_no_dialog_data                                     ; $00ACAC | |
    STA <r_generic_tmp_index.lo                                                 ; $00ACAE | |
    LDA #>bank14.tilemap_yes_no_dialog_data                                     ; $00ACB0 | |
    ADC #0.b                                                                    ; $00ACB2 | |
    STA <r_generic_tmp_index.hi                                                 ; $00ACB4 | |
    LDX <r_generic_tmp_index                                                    ; $00ACB6 | |
    STX reg_cpu_a1t0.w                                                          ; $00ACB8 |/
    LDA <r_yes_no_dialog_height                                                 ; $00ACBB |\
    ASL A                                                                       ; $00ACBD | | Set the target VRAM address to $2882 plus the height times 32.
    ASL A                                                                       ; $00ACBE | |
    ASL A                                                                       ; $00ACBF | |
    ASL A                                                                       ; $00ACC0 | |
    ASL A                                                                       ; $00ACC1 | |
    CLC                                                                         ; $00ACC2 | |
    ADC #$82.b                                                                  ; $00ACC3 | |
    STA <r_generic_tmp_index.lo                                                 ; $00ACC5 | |
    LDA #$28.b                                                                  ; $00ACC7 | |
    ADC #0.b                                                                    ; $00ACC9 | |
    STA <r_generic_tmp_index.hi                                                 ; $00ACCB | |
    LDX <r_generic_tmp_index                                                    ; $00ACCD | |
    STX reg_ppu_vmadd.w                                                         ; $00ACCF |/
    JSR _enable_dma_0                                                           ; $00ACD2 | Execute the DMA to copy that row to VRAM.
    LDA <r_generic_tmp_index.lo                                                 ; $00ACD5 |\
    CLC                                                                         ; $00ACD7 | | Add 32 to the VRAM address to move to the next line.
    ADC #32.b                                                                   ; $00ACD8 | |
    STA <r_generic_tmp_index.lo                                                 ; $00ACDA | |
    LDA <r_generic_tmp_index.hi                                                 ; $00ACDC | |
    ADC #0.b                                                                    ; $00ACDE | |
    STA <r_generic_tmp_index.hi                                                 ; $00ACE0 | |
    LDX <r_generic_tmp_index                                                    ; $00ACE2 | |
    STX reg_ppu_vmadd.w                                                         ; $00ACE4 |/
    STZ reg_cpu_mdmaen.w                                                        ; $00ACE7 |\
    LDX #bank14.tilemap_yes_no_dialog_data.w + (8 * 2 * 6)                      ; $00ACEA | | Execute a second DMA to explicitly copy the last row of the
    STX reg_cpu_a1t0.w                                                          ; $00ACED | | tilemap to the current row.
    LDX #16.w                                                                   ; $00ACF0 | |
    STX reg_cpu_das0.w                                                          ; $00ACF3 | |
    JSR _enable_dma_0                                                           ; $00ACF6 |/
    LDA <r_generic_tmp_index.lo                                                 ; $00ACF9 |\
    CLC                                                                         ; $00ACFB | | Add 32 to the VRAM address to move to the next line, and then fall
    ADC #32.b                                                                   ; $00ACFC | | through to the next function, which draws a blank line on this
    STA <r_generic_tmp_index.lo                                                 ; $00ACFE | | next line, taking the value in $3D as a parameter.
    LDA <r_generic_tmp_index.hi                                                 ; $00AD00 | |
    ADC #0.b                                                                    ; $00AD02 | |
    STA <r_generic_tmp_index.hi                                                 ; $00AD04 |/

; _dialog_yes_no_draw_blank_line ($00:AD06)
;
; Given a 16-bit VRAM address in $3D, draws a blank line of tiles for the
; yes/no dialog, primarily used to erase the last row when closing the dialog.
; Eight tiles will be written over.
_dialog_yes_no_draw_blank_line:
    LDA #%10000000.b                                                            ; $00AD06 |\ Set the VRAM increment to 1 by 1 after two writes.
    STA reg_ppu_vmainc.w                                                        ; $00AD08 |/
    JSR _init_dma_bank_0_to_vram                                                ; $00AD0B |\
    LDA #%00000001.b                                                            ; $00AD0E | | Configure DMA channel zero to copy from bank 0 to VRAM.
    STA reg_cpu_dmap0.w                                                         ; $00AD10 |/
    LDX <r_generic_tmp_index                                                    ; $00AD13 |\ Set the VRAM address to the passed parameter address.
    STX reg_ppu_vmadd.w                                                         ; $00AD15 |/
    LDX #bank14.tilemap_yes_no_dialog_data.w + (8 * 2 * 7)                      ; $00AD18 |\ Set the source address to the eighth line of tiles in the yes/no
    STX reg_cpu_a1t0.w                                                          ; $00AD1B |/ dialog tilemap data, which is blank tiles.
    LDA #:bank14.tilemap_yes_no_dialog_data.b                                   ; $00AD1E |\ Set the source bank to $14.
    STA reg_cpu_a1b0.w                                                          ; $00AD20 |/
    LDX #16.w                                                                   ; $00AD23 |\ Configure the DMA to copy eight tiles.
    STX reg_cpu_das0.w                                                          ; $00AD26 |/
    JSR _enable_dma_0                                                           ; $00AD29 | Execute the DMA.
    RTS                                                                         ; $00AD2C

; _lower_dialog_select_item ($00:AD2D)
;
; Displays and executes the item selection interface on the lower dialog. The
; chosen item is stored in $08FB. The value is $FF if no item was chosen.
; Otherwise, it was the selected item ID.
_lower_dialog_select_item:
-   LDA <r_player_field_sprite_dirty                                            ; $00AD2D |\ Loop until the player field sprite is no longer dirty.
    BNE -                                                                       ; $00AD2F |/
    LDA #1.b                                                                    ; $00AD31 |\ Set the lower dialog height to 1.
    STA <r_lower_dialog_height                                                  ; $00AD33 |/
    STA <r_dialog_pending                                                       ; $00AD35 | Flag a dialog as pending.
    STZ <r_dialog_scroll_index                                                  ; $00AD37 | Set the dialog scroll index to zero.
    STZ <r_dialog_cursor_coordinates.x                                          ; $00AD39 |\ Set the dialog cursor coordinates to zero.
    STZ <r_dialog_cursor_coordinates.y                                          ; $00AD3B |/
    LDA #112.b                                                                  ; $00AD3D |\ Set the vertical scroll value to 112 (to align the text with the
    STA <r_dialog_vertical_scroll                                               ; $00AD3F |/ lower dialog window).
    JSR _init_lower_dialog_inventory                                            ; $00AD41 | Initialize the lower dialog inventory.
    JSR _wait_for_nmi_complete_field                                            ; $00AD44 | Wait for the next frame.
    JSR _update_lower_dialog_text_inventory                                     ; $00AD47 | Update the lower dialog based on the inventory.
--  JSR _wait_for_nmi_complete_field                                            ; $00AD4A | Wait for the next frame.
-   LDA <r_irq_index                                                            ; $00AD4D |\
    CMP #2.b                                                                    ; $00AD4F | | Wait for the second IRQ to finish.
    BNE -                                                                       ; $00AD51 |/
    INC <r_lower_dialog_height                                                  ; $00AD53 |\
    LDA <r_lower_dialog_height                                                  ; $00AD55 | | Increment the dialog height and wait until it reaches maximum.
    CMP #8.b                                                                    ; $00AD57 | |
    BNE --                                                                      ; $00AD59 |/
@loop_start:
    JSR _wait_for_nmi_complete_field                                            ; $00AD5B | Wait for the next frame.
@loop_start_no_frame_wait:
    LDA #1.b                                                                    ; $00AD5E |\ Set the NMI status flag.
    STA <r_nmi_status                                                           ; $00AD60 |/
    LDA <r_joypad_pressed_hi                                                    ; $00AD62 |\
    AND #JOYPAD_H_B.b                                                           ; $00AD64 | | If the B button is being pressed, play the cursor sound effect,
    BEQ +                                                                       ; $00AD66 | | set the current item to $FF to signal no item, close the dialog
    JSR _play_cursor_sound_effect                                               ; $00AD68 | | and return.
    LDA #$FF.b                                                                  ; $00AD6B | |
    STA r_current_item.w                                                        ; $00AD6D | |
    JMP _close_lower_dialog                                                     ; $00AD70 |/
+   LDA <r_joypad_pressed_lo                                                    ; $00AD73 |\
    AND #JOYPAD_L_A.b                                                           ; $00AD75 | | Skip the next block unless the A button is pressed.
    BEQ +                                                                       ; $00AD77 |/
    JSR _play_cursor_sound_effect                                               ; $00AD79 | Play the cursor sound effect.
    LDA <r_dialog_scroll_index                                                  ; $00AD7C |\
    CLC                                                                         ; $00AD7E | | Calculate the inventory offset for the selected item, by taking
    ADC <r_dialog_cursor_coordinates.y                                          ; $00AD7F | | the scroll index, adding the Y coordinate, multiplying by two (as
    ASL A                                                                       ; $00AD81 | | there are two items on each row), adding the X coordinate, and
    CLC                                                                         ; $00AD82 | | multiplying by two (as each entry has two bytes).
    ADC <r_dialog_cursor_coordinates.x                                          ; $00AD83 | |
    ASL A                                                                       ; $00AD85 | |
    TAX                                                                         ; $00AD86 |/
    LDA r_lower_dialog_inventory.1.id.w,X                                       ; $00AD87 |\ Transfer the associated item ID as the current item.
    STA r_current_item.w                                                        ; $00AD8A |/
    JMP _close_lower_dialog                                                     ; $00AD8D | Close the dialog and return.
+   LDA <r_joypad_pressed_hi                                                    ; $00AD90 |\
    AND #JOYPAD_H_RIGHT.b                                                       ; $00AD92 | | Skip this next block unless the right d-pad button is pressed.
    BEQ +                                                                       ; $00AD94 |/
    JSR _play_cursor_sound_effect_and_delay                                     ; $00AD96 | Play the cursor sound effect and add a short delay.
    INC <r_dialog_cursor_erase_pending                                          ; $00AD99 | Flag the current cursor to be erased.
    LDA <r_dialog_cursor_coordinates.x                                          ; $00AD9B |\
    INC A                                                                       ; $00AD9D | | Increment the X coordinate and take it mod 2.
    AND #%00000001.b                                                            ; $00AD9E | |
    STA <r_dialog_cursor_coordinates.x                                          ; $00ADA0 |/
    BNE @loop_start                                                             ; $00ADA2 | If the result was 1, branch back to the start of the loop.
    LDA <r_dialog_cursor_coordinates.y                                          ; $00ADA4 |\
    CMP #3.b                                                                    ; $00ADA6 | | If the Y coordinate is 3, branch to scroll down.
    BEQ @scroll_down                                                            ; $00ADA8 |/
    INC A                                                                       ; $00ADAA |\
    STA <r_dialog_cursor_coordinates.y                                          ; $00ADAB | | Otherwise, increment the Y coordinate and branch to the start.
    JMP @loop_start                                                             ; $00ADAD |/
+   LDA <r_joypad_pressed_hi                                                    ; $00ADB0 |\
    AND #JOYPAD_H_LEFT.b                                                        ; $00ADB2 | | Skip this next section less the left d-pad is pressed.
    BEQ +                                                                       ; $00ADB4 |/
    JSR _play_cursor_sound_effect_and_delay                                     ; $00ADB6 | Play the cursor sound effect and add a short delay.
    INC <r_dialog_cursor_erase_pending                                          ; $00ADB9 | Flag the cursor for erasure.
    LDA <r_dialog_cursor_coordinates.x                                          ; $00ADBB |\
    DEC A                                                                       ; $00ADBD | | Decrement the X coordinate by one and take the result mod two.
    AND #%00000001.b                                                            ; $00ADBE | |
    STA <r_dialog_cursor_coordinates.x                                          ; $00ADC0 |/
    BEQ @loop_start                                                             ; $00ADC2 | If the result is now zero, branch back to the next loop.
    LDA <r_dialog_cursor_coordinates.y                                          ; $00ADC4 |\ If the Y coordinate is zero, branch to scroll up.
    BEQ @scroll_up                                                              ; $00ADC6 |/
    DEC A                                                                       ; $00ADC8 |\
    STA <r_dialog_cursor_coordinates.y                                          ; $00ADC9 | | Otherwise, decrement the Y coordinate and branch to the next loop.
    JMP @loop_start                                                             ; $00ADCB |/
+   LDA <r_dialog_cursor_coordinates.y                                          ; $00ADCE |\
    CMP #3.b                                                                    ; $00ADD0 | | If the Y coordinate is currently 3 and the down button is pressed,
    BNE +                                                                       ; $00ADD2 | | branch to scroll down. If the down button is not pressed, branch
    LDA <r_joypad_pressed_hi                                                    ; $00ADD4 | | ahead to the section that checks the up button.
    AND #JOYPAD_H_DOWN.b                                                        ; $00ADD6 | |
    BEQ ++                                                                      ; $00ADD8 | |
    JMP @scroll_down                                                            ; $00ADDA |/
+   LDA <r_joypad_repeat_hi                                                     ; $00ADDD |\
    AND #JOYPAD_H_DOWN.b                                                        ; $00ADDF | | If the Y coordinate is not 3 and the down button is pressed,
    BEQ ++                                                                      ; $00ADE1 | | increment the Y coordinate, set the cursor erase flag, play the
    INC <r_dialog_cursor_coordinates.y                                          ; $00ADE3 | | cursor sound effect, and jump back to the next loop.
    INC <r_dialog_cursor_erase_pending                                          ; $00ADE5 | |
    JSR _play_cursor_sound_effect_and_delay                                     ; $00ADE7 | |
    JMP @loop_start                                                             ; $00ADEA |/
@scroll_down:
    LDA <r_dialog_scroll_index                                                  ; $00ADED |\
    CMP #17.b                                                                   ; $00ADEF | | If the scroll index is already 17, ignore the scroll and jump back
    BNE +                                                                       ; $00ADF1 | | to the next loop.
    JMP @loop_start                                                             ; $00ADF3 |/  BUG: This should probably be 20, not 17.
+   INC <r_dialog_cursor_erase_pending                                          ; $00ADF6 | Flag the cursor for erasure.
    INC <r_dialog_scroll_index                                                  ; $00ADF8 | Increment the scroll index.
    JSR _play_cursor_sound_effect                                               ; $00ADFA | Play the cursor sound effect.
    JSR _update_lower_dialog_text_inventory                                     ; $00ADFD | Update the dialog text for the new scroll index.
    JSR _scroll_dialog_down_one_row                                             ; $00AE00 | Scroll the dialog down one row, which takes a few frames.
    JMP @loop_start_no_frame_wait                                               ; $00AE03 | Loop back to the next iteration, without waiting a frame.
++  LDA <r_dialog_cursor_coordinates.y                                          ; $00AE06 |\
    BNE +                                                                       ; $00AE08 | | If the Y coordinate is currently zero and up is pressed, jump to
    LDA <r_joypad_pressed_hi                                                    ; $00AE0A | | scroll up.
    AND #JOYPAD_H_UP.b                                                          ; $00AE0C | |
    BEQ ++                                                                      ; $00AE0E | |
    JMP @scroll_up                                                              ; $00AE10 |/
+   LDA <r_joypad_repeat_hi                                                     ; $00AE13 |\
    AND #JOYPAD_H_UP.b                                                          ; $00AE15 | | If up is not pressed, skip to the end, which loops back.
    BEQ ++                                                                      ; $00AE17 |/
    DEC <r_dialog_cursor_coordinates.y                                          ; $00AE19 | Decrement the Y coordinate.
    INC <r_dialog_cursor_erase_pending                                          ; $00AE1B | Flag the cursor for erasure.
    JSR _play_cursor_sound_effect_and_delay                                     ; $00AE1D | Play the cursor sound effect and delay.
    JMP @loop_start                                                             ; $00AE20 | Jump back to the next iteration.
@scroll_up:
    LDA <r_dialog_scroll_index                                                  ; $00AE23 |\
    BNE +                                                                       ; $00AE25 | | If the scroll index is already zero, loop back to the next loop.
    JMP @loop_start                                                             ; $00AE27 |/
+   INC <r_dialog_cursor_erase_pending                                          ; $00AE2A | Flag the cursor for erasure.
    DEC <r_dialog_scroll_index                                                  ; $00AE2C | Decrement the scroll index.
    JSR _play_cursor_sound_effect                                               ; $00AE2E | Play the cursor sound effect.
    JSR _update_lower_dialog_text_inventory                                     ; $00AE31 | Update the dialog text for the new scroll index.
    JSR _scroll_dialog_up_one_row                                               ; $00AE34 | Scroll the dialog up one row, which takes several frames.
    JMP @loop_start_no_frame_wait                                               ; $00AE37 | Jump back to the start, not waiting a frame.
++  JMP @loop_start                                                             ; $00AE3A

; _close_lower_dialog ($00:AE3D)
;
; Closes the lower dialog.
_close_lower_dialog:
--  JSR _wait_for_nmi_complete_field                                            ; $00AE3D | Wait for the next frame.
-   LDA <r_irq_index                                                            ; $00AE40 |\
    CMP #2.b                                                                    ; $00AE42 | | Wait for the second IRQ to pass.
    BNE -                                                                       ; $00AE44 |/
    DEC <r_lower_dialog_height                                                  ; $00AE46 |\
    LDA <r_lower_dialog_height                                                  ; $00AE48 | | Decrement the lower dialog height and loop until it reaches zero.
    CMP #0.b                                                                    ; $00AE4A | |
    BNE --                                                                      ; $00AE4C |/
    LDA #1.b                                                                    ; $00AE4E |\ Set the dialog erase pending flag.
    STA <r_dialog_erase_pending                                                 ; $00AE50 |/
    STZ <r_lower_dialog_height                                                  ; $00AE52 | Explicitly set the lower dialog height to zero.
    RTS                                                                         ; $00AE54

; _play_cursor_sound_effect ($00:AE55)
;
; Plays a cursor sound effect.
_play_cursor_sound_effect:
    LDA #AUDIO_MODE_EFFECT_CURSOR.b                                             ; $00AE55 |\
    STA r_play_audio_arg_mode.w                                                 ; $00AE57 | | Play the cursor sound effect.
    JSL bank04.play_audio                                                       ; $00AE5A |/
    RTS                                                                         ; $00AE5E

; _play_cursor_sound_effect_and_delay ($00:AE5F)
;
; Plays a cursor sound effect and waits seven frames before returning.
_play_cursor_sound_effect_and_delay:
    JSR _play_cursor_sound_effect                                               ; $00AE5F | Play the cursor sound effect.
    LDA #7.b                                                                    ; $00AE62 |\
    STA <r_generic_frame_counter                                                ; $00AE64 | | Wait for seven frames before returning.
-   JSR _wait_for_nmi_complete_field                                            ; $00AE66 | |
    DEC <r_generic_frame_counter                                                ; $00AE69 | |
    BNE -                                                                       ; $00AE6B |/
    RTS                                                                         ; $00AE6D

; _scroll_dialog_up_one_row ($00:AE6E)
;
; Scrolls the currently open dialog by one row upward by decrementing the dialog
; vertical scroll value in $06BB by 16.
_scroll_dialog_up_one_row:
    LDA #8.b                                                                    ; $00AE6E |\ Initialize the counter to 8.
    STA <r_generic_tmp_2                                                        ; $00AE70 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00AE72 | Wait for the next frame.
    DEC <r_dialog_vertical_scroll                                               ; $00AE75 |\ Decrement the dialog vertical scroll by two.
    DEC <r_dialog_vertical_scroll                                               ; $00AE77 |/
    DEC <r_generic_tmp_2                                                        ; $00AE79 |\ Decrement the count and loop until it reaches zero.
    BNE -                                                                       ; $00AE7B |/
    RTS                                                                         ; $00AE7D

; _scroll_dialog_down_one_row ($00:AE7E)
;
; Scrolls the currently open dialog by one row downward by incrementing the
; dialog vertical scroll value in $06BB by 16.
_scroll_dialog_down_one_row:
    LDA #8.b                                                                    ; $00AE7E |\ Initialize the counter to 8.
    STA <r_generic_tmp_2                                                        ; $00AE80 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00AE82 | Wait for the next frame.
    INC <r_dialog_vertical_scroll                                               ; $00AE85 |\ Increment the dialog vertical scroll by two.
    INC <r_dialog_vertical_scroll                                               ; $00AE87 |/
    DEC <r_generic_tmp_2                                                        ; $00AE89 |\ Decrement the count and loop until it reaches zero.
    BNE -                                                                       ; $00AE8B |/
    RTS                                                                         ; $00AE8D

; _set_lower_dialog_timer ($00:AE8E)
;
; Sets the timer IRQ to trigger for the lower dialog and sets the initial values
; for the scroll registers to display the dialog on the lower half of the
; screen. It also increments the dialog frame counter in $08F6.
_set_lower_dialog_timer:
    LDX #$008F.w                                                                ; $00AE8E |\ Set the vertical timer IRQ to trigger at line $8F.
    STX reg_cpu_vtimel                                                          ; $00AE91 |/
    LDA #%10100001.b                                                            ; $00AE94 |\ Enable NMI, vertical timer IRQ, and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00AE96 |/
    STZ reg_ppu_bg3h0fs                                                         ; $00AE99 |\ Set the BG3 horizontal scroll register to zero.
    STZ reg_ppu_bg3h0fs                                                         ; $00AE9C |/
    LDA #$88.b                                                                  ; $00AE9F |\
    STA reg_ppu_bg3v0fs                                                         ; $00AEA1 | | Set the BG3 vertical scroll register to $88.
    STZ reg_ppu_bg3v0fs                                                         ; $00AEA4 |/
    STZ <r_irq_index                                                            ; $00AEA7 | Zero out the IRQ index as the IRQ has been reset.
    LDX r_dialog_frame_counter.w                                                ; $00AEA9 |\
    INX                                                                         ; $00AEAC | | Increment the dialog frame counter.
    STX r_dialog_frame_counter.w                                                ; $00AEAD |/
    RTS                                                                         ; $00AEB0

; _lower_dialog_irq_handler ($00:AEB1)
;
; Handles the IRQs for the lower dialog. Sets the BG3 scroll registers to draw
; the inner part of the dialog and then sets the registers to draw the bottom of
; the dialog.
_lower_dialog_irq_handler:
    LDA <r_irq_index                                                            ; $00AEB1 |\ Check if this is the first or second IRQ.
    BNE @second_irq                                                             ; $00AEB3 |/
    LDA <r_lower_dialog_height                                                  ; $00AEB5 |\
    ASL A                                                                       ; $00AEB7 | | Based on the height of the dialog, calculate when to trigger the
    ASL A                                                                       ; $00AEB8 | | second IRQ.
    ASL A                                                                       ; $00AEB9 | |
    CLC                                                                         ; $00AEBA | |
    ADC #$90.b                                                                  ; $00AEBB | |
    STA reg_cpu_vtimel                                                          ; $00AEBD | |
    STZ reg_cpu_vtimeh                                                          ; $00AEC0 |/
    LDX #$0008.w                                                                ; $00AEC3 |\
-   DEX                                                                         ; $00AEC6 | | Loop for a few cycles.
    BNE -                                                                       ; $00AEC7 |/
    STZ reg_ppu_bg3h0fs                                                         ; $00AEC9 |\
    LDA #$01.b                                                                  ; $00AECC | | Set the BG3 horizontal scroll register to $100.
    STA reg_ppu_bg3h0fs                                                         ; $00AECE |/
    LDA <r_dialog_vertical_scroll                                               ; $00AED1 |\
    STA reg_ppu_bg3v0fs                                                         ; $00AED3 | | Set the BG3 vertical scroll register to the value in $06BB.
    STZ reg_ppu_bg3v0fs                                                         ; $00AED6 |/
    RTS                                                                         ; $00AED9
@second_irq:
    LDX #$0008.w                                                                ; $00AEDA |\
-   DEX                                                                         ; $00AEDD | | Loop for a few cycles.
    BNE -                                                                       ; $00AEDE |/
    STZ reg_ppu_bg3h0fs                                                         ; $00AEE0 |\ Set the BG3 horizontal scroll register to zero.
    STZ reg_ppu_bg3h0fs                                                         ; $00AEE3 |/
    LDA <r_lower_dialog_height                                                  ; $00AEE6 |\
    ASL A                                                                       ; $00AEE8 | | Based on the dialog height, calculate the value for the BG3
    ASL A                                                                       ; $00AEE9 | | vertical scroll register.
    ASL A                                                                       ; $00AEEA | |
    EOR #$FF.b                                                                  ; $00AEEB | |
    CLC                                                                         ; $00AEED | |
    ADC #$89.b                                                                  ; $00AEEE | |
    STA reg_ppu_bg3v0fs                                                         ; $00AEF0 | |
    STZ reg_ppu_bg3v0fs                                                         ; $00AEF3 |/
    LDA #%10000001.b                                                            ; $00AEF6 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00AEF8 |/
    RTS                                                                         ; $00AEFB

; _draw_dialog_cursor ($00:AEFC)
;
; Checks the value in $E7, which if set, causes the function to clear the
; existing dialog cursor. Afterward, regardless of the value of $E7, draws
; the dialog cursor in the correct location.
_draw_dialog_cursor:
    LDA <r_lower_dialog_height                                                  ; $00AEFC |\
    CMP #$08.b                                                                  ; $00AEFE | | Only execute this function if the lower dialog is at full height
    BEQ +                                                                       ; $00AF00 | | of eight inner tiles.
    RTS                                                                         ; $00AF02 |/
+   LDA #%10000000.b                                                            ; $00AF03 |\
    STA reg_ppu_vmainc                                                          ; $00AF05 | | Erase the existing cursor by drawing a blank tile to its stored
    LDA <r_dialog_cursor_erase_pending                                          ; $00AF08 | | VRAM location.
    BEQ +                                                                       ; $00AF0A | |
    LDX <r_dialog_cursor_vram_address                                           ; $00AF0C | |
    STX reg_ppu_vmadd                                                           ; $00AF0E | |
    STZ <r_dialog_cursor_erase_pending                                          ; $00AF11 | |
    LDA #$FF.b                                                                  ; $00AF13 | |
    STA reg_ppu_vmdatal_write                                                   ; $00AF15 | |
    LDA #$20.b                                                                  ; $00AF18 | |
    STA reg_ppu_vmdatah_write                                                   ; $00AF1A |/
+   LDA <r_dialog_scroll_index                                                  ; $00AF1D |\
    CLC                                                                         ; $00AF1F | | Calculate the VRAM address where the cursor should be placed. The
    ADC <r_dialog_cursor_coordinates.y                                          ; $00AF20 | | base address is $2923, which is position 3, 1 on the second half
    STA <r_draw_dialog_cursor_tmp_hi                                            ; $00AF22 | | of BG3. The row offset is calculated as the scroll index plus the
    STZ <r_draw_dialog_cursor_tmp_lo                                            ; $00AF24 | | Y coordinate of the cursor, which is multiplied by 64. This
    LSR <r_draw_dialog_cursor_tmp_hi                                            ; $00AF26 | | increases the address by two rows of tiles. Finally, if the X
    ROR <r_draw_dialog_cursor_tmp_lo                                            ; $00AF28 | | coordinate is 1, an additional 13 is added to the address to point
    LSR <r_draw_dialog_cursor_tmp_hi                                            ; $00AF2A | | at the right column.
    ROR <r_draw_dialog_cursor_tmp_lo                                            ; $00AF2C | |
    LDA <r_dialog_cursor_coordinates.x                                          ; $00AF2E | |
    BEQ +                                                                       ; $00AF30 | |
    LDA #$0D.b                                                                  ; $00AF32 | |
+   CLC                                                                         ; $00AF34 | |
    ADC #$23.b                                                                  ; $00AF35 | |
    ADC <r_draw_dialog_cursor_tmp_lo                                            ; $00AF37 | |
    STA <r_draw_dialog_cursor_tmp_lo                                            ; $00AF39 | |
    LDA <r_draw_dialog_cursor_tmp_hi                                            ; $00AF3B | |
    AND #$03.b                                                                  ; $00AF3D | |
    CLC                                                                         ; $00AF3F | |
    ADC #$2C.b                                                                  ; $00AF40 | |
    STA <r_draw_dialog_cursor_tmp_hi                                            ; $00AF42 |/
    LDX <r_draw_dialog_cursor_tmp                                               ; $00AF44 |\
    STX <r_dialog_cursor_vram_address                                           ; $00AF46 | | Draw the hand icon to the calculated cursor VRAM address, and
    STX reg_ppu_vmadd                                                           ; $00AF48 | | store the address for future use.
    LDA #$14.b                                                                  ; $00AF4B | |
    STA reg_ppu_vmdatal_write                                                   ; $00AF4D | |
    LDA #$20.b                                                                  ; $00AF50 | |
    STA reg_ppu_vmdatah_write                                                   ; $00AF52 |/
    RTS                                                                         ; $00AF55

; _draw_lower_dialog_text_if_pending ($00:AF56)
;
; Only draws text if $E6 is non-zero. If so, draws the text at $0774 to the
; lower dialog. Always checks to see if the dialog cursor needs to be drawn.
;
; The Japanese version differs from the USA version slightly, as it maintains
; another pointer to the diacritic text, whereas the USA version simply reuses
; the address, as it's always blank.
_draw_lower_dialog_text_if_pending:
    LDA <r_lower_dialog_text_pending                                            ; $00AF56 |\
    BNE +                                                                       ; $00AF58 | | Check if there is lower dialog text pending. If so, continue with
    JSR _draw_dialog_cursor                                                     ; $00AF5A | | the function. Otherwise, call the routine to draw the cursor and
    RTS                                                                         ; $00AF5D | | return.
+   STZ <r_lower_dialog_text_pending                                            ; $00AF5E |/
    LDA <r_dialog_scroll_index                                                  ; $00AF60 |\
    AND #%00001111.b                                                            ; $00AF62 | | Calculate the starting VRAM address. The lower four bits of the
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00AF64 | | scroll index are multiplied by 64 (two rows of tiles per index).
    STZ <r_draw_dialog_text_vram_address_lo                                     ; $00AF66 | | This is subsequently added to $2C04 to determine the final
    LSR <r_draw_dialog_text_vram_address_hi                                     ; $00AF68 | | location.
    ROR <r_draw_dialog_text_vram_address_lo                                     ; $00AF6A | |
    LSR <r_draw_dialog_text_vram_address_hi                                     ; $00AF6C | |
    ROR <r_draw_dialog_text_vram_address_lo                                     ; $00AF6E | |
    LDA <r_draw_dialog_text_vram_address_lo                                     ; $00AF70 | |
    CLC                                                                         ; $00AF72 | |
    ADC #$04.b                                                                  ; $00AF73 | |
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00AF75 | |
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00AF77 | |
    AND #%00000011.b                                                            ; $00AF79 | |
    CLC                                                                         ; $00AF7B | |
    ADC #$2C.b                                                                  ; $00AF7C | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00AF7E |/
    LDX #r_dialog_text.w                                                        ; $00AF80 |\ Set the dialog text base to the dialog text address.
    STX <r_draw_dialog_text_base                                                ; $00AF83 |/
.if FF4_REGION == "JAPAN"
    LDX #r_dialog_text_diacritic.w                                              ; $00B1A5 |\ For the Japanese version, save the offset to the diacritic text to
    STX <r_generic_japan_tmp_index                                              ; $00B1A8 |/ a temporary variable.
.endif
    STZ reg_ppu_vmainc                                                          ; $00AF85 |\  Set the initial parameters of the DMA. Copy from bank 0 and write
    JSR _init_dma_bank_0_to_vram                                                ; $00AF88 | | to VRAM 1 by 1, incrementing after writing the low byte. Write
    STZ reg_cpu_dmap0                                                           ; $00AF8B |/  one address.
    LDA #$04.b                                                                  ; $00AF8E |\ Initialize the index to 4, as there are 4 rows of text to draw.
    STA <r_draw_dialog_text_lines                                               ; $00AF90 |/
@loop:
.if FF4_REGION == "JAPAN"
    LDX <r_generic_japan_tmp_index                                              ; $00B1B7 |\
.else                                                                           ;         | | Draw an entire row of blank tiles to start. The first row is a
    LDX #r_dialog_text_blank.w                                                  ; $00AF92 | | padding row in between actual rows.
.endif                                                                          ;         | |
    STX reg_cpu_a1t0                                                            ; $00AF95 | | The Japanese version here is actually drawing the diacritic row.
    LDX <r_draw_dialog_text_vram_address                                        ; $00AF98 | | The USA version doesn't use diacritics, so it is treated as simply
    STX reg_ppu_vmadd                                                           ; $00AF9A | | blank tiles.
    LDX #DIALOG_TEXT_WIDTH.w                                                    ; $00AF9D | |
    STX reg_cpu_das0                                                            ; $00AFA0 | |
    JSR _enable_dma_0                                                           ; $00AFA3 |/
    LDA <r_draw_dialog_text_vram_address_lo                                     ; $00AFA6 |\
    CLC                                                                         ; $00AFA8 | | Increment the VRAM address by 32, moving to the next row of tiles.
    ADC #$20.b                                                                  ; $00AFA9 | |
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00AFAB | |
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00AFAD | |
    ADC #$00.b                                                                  ; $00AFAF | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00AFB1 |/
    STZ reg_cpu_mdmaen                                                          ; $00AFB3 |\
    LDX <r_draw_dialog_text_base                                                ; $00AFB6 | | Draw the actual row of tiles, as the second row of each pair
    STX reg_cpu_a1t0                                                            ; $00AFB8 | | contains the text.
    LDX <r_draw_dialog_text_vram_address                                        ; $00AFBB | |
    STX reg_ppu_vmadd                                                           ; $00AFBD | |
    LDX #DIALOG_TEXT_WIDTH.w                                                    ; $00AFC0 | |
    STX reg_cpu_das0                                                            ; $00AFC3 | |
    JSR _enable_dma_0                                                           ; $00AFC6 |/
    LDA <r_draw_dialog_text_vram_address_lo                                     ; $00AFC9 |\
    CLC                                                                         ; $00AFCB | | Add 32 to the address again to prepare for the next row.
    ADC #$20.b                                                                  ; $00AFCC | |
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00AFCE | |
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00AFD0 | |
    ADC #$00.b                                                                  ; $00AFD2 | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00AFD4 |/
    SEC                                                                         ; $00AFD6 |\
    SBC #$30.b                                                                  ; $00AFD7 | | If the VRAM address is less than $3000, continue as normal.
    BCC +                                                                       ; $00AFD9 | | Otherwise, Reset the high byte to rotate back to the start
    AND #%00000011.b                                                            ; $00AFDB | | of the list.
    CLC                                                                         ; $00AFDD | |
    ADC #$2C.b                                                                  ; $00AFDE | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00AFE0 |/
+   LDA <r_draw_dialog_text_base_lo                                             ; $00AFE2 |\
    CLC                                                                         ; $00AFE4 | | Add the dialog width to the text base, to move to the next row of
    ADC #DIALOG_TEXT_WIDTH.b                                                    ; $00AFE5 | | text.
    STA <r_draw_dialog_text_base_lo                                             ; $00AFE7 | |
    LDA <r_draw_dialog_text_base_hi                                             ; $00AFE9 | |
    ADC #0.b                                                                    ; $00AFEB | |
    STA <r_draw_dialog_text_base_hi                                             ; $00AFED |/
.if FF4_REGION == "JAPAN"
    LDA <r_generic_japan_tmp_index.lo                                           ; $00B213 |\
    CLC                                                                         ; $00B215 | | For the Japanese version, update the offset for the diacritic row
    ADC #DIALOG_TEXT_WIDTH.b                                                    ; $00B216 | | to move to the next row by adding the dialog width.
    STA <r_generic_japan_tmp_index.lo                                           ; $00B218 | |
    LDA <r_generic_japan_tmp_index.hi                                           ; $00B21A | |
    ADC #0.b                                                                    ; $00B21C | |
    STA <r_generic_japan_tmp_index.hi                                           ; $00B21E |/
.endif
    DEC <r_draw_dialog_text_lines                                               ; $00AFEF |\
    BEQ +                                                                       ; $00AFF1 | | Loop until all four rows of text have been drawn.
    JMP @loop                                                                   ; $00AFF3 |/
+   JSR _draw_dialog_cursor                                                     ; $00AFF6 | Draw the dialog cursor.
    RTS                                                                         ; $00AFF9

; _update_lower_dialog_text_inventory ($00:AFFA)
;
; Given the current lower dialog scroll index, updates the lower dialog text
; area in memory with the items in the lower dialog inventory at that location.
_update_lower_dialog_text_inventory:
    LDX #0.w                                                                    ; $00AFFA |\
    LDA #TEXT_SPACE.b                                                           ; $00AFFD | | Initialize the dialog text area to all blank tiles.
-   STA r_lower_dialog_text.w,X                                                 ; $00AFFF | |
    INX                                                                         ; $00B002 | |
    CPX #_sizeof_r_lower_dialog_text.w                                          ; $00B003 | |
    BNE -                                                                       ; $00B006 |/
    LDA <r_dialog_scroll_index                                                  ; $00B008 |\
    ASL A                                                                       ; $00B00A | | Initialize the inventory index to the dialog scroll index times
    ASL A                                                                       ; $00B00B | | four.
    TAX                                                                         ; $00B00C | |
    STX <r_generic_tmp_index                                                    ; $00B00D |/
    LDY #0.w                                                                    ; $00B00F |\ Initialize the dialog text index to zero.
    STY <r_generic_tmp_index_2                                                  ; $00B012 |/
    LDA #8.b                                                                    ; $00B014 |\ Initialize the row count to eight.
    STA <r_generic_tmp_2                                                        ; $00B016 |/
@loop_start:
    LDX <r_generic_tmp_index                                                    ; $00B018 |\
    LDA r_lower_dialog_inventory.1.id.w,X                                       ; $00B01A | | If the next item slot is empty, branch to the end.
    BNE +                                                                       ; $00B01D |/
    JMP @done                                                                   ; $00B01F |\
+   STZ <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B022 | | Set the X register to the item ID times nine to index the item
    ASL A                                                                       ; $00B024 | | name data.
    ROL <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B025 | |
    ASL A                                                                       ; $00B027 | |
    ROL <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B028 | |
    ASL A                                                                       ; $00B02A | |
    ROL <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B02B | |
    CLC                                                                         ; $00B02D | |
    ADC r_lower_dialog_inventory.1.id.w,X                                       ; $00B02E | |
    STA <r_lower_dialog_inventory_tmp_index_lo                                  ; $00B031 | |
    LDA <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B033 | |
    ADC #0.b                                                                    ; $00B035 | |
    STA <r_lower_dialog_inventory_tmp_index_hi                                  ; $00B037 | |
    LDX <r_lower_dialog_inventory_tmp_index                                     ; $00B039 |/
.if FF4_REGION == "JAPAN"
    INX                                                                         ; $00B26C | For the Japanese version, increment the index to skip the icon.
.endif
    LDY <r_generic_tmp_index_2                                                  ; $00B03B | Set the Y register to the current dialog text index.
    LDA #DIALOG_ITEM_WIDTH.b                                                    ; $00B03D |\ Initialize the number of bytes to copy to 8 for the Japanese
    STA <r_generic_tmp_3                                                        ; $00B03F |/ version or 9 for the USA version.
-   LDA bank0F.item_name_data.l,X                                               ; $00B041 | Read the next character.
.if FF4_REGION == "JAPAN"
    JSR _dialog_get_diacritic_character                                         ; $00B277 | For the Japanese version, get the diacritic tile if appropriate.
.endif
    STA r_lower_dialog_text.w,Y                                                 ; $00B045 | Store the low byte into the dialog area.
.if FF4_REGION == "JAPAN"
    XBA                                                                         ; $00B27D |\
    STA r_dialog_text_diacritic.w,Y                                             ; $00B27E | | For the Japanese version, store the high byte into the diacritic
    LDA #0.b                                                                    ; $00B281 | | area, and then reset the high byte of the accumulator to zero.
    XBA                                                                         ; $00B283 |/
.endif
    INY                                                                         ; $00B048 |\
    INX                                                                         ; $00B049 | | Increment the indexes and loop until all characters have been
    DEC <r_generic_tmp_3                                                        ; $00B04A | | handled.
    BNE -                                                                       ; $00B04C |/
    LDY <r_generic_tmp_index_2                                                  ; $00B04E |\
    LDA #TEXT_COLON.b                                                           ; $00B050 | | Set the next tile after the item name to a colon.
    STA r_lower_dialog_text.w + DIALOG_ITEM_OFFSET_COLON,Y                      ; $00B052 |/
    LDX <r_generic_tmp_index                                                    ; $00B055 |\
    LDA r_lower_dialog_inventory.1.count.w,X                                    ; $00B057 | | Call a routine to convert the count of the item into tiles.
    STA <r_format_number_arg_lo                                                 ; $00B05A | |
    STZ <r_format_number_arg_md                                                 ; $00B05C | |
    STZ <r_format_number_arg_hi                                                 ; $00B05E | |
    JSL bank15.format_number                                                    ; $00B060 |/
    LDY <r_generic_tmp_index_2                                                  ; $00B064 |\
    LDA <r_format_number_result + 6                                             ; $00B066 | | Copy the last two digits of the result into the dialog text area.
    STA r_lower_dialog_text.w + DIALOG_ITEM_OFFSET_DIGIT_1,Y                    ; $00B068 | |
    LDA <r_format_number_result + 7                                             ; $00B06B | |
    STA r_lower_dialog_text.w + DIALOG_ITEM_OFFSET_DIGIT_2,Y                    ; $00B06D |/
    LDA <r_generic_tmp_2                                                        ; $00B070 |\
    AND #%00000001.b                                                            ; $00B072 | | Add 13 to the dialog index to move to the slot for the next item.
    BNE +                                                                       ; $00B074 | |
    LDA <r_generic_tmp_index_2                                                  ; $00B076 | | NOTE: The Japanese version adds 11 if currently examining a slot
    CLC                                                                         ; $00B078 | |       on the right side, but the USA version always adds 13.
    ADC #13.b                                                                   ; $00B079 | |
    STA <r_generic_tmp_index_2                                                  ; $00B07B | |
    JMP ++                                                                      ; $00B07D | |
+   LDA <r_generic_tmp_index_2                                                  ; $00B080 | |
    CLC                                                                         ; $00B082 | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    ADC #11.b                                                                   ; $00B2BF | |
.else                                                                           ;         | |
    ADC #13.b                                                                   ; $00B083 | |
.endif                                                                          ;         | |
    STA <r_generic_tmp_index_2                                                  ; $00B085 |/
++  LDX <r_generic_tmp_index                                                    ; $00B087 |\
    INX                                                                         ; $00B089 | | Increment the inventory offset to move to the next item.
    INX                                                                         ; $00B08A | |
    STX <r_generic_tmp_index                                                    ; $00B08B |/
    DEC <r_generic_tmp_2                                                        ; $00B08D |\
    BEQ @done                                                                   ; $00B08F | | Loop until eight items have been drawn.
    JMP @loop_start                                                             ; $00B091 |/
@done:
    LDA #1.b                                                                    ; $00B094 |\ Flag the lower dialog text as pending.
    STA <r_lower_dialog_text_pending                                            ; $00B096 |/
    RTS                                                                         ; $00B098

; _init_lower_dialog_inventory ($00:B099)
;
; Initializes the lower dialog inventory by iterating thorugh the main
; inventory, copying items within a certain range into the lower dialog
; inventory.
_init_lower_dialog_inventory:
    LDX #0.w                                                                    ; $00B099 |\
-   STZ r_lower_dialog_inventory.w,X                                            ; $00B09C | | Loop through any existing lower dialog inventory, replacing all
    INX                                                                         ; $00B09F | | entries with zero.
    CPX #_sizeof_r_lower_dialog_inventory.w                                     ; $00B0A0 | |
    BNE -                                                                       ; $00B0A3 |/
    LDX #0.w                                                                    ; $00B0A5 |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $00B0A8 |/
-   LDA r_inventory.1.id.w,X                                                    ; $00B0AB |\
    CMP #ITEM_FIRST_FIELD_ITEM.b                                                ; $00B0AE | | Skip this item if it's not in the proper range. It should be in
    BCC ++                                                                      ; $00B0B0 | | range of items that are usable in the field, excluding the summon
    CMP #ITEM_FIRST_SUMMON.b                                                    ; $00B0B2 | | items and the two special items (Sort and TrashCan).
    BCC +                                                                       ; $00B0B4 | |
    CMP #ITEM_FIRST_SUMMON.b + 4                                                ; $00B0B6 | |
    BCC ++                                                                      ; $00B0B8 | |
    CMP #ITEM_SORT.b                                                            ; $00B0BA | |
    BCS ++                                                                      ; $00B0BC |/
+   STA r_lower_dialog_inventory.1.id.w,Y                                       ; $00B0BE | Save the item ID to the lower dialog inventory.
    LDA r_inventory.1.count.w,X                                                 ; $00B0C1 |\ Transfer the count as well.
    STA r_lower_dialog_inventory.1.count.w,Y                                    ; $00B0C4 |/
    INY                                                                         ; $00B0C7 |\ Increment the lower dialog inventory offset.
    INY                                                                         ; $00B0C8 |/
++  INX                                                                         ; $00B0C9 |\
    INX                                                                         ; $00B0CA | | Whether skipped or not, increment the inventory offset and loop
    CPX #_sizeof_r_inventory.w                                                  ; $00B0CB | | until the entire inventory has been scanned.
    BNE -                                                                       ; $00B0CE |/
    RTS                                                                         ; $00B0D0

; _show_upper_dialog ($00:B0D1)
;
; Shows a series of dialog boxes based on the bank number set in $06DD and the
; offset set in $0772.
_show_upper_dialog:
-   LDA <r_player_field_sprite_dirty                                            ; $00B0D1 |\ Wait until any field sprite updates are complete.
    BNE -                                                                       ; $00B0D3 |/
    LDA #1.b                                                                    ; $00B0D5 |\
    STA <r_map_title_erase_pending                                              ; $00B0D7 | | Flag any map title to be erased and wait for that process to be
-   JSR _wait_for_nmi_complete_field                                            ; $00B0D9 | | complete.
    LDA <r_map_title_erase_pending                                              ; $00B0DC | |
    CMP #2.b                                                                    ; $00B0DE | |
    BNE -                                                                       ; $00B0E0 |/
    LDX #$0000.w                                                                ; $00B0E2 |\ Initialize the delay before being able to advance the dialog to
    STX r_dialog_delay_frames.w                                                 ; $00B0E5 |/ zero.
    STZ <r_dialog_close_mode                                                    ; $00B0E8 | Set the dialog closing mode to zero (do not close).
    LDA #$EC.b                                                                  ; $00B0EA |\ Set the vertical scroll to $EC, which puts the first line of dialog
    STA <r_dialog_vertical_scroll                                               ; $00B0EC |/ at the top of the dialog box.
    STZ <r_dialog_scroll_index                                                  ; $00B0EE | Set the scroll index to zero.
    JSR _load_dialog                                                            ; $00B0F0 | Load the first four lines of dialog.
    LDA #$01.b                                                                  ; $00B0F3 |\ Set the upper dialog height to 1.
    STA <r_upper_dialog_height                                                  ; $00B0F5 |/
    STA <r_dialog_pending                                                       ; $00B0F7 | Flag that a dialog is pending to be drawn.
--  JSR _wait_for_nmi_complete_field                                            ; $00B0F9 | Wait for the next frame.
-   LDA <r_irq_index                                                            ; $00B0FC |\
    CMP #$02.b                                                                  ; $00B0FE | | Wait until after the second IRQ handler.
    BNE -                                                                       ; $00B100 |/
    INC <r_upper_dialog_height                                                  ; $00B102 |\
    LDA <r_upper_dialog_height                                                  ; $00B104 | | Increase the dialog height and loop until it reaches 8.
    CMP #$08.b                                                                  ; $00B106 | |
    BNE --                                                                      ; $00B108 |/
@loop_start:
    LDX r_dialog_delay_frames.w                                                 ; $00B10A |\
    BEQ +                                                                       ; $00B10D | | Loop until any required delay set by the dialog has elapsed and
-   CPX r_dialog_frame_counter.w                                                ; $00B10F | | then zero the delay.
    BNE -                                                                       ; $00B112 | |
    LDX #$0000.w                                                                ; $00B114 | |
    STX r_dialog_delay_frames.w                                                 ; $00B117 | |
    JMP ++                                                                      ; $00B11A |/
+   LDA <r_dialog_close_mode                                                    ; $00B11D |\
    CMP #DIALOG_CLOSE_MODE_AUTO.b                                               ; $00B11F | | If the dialog is set to close automatically, branch to the end.
    BEQ @done                                                                   ; $00B121 |/
    LDA <r_dialog_prologue_scroll_enable                                        ; $00B123 |\ Skip waiting for joypad input if the prologue scrolling is enabled.
    BNE ++                                                                      ; $00B125 |/
    JSR _wait_for_joypad_clear                                                  ; $00B127 |\ Wait for the joypad to be clear followed by a button press.
    JSR _wait_for_joypad_press                                                  ; $00B12A |/
++  LDA <r_dialog_close_mode                                                    ; $00B12D |\ If the dialog is supposed to close, branch to the end.
    BNE @done                                                                   ; $00B12F |/
    JSR _load_dialog                                                            ; $00B131 | Fetch the next four lines of dialog.
    LDA #$10.b                                                                  ; $00B134 |\ Initialize the counter to 16.
    STA <r_show_upper_dialog_tmp                                                ; $00B136 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00B138 | Wait for the next frame.
    LDA <r_dialog_prologue_scroll_enable                                        ; $00B13B |\ Branch to different code if prologue scrolling is enabled.
    BNE +                                                                       ; $00B13D |/
    INC <r_dialog_vertical_scroll                                               ; $00B13F |\
    INC <r_dialog_vertical_scroll                                               ; $00B141 | | Increment the scroll by 4 pixels, so that after 16 cycles, four
    INC <r_dialog_vertical_scroll                                               ; $00B143 | | lines of text will have scrolled by.
    INC <r_dialog_vertical_scroll                                               ; $00B145 | |
    DEC <r_show_upper_dialog_tmp                                                ; $00B147 | |
    JMP ++                                                                      ; $00B149 |/
+   LDA <r_map_frame_counter                                                    ; $00B14C |\
    AND #%00000111.b                                                            ; $00B14E | | Alternately, if $06CB is set, increment the scroll by one pixel
    BNE ++                                                                      ; $00B150 | | every eight frames, and decrement the counter every 32 frames.
    INC <r_dialog_vertical_scroll                                               ; $00B152 | | The entire sequence will take 512 frames or roughly 8.5 seconds.
    LDA <r_map_frame_counter                                                    ; $00B154 | |
    AND #%00011111.b                                                            ; $00B156 | |
    BNE ++                                                                      ; $00B158 | |
    DEC <r_show_upper_dialog_tmp                                                ; $00B15A |/
++  LDA <r_show_upper_dialog_tmp                                                ; $00B15C |\
    BNE -                                                                       ; $00B15E | | Return to the start of the loop.
    JMP @loop_start                                                             ; $00B160 |/
@done:
    RTS                                                                         ; $00B163

; _close_upper_dialog ($00:B164)
;
; Closes the upper dialog incrementally by decreasing its height until it
; reaches zero and then flagging it for erasure.
_close_upper_dialog:
--  JSR _wait_for_nmi_complete_field                                            ; $00B164 | Wait for the next frame.
-   LDA <r_irq_index                                                            ; $00B167 |\
    CMP #2.b                                                                    ; $00B169 | | Wait until after the second IRQ handler.
    BNE -                                                                       ; $00B16B |/
    DEC <r_upper_dialog_height                                                  ; $00B16D |\
    LDA <r_upper_dialog_height                                                  ; $00B16F | | Decrease the dialog height until it reaches zero.
    CMP #0.b                                                                    ; $00B171 | |
    BNE --                                                                      ; $00B173 |/
    LDA #1.b                                                                    ; $00B175 |\ Flag the dialog for erasure.
    STA <r_dialog_erase_pending                                                 ; $00B177 |/
    JSR _wait_for_nmi_complete_field                                            ; $00B179 | Wait for another frame.
    STZ <r_upper_dialog_height                                                  ; $00B17C | Set the height to zero again.
    RTS                                                                         ; $00B17E

; _load_message_bank_0_offset ($00:B17F)
;
; Loads the bank and offset for a message in the map-specific dialog bank in
; bank $11.
_load_message_bank_0_offset:
    LDA r_map_id.w                                                              ; $00B17F |\
    STZ <r_generic_tmp_index.hi                                                 ; $00B182 | | Set the X register to the full map ID (map plane times 256 plus
    ASL A                                                                       ; $00B184 | | the map ID) times two.
    ROL <r_generic_tmp_index.hi                                                 ; $00B185 | |
    STA <r_generic_tmp_index.lo                                                 ; $00B187 | |
    LDA r_map_plane.w                                                           ; $00B189 | |
    BEQ +                                                                       ; $00B18C | |
    INC <r_generic_tmp_index.hi                                                 ; $00B18E | |
    INC <r_generic_tmp_index.hi                                                 ; $00B190 | |
+   LDX <r_generic_tmp_index                                                    ; $00B192 |/
    LDA bank11.map_dialog_offset_data.l + 0,X                                   ; $00B194 |\
    STA <r_generic_tmp_index.lo                                                 ; $00B198 | | Load the offset to map-specific dialog for this map and store it
    LDA bank11.map_dialog_offset_data.l + 1,X                                   ; $00B19A | | in the X register.
    STA <r_generic_tmp_index.hi                                                 ; $00B19E | |
    LDX <r_generic_tmp_index                                                    ; $00B1A0 |/
    LDA <r_show_message_id                                                      ; $00B1A2 |\ If the desired message index is zero, simply branch to near the
    BEQ +                                                                       ; $00B1A4 |/ end of the function as we already have the correct offset.
    TAY                                                                         ; $00B1A6 | Otherwise, transfer the message ID to the Y register as a counter.
-   INX                                                                         ; $00B1A7 |\
    LDA bank11.map_dialog_message_data.l,X                                      ; $00B1A8 | | Loop until finding the next zero.
    BNE -                                                                       ; $00B1AC |/
    LDA bank11.map_dialog_message_data.l - 1,X                                  ; $00B1AE |\
    CMP #DIALOG_OPCODE_PLAY_SONG.b                                              ; $00B1B2 | | If the previous byte was either of the opcodes that can take a
    BEQ -                                                                       ; $00B1B4 | | zero for a parameter, loop back to the next byte.
    LDA bank11.map_dialog_message_data.l - 1,X                                  ; $00B1B6 | |
    CMP #DIALOG_OPCODE_CHARACTER_NAME.b                                         ; $00B1BA | |
    BEQ -                                                                       ; $00B1BC |/
    DEY                                                                         ; $00B1BE |\ Repeat the above process until the desired message number is
    BNE -                                                                       ; $00B1BF |/ reached.
    INX                                                                         ; $00B1C1 | Increment the X register to point at the first byte.
+   STX r_load_dialog_index.w                                                   ; $00B1C2 | Store the offset in the result variable.
    STZ <r_load_dialog_bank                                                     ; $00B1C5 | Set the dialog bank to zero.
    RTS                                                                         ; $00B1C7

; _load_message_bank_1_lo_offset ($00:B1C8)
;
; Loads the bank and offset for a message in the lower half of the first bank
; of dialog data located in bank 10.
_load_message_bank_1_lo_offset:
    JSR _get_message_offset_index                                               ; $00B1C8 | Get the index to the offset.
    LDA bank10.dialog_offset_data.l,X                                           ; $00B1CB |\
    STA <r_generic_tmp_index.lo                                                 ; $00B1CF | | Load and set the target offset.
    LDA bank10.dialog_offset_data.l + 1,X                                       ; $00B1D1 | |
    STA <r_generic_tmp_index.hi                                                 ; $00B1D5 | |
    LDX <r_generic_tmp_index                                                    ; $00B1D7 | |
    STX r_load_dialog_index.w                                                   ; $00B1D9 |/
    LDA #$01.b                                                                  ; $00B1DC |\ Set the bank to $01.
    STA <r_load_dialog_bank                                                     ; $00B1DE |/
    RTS                                                                         ; $00B1E0

; _load_message_bank_1_hi_offset ($00:B1E1)
;
; Loads the bank and offset for a message in the upper half of bank 1 of dialog
; data, which is located in bank 10.
_load_message_bank_1_hi_offset:
    JSR _get_message_offset_index                                               ; $00B1E1 | Get the index to the offset.
    LDA bank10.dialog_offset_data.l + $0200,X                                   ; $00B1E4 |\
    STA <r_generic_tmp_index.lo                                                 ; $00B1E8 | | Load and set the target offset.
    LDA bank10.dialog_offset_data.l + $0201,X                                   ; $00B1EA | |
    STA <r_generic_tmp_index.hi                                                 ; $00B1EE | |
    LDX <r_generic_tmp_index                                                    ; $00B1F0 | |
    STX r_load_dialog_index.w                                                   ; $00B1F2 |/
    LDA #1.b                                                                    ; $00B1F5 |\ Set the bank to 1.
    STA <r_load_dialog_bank                                                     ; $00B1F7 |/
    RTS                                                                         ; $00B1F9

; _load_message_bank_2_offset ($00:B1FA)
;
; Loads the bank and offset for a message in bank 2 of dialog data, which is
; located in bank 13.
_load_message_bank_2_offset:
    JSR _get_message_offset_index                                               ; $00B1FA | Get the index to the offset.
    LDA bank13.dialog_offset_data.l,X                                           ; $00B1FD |\
    STA <r_generic_tmp_index.lo                                                 ; $00B201 | | Load and set the target offset.
    LDA bank13.dialog_offset_data.l + 1,X                                       ; $00B203 | |
    STA <r_generic_tmp_index.hi                                                 ; $00B207 | |
    LDX <r_generic_tmp_index                                                    ; $00B209 | |
    STX r_load_dialog_index.w                                                   ; $00B20B |/
    LDA #2.b                                                                    ; $00B20E |\ Set the bank to 2.
    STA <r_load_dialog_bank                                                     ; $00B210 |/
    RTS                                                                         ; $00B212

; _get_message_offset_index ($00:B213)
;
; Given a message ID in $06B2, returns the index to its offset data in the X
; register.
_get_message_offset_index:
    LDA <r_show_message_id                                                      ; $00B213 |\
    STZ <r_generic_tmp_index.hi                                                 ; $00B215 | | Calculate the offset by multiplying the desired message ID by two.
    ASL A                                                                       ; $00B217 | |
    ROL <r_generic_tmp_index.hi                                                 ; $00B218 | |
    STA <r_generic_tmp_index.lo                                                 ; $00B21A | |
    LDX <r_generic_tmp_index                                                    ; $00B21C |/
    RTS                                                                         ; $00B21E

; _load_dialog ($00:B21F)
;
; Given a dialog bank number in $06DD and an already calculated pointer to the
; desired dialog data within that bank in $0772, reads up to four lines of
; dialog and copies it to the dialog staging area in RAM, to be later copied to
; BG3 by another routine.
_load_dialog:
    LDY #$0000.w                                                                ; $00B21F |\ Initialize the Y register to zero.
    STY <r_generic_tmp_index                                                    ; $00B222 |/
-   JSR _load_dialog_character                                                  ; $00B224 |\
    CMP #DIALOG_OPCODE_END_MESSAGE.b                                            ; $00B227 | | If the next character is $00, jump to the handling function.
    BNE +                                                                       ; $00B229 | |
    JMP _load_dialog_opcode_end_message                                         ; $00B22B |/
+   CMP #DIALOG_OPCODE_END_LINE.b                                               ; $00B22E |\
    BNE +                                                                       ; $00B230 | | If the next character is $01, jump to the handling function.
.if FF4_REGION == "JAPAN"                                                       ;         | |
    JMP _load_dialog_opcode_new_line                                            ; $00B46E | | The USA version adds a new function to handle this effect, while
.else                                                                           ;         | | relegating the original code to opcode $09.
    JMP _load_dialog_opcode_end_line                                            ; $00B232 | |
.endif                                                                          ;         |/
+   CMP #DIALOG_OPCODE_INSERT_BLANKS.b                                          ; $00B235 |\
    BNE +                                                                       ; $00B237 | | If the next character is $02, jump to the handling function.
    JMP _load_dialog_opcode_insert_blanks                                       ; $00B239 |/
+   CMP #DIALOG_OPCODE_PLAY_SONG.b                                              ; $00B23C |\
    BNE +                                                                       ; $00B23E | | If the next character is $03, jump to the handling function.
    JMP _load_dialog_opcode_play_song                                           ; $00B240 |/
+   CMP #DIALOG_OPCODE_CHARACTER_NAME.b                                         ; $00B243 |\
    BNE +                                                                       ; $00B245 | | If the next character is $04, jump to the handling function.
    JMP _load_dialog_opcode_character_name                                      ; $00B247 |/
+   CMP #DIALOG_OPCODE_SET_DELAY.b                                              ; $00B24A |\
    BNE +                                                                       ; $00B24C | | If the next character is $05, jump to the handling function.
    JMP _load_dialog_opcode_set_delay                                           ; $00B24E |/
+   CMP #DIALOG_OPCODE_END_MESSAGE_AUTO.b                                       ; $00B251 |\
    BNE +                                                                       ; $00B253 | | If the next character is $06, jump to the handling function.
    JMP _load_dialog_opcode_end_message_auto                                    ; $00B255 |/
+   CMP #DIALOG_OPCODE_CURRENT_ITEM_NAME.b                                      ; $00B258 |\
    BNE +                                                                       ; $00B25A | | If the next character is $07, jump to the handling function.
    JMP _load_dialog_opcode_current_item_name                                   ; $00B25C |/
+   CMP #DIALOG_OPCODE_CURRENT_NUMBER.b                                         ; $00B25F |\
    BNE +                                                                       ; $00B261 | | If the next character is $08, jump to the handling function.
    JMP _load_dialog_opcode_current_number                                      ; $00B263 |/
.if FF4_REGION == "JAPAN"
+   CMP #$C3.b                                                                  ; $00B4A2 |\
    BNE +                                                                       ; $00B4A4 | | If the next character is $C3, jump to the handling function.
    JMP _load_dialog_opcode_ellipsis                                            ; $00B4A6 |/
+   JSR _dialog_get_diacritic_character                                         ; $00B4A9 |\
    STA r_dialog_text.w,Y                                                       ; $00B4AC | | For the Japanese version, get the associated diacritic character
    XBA                                                                         ; $00B4AF | | and set the character and diacritic in their respective areas in
    STA r_dialog_text_diacritic.w,Y                                             ; $00B4B0 | | memory.
    LDA #0.b                                                                    ; $00B4B3 | |
    XBA                                                                         ; $00B4B5 |/
.else
+   CMP #DIALOG_OPCODE_NEW_LINE.b                                               ; $00B266 |\
    BNE +                                                                       ; $00B268 | | If the next character is $09, jump to the handling function.
    JMP _load_dialog_opcode_new_line                                            ; $00B26A |/
+   CMP #DIALOG_OPCODE_SPACE.b                                                  ; $00B26D |\
    BEQ ++                                                                      ; $00B26F | | For the USA version, if the opcode is in the range $8A to $BF or
    CMP #$8A.b                                                                  ; $00B271 | | $CA to $FE, jump to the dual-tile decoder.
    BCC ++                                                                      ; $00B273 | |
    CMP #$C0.b                                                                  ; $00B275 | |
    BCC +                                                                       ; $00B277 | |
    CMP #$CA.b                                                                  ; $00B279 | |
    BCC ++                                                                      ; $00B27B | |
+   JMP _load_dialog_opcode_dte                                                 ; $00B27D |/
++  STA r_dialog_text.w,Y                                                       ; $00B280 | Otherwise, copy the byte directly and continue.
.endif
    LDY <r_generic_tmp_index                                                    ; $00B283 |\
    INY                                                                         ; $00B285 | | Increment the index to move to the next character.
    STY <r_generic_tmp_index                                                    ; $00B286 |/
_load_dialog_opcode_next:
    LDX r_load_dialog_index.w                                                   ; $00B288 |\
    INX                                                                         ; $00B28B | | Increment the index pointing to the dialog data being copied.
    STX r_load_dialog_index.w                                                   ; $00B28C |/
    LDY <r_generic_tmp_index                                                    ; $00B28F |\
    CPY #DIALOG_TEXT_WIDTH.w * 4                                                ; $00B291 | | Continue looping until all potential four lines of dialog have
    BEQ +                                                                       ; $00B294 | | been processed.
    JMP -                                                                       ; $00B296 |/
_load_dialog_opcode_done:
+   JSR _load_dialog_character                                                  ; $00B299 |\
    CMP #DIALOG_OPCODE_END_MESSAGE.b                                            ; $00B29C | | If the last processed character was a non-automatic end message,
    BNE +                                                                       ; $00B29E | | forcibly reset the dialog closing mode to manual.
    LDA #DIALOG_CLOSE_MODE_MANUAL.b                                             ; $00B2A0 | |
    STA <r_dialog_close_mode                                                    ; $00B2A2 |/
+   LDA #1.b                                                                    ; $00B2A4 |\ Flag the upper dialog as having text pending.
    STA <r_upper_dialog_text_pending                                            ; $00B2A6 |/
.if FF4_REGION == "USA"
    LDX #0.w                                                                    ; $00B2A8 |\
    LDA #TEXT_SPACE.b                                                           ; $00B2AB | | For the USA version, fill the blank dialog area with blank tiles.
-   STA r_dialog_text_blank.w,X                                                 ; $00B2AD | |
    INX                                                                         ; $00B2B0 | | BUG: If the NMI occurs during this time, the resulting text box may
    CPX #$0034.w                                                                ; $00B2B1 | |      end up blank, as the actual dialog flag has not yet been set.
    BNE -                                                                       ; $00B2B4 |/
.endif
    RTS                                                                         ; $00B2B6

; _load_dialog_character_next ($00:B2B7)
;
; Increments the dialog index and then falls through to the next function which
; fetches the character that location.
_load_dialog_character_next:
    LDX r_load_dialog_index.w                                                   ; $00B2B7
    INX                                                                         ; $00B2BA
    STX r_load_dialog_index.w                                                   ; $00B2BB

; _load_dialog_character ($00:B2BE)
;
; Given a bank number in $06DD and an index in $0772, reads a single byte from
; the appropriate dialog message data and returns it in the accumulator.
_load_dialog_character:
    LDX r_load_dialog_index.w                                                   ; $00B2BE | Load the index into the X register.
    LDA <r_load_dialog_bank                                                     ; $00B2C1 | Load the bank into the accumulator.
    BNE +                                                                       ; $00B2C3 |\
    LDA bank11.map_dialog_message_data.l,X                                      ; $00B2C5 | | If bank 0, read from $11:8300.
    JMP ++                                                                      ; $00B2C9 |/
+   CMP #$01.b                                                                  ; $00B2CC |\
    BNE +                                                                       ; $00B2CE | | If bank 1, read from $10:8400.
    LDA bank10.dialog_message_data.l,X                                          ; $00B2D0 | |
    JMP ++                                                                      ; $00B2D4 |/
+   LDA bank13.dialog_message_data.l,X                                          ; $00B2D7 | Otherwise, read from $13:A700.
++  RTS                                                                         ; $00B2DB

.if FF4_REGION == "JAPAN"
; _load_dialog_opcode_ellipsis ($00:B501)
;
; Handles dialog opcode $C3, which encodes an ellipsis. Converts the value into
; two separate tiles, in order to display a total of four dots. This function is
; exclusive to the Japanese version, and can be seen as a rudimentary precursor
; to the full DTE available in the USA version.
_load_dialog_opcode_ellipsis:
    XBA                                                                         ; $00B501 |\
    LDA #TEXT_SPACE.b                                                           ; $00B502 | | Set the high byte of the accumulator to $FF.
    XBA                                                                         ; $00B504 |/
    STA r_dialog_text.w,Y                                                       ; $00B505 |\ Copy the ellipsis byte twice to the destination.
    STA r_dialog_text.w + 1,Y                                                   ; $00B508 |/
    XBA                                                                         ; $00B50B |\
    STA r_dialog_text_diacritic.w,Y                                             ; $00B50C | | Copy the space byte twice to the diacritic data.
    STA r_dialog_text_diacritic.w + 1,Y                                         ; $00B50F |/
    LDA #0.b                                                                    ; $00B512 |\ Reset the high byte of the accumulator to zero.
    XBA                                                                         ; $00B514 |/
    LDY <r_generic_tmp_index                                                    ; $00B515 |\
    INY                                                                         ; $00B517 | | Increment and save the updated dialog text index.
    INY                                                                         ; $00B518 | |
    STY <r_generic_tmp_index                                                    ; $00B519 |/
    JMP _load_dialog_opcode_next                                                ; $00B51B

.else
; _load_dialog_opcode_dte ($00:B2DC)
;
; Handles opcodes in the ranges $8A to $BF and $CA to $FE, inclusive. These
; bytes are used to index a table in ROM which encodes values for two separate
; tiles. Therefore, each of these bytes actually decodes to two tiles.
;
; This routine only exists in the USA version, as the Japanese version did not
; support dual-tile encoding.
_load_dialog_opcode_dte:
    SEC                                                                         ; $00B2DC |\
    SBC #$80.b                                                                  ; $00B2DD | | Subtract $80 and multiply by two to determine the index.
    ASL A                                                                       ; $00B2DF | |
    TAX                                                                         ; $00B2E0 |/
    LDA bank13.dialog_dte_data.l,X                                              ; $00B2E1 |\
    STA r_dialog_text,Y                                                         ; $00B2E5 | | Load the next two bytes from the DTE table in ROM.
    INY                                                                         ; $00B2E8 | |
    LDA bank13.dialog_dte_data.l + 1,X                                          ; $00B2E9 | |
    STA r_dialog_text,Y                                                         ; $00B2ED | |
    INY                                                                         ; $00B2F0 |/
    STY <r_generic_tmp_index                                                    ; $00B2F1 | Save the updated dialog text index.
    JMP _load_dialog_opcode_next                                                ; $00B2F3
.endif

; _load_dialog_opcode_play_song ($00:B2F6)
;
; Handles dialog opcode $03, which plays the song identified in the next byte.
_load_dialog_opcode_play_song:
    JSR _load_dialog_character_next                                             ; $00B2F6 |\ Load the next character and set that as the desired track.
    STA r_play_audio_arg_track.w                                                ; $00B2F9 |/
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $00B2FC |\ Set the mode to play music.
    STA r_play_audio_arg_mode.w                                                 ; $00B2FE |/
    JSL bank04.play_audio                                                       ; $00B301 | Play the actual song.
    JMP _load_dialog_opcode_next                                                ; $00B305

; _load_dialog_opcode_character_name ($00:B308)
;
; Handles dialog opcode $04, which displays the name of the character referenced
; by the ID number given in the next byte. The Japanese version has some
; additional handling related to diacritics.
_load_dialog_opcode_character_name:
    JSR _load_dialog_character_next                                             ; $00B308 |\
    ASL A                                                                       ; $00B30B | | Load the next byte and use that as an index into the character
    STA <r_load_dialog_opcode_tmp_index_lo                                      ; $00B30C | | name data by multiplying by 6 (the size of a name).
    ASL A                                                                       ; $00B30E | |
    CLC                                                                         ; $00B30F | |
    ADC <r_load_dialog_opcode_tmp_index_lo                                      ; $00B310 | |
    STA <r_load_dialog_opcode_tmp_index_lo                                      ; $00B312 | |
    STZ <r_load_dialog_opcode_tmp_index_hi                                      ; $00B314 | |
    LDX <r_load_dialog_opcode_tmp_index                                         ; $00B316 |/
    LDY <r_generic_tmp_index                                                    ; $00B318 | Load the current index into the dialog data.
    STZ <r_load_dialog_opcode_tmp                                               ; $00B31A | Zero out the counter.
-   LDA r_character_names.w,X                                                   ; $00B31C |\
    CMP #$FF.b                                                                  ; $00B31F | | Load the character. If it's $FF, branch to the end.
    BEQ +                                                                       ; $00B321 |/
.if FF4_REGION == "JAPAN"
    JSR _dialog_get_diacritic_character                                         ; $00B54B | For the Japanese version, get the diacritic characters.
.endif
    STA r_dialog_text,Y                                                         ; $00B323 | Save it in the next spot in the dialog.
.if FF4_REGION == "JAPAN"
    XBA                                                                         ; $00B551 |\
    STA r_dialog_text_diacritic.w,Y                                             ; $00B552 | | For the Japanese version, write the diacritic tile to the correct
    LDA #0.b                                                                    ; $00B555 | | location and then zero the high byte of the accumulator.
    XBA                                                                         ; $00B557 |/
.endif
    INY                                                                         ; $00B326 |\
    INX                                                                         ; $00B327 | | Increment the counters and loop until up to six characters have
    INC <r_load_dialog_opcode_tmp                                               ; $00B328 | | been copied.
    LDA <r_load_dialog_opcode_tmp                                               ; $00B32A | |
    CMP #_sizeof_character_name.b                                               ; $00B32C | |
    BEQ +                                                                       ; $00B32E | |
    JMP -                                                                       ; $00B330 |/
+   STY <r_generic_tmp_index                                                    ; $00B333 | Update the dialog index.
    JMP _load_dialog_opcode_next                                                ; $00B335

; _load_dialog_opcode_current_item_name ($00:B338)
;
; Prints the name of the currently active item. This item is set by an event
; opcode. The Japanese version has additional handling related to diacritics.
_load_dialog_opcode_current_item_name:
    LDA r_current_item.w                                                        ; $00B338 |\
    STZ <r_load_dialog_opcode_tmp_index_hi                                      ; $00B33B | | Multiply the item index by nine to determine the offset into the
    ASL A                                                                       ; $00B33D | | item name data.
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B33E | |
    ASL A                                                                       ; $00B340 | |
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B341 | |
    ASL A                                                                       ; $00B343 | |
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B344 | |
    CLC                                                                         ; $00B346 | |
    ADC r_current_item.w                                                        ; $00B347 | |
    STA <r_load_dialog_opcode_tmp_index_lo                                      ; $00B34A | |
    LDA <r_load_dialog_opcode_tmp_index_hi                                      ; $00B34C | |
    ADC #0.b                                                                    ; $00B34E | |
    STA <r_load_dialog_opcode_tmp_index_hi                                      ; $00B350 | |
    LDX <r_load_dialog_opcode_tmp_index                                         ; $00B352 |/
.if FF4_REGION == "JAPAN"
    INX                                                                         ; $00B586 | For the Japanese version, skip the icon character.
.endif
    LDY <r_generic_tmp_index                                                    ; $00B354 | Load the dialog text index.
    LDA #DIALOG_ITEM_WIDTH.b                                                    ; $00B356 |\ Initialize the counter to 8 for the Japanese version and 9 for the
    STA <r_load_dialog_opcode_tmp                                               ; $00B358 |/ USA version (the Japanese version skips the icon character).
-   LDA bank0F.item_name_data.l,X                                               ; $00B35A |\
    CMP #$FF.b                                                                  ; $00B35E | | Skip to the end if encountering a blank space.
    BEQ +                                                                       ; $00B360 |/
.if FF4_REGION == "JAPAN"
    JSR _dialog_get_diacritic_character                                         ; $00B595 | For the Japanese version, get the diacritic characters.
.endif
    STA r_dialog_text,Y                                                         ; $00B362 | Store the main tile value to the text area.
.if FF4_REGION == "JAPAN"
    XBA                                                                         ; $00B59B |\
    STA r_dialog_text_diacritic.w,Y                                             ; $00B59C | | For the Japanese version, store the diacritic tile as well.
    LDA #0.b                                                                    ; $00B59F | |
    XBA                                                                         ; $00B5A1 |/
.endif
    INY                                                                         ; $00B365 |\
    STY <r_generic_tmp_index                                                    ; $00B366 | | Update the indexes and loop until all characters have been copied.
    INX                                                                         ; $00B368 | |
    DEC <r_load_dialog_opcode_tmp                                               ; $00B369 | |
    BNE -                                                                       ; $00B36B |/
+   JMP _load_dialog_opcode_next                                                ; $00B36D

; _load_dialog_opcode_current_number ($00:B370)
;
; Responds to opcode $08. Formats the 24-bit current number in $08F8 as a
; decimal number and copies it to the dialog. Note that only the last six digits
; will be printed. Any leading zeroes will also be ignored. The Japanese version
; has additional code to ensure the diacritic tiles are set to spaces.
_load_dialog_opcode_current_number:
    LDA r_current_number_lo.w                                                   ; $00B370 |\
    STA <r_format_number_arg_lo                                                 ; $00B373 | | Load the current number and format its decimal value.
    LDA r_current_number_md.w                                                   ; $00B375 | |
    STA <r_format_number_arg_md                                                 ; $00B378 | |
    LDA r_current_number_hi.w                                                   ; $00B37A | |
    STA <r_format_number_arg_hi                                                 ; $00B37D | |
    JSL bank15.format_number                                                    ; $00B37F |/
    LDX #$0000.w                                                                ; $00B383 |\
-   LDA <r_format_number_result + 2,X                                           ; $00B386 | | Loop until either the first non-zero value is found or five digits
    CMP #$80.b                                                                  ; $00B388 | | have been processed.
    BNE @next                                                                   ; $00B38A | |
    INX                                                                         ; $00B38C | |
    CPX #$0005.w                                                                ; $00B38D | |
    BEQ @next                                                                   ; $00B390 | |
    JMP -                                                                       ; $00B392 |/
@next:
-   LDA <r_format_number_result + 2,X                                           ; $00B395 |\
    STA r_dialog_text.w,Y                                                       ; $00B397 | | Copy the remaining values to the dialog area.
.if FF4_REGION == "JAPAN"                                                       ;         | |
    LDA #TEXT_SPACE.b                                                           ; $00B5D7 | |
    STA r_dialog_text_diacritic.w,Y                                             ; $00B5D9 | |
.endif                                                                          ;         | |
    INY                                                                         ; $00B39A | |
    INX                                                                         ; $00B39B | |
    CPX #$0006.w                                                                ; $00B39C | |
    BNE -                                                                       ; $00B39F |/
    STY <r_generic_tmp_index                                                    ; $00B3A1 | Update the dialog text index.
    JMP _load_dialog_opcode_next                                                ; $00B3A3

; _load_dialog_opcode_set_delay ($00:B3A6)
;
; Sets the delay before the dialog will be advanced. The number of frames is
; equal to the following byte times eight.
_load_dialog_opcode_set_delay:
    JSR _load_dialog_character_next                                             ; $00B3A6 |\
    STZ <r_load_dialog_opcode_tmp_index_hi                                      ; $00B3A9 | | Load the next byte and multiply it by eight to determine the
    ASL A                                                                       ; $00B3AB | | number of frames to delay.
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B3AC | |
    ASL A                                                                       ; $00B3AE | |
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B3AF | |
    ASL A                                                                       ; $00B3B1 | |
    ROL <r_load_dialog_opcode_tmp_index_hi                                      ; $00B3B2 | |
    STA <r_load_dialog_opcode_tmp_index_lo                                      ; $00B3B4 | |
    LDX <r_load_dialog_opcode_tmp_index                                         ; $00B3B6 | |
    STX r_dialog_delay_frames.w                                                 ; $00B3B8 |/
    LDX #$0000.w                                                                ; $00B3BB |\ Make sure the frame counter is set to zero.
    STX r_dialog_frame_counter.w                                                ; $00B3BE |/
    JMP _load_dialog_opcode_next                                                ; $00B3C1

; _load_dialog_opcode_insert_blanks ($00:B3C4)
;
; Inserts a number of blanks into the loaded dialog corresponding to the value
; of the next byte. THe Japanese version has extra code to handle the diacritic
; text.
_load_dialog_opcode_insert_blanks:
    JSR _load_dialog_character_next                                             ; $00B3C4 |\ Load the next character, and initialize the counter to that value.
    STA <r_load_dialog_opcode_tmp                                               ; $00B3C7 |/
    LDY <r_generic_tmp_index                                                    ; $00B3C9 | Load the current dialog index into the Y register.
    LDA #$FF.b                                                                  ; $00B3CB | Load $FF into the accumulator (blank tile).
-   STA r_dialog_text,Y                                                         ; $00B3CD |\
.if FF4_REGION == "JAPAN"                                                       ;         | | Write $FF into the dialog area until either limit is reached or
    STA r_dialog_text_diacritic.w,Y                                             ; $00B612 | | the desired number of blanks is written.
.endif                                                                          ;         | |
    INY                                                                         ; $00B3D0 | |
    CPY #DIALOG_TEXT_WIDTH.w * 4                                                ; $00B3D1 | |
    BEQ +                                                                       ; $00B3D4 | |
    DEC <r_load_dialog_opcode_tmp                                               ; $00B3D6 | |
    BNE -                                                                       ; $00B3D8 |/
+   STY <r_generic_tmp_index                                                    ; $00B3DA | Save the index back.
    JMP _load_dialog_opcode_next                                                ; $00B3DC

; _load_dialog_opcode_new_line ($00:B3DF)
;
; Handles dialog opcode $09, which moves to a new line, even if the cursor is
; already at the start of a line. Useful for creating blank lines, which $01
; cannot do. The USA version has been rewritten slightly to account for the
; changed text width and to use the accumulator instead of the Y register, but
; serves the same purpose.
_load_dialog_opcode_new_line:
.if FF4_REGION == "JAPAN"
    LDA #TEXT_SPACE.b                                                           ; $00B624 |\
-   STA r_dialog_text.w,Y                                                       ; $00B626 | | Loop until the next to be written character is a new line, filling
    STA r_dialog_text_diacritic.w,Y                                             ; $00B629 | | with blank tiles as we go.
    INY                                                                         ; $00B62C | |
    CPY #DIALOG_TEXT_WIDTH.w * 1                                                ; $00B62D | |
    BEQ +                                                                       ; $00B630 | |
    CPY #DIALOG_TEXT_WIDTH.w * 2                                                ; $00B632 | |
    BEQ +                                                                       ; $00B635 | |
    CPY #DIALOG_TEXT_WIDTH.w * 3                                                ; $00B637 | |
    BEQ +                                                                       ; $00B63A | |
    CPY #DIALOG_TEXT_WIDTH.w * 4                                                ; $00B63C | |
    BNE -                                                                       ; $00B63F |/
.else
-   LDA #TEXT_SPACE.b                                                           ; $00B3DF |\
    STA r_dialog_text,Y                                                         ; $00B3E1 | | Loop until the next to be written character is a new line, filling
    INY                                                                         ; $00B3E4 | | with blank tiles as we go.
    TYA                                                                         ; $00B3E5 | |
    CMP #DIALOG_TEXT_WIDTH.b * 1                                                ; $00B3E6 | |
    BEQ +                                                                       ; $00B3E8 | |
    CMP #DIALOG_TEXT_WIDTH.b * 2                                                ; $00B3EA | |
    BEQ +                                                                       ; $00B3EC | |
    CMP #DIALOG_TEXT_WIDTH.b * 3                                                ; $00B3EE | |
    BEQ +                                                                       ; $00B3F0 | |
    CMP #DIALOG_TEXT_WIDTH.b * 4                                                ; $00B3F2 | |
    BEQ +                                                                       ; $00B3F4 | |
    JMP -                                                                       ; $00B3F6 |/
.endif
+   STY <r_generic_tmp_index                                                    ; $00B3F9 | Save the dialog text index.
    JMP _load_dialog_opcode_next                                                ; $00B3FB

.if FF4_REGION == "USA"
; _load_dialog_opcode_end_line ($00:B3FE)
;
; Handles dialog opcode $01, which ends the current line. This function is USA
; exclusive.
_load_dialog_opcode_end_line:
-   LDA #TEXT_SPACE.b                                                           ; $00B3FE |\
    STA r_dialog_text,Y                                                         ; $00B400 | | Loop until the remainder of the line is filled with blank tiles.
    TYA                                                                         ; $00B403 | |
    BEQ +                                                                       ; $00B404 | |
    CMP #DIALOG_TEXT_WIDTH.b * 1                                                ; $00B406 | |
    BEQ +                                                                       ; $00B408 | |
    CMP #DIALOG_TEXT_WIDTH.b * 2                                                ; $00B40A | |
    BEQ +                                                                       ; $00B40C | |
    CMP #DIALOG_TEXT_WIDTH.b * 3                                                ; $00B40E | |
    BEQ +                                                                       ; $00B410 | |
    CMP #DIALOG_TEXT_WIDTH.b * 4                                                ; $00B412 | |
    BEQ +                                                                       ; $00B414 | |
    INY                                                                         ; $00B416 | |
    JMP -                                                                       ; $00B417 |/
+   STY <r_generic_tmp_index                                                    ; $00B41A | Update the dialog index.
    JMP _load_dialog_opcode_next                                                ; $00B41C
.endif

; _load_dialog_opcode_end_message ($00:B41F)
;
; Handles dialog opcode $00, which ends the current message. The Japanese
; version has extra handling for the different size of the dialog area and the
; diacritic text.
_load_dialog_opcode_end_message:
    LDA #TEXT_SPACE.b                                                           ; $00B41F |\
-   STA r_dialog_text,Y                                                         ; $00B421 | | Loop until the remainder of the dialog text area in RAM is filled
.if FF4_REGION == "JAPAN"                                                       ;         | | with blank tiles.
    STA r_dialog_text_diacritic.w,Y                                             ; $00B64B | |
.endif                                                                          ;         | |
    INY                                                                         ; $00B424 | |
    CPY #_sizeof_r_dialog_text.w                                                ; $00B425 | |
    BNE -                                                                       ; $00B428 |/
    LDA #DIALOG_CLOSE_MODE_MANUAL.b                                             ; $00B42A |\ Set the flag so the dialog is closed manually.
    STA <r_dialog_close_mode                                                    ; $00B42C |/
    JMP _load_dialog_opcode_done                                                ; $00B42E

; _load_dialog_opcode_end_message_auto ($00:B431)
;
; Handles dialog opcode $06, which ends the current message while also telling
; the game to close the dialog automatically. The Japanese version has
; additional code to handle the diacritics.
_load_dialog_opcode_end_message_auto:
    LDA #TEXT_SPACE.b                                                           ; $00B431 |\
-   STA r_dialog_text,Y                                                         ; $00B433 | | Loop until the remainder of the dialog text area in RAM is filled
.if FF4_REGION == "JAPAN"                                                       ;         | | with blank tiles.
    STA r_dialog_text_diacritic.w,Y                                             ; $00B660 | |
.endif                                                                          ;         | |
    INY                                                                         ; $00B436 | |
    CPY #_sizeof_r_dialog_text.w                                                ; $00B437 | |
    BNE -                                                                       ; $00B43A |/
    LDA #DIALOG_CLOSE_MODE_AUTO.b                                               ; $00B43C |\ Set the flag so the dialog is closed automatically.
    STA <r_dialog_close_mode                                                    ; $00B43E |/
    JMP _load_dialog_opcode_done                                                ; $00B440

.if FF4_REGION == "JAPAN"
; _dialog_get_diacritic_character ($00:B670)
;
; For the Japanese version only, takes a character value in the accumulator and
; returns the base tile value and the diacritic tile value in the accumulator
; such that the diacritic tile is in the high byte.
_dialog_get_diacritic_character:
    CMP #TILE_MENU_NON_DIACRITIC_BASE.b                                         ; $00B670 |\
    BCS +                                                                       ; $00B672 | | If the character value is less than $42, subtract $0F (as that's
    PHX                                                                         ; $00B674 | | the base value) and index the diacritic data to determine the
    SEC                                                                         ; $00B675 | | appropriate base and diacritic tiles for that character. Store the
    SBC #DIALOG_OPCODE_FIRST_DIACRITIC.b                                        ; $00B676 | | result in the two bytes of the accumulator and jump to the end.
    ASL A                                                                       ; $00B678 | |
    TAX                                                                         ; $00B679 | |
    LDA dialog_diacritic_data.l + word.lo,X                                     ; $00B67A | |
    XBA                                                                         ; $00B67E | |
    LDA dialog_diacritic_data.l + word.hi,X                                     ; $00B67F | |
    XBA                                                                         ; $00B683 | |
    PLX                                                                         ; $00B684 | |
    JMP ++                                                                      ; $00B685 |/
+   XBA                                                                         ; $00B688 |\
    LDA #$FF.b                                                                  ; $00B689 | | Otherwise, set the diacritic tile to be a blank tile.
    XBA                                                                         ; $00B68B |/
++  RTS                                                                         ; $00B68C

; dialog_diacritic_data ($00:B68D)
;
; This data maps dialog characters in the range of $0F through $41 to a pair of
; tiles, comprising the kana with the appropriate diacritic for voiced or
; semivoiced sounds. It only exists in the Japanese version.
dialog_diacritic_data:
    .db $CC, $C0                                                                ; $00B68D.B68E
    .db $8F, $C0                                                                ; $00B68F.B690
    .db $90, $C0                                                                ; $00B691.B692
    .db $91, $C0                                                                ; $00B693.B694
    .db $92, $C0                                                                ; $00B695.B696
    .db $93, $C0                                                                ; $00B697.B698
    .db $94, $C0                                                                ; $00B699.B69A
    .db $95, $C0                                                                ; $00B69B.B69C
    .db $96, $C0                                                                ; $00B69D.B69E
    .db $97, $C0                                                                ; $00B69F.B6A0
    .db $98, $C0                                                                ; $00B6A1.B6A2
    .db $99, $C0                                                                ; $00B6A3.B6A4
    .db $9A, $C0                                                                ; $00B6A5.B6A6
    .db $9B, $C0                                                                ; $00B6A7.B6A8
    .db $9C, $C0                                                                ; $00B6A9.B6AA
    .db $9D, $C0                                                                ; $00B6AB.B6AC
    .db $A3, $C0                                                                ; $00B6AD.B6AE
    .db $A4, $C0                                                                ; $00B6AF.B6B0
    .db $A5, $C0                                                                ; $00B6B1.B6B2
    .db $A6, $C0                                                                ; $00B6B3.B6B4
    .db $A7, $C0                                                                ; $00B6B5.B6B6
    .db $A3, $C1                                                                ; $00B6B7.B6B8
    .db $A4, $C1                                                                ; $00B6B9.B6BA
    .db $A5, $C1                                                                ; $00B6BB.B6BC
    .db $A6, $C1                                                                ; $00B6BD.B6BE
    .db $A7, $C1                                                                ; $00B6BF.B6C0
    .db $CF, $C0                                                                ; $00B6C1.B6C2
    .db $D0, $C0                                                                ; $00B6C3.B6C4
    .db $D1, $C0                                                                ; $00B6C5.B6C6
    .db $D2, $C0                                                                ; $00B6C7.B6C8
    .db $D3, $C0                                                                ; $00B6C9.B6CA
    .db $D4, $C0                                                                ; $00B6CB.B6CC
    .db $D5, $C0                                                                ; $00B6CD.B6CE
    .db $D6, $C0                                                                ; $00B6CF.B6D0
    .db $D7, $C0                                                                ; $00B6D1.B6D2
    .db $D8, $C0                                                                ; $00B6D3.B6D4
    .db $D9, $C0                                                                ; $00B6D5.B6D6
    .db $DA, $C0                                                                ; $00B6D7.B6D8
    .db $DB, $C0                                                                ; $00B6D9.B6DA
    .db $DC, $C0                                                                ; $00B6DB.B6DC
    .db $DD, $C0                                                                ; $00B6DD.B6DE
    .db $E3, $C0                                                                ; $00B6DF.B6E0
    .db $E4, $C0                                                                ; $00B6E1.B6E2
    .db $E5, $C0                                                                ; $00B6E3.B6E4
    .db $E6, $C0                                                                ; $00B6E5.B6E6
    .db $E7, $C0                                                                ; $00B6E7.B6E8
    .db $E3, $C1                                                                ; $00B6E9.B6EA
    .db $E4, $C1                                                                ; $00B6EB.B6EC
    .db $E5, $C1                                                                ; $00B6ED.B6EE
    .db $E6, $C1                                                                ; $00B6EF.B6F0
    .db $E7, $C1                                                                ; $00B6F1.B6F2
.endif

; _set_upper_dialog_timer ($00:B443)
;
; Configures the timers to trigger an IRQ on line 19 and increments the dialog
; frame counter. The game uses timer IRQs to change the BG3 scroll registers
; during the frame to simulate a dialog box of varying sizes. This sets the
; BG3 scroll registers to show the dialog on the upper half of the screen.
_set_upper_dialog_timer:
    LDX #$0013.w                                                                ; $00B443 |\ Set the vertical timer to trigger an IRQ on line 19.
    STX reg_cpu_vtimel                                                          ; $00B446 |/
    LDA #%10100001.b                                                            ; $00B449 |\ Enable NMI, vertical IRQ timer, and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00B44B |/
    STZ reg_ppu_bg3h0fs                                                         ; $00B44E |\ Set the BG3 horizontal scroll register to zero.
    STZ reg_ppu_bg3h0fs                                                         ; $00B451 |/
    LDA #$03.b                                                                  ; $00B454 |\
    STA reg_ppu_bg3v0fs                                                         ; $00B456 | | Set the BG3 vertical scroll register to 3.
    STZ reg_ppu_bg3v0fs                                                         ; $00B459 |/
    STZ <r_irq_index                                                            ; $00B45C | Zero out the IRQ index.
    LDX r_dialog_frame_counter.w                                                ; $00B45E |\
    INX                                                                         ; $00B461 | | Increment the dialog frame counter.
    STX r_dialog_frame_counter.w                                                ; $00B462 |/
    RTS                                                                         ; $00B465

; _upper_dialog_irq_handler ($00:B466)
;
; Handles IRQs for the upper dialog. Ensures that the BG3 scroll registers are
; adjusted to draw the interior of the dialog and then adjusted again to draw
; the bottom of the dialog at the appropriate time.
_upper_dialog_irq_handler:
    LDA <r_irq_index                                                            ; $00B466 |\ Determine if this is the first or second IRQ.
    BNE @second_irq                                                             ; $00B468 |/
    LDA <r_upper_dialog_height                                                  ; $00B46A |\
    ASL A                                                                       ; $00B46C | | Since this is the first IRQ, calculate when to trigger the second
    ASL A                                                                       ; $00B46D | | IRQ by multiplying the dialog height by 8 and adding 20.
    ASL A                                                                       ; $00B46E | |
    CLC                                                                         ; $00B46F | |
    ADC #$14.b                                                                  ; $00B470 | |
    STA reg_cpu_vtimel                                                          ; $00B472 | |
    STZ reg_cpu_vtimeh                                                          ; $00B475 |/
    LDX #$0008.w                                                                ; $00B478 |\
-   DEX                                                                         ; $00B47B | | Loop for a few cycles.
    BNE -                                                                       ; $00B47C |/
    STZ reg_ppu_bg3h0fs                                                         ; $00B47E |\
    LDA #$01.b                                                                  ; $00B481 | | Set the BG3 horizontal scroll register to $100.
    STA reg_ppu_bg3h0fs                                                         ; $00B483 |/
    LDA <r_dialog_vertical_scroll                                               ; $00B486 |\
    STA reg_ppu_bg3v0fs                                                         ; $00B488 | | Set the BG3 vertical scroll register to the value stored at $06BB.
    STZ reg_ppu_bg3v0fs                                                         ; $00B48B |/
    RTS                                                                         ; $00B48E
@second_irq:
    LDX #$0008.w                                                                ; $00B48F |\
-   DEX                                                                         ; $00B492 | | Loop for a few cycles.
    BNE -                                                                       ; $00B493 |/
    STZ reg_ppu_bg3h0fs                                                         ; $00B495 |\ Set the BG3 horizontal scroll register to zero.
    STZ reg_ppu_bg3h0fs                                                         ; $00B498 |/
    LDA <r_upper_dialog_height                                                  ; $00B49B |\
    ASL A                                                                       ; $00B49D | | Set the BG3 vertical scroll register to the negative of the dialog
    ASL A                                                                       ; $00B49E | | height times eight plus four. This results in the bottom of the
    ASL A                                                                       ; $00B49F | | dialog box being drawn where it should be.
    EOR #$FF.b                                                                  ; $00B4A0 | |
    CLC                                                                         ; $00B4A2 | |
    ADC #$05.b                                                                  ; $00B4A3 | |
    STA reg_ppu_bg3v0fs                                                         ; $00B4A5 | |
    STZ reg_ppu_bg3v0fs                                                         ; $00B4A8 |/
    LDA #%10000001.b                                                            ; $00B4AB |\ Enable NMI and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00B4AD |/
    RTS                                                                         ; $00B4B0

; _draw_dialog_if_pending ($00:B4B1)
;
; Checks $CB for a non-zero value. If non-zero, returns immediately. If $EB if
; non-zero, it will then draw an empty dialog box to BG3. Otherwise, it returns.
_draw_dialog_if_pending:
    LDA <r_dialog_prologue_scroll_enable                                        ; $00B4B1 |\
    BEQ +                                                                       ; $00B4B3 | | If a dialog is not pending or if the prologue scroll mode is
    RTS                                                                         ; $00B4B5 | | enabled, return from the function.
+   LDA <r_dialog_pending                                                       ; $00B4B6 | |
    BNE +                                                                       ; $00B4B8 | |
    RTS                                                                         ; $00B4BA | |
+   STZ <r_dialog_pending                                                       ; $00B4BB |/
    LDA #%10000000.b                                                            ; $00B4BD |\
    STA reg_ppu_vmainc                                                          ; $00B4BF | | Draw the top of a dialog box on row 2 of BG3.
    JSR _init_dma_bank_0_to_vram                                                ; $00B4C2 | |
    LDA #%00000001.b                                                            ; $00B4C5 | |
    STA reg_cpu_dmap0                                                           ; $00B4C7 | |
    LDX #$2840.w                                                                ; $00B4CA | |
    STX reg_ppu_vmadd                                                           ; $00B4CD | |
    LDX #bank14.dialog_top_row_tilemap_data.w                                   ; $00B4D0 | |
    STX reg_cpu_a1t0                                                            ; $00B4D3 | |
    LDA #:bank14.dialog_top_row_tilemap_data.b                                  ; $00B4D6 | |
    STA reg_cpu_a1b0                                                            ; $00B4D8 | |
    LDX #$0040.w                                                                ; $00B4DB | |
    STX reg_cpu_das0                                                            ; $00B4DE | |
    JSR _enable_dma_0                                                           ; $00B4E1 |/
    LDX #$2860.w                                                                ; $00B4E4 |\
    STX reg_ppu_vmadd                                                           ; $00B4E7 | | Draw the bottom of a dialog box on row 3 of BG3.
    STZ reg_cpu_mdmaen                                                          ; $00B4EA | |
    LDX #bank14.dialog_bottom_row_tilemap_data.w                                ; $00B4ED | |
    STX reg_cpu_a1t0                                                            ; $00B4F0 | |
    LDX #$0040.w                                                                ; $00B4F3 | |
    STX reg_cpu_das0                                                            ; $00B4F6 | |
    JSR _enable_dma_0                                                           ; $00B4F9 |/
    LDY #$0020.w                                                                ; $00B4FC |\
    LDX #$2C00.w                                                                ; $00B4FF | | Draw 32 rows of blank dialog box to the entire second half of BG3.
    STX reg_ppu_vmadd                                                           ; $00B502 | | (In other words, rows 0 through 31 of the second 32x32 section.)
-   STZ reg_cpu_mdmaen                                                          ; $00B505 | |
    LDX #bank14.dialog_center_tilemap_data.l                                    ; $00B508 | |
    STX reg_cpu_a1t0                                                            ; $00B50B | |
    LDX #$0040.w                                                                ; $00B50E | |
    STX reg_cpu_das0                                                            ; $00B511 | |
    JSR _enable_dma_0                                                           ; $00B514 | |
    DEY                                                                         ; $00B517 | |
    BNE -                                                                       ; $00B518 |/
    RTS                                                                         ; $00B51A

; _erase_dialog_if_pending ($00:B51B)
;
; Checks the value of $EC. If $EC is non-zero, it erases rows 2 and 3 of BG3,
; which can effectively erase the smallest size dialog possible.
_erase_dialog_if_pending:
    LDA <r_dialog_erase_pending                                                 ; $00B51B |\
    BNE +                                                                       ; $00B51D | | Check to see if a dialog is pending to be erased.
    RTS                                                                         ; $00B51F | |
+   STZ <r_dialog_erase_pending                                                 ; $00B520 |/
    LDA #%10000000.b                                                            ; $00B522 |\
    STA reg_ppu_vmainc                                                          ; $00B524 | | Initialize common DMA parameters.
    JSR _init_dma_bank_0_to_vram                                                ; $00B527 | |
    LDA #%00001001.b                                                            ; $00B52A | |
    STA reg_cpu_dmap0                                                           ; $00B52C |/
    LDX #$2840.w                                                                ; $00B52F |\
    STX reg_ppu_vmadd                                                           ; $00B532 | | Zero out 64 bytes in VRAM starting at $2840, which serves to erase
    STZ <r_tmp_dma_fixed_source                                                 ; $00B535 | | row 2 of BG3.
    LDX #r_tmp_dma_fixed_source.w                                               ; $00B537 | |
    STX reg_cpu_a1t0                                                            ; $00B53A | |
    LDX #$0040.w                                                                ; $00B53D | |
    STX reg_cpu_das0                                                            ; $00B540 | |
    JSR _enable_dma_0                                                           ; $00B543 |/
    LDX #$2860.w                                                                ; $00B546 |\
    STX reg_ppu_vmadd                                                           ; $00B549 | | Zero out 64 bytes in VRAM starting at $2860, which serves to erase
    STZ reg_cpu_mdmaen                                                          ; $00B54C | | row 3 of BG3.
    LDX #r_tmp_dma_fixed_source.w                                               ; $00B54F | |
    STX reg_cpu_a1t0                                                            ; $00B552 | |
    LDX #$0040.w                                                                ; $00B555 | |
    STX reg_cpu_das0                                                            ; $00B558 | |
    JSR _enable_dma_0                                                           ; $00B55B |/
    RTS                                                                         ; $00B55E

; _draw_upper_dialog_text_if_pending ($00:B55F)
;
; Checks $ED for a non-zero value. If so, draws the text stored in $0774 to BG3
; at a vertical location depending on the value of $BA. (Specifically, there are
; four potential locations, representing four pages of text.) The Japanese
; version has extra handling for the diacritic tiles.
_draw_upper_dialog_text_if_pending:
    LDA <r_upper_dialog_text_pending                                            ; $00B55F |\
    BNE +                                                                       ; $00B561 | | Only execute this function if there is dialog text pending to be
    RTS                                                                         ; $00B563 | | drawn.
+   STZ <r_upper_dialog_text_pending                                            ; $00B564 |/
    LDA <r_dialog_scroll_index                                                  ; $00B566 |\
    AND #%00000011.b                                                            ; $00B568 | | Calculate the VRAM address based on the current dialog index.
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00B56A | | There are four slots for dialog on BG3, so we disregard all but
    LDA #DIALOG_FIRST_CHARACTER_X_COORDINATE.b                                  ; $00B56C | | the two lowest bits of the index, and then multiply that by
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00B56E | | $100, as each section is 8 lines of 32 tiles. Finally, add 3,
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00B570 | | since the text starts in the fourth column. Also add $2C00 as
    CLC                                                                         ; $00B572 | | that is the overall base address.
    ADC #$2C.b                                                                  ; $00B573 | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00B575 |/
    LDX #r_dialog_text.w                                                        ; $00B577 |\ Save the dialog text base address for easy access later.
    STX <r_draw_dialog_text_base                                                ; $00B57A |/
.if FF4_REGION == "JAPAN"
    LDX #r_dialog_text_diacritic.w                                              ; $00B82C |\ For the Japanese version, save the offset to the diacritic data to
    STX <r_generic_japan_tmp_index                                              ; $00B82F |/ a temporary variable.
.endif
    STZ reg_ppu_vmainc                                                          ; $00B57C | Set VRAM increment to 1 by 1, low address.
    JSR _init_dma_bank_0_to_vram                                                ; $00B57F |\ Initialize basic DMA parameters.
    STZ reg_cpu_dmap0                                                           ; $00B582 |/
    LDA #$04.b                                                                  ; $00B585 |\ There are up to four lines of text to process, so initialize the
    STA <r_draw_dialog_text_lines                                               ; $00B587 |/ counter to four.
@begin_loop:
.if FF4_REGION == "JAPAN"                                                       ;         |\
    LDX <r_generic_japan_tmp_index                                              ; $00B83E | | Copy either diacritic tile data (for the Japanese version) or the
.else                                                                           ;         | | blank tiles (for the USA version) for this row.
    LDX #r_dialog_text_blank.w                                                  ; $00B589 | |
.endif                                                                          ;         | |
    STX reg_cpu_a1t0                                                            ; $00B58C | |
    LDX <r_draw_dialog_text_vram_address                                        ; $00B58F | |
    STX reg_ppu_vmadd                                                           ; $00B591 | |
    LDX #DIALOG_TEXT_WIDTH.w                                                    ; $00B594 | |
    STX reg_cpu_das0                                                            ; $00B597 | |
    JSR _enable_dma_0                                                           ; $00B59A |/
    LDA <r_draw_dialog_text_vram_address_lo                                     ; $00B59D |\
    CLC                                                                         ; $00B59F | | Add $20 to the VRAM address, which advances exactly one row of
    ADC #$20.b                                                                  ; $00B5A0 | | tiles in BG3.
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00B5A2 | |
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00B5A4 | |
    ADC #$00.b                                                                  ; $00B5A6 | |
    STA <r_draw_dialog_text_vram_address_hi                                     ; $00B5A8 |/
    STZ reg_cpu_mdmaen                                                          ; $00B5AA |\
    LDX <r_draw_dialog_text_base                                                ; $00B5AD | |
    STX reg_cpu_a1t0                                                            ; $00B5AF | | Draw the actual line of text by copying 26 bytes from the staging
    LDX <r_draw_dialog_text_vram_address                                        ; $00B5B2 | | area in RAM to VRAM. While VRAM actually contains two bytes per
    STX reg_ppu_vmadd                                                           ; $00B5B4 | | tile, the high byte is not being modified, so only the low bytes
    LDX #DIALOG_TEXT_WIDTH.w                                                    ; $00B5B7 | | are copied.
    STX reg_cpu_das0                                                            ; $00B5BA | |
    JSR _enable_dma_0                                                           ; $00B5BD |/
    LDA <r_draw_dialog_text_vram_address_lo                                     ; $00B5C0 |\
    CLC                                                                         ; $00B5C2 | | Once again, add $20 to the VRAM address to get to the next row in
    ADC #$20.b                                                                  ; $00B5C3 | | BG3. if the value reaches $30XX, reset it to $2CXX to wrap around
    STA <r_draw_dialog_text_vram_address_lo                                     ; $00B5C5 | | to the top of the background.
    LDA <r_draw_dialog_text_vram_address_hi                                     ; $00B5C7 | |
    ADC #$00.b                                                                  ; $00B5C9 | |
    CMP #$30.b                                                                  ; $00B5CB | |
    BNE +                                                                       ; $00B5CD | |
    LDA #$2C.b                                                                  ; $00B5CF | |
+   STA <r_draw_dialog_text_vram_address_hi                                     ; $00B5D1 |/
    LDA <r_draw_dialog_text_base_lo                                             ; $00B5D3 |\
    CLC                                                                         ; $00B5D5 | | Add 26 to the base address the text is being copied from to move
    ADC #DIALOG_TEXT_WIDTH.b                                                    ; $00B5D6 | | to the next line.
    STA <r_draw_dialog_text_base_lo                                             ; $00B5D8 | |
    LDA <r_draw_dialog_text_base_hi                                             ; $00B5DA | |
    ADC #$00.b                                                                  ; $00B5DC | |
    STA <r_draw_dialog_text_base_hi                                             ; $00B5DE |/
.if FF4_REGION == "JAPAN"
    LDA <r_generic_japan_tmp_index.lo                                           ; $00B894
    CLC                                                                         ; $00B896
    ADC #DIALOG_TEXT_WIDTH.b                                                    ; $00B897
    STA <r_generic_japan_tmp_index.lo                                           ; $00B899
    LDA <r_generic_japan_tmp_index.hi                                           ; $00B89B
    ADC #0.b                                                                    ; $00B89D
    STA <r_generic_japan_tmp_index.hi                                           ; $00B89F
.endif
    DEC <r_draw_dialog_text_lines                                               ; $00B5E0 |\
    BEQ +                                                                       ; $00B5E2 | | Repeat the above loop until all four lines have been drawn.
    JMP @begin_loop                                                             ; $00B5E4 |/
+   INC <r_dialog_scroll_index                                                  ; $00B5E7 | Increment the dialog scroll index.
    RTS                                                                         ; $00B5E9

; _erase_map_title_if_pending ($00:B5EA)
;
; Checks if $EA is exactly equal to 1. If so, clears BG3 rows 2 through 5,
; effectively erasing any dialog box that was previously drawn there.
_erase_map_title_if_pending:
    LDA <r_map_title_erase_pending                                              ; $00B5EA |\
    CMP #$01.b                                                                  ; $00B5EC | | Only erase the map title if there is a map title to be erased.
    BEQ +                                                                       ; $00B5EE | |
    RTS                                                                         ; $00B5F0 |/
+   INC <r_map_title_erase_pending                                              ; $00B5F1 | Increment the status to signal that this has been completed.
    LDA #%10000000.b                                                            ; $00B5F3 |\
    STA reg_ppu_vmainc                                                          ; $00B5F5 | | Use a DMA transfer to zero out VRAM from $2840 to $28CF. When
    JSR _init_dma_bank_0_to_vram                                                ; $00B5F8 | | called, this corresponds to rows 2 through 5 on BG3, which will
    LDA #%00001001.b                                                            ; $00B5FB | | effectively erase any dialog boxes that are currently drawn there.
    STA reg_cpu_dmap0                                                           ; $00B5FD | |
    LDX #$2840.w                                                                ; $00B600 | |
    STX reg_ppu_vmadd                                                           ; $00B603 | |
    STZ <r_tmp_dma_fixed_source                                                 ; $00B606 | |
    LDX #r_tmp_dma_fixed_source.w                                               ; $00B608 | |
    STX reg_cpu_a1t0                                                            ; $00B60B | |
    LDX #$0100.w                                                                ; $00B60E | |
    STX reg_cpu_das0                                                            ; $00B611 | |
    JSR _enable_dma_0                                                           ; $00B614 |/
    RTS                                                                         ; $00B617

; _load_map_title ($00:B618)
;
; If the current map has a map title, loads the map title into RAM and sets the
; flag that will cause it to be drawn during the next NMI. This function only
; executes if $06C5 and $06D1 are zero. The Japanese version has extra code to
; handle diacritic characters.
_load_map_title:
    LDA <r_disable_map_title                                                    ; $00B618 |\
    BEQ +                                                                       ; $00B61A | | If the disable map title flag is set, reset it to zero and return
    STZ <r_disable_map_title                                                    ; $00B61C | | without drawing the map title.
    RTS                                                                         ; $00B61E |/
+   LDA <r_exiting_map                                                          ; $00B61F |\
    BEQ +                                                                       ; $00B621 | | Return without drawing the title if exiting the map.
    RTS                                                                         ; $00B623 |/
+   LDX #0.w                                                                    ; $00B624 | Initialize the X register to zero.
    LDA r_map_properties.title.w                                                ; $00B627 |\
    BPL +                                                                       ; $00B62A | | Make sure the map title is set to less than $80.
    RTS                                                                         ; $00B62C |/
+   TAY                                                                         ; $00B62D |\
    BEQ +                                                                       ; $00B62E | | Loop through the map titles until the desired one is reached.
-   LDA bank15.map_title_data.l,X                                               ; $00B630 | |
    INX                                                                         ; $00B634 | |
    CMP #0.b                                                                    ; $00B635 | |
    BNE -                                                                       ; $00B637 | |
    DEY                                                                         ; $00B639 | |
    BNE -                                                                       ; $00B63A |/
+   STX <r_generic_tmp_index                                                    ; $00B63C | Save the index to the map title.
    STZ <r_load_map_title_tmp                                                   ; $00B63E |\
-   LDA bank15.map_title_data.l,X                                               ; $00B640 | | Determine the length of the title.
    INX                                                                         ; $00B644 | |
    INC <r_load_map_title_tmp                                                   ; $00B645 | |
    CMP #$00.b                                                                  ; $00B647 | |
    BNE -                                                                       ; $00B649 | |
    DEC <r_load_map_title_tmp                                                   ; $00B64B |/
    LDA #MAP_TITLE_WIDTH.b                                                      ; $00B64D |\
    SEC                                                                         ; $00B64F | | Determine where to put the string to center it.
    SBC <r_load_map_title_tmp                                                   ; $00B650 | |
    LSR A                                                                       ; $00B652 | |
    STA <r_load_map_title_start                                                 ; $00B653 |/
    LDX #0.w                                                                    ; $00B655 |\
    LDA #TEXT_SPACE.b                                                           ; $00B658 | | Clear any existing title by filling it with blank spaces.
-   STA r_dialog_text.w,X                                                       ; $00B65A | |
    STA r_dialog_text.w + MAP_TITLE_WIDTH,X                                     ; $00B65D | |
    INX                                                                         ; $00B660 | |
    CPX #MAP_TITLE_WIDTH.w                                                      ; $00B661 | |
    BNE -                                                                       ; $00B664 |/
    LDX <r_generic_tmp_index                                                    ; $00B666 |\
    LDA <r_load_map_title_start                                                 ; $00B668 | | Copy the entire map title to RAM. The Japanese version has extra
    TAY                                                                         ; $00B66A | | code to handle diacritic characters.
-   LDA bank15.map_title_data.l,X                                               ; $00B66B | |
    INX                                                                         ; $00B66F | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    JSR _dialog_get_diacritic_character                                         ; $00B931 | |
    STA r_dialog_text.w,Y                                                       ; $00B934 | |
    XBA                                                                         ; $00B937 | |
    STA r_dialog_text.w + MAP_TITLE_WIDTH.w,Y                                   ; $00B938 | |
    INY                                                                         ; $00B93B | |
    LDA #0.b                                                                    ; $00B93C | |
    XBA                                                                         ; $00B93E | |
.else                                                                           ;         | |
    STA r_dialog_text,Y                                                         ; $00B670 | |
    INY                                                                         ; $00B673 | |
.endif                                                                          ;         | |
    DEC <r_load_map_title_tmp                                                   ; $00B674 | |
    BNE -                                                                       ; $00B676 |/
    LDA #1.b                                                                    ; $00B678 |\ Set the pending map title flag so it will be drawn.
    STA <r_map_title_pending                                                    ; $00B67A |/
    RTS                                                                         ; $00B67C

; _draw_map_title_if_pending ($00:B67D)
;
; Draws a small dialog box at the top of the window showing the text stored at
; $0774. This appears to be used to draw map titles. The original Japanese
; version stored some of the tilemap data in ROM to be directly copied. It also
; was kind of weird and directly set VRAM addresses that it probably didn't
; need to set.
_draw_map_title_if_pending:
    LDA <r_map_title_pending                                                    ; $00B67D |\
    BNE +                                                                       ; $00B67F | | If there is no map title to be drawn, skip this function.
    RTS                                                                         ; $00B681 |/
+   STZ <r_map_title_pending                                                    ; $00B682 |/
    STZ reg_ppu_bg3v0fs                                                         ; $00B684 |\ Set the BG3 scroll value to zero.
    STZ reg_ppu_bg3v0fs                                                         ; $00B687 |/
    LDA #%10000000.b                                                            ; $00B68A |\ Set the VRAM increment to 1 by 1 on high byte write.
    STA reg_ppu_vmainc                                                          ; $00B68C |/
    LDX #VRAM_FIELD_TILEMAP_BG3.W + MAP_TITLE_LEFT_MARGIN + (2 * 32)            ; $00B68F |\ Set the current VRAM address to the top left corner of the map
    STX reg_ppu_vmadd                                                           ; $00B692 |/ title dialog.
.if FF4_REGION == "JAPAN"
    LDX #0.w                                                                    ; $00B960 |\
-   LDA bank14.map_title_top_tilemap_data.l,X                                   ; $00B963 | | For the Japanese version, draw the top row of the map title dialog
    STA reg_ppu_vmdatal_write                                                   ; $00B967 | | by reading the correct data from ROM.
    INX                                                                         ; $00B96A | |
    LDA bank14.map_title_top_tilemap_data.l,X                                   ; $00B96B | |
    STA reg_ppu_vmdatah_write                                                   ; $00B96F | |
    INX                                                                         ; $00B972 | |
    CPX #bank14._sizeof_map_title_top_tilemap_data.w                            ; $00B973 | |
    BNE -                                                                       ; $00B976 |/
.else
    LDA #$16.b                                                                  ; $00B695 |\
    STA reg_ppu_vmdatal_write                                                   ; $00B697 | | For the USA version, directly write the top left dialog tile.
    LDA #$20.b                                                                  ; $00B69A | |
    STA reg_ppu_vmdatah_write                                                   ; $00B69C |/
    LDX #0.w                                                                    ; $00B69F | Initialize the X register to zero.
-   LDA #$17.b                                                                  ; $00B6A2 |\
    STA reg_ppu_vmdatal_write                                                   ; $00B6A4 | | Draw 24 short top dialog tiles to positions 4 through 27 on row
    LDA #$20.b                                                                  ; $00B6A7 | | 2 on BG3 at priority 1.
    STA reg_ppu_vmdatah_write                                                   ; $00B6A9 | |
    INX                                                                         ; $00B6AC | |
    CPX #$0018.w                                                                ; $00B6AD | |
    BNE -                                                                       ; $00B6B0 |/
    LDA #$18.b                                                                  ; $00B6B2 |\
    STA reg_ppu_vmdatal_write                                                   ; $00B6B4 | | Draw a short top right dialog tile to position 28, 2 on BG3 at
    LDA #$20.b                                                                  ; $00B6B7 | | priority 1.
    STA reg_ppu_vmdatah_write                                                   ; $00B6B9 |/
.endif
    LDX #VRAM_FIELD_TILEMAP_BG3.w + MAP_TITLE_LEFT_MARGIN + (3 * 32)            ; $00B6BC |\
    STX reg_ppu_vmadd                                                           ; $00B6BF | | Draw a left dialog tile to position 3, 3 on BG3 at priority 1.
    LDX #$2019.w                                                                ; $00B6C2 | |
    STX reg_ppu_vmdatal_write                                                   ; $00B6C5 |/
    LDX #$20FF.w                                                                ; $00B6C8 |\
    STX reg_ppu_vmdatal_write                                                   ; $00B6CB | | Draw 23 blank dialog tiles to position 4 through 27 on row 3 on
    LDX #$0000.w                                                                ; $00B6CE | | BG3 at priority 1.
.if FF4_REGION == "JAPAN"                                                       ;         | |
-   LDA r_dialog_text.w + MAP_TITLE_WIDTH,X                                     ; $00B98D | | NOTE: The Japanese version instead copies from the dialog text
.else                                                                           ;         | |       area in RAM, in order to copy the diacritic tiles.
-   LDA #TEXT_SPACE.b                                                           ; $00B6D1 | |
.endif                                                                          ;         | |
    STA reg_ppu_vmdatal_write                                                   ; $00B6D3 | |
    LDA #$20.b                                                                  ; $00B6D6 | |
    STA reg_ppu_vmdatah_write                                                   ; $00B6D8 | |
    INX                                                                         ; $00B6DB | |
    CPX #MAP_TITLE_WIDTH.w                                                      ; $00B6DC | |
    BNE -                                                                       ; $00B6DF |/
.if FF4_REGION == "JAPAN"
    LDX #VRAM_FIELD_TILEMAP_BG3.w + MAP_TITLE_LEFT_MARGIN + 14 + (3 * 32)       ; $00B99E |\ For the Japanese version, explicitly set the VRAM address to the
    STX reg_ppu_vmadd.w                                                         ; $00B9A1 |/ next desired location.
.endif
    LDX #$20FF.w                                                                ; $00B6E1 |\ Write a blank dialog tile to the next location.
    STX reg_ppu_vmdatal_write                                                   ; $00B6E4 |/
    LDX #$201A.w                                                                ; $00B6E7 |\ Draw a right dialog tile to position 28, 3 on BG3 at priority 1.
    STX reg_ppu_vmdatal_write                                                   ; $00B6EA |/
    LDX #VRAM_FIELD_TILEMAP_BG3.w + MAP_TITLE_LEFT_MARGIN + (4 * 32)            ; $00B6ED |\
    STX reg_ppu_vmadd                                                           ; $00B6F0 | | Draw a left dialog tile to position 3, 4 on BG3 at priority 1. The
    LDX #$2019.w                                                                ; $00B6F3 | | Japanese version draws to 7, 4.
    STX reg_ppu_vmdatal_write                                                   ; $00B6F6 |/
    LDX #$20FF.w                                                                ; $00B6F9 |\ Draw a blank dialog tile to position 4, 4 on BG3 at priority 1.
    STX reg_ppu_vmdatal_write                                                   ; $00B6FC |/
    LDX #$0000.w                                                                ; $00B6FF |\
-   LDA r_dialog_text.w,X                                                       ; $00B702 | | Draw the actual map title as stored at $0774. The text encoding
    STA reg_ppu_vmdatal_write                                                   ; $00B705 | | translates directly into the appropriate tile number. 22
    LDA #$20.b                                                                  ; $00B708 | | characters are drawn starting at position 5, 4. Blanks must be
    STA reg_ppu_vmdatah_write                                                   ; $00B70A | | specified explicitly.
    INX                                                                         ; $00B70D | |
    CPX #MAP_TITLE_WIDTH.w                                                      ; $00B70E | |
    BNE -                                                                       ; $00B711 |/
.if FF4_REGION == "JAPAN"
    LDX #VRAM_FIELD_TILEMAP_BG3.w + MAP_TITLE_LEFT_MARGIN + 14 + (4 * 32)       ; $00B9D6 |\ For the Japanese version, set the target VRAM address to 22, 4.
    STX reg_ppu_vmadd.w                                                         ; $00B9D9 |/
.endif
    LDX #$20FF.w                                                                ; $00B713 |\ Draw a blank dialog tile to position 27, 4 on BG3 at priority 1.
    STX reg_ppu_vmdatal_write                                                   ; $00B716 |/
    LDX #$201A.w                                                                ; $00B719 |\ Draw a right dialog tile to position 28, 4 on BG3 at priority 1.
    STX reg_ppu_vmdatal_write                                                   ; $00B71C |/
    LDA #%10000000.b                                                            ; $00B71F |\ Set the VRAM increment again.
    STA reg_ppu_vmainc                                                          ; $00B721 |/
    LDX #VRAM_FIELD_TILEMAP_BG3.w + MAP_TITLE_LEFT_MARGIN + (5 * 32)            ; $00B724 |\ Set the VRAM address to the location of the bottom left tile of the
    STX reg_ppu_vmadd                                                           ; $00B727 |/ map title dialog.
.if FF4_REGION == "JAPAN"
    LDX #0.w                                                                    ; $00B9F3 |\
-   LDA bank14.map_title_bottom_tilemap_data.l,X                                ; $00B9F6 | | For the Japanese version, copy the tilemap for the bottom row of
    STA reg_ppu_vmdatal_write.w                                                 ; $00B9FA | | the dialog directly from ROM.
    INX                                                                         ; $00B9FD | |
    LDA bank14.map_title_bottom_tilemap_data.l,X                                ; $00B9FE | |
    STA reg_ppu_vmdatah_write.w                                                 ; $00BA02 | |
    INX                                                                         ; $00BA05 | |
    CPX #bank14._sizeof_map_title_bottom_tilemap_data.w                         ; $00BA06 | |
    BNE -                                                                       ; $00BA09 |/
.else
    LDA #$1B.b                                                                  ; $00B72A |\
    STA reg_ppu_vmdatal_write                                                   ; $00B72C | | For the USA version, start by writing the bottom left tile.
    LDA #$20.b                                                                  ; $00B72F | |
    STA reg_ppu_vmdatah_write                                                   ; $00B731 |/
    LDX #$0000.w                                                                ; $00B734 |\
-   LDA #$1C.b                                                                  ; $00B737 | | Draw 24 bottom dialog tiles to positions 4 through 27 on BG3 at
    STA reg_ppu_vmdatal_write                                                   ; $00B739 | | priority 1 on row 5.
    LDA #$20.b                                                                  ; $00B73C | |
    STA reg_ppu_vmdatah_write                                                   ; $00B73E | |
    INX                                                                         ; $00B741 | |
    CPX #$0018.w                                                                ; $00B742 | |
    BNE -                                                                       ; $00B745 |/
    LDA #$1D.b                                                                  ; $00B747 |\
    STA reg_ppu_vmdatal_write                                                   ; $00B749 | | Draw a bottom right dialog tile to position 28, 5 on BG3 at
    LDA #$20.b                                                                  ; $00B74C | | priority 1.
    STA reg_ppu_vmdatah_write                                                   ; $00B74E |/
.endif
    RTS                                                                         ; $00B751

; _check_facing_npc ($00:B752)
;
; Checks if there is an NPC within talking range in the facing direction and if
; so, executes their talking event.
_check_facing_npc:
    LDA r_direction.w                                                           ; $00B752 |\ Initially set a temporary variable to the facing direction.
    STA <r_generic_tmp_3                                                        ; $00B755 |/
    ASL A                                                                       ; $00B757 |\ Set the Y register to the direction times two to index tile
    TAY                                                                         ; $00B758 |/ properties.
    BNE +                                                                       ; $00B759 |\
    LDA r_tile_properties_up.properties_2.w,Y                                   ; $00B75B | | If the player's facing direction is up and if the upward tile has
    AND #TILE_PROPERTY_2_TALK_OVER.b                                            ; $00B75E | | the talk over property set, change the value to 4 and branch
    BEQ +                                                                       ; $00B760 | | ahead.
    LDA #4.b                                                                    ; $00B762 | |
    STA <r_generic_tmp_3                                                        ; $00B764 | |
    JMP ++                                                                      ; $00B766 |/
+   LDA r_tile_properties_up.properties_1.w,Y                                   ; $00B769 |\
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $00B76C | | Otherwise, check to make sure that if the tile has a layer set
    BEQ ++                                                                      ; $00B76E | | that our position matches at least one layer. If not, return.
    AND <r_current_map_layer                                                    ; $00B770 | |
    BNE ++                                                                      ; $00B772 | |
    RTS                                                                         ; $00B774 |/
++  LDA <r_generic_tmp_3                                                        ; $00B775 |\
    TAY                                                                         ; $00B777 | | Check if there is an NPC in the tile one tile away in the facing
    LDA r_current_coordinates.x.w                                               ; $00B778 | | direction, and if so, dispatch to have them turn and execute their
    CLC                                                                         ; $00B77B | | event.
    ADC npc_talk_direct_x_offset_data.w,Y                                       ; $00B77C | |
    STA <r_generic_arg_x_lo                                                     ; $00B77F | |
    LDA r_current_coordinates.y.w                                               ; $00B781 | |
    CLC                                                                         ; $00B784 | |
    ADC npc_talk_direct_y_offset_data.w,Y                                       ; $00B785 | |
    STA <r_generic_arg_y_lo                                                     ; $00B788 | |
    JSR _get_field_sprite_positioning                                           ; $00B78A | |
    CMP #0.b                                                                    ; $00B78D | |
    BEQ +                                                                       ; $00B78F | |
    CMP #$FF.b                                                                  ; $00B791 | |
    BEQ +                                                                       ; $00B793 | |
    JSR _get_npc_movement_direction_and_properties_offset                       ; $00B795 | |
    JMP @turn_npc_execute_event                                                 ; $00B798 |/
+   LDA <r_generic_tmp_3                                                        ; $00B79B |\
    TAY                                                                         ; $00B79D | | Check if there is an NPC in the left diagonal tile of the facing
    LDA r_current_coordinates.x.w                                               ; $00B79E | | direction and if they're moving in the correct direction, dispatch
    CLC                                                                         ; $00B7A1 | | to execute their event.
    ADC npc_talk_left_diagonal_x_offset_data.w,Y                                ; $00B7A2 | |
    STA <r_generic_arg_x_lo                                                     ; $00B7A5 | |
    LDA r_current_coordinates.y.w                                               ; $00B7A7 | |
    CLC                                                                         ; $00B7AA | |
    ADC npc_talk_left_diagonal_y_offset_data.w,Y                                ; $00B7AB | |
    STA <r_generic_arg_y_lo                                                     ; $00B7AE | |
    JSR _get_field_sprite_positioning                                           ; $00B7B0 | |
    CMP #0.b                                                                    ; $00B7B3 | |
    BEQ +                                                                       ; $00B7B5 | |
    CMP #$FF.b                                                                  ; $00B7B7 | |
    BEQ +                                                                       ; $00B7B9 | |
    JSR _get_npc_movement_direction_and_properties_offset                       ; $00B7BB | |
    CMP #$FF.b                                                                  ; $00B7BE | |
    BEQ +                                                                       ; $00B7C0 | |
    CMP npc_talk_left_diagonal_direction_data.w,Y                               ; $00B7C2 | |
    BNE +                                                                       ; $00B7C5 | |
    JMP @turn_npc_execute_event                                                 ; $00B7C7 |/
+   LDA <r_generic_tmp_3                                                        ; $00B7CA |\
    TAY                                                                         ; $00B7CC | | Check if there is an NPC in the right diagonal tile of the facing
    LDA r_current_coordinates.x.w                                               ; $00B7CD | | direction and if they're moving in the correct direction, dispatch
    CLC                                                                         ; $00B7D0 | | to execute their event.
    ADC npc_talk_right_diagonal_x_offset_data.w,Y                               ; $00B7D1 | |
    STA <r_generic_arg_x_lo                                                     ; $00B7D4 | |
    LDA r_current_coordinates.y.w                                               ; $00B7D6 | |
    CLC                                                                         ; $00B7D9 | |
    ADC npc_talk_right_diagonal_y_offset_data.w,Y                               ; $00B7DA | |
    STA <r_generic_arg_y_lo                                                     ; $00B7DD | |
    JSR _get_field_sprite_positioning                                           ; $00B7DF | |
    CMP #$00.b                                                                  ; $00B7E2 | |
    BEQ +                                                                       ; $00B7E4 | |
    CMP #$FF.b                                                                  ; $00B7E6 | |
    BEQ +                                                                       ; $00B7E8 | |
    JSR _get_npc_movement_direction_and_properties_offset                       ; $00B7EA | |
    CMP #$FF.b                                                                  ; $00B7ED | |
    BEQ +                                                                       ; $00B7EF | |
    CMP npc_talk_right_diagonal_direction_data.w,Y                              ; $00B7F1 | |
    BNE +                                                                       ; $00B7F4 | |
    JMP @turn_npc_execute_event                                                 ; $00B7F6 |/
+   LDA <r_generic_tmp_3                                                        ; $00B7F9 |\
    TAY                                                                         ; $00B7FB | | Check to see if there is an NPC two tiles away in the facing
    LDA r_current_coordinates.x.w                                               ; $00B7FC | | direction and if they are moving in the correct direction, branch
    CLC                                                                         ; $00B7FF | | to execute their event.
    ADC npc_talk_double_direct_x_offset_data.w,Y                                ; $00B800 | |
    STA <r_generic_arg_x_lo                                                     ; $00B803 | |
    LDA r_current_coordinates.y.w                                               ; $00B805 | |
    CLC                                                                         ; $00B808 | |
    ADC npc_talk_double_direct_y_offset_data.w,Y                                ; $00B809 | |
    STA <r_generic_arg_y_lo                                                     ; $00B80C | |
    JSR _get_field_sprite_positioning                                           ; $00B80E | |
    CMP #$00.b                                                                  ; $00B811 | |
    BEQ +                                                                       ; $00B813 | |
    CMP #$FF.b                                                                  ; $00B815 | |
    BEQ +                                                                       ; $00B817 | |
    JSR _get_npc_movement_direction_and_properties_offset                       ; $00B819 | |
    CMP #$FF.b                                                                  ; $00B81C | |
    BEQ +                                                                       ; $00B81E | |
    CMP npc_talk_double_direct_direction_data.w,Y                               ; $00B820 | |
    BNE +                                                                       ; $00B823 | |
    JMP @turn_npc_execute_event                                                 ; $00B825 |/
+   JMP @done                                                                   ; $00B828 | Otherwise, jump to return.
@turn_npc_execute_event:
    LDA r_npc_properties.1.direction.w,X                                        ; $00B82B |\ Preserve the NPC's current facing direction.
    PHA                                                                         ; $00B82E |/
    LDA r_npc_properties.1.movement_properties.w,X                              ; $00B82F |\
    AND #NPC_MOVEMENT_PROPERTIES_TURNS.b                                        ; $00B832 | | If the NPC is configured to turn, set its direction to the
    BEQ +                                                                       ; $00B834 | | opposite of the player's direction.
    LDA r_direction.w                                                           ; $00B836 | |
    CLC                                                                         ; $00B839 | |
    ADC #2.b                                                                    ; $00B83A | |
    AND #%00000011.b                                                            ; $00B83C | |
    STA r_npc_properties.1.direction.w,X                                        ; $00B83E |/
+   PHX                                                                         ; $00B841 |\
    JSR _draw_field_sprite_npcs                                                 ; $00B842 | | Draw the updated NPC direction.
    PLX                                                                         ; $00B845 |/
    LDA r_npc_properties.1.npc.w,X                                              ; $00B846 |\
    PHX                                                                         ; $00B849 | | Check the NPC for an event and execute it.
    JSR _check_npc_event                                                        ; $00B84A | |
    PLX                                                                         ; $00B84D |/
    PLA                                                                         ; $00B84E |\ Restore the NPC's original direction.
    STA r_npc_properties.1.direction.w,X                                        ; $00B84F |/
    STZ <r_pushed_npc_index                                                     ; $00B852 | Reset the pushed NPC index.
@done:
    RTS                                                                         ; $00B854

; _get_npc_movement_direction_and_properties_offset ($00:B855)
;
; Given an NPC index for the current map in the accumulator, returns the NPC's
; current movement direction if its X or Y offset are not zero. Otherwise,
; returns $FF. Has the side effect of setting the X register to the offset for
; the NPC properties data.
_get_npc_movement_direction_and_properties_offset:
    AND #%01111111.b                                                            ; $00B855 |\ Transfer the NPC index to the X register.
    TAX                                                                         ; $00B857 |/
    LDA #0.b                                                                    ; $00B858 |\
-   CPX #0.w                                                                    ; $00B85A | | Set the X register to the offset to that NPC's properties in the
    BEQ +                                                                       ; $00B85D | | NPC properties array.
    DEX                                                                         ; $00B85F | |
    CLC                                                                         ; $00B860 | |
    ADC #_sizeof_npc_properties.b                                               ; $00B861 | |
    JMP -                                                                       ; $00B863 | |
+   TAX                                                                         ; $00B866 |/
    LDA r_npc_properties.1.x_offset.w,X                                         ; $00B867 |\
    ORA r_npc_properties.1.y_offset.w,X                                         ; $00B86A | | If the NPC is not currently in the process of moving (has no X or
    BNE +                                                                       ; $00B86D | | Y offset), load an $FF into the accumulator and return.
    LDA #$FF.b                                                                  ; $00B86F | |
    JMP ++                                                                      ; $00B871 |/
+   LDA r_npc_properties.1.movement_direction.w,X                               ; $00B874 |\ Otherwise, return the NPC's movement direction minus one (to serve
    DEC A                                                                       ; $00B877 |/ as a regular direction value).
++  RTS                                                                         ; $00B878

; npc_talk_direct_x_offset_data (00:B879)
;
; For each facing direction, determines the X offset to add to the current
; coordinate to search for an NPC directly in that direction.
npc_talk_direct_x_offset_data:
    .db  0                                                                      ; $00B879 | $00: Up
    .db  1                                                                      ; $00B87A | $01: Right
    .db  0                                                                      ; $00B87B | $02: Down
    .db -1                                                                      ; $00B87C | $03: Left
    .db  0                                                                      ; $00B87D | $04: Up (over a talk over tile)

; npc_talk_direct_y_offset_data (00:B87E)
;
; For each facing direction, determines the Y offset to add to the current
; coordinate to search for an NPC directly in that direction.
npc_talk_direct_y_offset_data:
    .db -1                                                                      ; $00B87E | $00: Up
    .db  0                                                                      ; $00B87F | $01: Right
    .db  1                                                                      ; $00B880 | $02: Down
    .db  0                                                                      ; $00B881 | $03: Left
    .db -2                                                                      ; $00B882 | $04: Up (over a talk over tile)

; npc_talk_left_diagonal_x_offset_data (00:B883)
;
; For each facing direction, determines the X offset to add to the current
; coordinate to search for an NPC on the left diagonal in that direction.
npc_talk_left_diagonal_x_offset_data:
    .db -1                                                                      ; $00B883 | $00: Up
    .db  1                                                                      ; $00B884 | $01: Right
    .db  1                                                                      ; $00B885 | $02: Down
    .db -1                                                                      ; $00B886 | $03: Left
    .db -1                                                                      ; $00B887 | $04: Up (over a talk over tile)

; npc_talk_left_diagonal_y_offset_data ($00:B888)
;
; For each facing direction, determines the Y offset to add to the current
; coordinate to search for an NPC on the left diagonal in that direction.
npc_talk_left_diagonal_y_offset_data:
    .db -1                                                                      ; $00B888 | $00: Up
    .db -1                                                                      ; $00B889 | $01: Right
    .db  1                                                                      ; $00B88A | $02: Down
    .db  1                                                                      ; $00B88B | $03: Left
    .db -2                                                                      ; $00B88C | $04: Up (over a talk over tile)

; npc_talk_right_diagonal_x_offset_data ($00:B88D)
;
; For each facing direction, determines the X offset to add to the current
; coordinate to search for an NPC on the right diagonal in that direction.
npc_talk_right_diagonal_x_offset_data:
    .db  1                                                                      ; $00B88D | $00: Up
    .db  1                                                                      ; $00B88E | $01: Right
    .db -1                                                                      ; $00B88F | $02: Down
    .db -1                                                                      ; $00B890 | $03: Left
    .db  1                                                                      ; $00B891 | $04: Up (over a talk over tile)

; npc_talk_right_diagonal_y_offset_data ($00:B892)
;
; For each facing direction, determines the Y offset to add to the current
; coordinate to search for an NPC on the right diagonal in that direction.
npc_talk_right_diagonal_y_offset_data:
    .db -1                                                                      ; $00B892 | $00: Up
    .db  1                                                                      ; $00B893 | $01: Right
    .db  1                                                                      ; $00B894 | $02: Down
    .db -1                                                                      ; $00B895 | $03: Left
    .db -2                                                                      ; $00B896 | $04: Up (over a talk over tile)

; npc_talk_double_direct_x_offset_data ($00:B897)
;
; For each facing direction, determines the X offset to add to the current
; coordinate to search for an NPC two tiles in that direction.
npc_talk_double_direct_x_offset_data:
    .db  0                                                                      ; $00B897 | $00: Up
    .db  2                                                                      ; $00B898 | $01: Right
    .db  0                                                                      ; $00B899 | $02: Down
    .db -2                                                                      ; $00B89A | $03: Left
    .db  0                                                                      ; $00B89B | $04: Up (over a talk over tile)

; npc_talk_double_direct_y_offset_data ($00:B89C)
;
; For each facing direction, determines the Y offset to add to the current
; coordinate to search for an NPC two tiles in that direction.
npc_talk_double_direct_y_offset_data:
    .db -2                                                                      ; $00B89C | $00: Up
    .db  0                                                                      ; $00B89D | $01: Right
    .db  2                                                                      ; $00B89E | $02: Down
    .db  0                                                                      ; $00B89F | $03: Left
    .db -2                                                                      ; $00B8A0 | $04: Up (over a talk over tile)

; npc_talk_left_diagonal_direction_data ($00:B8A1)
;
; For each facing direction, determines the direction an NPC must be moving if
; they are in the left diagonal position to be considered adjacent.
npc_talk_left_diagonal_direction_data:
    .db DIRECTION_LEFT                                                          ; $00B8A1 | $00: Up
    .db DIRECTION_UP                                                            ; $00B8A2 | $01: Right
    .db DIRECTION_RIGHT                                                         ; $00B8A3 | $02: Down
    .db DIRECTION_DOWN                                                          ; $00B8A4 | $03: Left
    .db DIRECTION_LEFT                                                          ; $00B8A5 | $04: Up (over a talk over tile)

; npc_talk_right_diagonal_direction_data ($00:B8A6)
;
; For each facing direction, determines the direction an NPC must be moving if
; they are in the right diagonal position to be considered adjacent.
npc_talk_right_diagonal_direction_data:
    .db DIRECTION_RIGHT                                                         ; $00B8A6 | $00: Up
    .db DIRECTION_DOWN                                                          ; $00B8A7 | $01: Right
    .db DIRECTION_LEFT                                                          ; $00B8A8 | $02: Down
    .db DIRECTION_UP                                                            ; $00B8A9 | $03: Left
    .db DIRECTION_RIGHT                                                         ; $00B8AA | $04: Up (over a talk over tile)

; npc_talk_double_direct_direction_data ($00:B8AB)
;
; For each facing direction, determines the direction an NPC must be moving if
; they are two tiles away to be considered adjacent.
npc_talk_double_direct_direction_data:
    .db DIRECTION_UP                                                            ; $00B8AB | $00: Up
    .db DIRECTION_RIGHT                                                         ; $00B8AC | $01: Right
    .db DIRECTION_DOWN                                                          ; $00B8AD | $02: Down
    .db DIRECTION_LEFT                                                          ; $00B8AE | $03: Left
    .db DIRECTION_UP                                                            ; $00B8AF | $04: Up (over a talk over tile)

; _draw_field_sprite_npcs ($00:B8B0)
;
; For each of the potential 12 NPCs on a map, draws them on the screen based on
; their parameters.
_draw_field_sprite_npcs:
    LDA r_npc_count.w                                                           ; $00B8B0 |\
    BNE +                                                                       ; $00B8B3 | | Skip this function if there are no NPCs on the map.
    RTS                                                                         ; $00B8B5 |/
+   LDX #0.w                                                                    ; $00B8B6 |\
    STX <r_draw_field_sprite_npc_properties_index                               ; $00B8B9 | | Initialize the various variables.
    STX <r_draw_field_sprite_npcs_oam_index                                     ; $00B8BB | |
    STZ <r_draw_field_sprite_npc_index                                          ; $00B8BD | |
    LDX #$20.w                                                                  ; $00B8BF | |
    STX <r_draw_field_sprite_npcs_base_tile                                     ; $00B8C2 |/
@loop_start:
    LDX <r_draw_field_sprite_npc_properties_index                               ; $00B8C4 |\
    LDA r_npc_properties.1.visible.w,X                                          ; $00B8C6 | | If the NPC is invisible, skip to almost the end of the loop.
    BNE +                                                                       ; $00B8C9 | |
    JMP @invisible                                                              ; $00B8CB |/
+   LDA r_npc_properties.1.movement_properties.w,X                              ; $00B8CE |\
    AND #NPC_MOVEMENT_PROPERTIES_ANIMATION_MODE.b                               ; $00B8D1 | | If the NPC animation mode is normal, branch to that code.
    BEQ @normal                                                                 ; $00B8D3 |/
    TAY                                                                         ; $00B8D5 | Transfer the movement mode to the Y register.
    LDA r_npc_properties.1.movement_properties.w,X                              ; $00B8D6 |\
    AND #NPC_MOVEMENT_PROPERTIES_ANIMATED.b                                     ; $00B8D9 | | If the (stationary) NPC is not flagged as animated, set the index
    BNE +                                                                       ; $00B8DB | | directly to $100, which simply uses the first four tiles in the
    LDY #_sizeof_oam_sprite.w * 4 * 16                                          ; $00B8DD | | normal arrangement. Branch to draw the sprite.
    STY <r_generic_tmp_index                                                    ; $00B8E0 | |
    JMP @draw_sprite                                                            ; $00B8E2 |/
+   CPY #NPC_ANIMATION_MODE_ONE_FRAME.w                                         ; $00B8E5 |\
    BNE +                                                                       ; $00B8E8 | | If the stationary NPC only has a single frame, alternate between
    LDA <r_map_frame_counter                                                    ; $00B8EA | | indexes $100 and $140 every 16 frames, which will alternate
    AND #%00010000.b                                                            ; $00B8EC | | ultimately alternate between the single frame and a horizontally
    ASL A                                                                       ; $00B8EE | | flipped version of the frame.
    ASL A                                                                       ; $00B8EF | |
    STA <r_generic_tmp_index.lo                                                 ; $00B8F0 | |
    LDA #$01.b                                                                  ; $00B8F2 | |
    STA <r_generic_tmp_index.hi                                                 ; $00B8F4 | |
    JMP @draw_sprite                                                            ; $00B8F6 |/
+   LDA r_npc_properties.1.movement_properties.w,X                              ; $00B8F9 |\
    LSR A                                                                       ; $00B8FC | | If the stationary NPC has two or four frames, using the NPC's
    LSR A                                                                       ; $00B8FD | | configured speed, shift the map frame counter a particular number
    LSR A                                                                       ; $00B8FE | | of bits ranging from 1 to 4. This value will therefore update
    LSR A                                                                       ; $00B8FF | | anywhere from every 2 frames to every 16 frames.
    LSR A                                                                       ; $00B900 | |
    LSR A                                                                       ; $00B901 | | Afterward, the result is immediately masked to remove the lower
    TAX                                                                         ; $00B902 | | two bits, resulting in an animation speed of either every 8, 16,
    LDA npc_stationary_animated_speed_data.w,X                                  ; $00B903 | | 32 or 64 frames, depending on the NPC's speed.
    TAX                                                                         ; $00B906 | |
    LDA <r_map_frame_counter                                                    ; $00B907 | | This result is then masked by an additional mask to restrict the
-   LSR A                                                                       ; $00B909 | | result to the number of available frames for this sprite.
    DEX                                                                         ; $00B90A | |
    BNE -                                                                       ; $00B90B | |
    LDX <r_draw_field_sprite_npc_properties_index                               ; $00B90D | |
    AND #%00001100.b                                                            ; $00B90F | |
    ASL A                                                                       ; $00B911 | |
    ASL A                                                                       ; $00B912 |/
    AND npc_stationary_animated_mask_data.w,Y                                   ; $00B913 |\
    STA <r_generic_tmp_index.lo                                                 ; $00B916 | | Set the final sprite number based on the previous calculation.
    LDA #$01.b                                                                  ; $00B918 | | Possible values are $100, $110, $120 or $130, which correspond to
    STA <r_generic_tmp_index.hi                                                 ; $00B91A | | the four possible frames (though some sprites only have two).
    JMP @draw_sprite                                                            ; $00B91C |/
@normal:
    LDA r_npc_properties.1.flags.w,X                                            ; $00B91F |\
    AND #NPC_FLAGS_SPINNING.b                                                   ; $00B922 | | If the NPC isn't spinning, branch ahead.
    BEQ +++                                                                     ; $00B924 |/
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00B926 |\
    AND #%01111111.b                                                            ; $00B929 | | Determine the index into the data by taking the NPC's frame
    LSR A                                                                       ; $00B92B | | counter mod 128 and dividing by 16. Therefore, it changes every 16
    LSR A                                                                       ; $00B92C | | frames and has 8 possible values.
    LSR A                                                                       ; $00B92D | |
    LSR A                                                                       ; $00B92E | |
    TAY                                                                         ; $00B92F |/
    LDA r_npc_properties.1.flags.w,X                                            ; $00B930 |\
    AND #NPC_FLAGS_JUMPING.b                                                    ; $00B933 | | Depending on if the NPC is jumping as well, load appropriate data
    BNE +                                                                       ; $00B935 | | and then move on to calculating the index based on that value.
    LDA npc_spinning_direction_data,Y                                           ; $00B937 | |
    JMP ++                                                                      ; $00B93A | |
+   LDA npc_jumping_spin_direction_data,Y                                       ; $00B93D | |
++  STZ <r_generic_tmp_index.lo                                                 ; $00B940 | |
    JMP @calculate_index                                                        ; $00B942 |/
+++ LDA r_npc_properties.1.movement_direction.w,X                               ; $00B945 |\
    AND #%01111111.b                                                            ; $00B948 | | If the NPC is not moving and is not set to animate, set the index
    BNE +                                                                       ; $00B94A | | to 0 to always use frame zero and branch ahead.
    LDA r_npc_properties.1.movement_properties.w,X                              ; $00B94C | |
    AND #NPC_MOVEMENT_PROPERTIES_ANIMATED.b                                     ; $00B94F | |
    BNE ++                                                                      ; $00B951 | |
    LDA #0.b                                                                    ; $00B953 | |
    JMP @load_direction                                                         ; $00B955 |/
+   LDA r_npc_properties.1.frame_counter.w,X                                    ; $00B958 |\
    AND #%01000000.b                                                            ; $00B95B | | Every 64 NPC frames (depends on speed), switch between following
    BEQ +                                                                       ; $00B95D | | the next block, or simply setting the frame to zero.
    LDA #0.b                                                                    ; $00B95F | |
    JMP @load_direction                                                         ; $00B961 |/
+   LDA r_npc_properties.1.frame_counter_limit.w,X                              ; $00B964 |\
    BEQ +                                                                       ; $00B967 | | If a frame counter limit is configured, load half the NPC's frame
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00B969 | | counter into the accumulator and jump ahead.
    LSR A                                                                       ; $00B96C | |
    JMP +++                                                                     ; $00B96D |/
+   LDA <r_cutscene_active                                                      ; $00B970 |\
    BNE ++                                                                      ; $00B972 | | If a cutscene is active, load the map frame counter value.
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00B974 | | Otherwise, use the NPC's frame counter value directly.
    JMP +++                                                                     ; $00B977 | |
++  LDA <r_map_frame_counter                                                    ; $00B97A |/
+++ AND #%00010000.b                                                            ; $00B97C |\
    LSR A                                                                       ; $00B97E | | Using that value, set the frame such that it changes frame every
    LSR A                                                                       ; $00B97F | | 16 times the value changes. (So either every 32 NPC frames, every
    LSR A                                                                       ; $00B980 | | 16 NPC frames, or every 16 map frames.)
    LSR A                                                                       ; $00B981 |/
@load_direction:
    STA <r_generic_tmp_index.lo                                                 ; $00B982 | Set the desired frame based on the accumulator.
    LDA r_npc_properties.1.direction.w,X                                        ; $00B984 |\ Load the NPC's direction and mask out the top bit.
    AND #%01111111.b                                                            ; $00B987 |/
@calculate_index:
    ASL A                                                                       ; $00B989 |\
    CLC                                                                         ; $00B98A | | At this point, the accumulator should contain a direction and
    ADC <r_generic_tmp_index.lo                                                 ; $00B98B | | the index contains either zero or one, depending on the desired
    ASL A                                                                       ; $00B98D | | animation frame. These are multiplied and added in such a way to
    ASL A                                                                       ; $00B98E | | determine the correct offset from the base tile to draw the
    ASL A                                                                       ; $00B98F | | desired frame.
    ASL A                                                                       ; $00B990 | |
    STA <r_generic_tmp_index.lo                                                 ; $00B991 | |
    STZ <r_generic_tmp_index.hi                                                 ; $00B993 |/
@draw_sprite:
    LDA r_npc_properties.1.palette.w,X                                          ; $00B995 |\
    ASL A                                                                       ; $00B998 | | Calculate the palette in the correct bit locations.
    STA <r_draw_field_sprite_npcs_tmp_1                                         ; $00B999 |/
    STZ <r_draw_field_sprite_npcs_tmp_2                                         ; $00B99B |\
    LDA r_npc_properties.1.flags.w,X                                            ; $00B99D | | If the NPC is set to jump, determine their Y coordinate shift by
    AND #NPC_FLAGS_JUMPING.b                                                    ; $00B9A0 | | taking their frame counter divided by four mod 32, and indexing
    BEQ +                                                                       ; $00B9A2 | | into the jumping NPC data. Note that NPC frame counters are
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00B9A4 | | affected by their movement speed.
    LSR A                                                                       ; $00B9A7 | |
    LSR A                                                                       ; $00B9A8 | |
    AND #%00011111.b                                                            ; $00B9A9 | |
    TAX                                                                         ; $00B9AB | |
    LDA bank14.jumping_npc_shift_data.l,X                                       ; $00B9AC | |
    STA <r_draw_field_sprite_npcs_tmp_2                                         ; $00B9B0 |/
+   LDX <r_generic_tmp_index                                                    ; $00B9B2 | Load the index into the OAM data in ROM.
    LDA #4.b                                                                    ; $00B9B4 |\ Initialize the subtile counter to four.
    STA <r_draw_field_sprite_npcs_subtile_index                                 ; $00B9B6 |/
@subtile_loop_start:
    LDY <r_draw_field_sprite_npc_properties_index                               ; $00B9B8 | Load the NPC properties index into Y.
    LDA r_npc_properties.1.x_offset,Y                                           ; $00B9BA |\
    CLC                                                                         ; $00B9BD | | Determine this particular tile's X and Y pixel coordinates by
    ADC bank14.npc_field_sprite_oam_data.l,X                                    ; $00B9BE | | adding the NPC's pixel offset to the tile's offset, and then
    STA <r_generic_arg_x_lo                                                     ; $00B9C2 | | calling the function to calculate the overall coordinates
    STZ <r_generic_arg_x_hi                                                     ; $00B9C4 | |
    LDA r_npc_properties.1.y_offset,Y                                           ; $00B9C6 | |
    CLC                                                                         ; $00B9C9 | |
    ADC bank14.npc_field_sprite_oam_data.l + 1,X                                ; $00B9CA | |
    STA <r_generic_arg_y_lo                                                     ; $00B9CE | |
    STZ <r_generic_arg_y_hi                                                     ; $00B9D0 | |
    JSR _get_npc_pixel_coordinates                                              ; $00B9D2 |/
    LDA <r_get_npc_pixel_coordinates_result_offscreen                           ; $00B9D5 |\ If the left/top of the tile would be off screen, skip the drawing.
    BNE @next                                                                   ; $00B9D7 |/
    LDY <r_draw_field_sprite_npcs_oam_index                                     ; $00B9D9 | Load the OAM index into the Y register.
    LDA <r_draw_field_sprite_npcs_subtile_index                                 ; $00B9DB |\
    LSR A                                                                       ; $00B9DD | | If this is the second or fourth subtile, branch.
    BCS +                                                                       ; $00B9DE |/
    LDA <r_get_npc_pixel_coordinates_result_x                                   ; $00B9E0 |\ Set the tile's X coordinate.
    STA r_oam.65.x,Y                                                            ; $00B9E2 |/
    LDA <r_get_npc_pixel_coordinates_result_y                                   ; $00B9E5 |\
    SEC                                                                         ; $00B9E7 | | Calculate the Y coordinate by subtracting 4  and then subtracting
    SBC #4.b                                                                    ; $00B9E8 | | any additional shift.
    SEC                                                                         ; $00B9EA | |
    SBC <r_draw_field_sprite_npcs_tmp_2                                         ; $00B9EB | |
    STA r_oam.65.y,Y                                                            ; $00B9ED |/
    LDA bank14.npc_field_sprite_oam_data.l + 2,X                                ; $00B9F0 |\
    CLC                                                                         ; $00B9F4 | | Set the tile number to the base tile number plus the offset for
    ADC <r_draw_field_sprite_npcs_base_tile_lo                                  ; $00B9F5 | | the calculated tile.
    STA r_oam.65.tile,Y                                                         ; $00B9F7 |/
    LDA <r_draw_field_sprite_npcs_base_tile_hi                                  ; $00B9FA |\
    ADC #0.b                                                                    ; $00B9FC | | Set the flags by taking the base flags, adding any high bit from
    CLC                                                                         ; $00B9FE | | the tile number, and then adding in the correct palette number.
    ADC bank14.npc_field_sprite_oam_data.l + 3,X                                ; $00B9FF | |
    AND #%11110001.b                                                            ; $00BA03 | |
    CLC                                                                         ; $00BA05 | |
    ADC <r_draw_field_sprite_npcs_tmp_1                                         ; $00BA06 | |
    STA r_oam.65.flags,Y                                                        ; $00BA08 |/
    JMP @next                                                                   ; $00BA0B |\
+   LDA <r_get_npc_pixel_coordinates_result_x                                   ; $00BA0E | | Repeat the above, except for the lower two tiles of the sprite.
    STA r_oam.97.x,Y                                                            ; $00BA10 | | The only real difference is the base OAM offset.
    LDA <r_get_npc_pixel_coordinates_result_y                                   ; $00BA13 | |
    SEC                                                                         ; $00BA15 | |
    SBC #4.b                                                                    ; $00BA16 | |
    SEC                                                                         ; $00BA18 | |
    SBC <r_draw_field_sprite_npcs_tmp_2                                         ; $00BA19 | |
    STA r_oam.97.y,Y                                                            ; $00BA1B | |
    LDA bank14.npc_field_sprite_oam_data.l + 2,X                                ; $00BA1E | |
    CLC                                                                         ; $00BA22 | |
    ADC <r_draw_field_sprite_npcs_base_tile_lo                                  ; $00BA23 | |
    STA r_oam.97.tile,Y                                                         ; $00BA25 | |
    LDA <r_draw_field_sprite_npcs_base_tile_hi                                  ; $00BA28 | |
    ADC #0.b                                                                    ; $00BA2A | |
    CLC                                                                         ; $00BA2C | |
    ADC bank14.npc_field_sprite_oam_data.l + 3,X                                ; $00BA2D | |
    AND #%11110001.b                                                            ; $00BA31 | |
    CLC                                                                         ; $00BA33 | |
    ADC <r_draw_field_sprite_npcs_tmp_1                                         ; $00BA34 | |
    STA r_oam.97.flags,Y                                                        ; $00BA36 |/
    LDY <r_draw_field_sprite_npc_properties_index                               ; $00BA39 |\
    LDA r_npc_properties.1.hide_lower,Y                                         ; $00BA3B | | However, continuing, if the sprite has its hide lower property
    BEQ @next                                                                   ; $00BA3E | | set, the lower two tiles are moved to be drawn off screen.
    LDY <r_draw_field_sprite_npcs_oam_index                                     ; $00BA40 | |
    LDA #248.b                                                                  ; $00BA42 | |
    STA r_oam.97.y,Y                                                            ; $00BA44 |/
@next:
    INX                                                                         ; $00BA47 |\
    INX                                                                         ; $00BA48 | | Increment the X register by four.
    INX                                                                         ; $00BA49 | |
    INX                                                                         ; $00BA4A |/
    LDA <r_draw_field_sprite_npcs_subtile_index                                 ; $00BA4B |\
    LSR A                                                                       ; $00BA4D | | If this is the second or fourth subtile, increment the OAM index.
    BCC +                                                                       ; $00BA4E | |
    LDA <r_draw_field_sprite_npcs_oam_index                                     ; $00BA50 | |
    CLC                                                                         ; $00BA52 | |
    ADC #_sizeof_oam_sprite.b                                                   ; $00BA53 | |
    STA <r_draw_field_sprite_npcs_oam_index                                     ; $00BA55 |/
+   DEC <r_draw_field_sprite_npcs_subtile_index                                 ; $00BA57 |\
    BEQ @invisible                                                              ; $00BA59 | | Loop until all four subtiles have been set.
    JMP @subtile_loop_start                                                     ; $00BA5B |/
@invisible:
    LDA <r_draw_field_sprite_npcs_base_tile_lo                                  ; $00BA5E |\
    CLC                                                                         ; $00BA60 | | For the next NPC, increment the base tile by $20 to move to the
    ADC #$20.b                                                                  ; $00BA61 | | next set of sprites.
    STA <r_draw_field_sprite_npcs_base_tile_lo                                  ; $00BA63 | |
    LDA <r_draw_field_sprite_npcs_base_tile_hi                                  ; $00BA65 | |
    ADC #$00.b                                                                  ; $00BA67 | |
    STA <r_draw_field_sprite_npcs_base_tile_hi                                  ; $00BA69 |/
    LDA <r_draw_field_sprite_npc_properties_index_lo                            ; $00BA6B |\
    CLC                                                                         ; $00BA6D | | Increment the NPC properties index by the size of the data.
    ADC #_sizeof_npc_properties.b                                               ; $00BA6E | |
    STA <r_draw_field_sprite_npc_properties_index_lo                            ; $00BA70 |/
    INC <r_draw_field_sprite_npc_index                                          ; $00BA72 |\
    LDA <r_draw_field_sprite_npc_index                                          ; $00BA74 | | Increment the NPC index and loop until all the NPCs of the map
    CMP r_npc_count.w                                                           ; $00BA76 | | have been processed.
    BEQ +                                                                       ; $00BA79 | |
    JMP @loop_start                                                             ; $00BA7B |/
+   LDA r_plot_flags.11.w                                                       ; $00BA7E |\
    AND #PLOT_FLAG_11_ENDING.b                                                  ; $00BA81 | | Unless this is the ending, return.
    BEQ @done                                                                   ; $00BA83 |/
    STZ <r_draw_field_sprite_npc_index                                          ; $00BA85 | Initialize the NPC index to zero.
@loop2_start:
    LDA <r_draw_field_sprite_npc_index                                          ; $00BA87 |\ Transfer the current NPC index to the X register.
    TAX                                                                         ; $00BA89 |/
    LDA bank14.ending_coronation_sprites_x_data.l,X                             ; $00BA8A |\ Load the base X coordinate for the NPC.
    STA <r_generic_arg_x_lo                                                     ; $00BA8E |/
    LDA bank14.ending_coronation_sprites_y_data.l,X                             ; $00BA90 |\ Load the base Y coordinate for the NPC.
    STA <r_generic_arg_y_lo                                                     ; $00BA94 |/
    LDA bank14.ending_coronation_sprites_tile_data.l,X                          ; $00BA96 |\ Load the tile number for the NPC.
    STA <r_draw_field_sprite_npcs_tmp_1                                         ; $00BA9A |/
    LDA bank14.ending_coronation_sprites_flags_data.l,X                         ; $00BA9C |\ Load the base flags for this NPC.
    STA <r_draw_field_sprite_npcs_tmp_2                                         ; $00BAA0 |/
    LDA <r_draw_field_sprite_npc_index                                          ; $00BAA2 |\
    STZ <r_generic_tmp_index.hi                                                 ; $00BAA4 | | Calculate the offset into the OAM data by taking the NPC index and
    ASL A                                                                       ; $00BAA6 | | multiplying by 16. (Each NPC will use four sprites of four bytes
    ROL <r_generic_tmp_index.hi                                                 ; $00BAA7 | | each.)
    ASL A                                                                       ; $00BAA9 | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BAAA | |
    ASL A                                                                       ; $00BAAC | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BAAD | |
    ASL A                                                                       ; $00BAAF | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BAB0 | |
    STA <r_generic_tmp_index.lo                                                 ; $00BAB2 | |
    LDY <r_generic_tmp_index                                                    ; $00BAB4 |/
    LDA <r_draw_field_sprite_npc_index                                          ; $00BAB6 |\
    TAX                                                                         ; $00BAB8 | | Set the X register to the value read from the coronation sprites
    LDA bank14.ending_coronation_sprites_oam_offset_data.l,X                    ; $00BAB9 | | OAM data.
    TAX                                                                         ; $00BABD |/
-   LDA <r_generic_arg_x_lo                                                     ; $00BABE |\
    CLC                                                                         ; $00BAC0 | | Set the tile's X coordinate by adding the sprite's base coordinate
    ADC bank14.npc_field_sprite_oam_data.l,X                                    ; $00BAC1 | | and the offset for this tile.
    STA r_oam.1.x,Y                                                             ; $00BAC5 |/
    LDA <r_generic_arg_y_lo                                                     ; $00BAC8 |\
    CLC                                                                         ; $00BACA | | Repeat to set the tile's Y coordinate.
    ADC bank14.npc_field_sprite_oam_data.l + 1,X                                ; $00BACB | |
    STA r_oam.1.y,Y                                                             ; $00BACF |/
    LDA <r_draw_field_sprite_npcs_tmp_1                                         ; $00BAD2 |\
    CLC                                                                         ; $00BAD4 | | Set the tile number by adding the subtile-specific offset to the
    ADC bank14.npc_field_sprite_oam_data.l + 2,X                                ; $00BAD5 | | base index.
    STA r_oam.1.tile,Y                                                          ; $00BAD9 |/
    LDA bank14.npc_field_sprite_oam_data.l + 3,X                                ; $00BADC |\
    AND #%11110001.b                                                            ; $00BAE0 | | Set the flags by masking out the palette and substituting the
    ORA <r_draw_field_sprite_npcs_tmp_2                                         ; $00BAE2 | | correct palette for this NPC.
    STA r_oam.1.flags,Y                                                         ; $00BAE4 |/
    JSR _increment_indexes_by_four                                              ; $00BAE7 |\
    TYA                                                                         ; $00BAEA | | Increment the indexes and loop until all four subtiles have been
    AND #$0F.b                                                                  ; $00BAEB | | set.
    BNE -                                                                       ; $00BAED |/
    INC <r_draw_field_sprite_npc_index                                          ; $00BAEF |\
    LDA <r_draw_field_sprite_npc_index                                          ; $00BAF1 | | Loop until all 16 extra sprites have been set.
    CMP #$10.b                                                                  ; $00BAF3 | |
    BNE @loop2_start                                                            ; $00BAF5 |/
@done:
    RTS                                                                         ; $00BAF7

; _get_npc_pixel_coordinates ($00:BAF8)
;
; Given a 16-bit index into the NPC properties array in $06AF, an X coordinate
; offset in $060C, and a Y coordinate offset in $060E, determines if the
; referenced NPC subtile would be offscreen. Technically, it measures if the
; leftmost pixel would be offscreen. If so, a 1 is returned in $06D7. The pixel
; coordinates of the subtile are returned in $0618 and $061A. Both values are
; 16-bit.
_get_npc_pixel_coordinates:
    PHX                                                                         ; $00BAF8 |\ Preserve the X and Y registers.
    PHY                                                                         ; $00BAF9 |/
    STZ <r_get_npc_pixel_coordinates_result_offscreen                           ; $00BAFA | Zero out the result variable.
    LDX <r_draw_field_sprite_npc_properties_index                               ; $00BAFC | Load the index into the NPC property data for the current NPC.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00BAFE | Switch into 16-bit accumulator mode.
    LDA r_npc_properties.1.x.w,X                                                ; $00BB00 |\
    AND #$00FF.w                                                                ; $00BB03 | | Multiply the X coordinate by 16 and add the X coordinate
    ASL A                                                                       ; $00BB06 | | parameter (which was the X offset plus the subtile X offset), and
    ASL A                                                                       ; $00BB07 | | then subtract the horizontal BG1 scroll register. Take the result
    ASL A                                                                       ; $00BB08 | | mod 1024 (64 tiles), and store the result. If the result would be
    ASL A                                                                       ; $00BB09 | | off-screen, set the result flag and return.
    CLC                                                                         ; $00BB0A | |
    ADC <r_generic_arg_x                                                        ; $00BB0B | |
    SEC                                                                         ; $00BB0D | |
    SBC <r_scroll_bg1_horizontal                                                ; $00BB0E | |
    AND #$03FF.w                                                                ; $00BB10 | |
    STA <r_get_npc_pixel_coordinates_result_x                                   ; $00BB13 | |
    CMP #256.w                                                                  ; $00BB15 | |
    BCS +                                                                       ; $00BB18 |/
    LDA r_npc_properties.1.y.w,X                                                ; $00BB1A |\
    AND #$00FF.w                                                                ; $00BB1D | | Repeat the process with the Y coordinate, except the comparison
    ASL A                                                                       ; $00BB20 | | is to 240 instead of 256.
    ASL A                                                                       ; $00BB21 | |
    ASL A                                                                       ; $00BB22 | |
    ASL A                                                                       ; $00BB23 | |
    CLC                                                                         ; $00BB24 | |
    ADC <r_generic_arg_y                                                        ; $00BB25 | |
    SEC                                                                         ; $00BB27 | |
    SBC <r_scroll_bg1_vertical                                                  ; $00BB28 | |
    AND #$03FF.w                                                                ; $00BB2A | |
    STA <r_get_npc_pixel_coordinates_result_y                                   ; $00BB2D | |
    CMP #240.w                                                                  ; $00BB2F | |
    BCC ++                                                                      ; $00BB32 | |
+   INC <r_get_npc_pixel_coordinates_result_offscreen                           ; $00BB34 | |
++  LDA #0.w                                                                    ; $00BB36 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00BB39 |/
    PLY                                                                         ; $00BB3B |\ Restore the X and Y registers.
    PLX                                                                         ; $00BB3C |/
    RTS                                                                         ; $00BB3D

; npc_stationary_animated_speed_data ($00:BB3E)
;
; For a stationary animated NPC of a given speed, contains the number of bits to
; shift the frame counter to the right to determine the frame index.
npc_stationary_animated_speed_data:
    .db 4                                                                       ; $00BB3E
    .db 3                                                                       ; $00BB3F
    .db 2                                                                       ; $00BB40
    .db 1                                                                       ; $00BB41

; npc_stationary_animated_mask_data ($00:BB42)
;
; Masks that, when applied to a frame counter, determine which animation frame
; to use at any given moment.
npc_stationary_animated_mask_data:
    .db %00000000                                                               ; $00BB42 | $00: <unused>
    .db %00000000                                                               ; $00BB43 | $01: <unused>
    .db %00010000                                                               ; $00BB44 | $02: Two Frames
    .db %00110000                                                               ; $00BB45 | $03: Four Frames

; npc_spinning_direction_data ($00:BB4E)
;
; For an NPC that is standing and spinning, contains the appropriate direction
; for them to face, in order.
npc_spinning_direction_data:
    .db 3                                                                       ; $00BB46
    .db 0                                                                       ; $00BB47
    .db 1                                                                       ; $00BB48
    .db 2                                                                       ; $00BB49
    .db 3                                                                       ; $00BB4A
    .db 0                                                                       ; $00BB4B
    .db 1                                                                       ; $00BB4C
    .db 2                                                                       ; $00BB4D

; npc_jumping_spin_direction_data ($00:BB4E)
;
; For an NPC that is both jumping and spinning, contains the appropriate
; direction for them to face, in order.
npc_jumping_spin_direction_data:
    .db 2                                                                       ; $00BB4E
    .db 2                                                                       ; $00BB4F
    .db 3                                                                       ; $00BB50
    .db 0                                                                       ; $00BB51
    .db 1                                                                       ; $00BB52
    .db 2                                                                       ; $00BB53
    .db 2                                                                       ; $00BB54
    .db 2                                                                       ; $00BB55

; _update_npc_movement ($00:BB56)
;
; Loops through the NPCs for the current map, updating their movement direction.
_update_npc_movement:
    LDA r_npc_count.w                                                           ; $00BB56 |\
    BNE +                                                                       ; $00BB59 | | Return if there are no NPCs.
    RTS                                                                         ; $00BB5B |/
+   STZ <r_npc_index                                                            ; $00BB5C |\
    LDX #0.w                                                                    ; $00BB5E | | Initialize the NPC index and properties offset to zero.
    STX <r_npc_properties_offset                                                ; $00BB61 |/
@loop_start:
    LDX <r_npc_properties_offset                                                ; $00BB63 |\
    LDA <r_cutscene_active                                                      ; $00BB65 | | If a cutscene is active and if the NPC's frame counter limit is at
    BEQ +                                                                       ; $00BB67 | | zero, jump to finalize this NPC and move on to the next.
    LDA r_npc_properties.1.frame_counter_limit.w,X                              ; $00BB69 | |
    BNE +                                                                       ; $00BB6C | |
    JMP @next                                                                   ; $00BB6E |/
+   LDA r_npc_properties.1.movement_direction.w,X                               ; $00BB71 |\
    AND #%01111111.b                                                            ; $00BB74 | | If the NPC has no movement direction, branch to update the field
    BNE +                                                                       ; $00BB76 | | sprite positioning, as this NPC doesn't move.
    JMP @execute_movement                                                       ; $00BB78 |/
+   LDA r_npc_properties.1.frame_counter.w,X                                    ; $00BB7B |\
    AND #%01000000.b                                                            ; $00BB7E | | Branch to the next NPC if the frame counter is between 64 and 127
    BEQ +                                                                       ; $00BB80 | | or 192 and 255, to let the NPC not move during those cycles.
    JMP @next                                                                   ; $00BB82 |/
+   LDA r_npc_properties.1.frame_counter.w,X                                    ; $00BB85 |\
    AND #%00111111.b                                                            ; $00BB88 | | Branch to the next NPC if the frame counter mod 64 is not zero.
    BEQ +                                                                       ; $00BB8A | |
    JMP @next                                                                   ; $00BB8C |/
+   STZ r_npc_properties.1.force_normal_speed.w,X                               ; $00BB8F |\
    LDA <r_pushed_npc_index                                                     ; $00BB92 | | If the NPC was pushed, set the flag to force them to move at
    BEQ +                                                                       ; $00BB94 | | normal speed.
    AND #NPC_MOVEMENT_DIRECTION_VALUE.b                                         ; $00BB96 | |
    CMP <r_npc_index                                                            ; $00BB98 | |
    BNE +                                                                       ; $00BB9A | |
    STZ <r_pushed_npc_index                                                     ; $00BB9C | |
    LDA #1.b                                                                    ; $00BB9E | |
    STA r_npc_properties.1.force_normal_speed.w,X                               ; $00BBA0 |/
+   LDA r_npc_properties.1.x.w,X                                                ; $00BBA3 |\
    STA <r_generic_arg_x_lo                                                     ; $00BBA6 | | Get the layer property bits for the NPC's current coordinates.
    LDA r_npc_properties.1.y.w,X                                                ; $00BBA8 | |
    STA <r_generic_arg_y_lo                                                     ; $00BBAB | |
    JSR _get_tile_layer_1_2                                                     ; $00BBAD | |
    STA <r_generic_tmp_1                                                        ; $00BBB0 |/
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BBB2 |\
    AND #~NPC_MOVEMENT_DIRECTION_PREVENT_MOVEMENT.b                             ; $00BBB5 | | Reset the bit that prevents NPC movement.
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BBB7 |/
    JSR _get_field_rng                                                          ; $00BBBA |\
    CMP #128.b                                                                  ; $00BBBD | | If a random number from 0 to 255 is 128 or greater, jump to
    BCC +                                                                       ; $00BBBF | | immediately validate their movement.
    JMP @validate_movement                                                      ; $00BBC1 |/
+   LDA r_npc_properties.1.x.w,X                                                ; $00BBC4 |\
    STA <r_generic_arg_x_lo                                                     ; $00BBC7 | | If the NPC is moving horizontally, branch to the horizontal code.
    LDA r_npc_properties.1.y.w,X                                                ; $00BBC9 | |
    STA <r_generic_arg_y_lo                                                     ; $00BBCC | |
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BBCE | |
    LSR A                                                                       ; $00BBD1 | |
    BCC @horizontal                                                             ; $00BBD2 |/
    JSR _get_field_rng                                                          ; $00BBD4 |\
    LSR A                                                                       ; $00BBD7 | | If a random value mod 2 is zero, increment the X coordinate and if
    BCS +                                                                       ; $00BBD8 | | the layers match the value for the current tile, and if the other
    INC <r_generic_arg_x_lo                                                     ; $00BBDA | | tile is in bounds and empty, set the NPC's movement direction to
    JSR _get_tile_layer_1_2                                                     ; $00BBDC | | right. Afterward, branch to a later section of code.
    CMP <r_generic_tmp_1                                                        ; $00BBDF | |
    BNE @validate_movement                                                      ; $00BBE1 | |
    JSR _get_field_sprite_positioning_bounded                                   ; $00BBE3 | |
    CMP #0.b                                                                    ; $00BBE6 | |
    BNE @validate_movement                                                      ; $00BBE8 | |
    LDA #MOVEMENT_DIRECTION_RIGHT.b                                             ; $00BBEA | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BBEC | |
    JMP @validate_movement                                                      ; $00BBEF |/
+   DEC <r_generic_arg_x_lo                                                     ; $00BBF2 |\
    JSR _get_tile_layer_1_2                                                     ; $00BBF4 | | If the random value mod 2 was one, instead do the same procedure
    CMP <r_generic_tmp_1                                                        ; $00BBF7 | | except for the tile to the left.
    BNE @validate_movement                                                      ; $00BBF9 | |
    JSR _get_field_sprite_positioning_bounded                                   ; $00BBFB | |
    CMP #0.b                                                                    ; $00BBFE | |
    BNE @validate_movement                                                      ; $00BC00 | |
    LDA #MOVEMENT_DIRECTION_LEFT.b                                              ; $00BC02 | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BC04 | |
    JMP @validate_movement                                                      ; $00BC07 |/
@horizontal:
    JSR _get_field_rng                                                          ; $00BC0A |\
    LSR A                                                                       ; $00BC0D | | If moving horizontally and if a random value mod 2 is zero, check
    BCS +                                                                       ; $00BC0E | | if the tile to the north is available using the same procedure as
    DEC <r_generic_arg_y_lo                                                     ; $00BC10 | | above. If so, set the movement direction to up.
    JSR _get_tile_layer_1_2                                                     ; $00BC12 | |
    CMP <r_generic_tmp_1                                                        ; $00BC15 | |
    BNE @validate_movement                                                      ; $00BC17 | |
    JSR _get_field_sprite_positioning_bounded                                   ; $00BC19 | |
    CMP #0.b                                                                    ; $00BC1C | |
    BNE @validate_movement                                                      ; $00BC1E | |
    LDA #MOVEMENT_DIRECTION_UP.b                                                ; $00BC20 | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BC22 | |
    JMP @validate_movement                                                      ; $00BC25 |/
+   INC <r_generic_arg_y_lo                                                     ; $00BC28 |\
    JSR _get_tile_layer_1_2                                                     ; $00BC2A | | If moving horizontally and the random value mod 2 is one, check
    CMP <r_generic_tmp_1                                                        ; $00BC2D | | the tile to the south instead.
    BNE @validate_movement                                                      ; $00BC2F | |
    JSR _get_field_sprite_positioning_bounded                                   ; $00BC31 | |
    CMP #0.b                                                                    ; $00BC34 | |
    BNE @validate_movement                                                      ; $00BC36 | |
    LDA #MOVEMENT_DIRECTION_DOWN.b                                              ; $00BC38 | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BC3A | |
    JMP @validate_movement                                                      ; $00BC3D |/
@validate_movement:
    LDX <r_npc_properties_offset                                                ; $00BC40 |\
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BC42 | | Update the X coordinate with the delta for the current movement
    AND #NPC_MOVEMENT_DIRECTION_VALUE.b                                         ; $00BC45 | | direction.
    TAY                                                                         ; $00BC47 | |
    LDA r_npc_properties.1.x.w,X                                                ; $00BC48 | |
    CLC                                                                         ; $00BC4B | |
    ADC movement_direction_x_delta_data.w,Y                                     ; $00BC4C | |
    STA <r_generic_arg_x_lo                                                     ; $00BC4F |/
    LDA r_npc_properties.1.y.w,X                                                ; $00BC51 |\
    CLC                                                                         ; $00BC54 | | Update the Y coordinate with the delta for the current movement
    ADC movement_direction_y_delta_data.w,Y                                     ; $00BC55 | | direction.
    STA <r_generic_arg_y_lo                                                     ; $00BC58 |/
    JSR _get_tile_layer_1_2                                                     ; $00BC5A |\
    CMP <r_generic_tmp_1                                                        ; $00BC5D | | If the new tile has the same layer properties and if it's open
    BNE +                                                                       ; $00BC5F | | for movement, branch ahead.
    JSR _get_field_sprite_positioning_bounded                                   ; $00BC61 | |
    CMP #0.b                                                                    ; $00BC64 | |
    BEQ @execute_movement                                                       ; $00BC66 |/
+   LDA r_npc_properties.1.movement_direction.w,X                               ; $00BC68 |\
    DEC A                                                                       ; $00BC6B | | Calculate a new movement direction by inverting the current
    CLC                                                                         ; $00BC6C | | direction.
    ADC #2.b                                                                    ; $00BC6D | |
    AND #%00000011.b                                                            ; $00BC6F | |
    INC A                                                                       ; $00BC71 |/
    TAY                                                                         ; $00BC72 |\
    LDA r_npc_properties.1.x.w,X                                                ; $00BC73 | | Calculate the coordinates for the new direction.
    CLC                                                                         ; $00BC76 | |
    ADC movement_direction_x_delta_data.w,Y                                     ; $00BC77 | |
    STA <r_generic_arg_x_lo                                                     ; $00BC7A | |
    LDA r_npc_properties.1.y.w,X                                                ; $00BC7C | |
    CLC                                                                         ; $00BC7F | |
    ADC movement_direction_y_delta_data.w,Y                                     ; $00BC80 | |
    STA <r_generic_arg_y_lo                                                     ; $00BC83 |/
    JSR _get_tile_layer_1_2                                                     ; $00BC85 |\
    CMP <r_generic_tmp_1                                                        ; $00BC88 | | If the tile doesn't match layers or if the tile is not empty,
    BNE +                                                                       ; $00BC8A | | branch to code to handle that situation.
    JSR _get_field_sprite_positioning_bounded                                   ; $00BC8C | |
    CMP #0.b                                                                    ; $00BC8F | |
    BNE +                                                                       ; $00BC91 |/
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BC93 |\
    DEC A                                                                       ; $00BC96 | | Update the NPC's movement direction to invert it.
    CLC                                                                         ; $00BC97 | |
    ADC #2.b                                                                    ; $00BC98 | |
    AND #%00000011.b                                                            ; $00BC9A | |
    INC A                                                                       ; $00BC9C | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BC9D | |
    JMP @execute_movement                                                       ; $00BCA0 |/
+   LDA r_npc_properties.1.movement_direction.w,X                               ; $00BCA3 |\
    ORA #NPC_MOVEMENT_DIRECTION_PREVENT_MOVEMENT.b                              ; $00BCA6 | | If the tile isn't available, set the flag to prevent movement and
    STA r_npc_properties.1.movement_direction.w,X                               ; $00BCA8 | | jump to the next NPC.
    JMP @next                                                                   ; $00BCAB |/
@execute_movement:
    LDA r_npc_properties.1.visible.w,X                                          ; $00BCAE |\
    BNE +                                                                       ; $00BCB1 | | If the NPC isn't visible, skip to the next NPC.
    JMP @next                                                                   ; $00BCB3 |/
+   LDA r_npc_properties.1.x.w,X                                                ; $00BCB6 |\
    STA <r_generic_arg_x_lo                                                     ; $00BCB9 | | Clear the sprite position at the current NPC coordinates.
    LDA r_npc_properties.1.y.w,X                                                ; $00BCBB | |
    STA <r_generic_arg_y_lo                                                     ; $00BCBE | |
    JSR _clear_sprite_position                                                  ; $00BCC0 |/
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BCC3 |\
    AND #NPC_MOVEMENT_DIRECTION_VALUE.b                                         ; $00BCC6 | | Update the field sprite positioning array to move the NPC to its
    TAY                                                                         ; $00BCC8 | | new coordinates.
    LDA r_npc_properties.1.x.w,X                                                ; $00BCC9 | |
    CLC                                                                         ; $00BCCC | |
    ADC movement_direction_x_delta_data.w,Y                                     ; $00BCCD | |
    STA <r_generic_arg_x_lo                                                     ; $00BCD0 | |
    LDA r_npc_properties.1.y.w,X                                                ; $00BCD2 | |
    CLC                                                                         ; $00BCD5 | |
    ADC movement_direction_y_delta_data.w,Y                                     ; $00BCD6 | |
    STA <r_generic_arg_y_lo                                                     ; $00BCD9 | |
    JSR _update_field_sprite_positioning                                        ; $00BCDB |/
@next:
    LDX <r_npc_properties_offset                                                ; $00BCDE |\
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BCE0 | | Set the NPC's direction based on its movement direction.
    BEQ +                                                                       ; $00BCE3 | |
    DEC A                                                                       ; $00BCE5 | |
    STA r_npc_properties.1.direction.w,X                                        ; $00BCE6 |/
+   LDA r_npc_properties.1.x.w,X                                                ; $00BCE9 |\
    STA <r_generic_tmp_index.lo                                                 ; $00BCEC | | If the tile the NPC is currently on has the hide lower bit set,
    LDA r_npc_properties.1.y.w,X                                                ; $00BCEE | | set the flag to hide the lower half of the NPC.
    STA <r_generic_tmp_index.hi                                                 ; $00BCF1 | |
    LDX <r_generic_tmp_index                                                    ; $00BCF3 | |
    LDA r_tilemap_data.l,X                                                      ; $00BCF5 | |
    STA <r_generic_tmp_index.lo                                                 ; $00BCF9 | |
    STZ <r_generic_tmp_index.hi                                                 ; $00BCFB | |
    ASL <r_generic_tmp_index.lo                                                 ; $00BCFD | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BCFF | |
    LDX <r_generic_tmp_index                                                    ; $00BD01 | |
    LDA r_tile_properties.1.properties_2.w,X                                    ; $00BD03 | |
    LDX <r_npc_properties_offset                                                ; $00BD06 | |
    AND #TILE_PROPERTY_2_HIDE_LOWER.b                                           ; $00BD08 | |
    STA r_npc_properties.1.hide_lower.w,X                                       ; $00BD0A |/
    LDA <r_npc_properties_offset.lo                                             ; $00BD0D |\
    CLC                                                                         ; $00BD0F | | Increment the properties offset to move to the next NPC.
    ADC #_sizeof_npc_properties.b                                               ; $00BD10 | |
    STA <r_npc_properties_offset.lo                                             ; $00BD12 |/
    INC <r_npc_index                                                            ; $00BD14 |\
    LDA <r_npc_index                                                            ; $00BD16 | | Increment the NPC index and loop until it reaches the NPC count.
    CMP r_npc_count.w                                                           ; $00BD18 | |
    BEQ +                                                                       ; $00BD1B | |
    JMP @loop_start                                                             ; $00BD1D |/
+   RTS                                                                         ; $00BD20

; movement_direction_x_delta_data ($00:BD21)
;
; For each movement direction value, determines the delta to add to the X
; coordinate to update the coordinate.
movement_direction_x_delta_data:
    .db  0                                                                      ; $00BD21 | $00: <no movement>
    .db  0                                                                      ; $00BD22 | $01: Up
    .db  1                                                                      ; $00BD23 | $02: Right
    .db  0                                                                      ; $00BD24 | $03: Down
    .db -1                                                                      ; $00BD25 | $04: Left

; movement_direction_y_delta_data ($00:BD26)
;
; For each movement direction value, determines the delta to add to the Y
; coordinate to update the coordinate.
movement_direction_y_delta_data:
    .db  0                                                                      ; $00BD26 | $00: <no movement>
    .db -1                                                                      ; $00BD27 | $01: Up
    .db  0                                                                      ; $00BD28 | $02: Right
    .db  1                                                                      ; $00BD29 | $03: Down
    .db  0                                                                      ; $00BD2A | $04: Left

; _get_tile_layer_1_2 ($00:BD2B)
;
; Given an 8-bit X coordinate in $0C and an 8-bit Y coordinate in $0E, loads the
; tile properties for that tile and returns the first properties byte masked to
; return only the two layer bits as well as the high bit. If either coordinate
; has the high bit set, zero will be returned.
_get_tile_layer_1_2:
    PHX                                                                         ; $00BD2B | Preserve the value in the X register.
    LDA <r_generic_arg_x_lo                                                     ; $00BD2C |\
    BMI +                                                                       ; $00BD2E | | Branch to return zero if either coordinate has the high bit set.
    STA <r_generic_tmp_index.lo                                                 ; $00BD30 | |
    LDA <r_generic_arg_y_lo                                                     ; $00BD32 | |
    BMI +                                                                       ; $00BD34 |/
    STA <r_generic_tmp_index.hi                                                 ; $00BD36 |\
    LDX <r_generic_tmp_index                                                    ; $00BD38 | | Otherwise, read the tile properties for the tile at those
    LDA r_tilemap_data.l,X                                                      ; $00BD3A | | coordinates and mask out three bits: the layer 1 and layer 2 bits,
    STA <r_generic_tmp_index.lo                                                 ; $00BD3E | | and a TODO bit that doesn't seem to be used.
    STZ <r_generic_tmp_index.hi                                                 ; $00BD40 | |
    ASL <r_generic_tmp_index.lo                                                 ; $00BD42 | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BD44 | |
    LDX <r_generic_tmp_index                                                    ; $00BD46 | |
    LDA r_tile_properties.1.properties_1.w,X                                    ; $00BD48 | |
    AND #%10000011.b                                                            ; $00BD4B | |
    JMP ++                                                                      ; $00BD4D |/
+   LDA #0.b                                                                    ; $00BD50 | Load zero for the out of range coordinates.
++  PLX                                                                         ; $00BD52 | Restore the X register.
    RTS                                                                         ; $00BD53

; _do_npc_movement ($00:BD54)
;
; Handles NPC movement by updating each NPC's coordinates and coordinate offsets
; based on its parameters.
_do_npc_movement:
    LDA r_npc_count.w                                                           ; $00BD54 |\
    BNE +                                                                       ; $00BD57 | | If the current map has no NPCs, return.
    RTS                                                                         ; $00BD59 |/
+   STZ <r_npc_index                                                            ; $00BD5A | Initialize the current NPC index to zero.
    LDX #0.w                                                                    ; $00BD5C |\ Initialize the NPC properties offset to zero.
    STX <r_npc_properties_offset                                                ; $00BD5F |/
@loop_start:
    LDX <r_npc_properties_offset                                                ; $00BD61 | Set the X register to the current NPC properties offset.
    LDA <r_cutscene_active                                                      ; $00BD63 |\
    BEQ +                                                                       ; $00BD65 | | If a cutscene is active, and the NPC's frame counter limit is set
    LDA r_npc_properties.1.frame_counter_limit.w,X                              ; $00BD67 | | to zero, jump to skip this NPC. Otherwise, if a cutscene is
    BNE ++                                                                      ; $00BD6A | | active, branch to skip the next block.
    JMP @next                                                                   ; $00BD6C |/
+   LDA r_npc_properties.1.movement_direction.w,X                               ; $00BD6F |\
    BPL +                                                                       ; $00BD72 | | If no cutscene is active and if either the high bit of the NPC's
    JMP @update_frame_counter                                                   ; $00BD74 | | movement direction is set or if the NPC's frame counter is
+   LDX <r_npc_properties_offset                                                ; $00BD77 | | does not have bit 6 set, branch to update the NPC's frame counter
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00BD79 | | and skip to the next one. (In other words, the NPC alternates
    AND #%01000000.b                                                            ; $00BD7C | | between moving and not moving every 64 NPC frames.)
    BEQ ++                                                                      ; $00BD7E | |
    JMP @update_frame_counter                                                   ; $00BD80 |/
++  LDA r_npc_properties.1.movement_direction.w,X                               ; $00BD83 |\
    AND #%01111111.b                                                            ; $00BD86 | | If the NPC has no movement direction configured, branch to update
    BNE +                                                                       ; $00BD88 | | its frame counter and move to the next.
    JMP @update_frame_counter                                                   ; $00BD8A |/
+   LDA r_npc_properties.1.frame_counter.w,X                                    ; $00BD8D |\
    AND #%00000011.b                                                            ; $00BD90 | | If the NPC's frame counter is not divisible by four, branch to
    BEQ +                                                                       ; $00BD92 | | only update the frame counter.
    JMP @update_frame_counter                                                   ; $00BD94 |/
+   LDX <r_npc_properties_offset                                                ; $00BD97 |\
    LDA r_npc_properties.1.force_normal_speed.w,X                               ; $00BD99 | | Determine the NPC's speed. This is either the top 2 bits of the
    BNE +                                                                       ; $00BD9C | | movement properties shifted right six times, or (if normal speed
    LDA r_npc_properties.1.movement_properties.w,X                              ; $00BD9E | | is forced) simply 2. The movement speeds are:
    AND #NPC_MOVEMENT_PROPERTIES_SPEED.b                                        ; $00BDA1 | |
    LSR A                                                                       ; $00BDA3 | |   0: 1 pixel every four frames
    LSR A                                                                       ; $00BDA4 | |   1: 1 pixel every two frames
    LSR A                                                                       ; $00BDA5 | |   2: 1 pixel every frame
    LSR A                                                                       ; $00BDA6 | |   3: 2 pixels every frame
    LSR A                                                                       ; $00BDA7 | |
    LSR A                                                                       ; $00BDA8 | | In any case, transfer the speed to the Y register.
    JMP ++                                                                      ; $00BDA9 | |
+   LDA #2.b                                                                    ; $00BDAC | |
++  TAY                                                                         ; $00BDAE |/
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00BDAF |\
    DEC A                                                                       ; $00BDB2 | | Branch to the appropriate code for the NPC's movement direction.
    BEQ @up                                                                     ; $00BDB3 | |
    DEC A                                                                       ; $00BDB5 | |
    BEQ @right                                                                  ; $00BDB6 | |
    DEC A                                                                       ; $00BDB8 | |
    BEQ @down                                                                   ; $00BDB9 | |
    JMP @left                                                                   ; $00BDBB |/
@up:
    LDA r_npc_properties.1.y_offset.w,X                                         ; $00BDBE |\
    SEC                                                                         ; $00BDC1 | | Based on the NPC's movement speed, decrement the Y offset by the
    SBC npc_pixels_per_movement_data.w,Y                                        ; $00BDC2 | | correct number of pixels. If the result is negative, decrement the
    PHA                                                                         ; $00BDC5 | | NPC's Y coordinate. Store the new Y offset mod 16. Finally, jump
    AND #%00001111.b                                                            ; $00BDC6 | | to update the frame counter.
    STA r_npc_properties.1.y_offset.w,X                                         ; $00BDC8 | |
    PLA                                                                         ; $00BDCB | |
    BPL +                                                                       ; $00BDCC | |
    DEC r_npc_properties.1.y.w,X                                                ; $00BDCE | |
+   JMP @update_frame_counter                                                   ; $00BDD1 |/
@right:
    LDA r_npc_properties.1.x_offset.w,X                                         ; $00BDD4 |\
    CLC                                                                         ; $00BDD7 | | Increment the X offset based on the movement speed. If the result
    ADC npc_pixels_per_movement_data.w,Y                                        ; $00BDD8 | | mod 16 is equal to zero, increment the X coordinate. Jump to
    AND #%00001111.b                                                            ; $00BDDB | | update the frame counter.
    STA r_npc_properties.1.x_offset.w,X                                         ; $00BDDD | |
    CMP #0.b                                                                    ; $00BDE0 | |
    BNE +                                                                       ; $00BDE2 | |
    INC r_npc_properties.1.x.w,X                                                ; $00BDE4 | |
+   JMP @update_frame_counter                                                   ; $00BDE7 |/
@down:
    LDA r_npc_properties.1.y_offset.w,X                                         ; $00BDEA |\
    CLC                                                                         ; $00BDED | | Increment the Y offset based on the movement speed. If the result
    ADC npc_pixels_per_movement_data.w,Y                                        ; $00BDEE | | mod 16 is equal to zero, increment the Y coordinate. Jump to
    AND #%00001111.b                                                            ; $00BDF1 | | update the frame counter.
    STA r_npc_properties.1.y_offset.w,X                                         ; $00BDF3 | |
    CMP #0.b                                                                    ; $00BDF6 | |
    BNE +                                                                       ; $00BDF8 | |
    INC r_npc_properties.1.y.w,X                                                ; $00BDFA | |
+   JMP @update_frame_counter                                                   ; $00BDFD |/
@left:
    LDA r_npc_properties.1.x_offset.w,X                                         ; $00BE00 |\
    SEC                                                                         ; $00BE03 | | Decrement the X offset based on the movement speed. If the result
    SBC npc_pixels_per_movement_data.w,Y                                        ; $00BE04 | | is negative, decrement the X coordinate. Store the updated X
    PHA                                                                         ; $00BE07 | | offset mod 16. Jump to update the frame counter.
    AND #%00001111.b                                                            ; $00BE08 | |
    STA r_npc_properties.1.x_offset.w,X                                         ; $00BE0A | |
    PLA                                                                         ; $00BE0D | |
    BPL +                                                                       ; $00BE0E | |
    DEC r_npc_properties.1.x.w,X                                                ; $00BE10 | |
+   JMP @update_frame_counter                                                   ; $00BE13 |/
@update_frame_counter:
    LDA r_npc_properties.1.force_normal_speed.w,X                               ; $00BE16 |\
    BNE +                                                                       ; $00BE19 | | Pointlessly determine the NPC's movement speed again, even though
    LDA r_npc_properties.1.movement_properties.w,X                              ; $00BE1B | | the speed is still in the Y register.
    LSR A                                                                       ; $00BE1E | |
    LSR A                                                                       ; $00BE1F | |
    LSR A                                                                       ; $00BE20 | |
    LSR A                                                                       ; $00BE21 | |
    LSR A                                                                       ; $00BE22 | |
    LSR A                                                                       ; $00BE23 | |
    JMP ++                                                                      ; $00BE24 | |
+   LDA #2.b                                                                    ; $00BE27 | |
++  TAY                                                                         ; $00BE29 |/
    LDA r_npc_properties.1.frame_counter.w,X                                    ; $00BE2A |\
    CLC                                                                         ; $00BE2D | | Based on the movement speed, update the NPC's frame counter.
    ADC npc_frames_per_frame_data.w,Y                                           ; $00BE2E | |
    STA r_npc_properties.1.frame_counter.w,X                                    ; $00BE31 |/
@next:
    LDA <r_cutscene_active                                                      ; $00BE34 |\
    BEQ +                                                                       ; $00BE36 | | If a cutscene is active, if the NPC has a non-zero frame counter
    LDA r_npc_properties.1.frame_counter_limit.w,X                              ; $00BE38 | | limit and if the NPC's frame counter is equal to the limit, set
    BEQ +                                                                       ; $00BE3B | | the limit again to zero and set the NPC's movement direction to
    CMP r_npc_properties.1.frame_counter.w,X                                    ; $00BE3D | | none.
    BNE +                                                                       ; $00BE40 | |
    STZ r_npc_properties.1.frame_counter_limit.w,X                              ; $00BE42 | |
    STZ r_npc_properties.1.movement_direction.w,X                               ; $00BE45 |/
+   LDA <r_npc_properties_offset.lo                                             ; $00BE48 |\
    CLC                                                                         ; $00BE4A | | Update the NPC properties offset for the next NPC.
    ADC #_sizeof_npc_properties.b                                               ; $00BE4B | |
    STA <r_npc_properties_offset.lo                                             ; $00BE4D |/
    INC <r_npc_index                                                            ; $00BE4F | Increment the NPC index.
    LDA <r_npc_index                                                            ; $00BE51 |\
    CMP r_npc_count.w                                                           ; $00BE53 | | Loop until all NPCs on the map have been processed.
    BEQ +                                                                       ; $00BE56 | |
    JMP @loop_start                                                             ; $00BE58 |/
+   INC r_npc_frame_counter.w                                                   ; $00BE5B | Increment the NPC frame counter.
    RTS                                                                         ; $00BE5E

; npc_pixels_per_movement_data ($00:BE5F)
;
; For each possible NPC speed, determines how many pixels the NPC should move
; each time it moves. (They move every four NPC frames. The number of NPC frames
; per actual frame varies from 1 to 8, depending on NPC speed. The 8 value is
; the reason the fastest speed needs to move 2 pixels per frame.)
npc_pixels_per_movement_data:
    .db 1                                                                       ; $00BE5F | $00: Very Slow
    .db 1                                                                       ; $00BE60 | $01: Slow
    .db 1                                                                       ; $00BE61 | $02: Normal
    .db 2                                                                       ; $00BE62 | $03: Fast

; npc_frames_per_frame_data ($00:BE63)
;
; For each movement speed, determines how many NPC frames corresponds to a
; single frame. An NPC moves every four NPC frames.
npc_frames_per_frame_data:
    .db 1                                                                       ; $00BE63 | $00: Very Slow
    .db 2                                                                       ; $00BE64 | $01: Slow
    .db 4                                                                       ; $00BE65 | $02: Normal
    .db 8                                                                       ; $00BE66 | $03: Fast

; _load_npc_sprites ($00:BE67)
;
; Loops through the currently loaded NPC placements, loading the sprites for the
; NPCS to VRAM. Used after battle to reload the sprites.
_load_npc_sprites:
    STZ <r_draw_field_sprite_npc_index                                          ; $00BE67 | Initialize the current NPC index to zero.
    LDX r_npc_placement_base_offset.w                                           ; $00BE69 |\ Initialize the current NPC placement offset to the base offset.
    STX r_npc_placement_offset.w                                                ; $00BE6C |/
-   LDA bank13.npc_placement_data.l + npc_placement.npc_index,X                 ; $00BE6F |\ Load the sprite for this NPC to VRAM.
    JSR _copy_npc_field_sprite_to_vram                                          ; $00BE73 |/
    LDX r_npc_placement_offset.w                                                ; $00BE76 |\
    INX                                                                         ; $00BE79 | | Increment the X register by four to move to the next NPC.
    INX                                                                         ; $00BE7A | |
    INX                                                                         ; $00BE7B | |
    INX                                                                         ; $00BE7C | |
    STX r_npc_placement_offset.w                                                ; $00BE7D |/
    INC <r_draw_field_sprite_npc_index                                          ; $00BE80 |\
    LDA <r_draw_field_sprite_npc_index                                          ; $00BE82 | | Increment the NPC index and loop until all 12 placements are
    CMP #12.b                                                                   ; $00BE84 | | checked.
    BNE -                                                                       ; $00BE86 |/
    RTS                                                                         ; $00BE88

; _load_npcs ($00:BE89)
;
; Loads the NPCs for the current map. This sets the sprite positioning data,
; loads the sprites into VRAM, and initializes the properties for the NPCs.
_load_npcs:
    STZ r_npc_frame_counter.w                                                   ; $00BE89 | Reset the NPC frame counter to zero.
    JSR _init_sprite_positioning                                                ; $00BE8C | Clear the sprite positioning array.
    LDA r_map_properties.npc_placements.w                                       ; $00BE8F |\
    STZ <r_generic_tmp_index.hi                                                 ; $00BE92 | | Calculate the index to access the NPC placement offset data. The
    ASL A                                                                       ; $00BE94 | | index is multiplied by two (as each entry has two bytes). If the
    ROL <r_generic_tmp_index.hi                                                 ; $00BE95 | | highest bit of property 11 is set or if the current map plane is
    STA <r_generic_tmp_index.lo                                                 ; $00BE97 | | non-zero, $200 is added to the offset to access the second set of
    LDA r_map_properties.bank_flags.w                                           ; $00BE99 | | offsets.
    BMI +                                                                       ; $00BE9C | |
    LDA r_map_plane.w                                                           ; $00BE9E | |
    BEQ ++                                                                      ; $00BEA1 | |
+   INC <r_generic_tmp_index.hi                                                 ; $00BEA3 | |
    INC <r_generic_tmp_index.hi                                                 ; $00BEA5 |/
++  LDX <r_generic_tmp_index                                                    ; $00BEA7 |\
    LDA bank13.npc_placement_offset_data.l,X                                    ; $00BEA9 | | Load the actual offset into the NPC placement data.
    STA <r_generic_tmp_index.lo                                                 ; $00BEAD | |
    LDA bank13.npc_placement_offset_data.l + 1,X                                ; $00BEAF | |
    STA <r_generic_tmp_index.hi                                                 ; $00BEB3 | |
    LDX <r_generic_tmp_index                                                    ; $00BEB5 |/
    STX r_npc_placement_offset.w                                                ; $00BEB7 |\ Save the offset to a couple of locations.
    STX r_npc_placement_base_offset.w                                           ; $00BEBA |/
    STZ r_npc_count.w                                                           ; $00BEBD | Zero out the NPC count.
    LDX r_npc_placement_offset.w                                                ; $00BEC0 |\
-   LDA bank13.npc_placement_data.l,X                                           ; $00BEC3 | | Loop through the NPC placement data until encountering a zero,
    BEQ +                                                                       ; $00BEC7 | | which signals the end of the block. Increment the NPC count for
    INC r_npc_count.w                                                           ; $00BEC9 | | each non-zero entry, which gives us an NPC count for the current
    INX                                                                         ; $00BECC | | map.
    INX                                                                         ; $00BECD | |
    INX                                                                         ; $00BECE | |
    INX                                                                         ; $00BECF | |
    JMP -                                                                       ; $00BED0 |/
+   LDA r_npc_count.w                                                           ; $00BED3 |\
    BNE +                                                                       ; $00BED6 | | Exit the function if there are zero NPCs.
    RTS                                                                         ; $00BED8 |/
+   STZ <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BED9 |\
    LDX #0.w                                                                    ; $00BEDB | | Initialize the indexes to zero.
    STX <r_load_npcs_tmp_npc_index                                              ; $00BEDE |/
@start:
    LDX r_npc_placement_offset.w                                                ; $00BEE0 | Load the current NPC placement index.
    LDA bank13.npc_placement_data.l,X                                           ; $00BEE3 | Read the NPC value.
    JSR _copy_npc_field_sprite_to_vram                                          ; $00BEE7 | Copy that NPC's sprite to VRAM in the current slot.
    LDA <r_copy_npc_field_sprite_to_vram_result                                 ; $00BEEA |\
    CMP #FIELD_SPRITE_STANDING_NPC_FOUR_FRAMES.b                                ; $00BEEC | | If the sprite index is less than $2E, set its animation mode to
    BCS +                                                                       ; $00BEEE | | normal, as it's a standard walking sprite.
    LDA #NPC_ANIMATION_MODE_NORMAL.b                                            ; $00BEF0 | |
    JMP ++                                                                      ; $00BEF2 |/
+   CMP #FIELD_SPRITE_STANDING_NPC.b                                            ; $00BEF5 |\
    BCS +                                                                       ; $00BEF7 | | If the sprite index is either $2E or $2F, set the animation mode
    LDA #NPC_ANIMATION_MODE_FOUR_FRAMES.b                                       ; $00BEF9 | | to four frames.
    JMP ++                                                                      ; $00BEFB |/
+   CMP #FIELD_SPRITE_STATIC_NPC.b                                              ; $00BEFE |\
    BCS +                                                                       ; $00BF00 | | If the sprite index is between $30 and $44, inclusive, set the
    LDA #NPC_ANIMATION_MODE_TWO_FRAMES.b                                        ; $00BF02 | | animation mode to two frames.
    JMP ++                                                                      ; $00BF04 |/
+   LDA #NPC_ANIMATION_MODE_ONE_FRAME.b                                         ; $00BF07 | Otherwise, default to one frame.
++  STA <r_load_npcs_tmp                                                        ; $00BF09 | Save that result to a temporary variable.
    LDX r_npc_placement_offset.w                                                ; $00BF0B |\
    LDY <r_load_npcs_tmp_npc_index                                              ; $00BF0E | | Read the NPC's movement properties and transfer them to the NPC
    LDA bank13.npc_placement_data.l + npc_placement.movement,X                  ; $00BF10 | | properties.
    STA r_npc_properties.1.movement_properties.w,Y                              ; $00BF14 |/
    AND #NPC_PLACEMENT_MOVEMENT_DIRECTION.b                                     ; $00BF17 |\
    STA r_npc_properties.1.direction.w,Y                                        ; $00BF19 | | Set the direction and movement direction from the lowest two bits
    INC A                                                                       ; $00BF1C | | of that byte.
    STA r_npc_properties.1.movement_direction.w,Y                               ; $00BF1D |/
    LDA r_npc_properties.1.movement_properties.w,Y                              ; $00BF20 |\
    AND #~NPC_PLACEMENT_MOVEMENT_DIRECTION.b                                    ; $00BF23 | | Set the NPC's animation mode in its movement properties.
    ORA <r_load_npcs_tmp                                                        ; $00BF25 | |
    STA r_npc_properties.1.movement_properties.w,Y                              ; $00BF27 |/
    LDA <r_copy_npc_field_sprite_to_vram_result                                 ; $00BF2A |\
    CMP #FIELD_SPRITE_NON_CHARACTER.b                                           ; $00BF2C | | If the sprite is a character sprite, load the proper palette index
    BCS +                                                                       ; $00BF2E | | from ROM.
    TAX                                                                         ; $00BF30 | |
    LDA bank15.player_field_sprite_palette_index_data.l,X                       ; $00BF31 | |
    JMP ++                                                                      ; $00BF35 |/
+   LDA bank13.npc_placement_data.l + npc_placement.movement,X                  ; $00BF38 |\
    AND #NPC_PLACEMENT_MOVEMENT_PALETTE.b                                       ; $00BF3C | | Otherwise, the palette index is four plus the third and fourth
    LSR A                                                                       ; $00BF3E | | lowest bits of the fourth NPC placement byte (shifted to the
    LSR A                                                                       ; $00BF3F | | right).
    CLC                                                                         ; $00BF40 | |
    ADC #4.b                                                                    ; $00BF41 |/
++  STA r_npc_properties.1.palette.w,Y                                          ; $00BF43 | Store the palette index in the NPC properties array.
    LDX r_npc_placement_offset.w                                                ; $00BF46 |\
    LDA bank13.npc_placement_data.l + npc_placement.npc_index,X                 ; $00BF49 | | Load the NPC number and store it in the NPC properties array.
    STA r_npc_properties.1.npc.w,Y                                              ; $00BF4D |/
    LDA bank13.npc_placement_data.l + npc_placement.x,X                         ; $00BF50 |\
    BMI +                                                                       ; $00BF54 | | If the highest bit of the X coordinate byte is not set, clear the
    LDA #MOVEMENT_DIRECTION_NONE.b                                              ; $00BF56 | | movement direction (as the NPC is not moving).
    STA r_npc_properties.1.movement_direction.w,Y                               ; $00BF58 |/
+   LDA bank13.npc_placement_data.l + 1,X                                       ; $00BF5B |\
    AND #NPC_PLACEMENT_X_COORDINATE.b                                           ; $00BF5F | | Set the NPC's X coordinate.
    STA r_npc_properties.1.x.w,Y                                                ; $00BF61 | |
    STA <r_generic_arg_x_lo                                                     ; $00BF64 |/
    LDA bank13.npc_placement_data.l + npc_placement.y,X                         ; $00BF66 |\
    STA r_npc_properties.1.y.w,Y                                                ; $00BF6A | | Set the NPC's Y coordinate.
    STA <r_generic_arg_y_lo                                                     ; $00BF6D |/
    LDA r_npc_properties.1.npc.w,Y                                              ; $00BF6F |\
    JSR _check_npc_visible                                                      ; $00BF72 | | Determine if this NPC is visible or not.
    STA r_npc_properties.1.visible.w,Y                                          ; $00BF75 |/
    CMP #0.b                                                                    ; $00BF78 |\
    BEQ +                                                                       ; $00BF7A | | If the sprite is visible, update the sprite positioning array.
    JSR _update_field_sprite_positioning                                        ; $00BF7C |/
+   LDA #0.b                                                                    ; $00BF7F |\
    STA r_npc_properties.1.frame_counter.w,Y                                    ; $00BF81 | | Zero out the NPC's frame counter and X and Y offsets.
    STA r_npc_properties.1.x_offset.w,Y                                         ; $00BF84 | |
    STA r_npc_properties.1.y_offset.w,Y                                         ; $00BF87 |/
    STA r_npc_properties.1.force_normal_speed.w,Y                               ; $00BF8A | Disable the forced normal speed.
    STA r_npc_properties.1.frame_counter_limit.w,Y                              ; $00BF8D | Initially have no frame counter limit.
    STA r_npc_properties.1.flags.w,Y                                            ; $00BF90 | Reset the NPC flags.
    LDA r_npc_properties.1.x.w,Y                                                ; $00BF93 |\
    STA <r_generic_tmp_index.lo                                                 ; $00BF96 | | If the NPC is currently on a tile that has the "hide lower"
    LDA r_npc_properties.1.y.w,Y                                                ; $00BF98 | | property bit set, a property in the NPC properties array is set
    STA <r_generic_tmp_index.hi                                                 ; $00BF9B | | to that value ($08).
    LDX <r_generic_tmp_index                                                    ; $00BF9D | |
    LDA r_tilemap_data.l,X                                                      ; $00BF9F | |
    STA <r_generic_tmp_index.lo                                                 ; $00BFA3 | |
    STZ <r_generic_tmp_index.hi                                                 ; $00BFA5 | |
    ASL <r_generic_tmp_index.lo                                                 ; $00BFA7 | |
    ROL <r_generic_tmp_index.hi                                                 ; $00BFA9 | |
    LDX <r_generic_tmp_index                                                    ; $00BFAB | |
    LDA r_tile_properties.1.properties_2.w,X                                    ; $00BFAD | |
    LDX <r_load_npcs_tmp_npc_index                                              ; $00BFB0 | |
    AND #TILE_PROPERTY_2_HIDE_LOWER.b                                           ; $00BFB2 | |
    STA r_npc_properties.1.hide_lower.w,X                                       ; $00BFB4 |/
    LDX r_npc_placement_offset.w                                                ; $00BFB7 |\
    INX                                                                         ; $00BFBA | | Increment the NPC placement index by four to move on to the next
    INX                                                                         ; $00BFBB | | NPC.
    INX                                                                         ; $00BFBC | |
    INX                                                                         ; $00BFBD | |
    STX r_npc_placement_offset.w                                                ; $00BFBE |/
    LDA <r_load_npcs_tmp_npc_index_lo                                           ; $00BFC1 |\
    CLC                                                                         ; $00BFC3 | | Increment the NPC index by the size of the NPC properties array.
    ADC #_sizeof_npc_properties.b                                               ; $00BFC4 | |
    STA <r_load_npcs_tmp_npc_index_lo                                           ; $00BFC6 |/
    INC <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BFC8 |\
    LDA <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BFCA | | Repeat the loop until all NPCs on the map have been processed.
    CMP r_npc_count.w                                                           ; $00BFCC | |
    BEQ +                                                                       ; $00BFCF | |
    JMP @start                                                                  ; $00BFD1 |/
+   LDA #12.b                                                                   ; $00BFD4 |\
    STA <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BFD6 | | Copy a soldier to sprite slot 12.
    LDA #FIELD_SPRITE_SOLDIER.b                                                 ; $00BFD8 | |
    JSR _copy_field_sprite_to_vram                                              ; $00BFDA |/
    LDA #FIELD_SPRITE_BLACK_MAGE.b                                              ; $00BFDD |\
    INC <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BFDF | | Copy a black mage to sprite slot 13.
    JSR _copy_field_sprite_to_vram                                              ; $00BFE1 |/
    LDA #FIELD_SPRITE_WHITE_MAGE.b                                              ; $00BFE4 |\
    INC <r_copy_field_sprite_to_vram_arg_slot                                   ; $00BFE6 | | Copy a white mage to sprite slot 14.
    JSR _copy_field_sprite_to_vram                                              ; $00BFE8 |/
    LDA r_map_properties.npc_palettes.w                                         ; $00BFEB |\
    AND #%00001111.b                                                            ; $00BFEE | | Load the first two NPC palettes for the map.
    LDY #$0000.w                                                                ; $00BFF0 | |
    JSR _load_npc_field_sprite_palette                                          ; $00BFF3 |/
    LDA r_map_properties.npc_palettes.w                                         ; $00BFF6 |\
    LSR A                                                                       ; $00BFF9 | | Load the second two NPC palettes for the map.
    LSR A                                                                       ; $00BFFA | |
    LSR A                                                                       ; $00BFFB | |
    LSR A                                                                       ; $00BFFC | |
    LDY #$0040.w                                                                ; $00BFFD | |
    JSR _load_npc_field_sprite_palette                                          ; $00C000 |/
    RTS                                                                         ; $00C003

; _load_npc_field_sprite_palette ($00:C004)
;
; Given an index in the accumulator, loads a pair of NPC palettes from ROM to
; the palette indicated by the Y register. For practical reasons, the Y register
; should be either $0000 to write the first two NPC palettes or $0040 to write
; the second two palettes.
_load_npc_field_sprite_palette:
    STA <r_generic_tmp_index.hi                                                 ; $00C004 |\
    STZ <r_generic_tmp_index.lo                                                 ; $00C006 | | Calculate the index by multiplying the parameter by 32 (two bytes
    LSR <r_generic_tmp_index.hi                                                 ; $00C008 | | for each of 16 colors).
    ROR <r_generic_tmp_index.lo                                                 ; $00C00A | |
    LSR <r_generic_tmp_index.hi                                                 ; $00C00C | |
    ROR <r_generic_tmp_index.lo                                                 ; $00C00E | |
    LSR <r_generic_tmp_index.hi                                                 ; $00C010 | |
    ROR <r_generic_tmp_index.lo                                                 ; $00C012 | |
    LDX <r_generic_tmp_index                                                    ; $00C014 |/
--  LDA bank0D.npc_field_sprite_palette_data.l,X                                ; $00C016 |\ Load the next value and store it in the CG-RAM staging area at the
    STA r_cgram_data.13,Y                                                       ; $00C01A |/ destinated index.
    INX                                                                         ; $00C01D |\ Increment the two indexes.
    INY                                                                         ; $00C01E |/
    TYA                                                                         ; $00C01F |\
    AND #%00001111.b                                                            ; $00C020 | | Loop until 16 bytes (8 colors) have been copied.
    BNE --                                                                      ; $00C022 |/
-   LDA #0.b                                                                    ; $00C024 |\
    STA r_cgram_data.13,Y                                                       ; $00C026 | | Fill the remainder of the palette with zeroes.
    INY                                                                         ; $00C029 | |
    TYA                                                                         ; $00C02A | |
    AND #%00001111.b                                                            ; $00C02B | |
    BNE -                                                                       ; $00C02D |/
    TYA                                                                         ; $00C02F |\  Repeat the entire block until all 64 bytes (32 colors) have been
    AND #%00111111.b                                                            ; $00C030 | | written. 16 colors read from ROM, and 16 blacks.
    BNE --                                                                      ; $00C032 |/
    RTS                                                                         ; $00C034

; _init_sprite_positioning ($00:C035)
;
; Clears out the sprite positioning array, by writing zeroes to the entire
; block.
_init_sprite_positioning:
    LDX #$0000.w                                                                ; $00C035 |\
    LDA #$00.b                                                                  ; $00C038 | | Write zeroes to the sprite positioning array.
-   STA r_field_sprite_positioning.l,X                                          ; $00C03A | |
    INX                                                                         ; $00C03E | |
    CPX #$0400.w                                                                ; $00C03F | |
    BNE -                                                                       ; $00C042 |/
    RTS                                                                         ; $00C044

; _clear_sprite_position ($00:C045)
;
; Clears the coordinates passed in $060C and $060E in the sprite positioning
; array.
_clear_sprite_position:
    PHX                                                                         ; $00C045 | Preserve the X register.
    JSR _get_field_sprite_positioning_index                                     ; $00C046 |\ Get the index for the coordinates passed in the parameters.
    LDX <r_generic_tmp_index                                                    ; $00C049 |/
    LDA #$00.b                                                                  ; $00C04B |\ Set the value to zero.
    STA r_field_sprite_positioning.l,X                                          ; $00C04D |/
    PLX                                                                         ; $00C051 | Restore the X register.
    RTS                                                                         ; $00C052

; _get_field_sprite_positioning_bounded ($00:C053)
;
; Given an 8-bit X coordinate in $060C and an 8-bit Y coordinate in $060E, gets
; the current field sprite value present at that location. The result is zero if
; there is no sprite at that location. If the coordinates are out of bounds,
; the result will be 1 instead.
_get_field_sprite_positioning_bounded:
    PHX                                                                         ; $00C053 | Preserve the value in the X register.
    LDA <r_generic_arg_x_lo                                                     ; $00C054 |\
    CMP #32.b                                                                   ; $00C056 | | If both passed coordinates are 31 or less, read the value of the
    BCS +                                                                       ; $00C058 | | field sprite at those coordinates. The value is zero if no sprite
    LDA <r_generic_arg_y_lo                                                     ; $00C05A | | at that location.
    CMP #32.b                                                                   ; $00C05C | |
    BCS +                                                                       ; $00C05E | |
    JSR _get_field_sprite_positioning_index                                     ; $00C060 | |
    LDX <r_generic_tmp_index                                                    ; $00C063 | |
    LDA r_field_sprite_positioning.l,X                                          ; $00C065 | |
    JMP ++                                                                      ; $00C069 |/
+   LDA #1.b                                                                    ; $00C06C | Otherwise, return 1.
++  PLX                                                                         ; $00C06E | Restore the X register value.
    RTS                                                                         ; $00C06F

; _get_field_sprite_positioning ($00:C070)
;
; Given an 8-bit X coordinate in $060C and an 8-bit Y coordinate in $060E, gets
; the current sprite slot value present at that location. If the coordinates are
; out of range, returns zero. Also returns zero if there is no sprite at that
; location.
_get_field_sprite_positioning:
    PHX                                                                         ; $00C070 | Preserve the value in the X register.
    LDA <r_generic_arg_x_lo                                                     ; $00C071 |\
    CMP #32.b                                                                   ; $00C073 | | If both passed coordinates are 31 or less, read the value of the
    BCS +                                                                       ; $00C075 | | field sprite at those coordinates.
    LDA <r_generic_arg_y_lo                                                     ; $00C077 | |
    CMP #32.b                                                                   ; $00C079 | |
    BCS +                                                                       ; $00C07B | |
    JSR _get_field_sprite_positioning_index                                     ; $00C07D | |
    LDX <r_generic_tmp_index                                                    ; $00C080 | |
    LDA r_field_sprite_positioning.l,X                                          ; $00C082 | |
    JMP ++                                                                      ; $00C086 |/
+   LDA #0.b                                                                    ; $00C089 | Otherwise, load a zero.
++  PLX                                                                         ; $00C08B | Restore the value of the X register.
    RTS                                                                         ; $00C08C

; _update_field_sprite_positioning ($00:C08D)
;
; Given an 8-bit X coordinate in $060C and an 8-bit Y coordinate in $060E, sets
; that location in the sprite positioning array to the sprite slot value in
; $06AE, with the upmost bit set.
_update_field_sprite_positioning:
    PHX                                                                         ; $00C08D | Preserve the contents of the X register.
    JSR _get_field_sprite_positioning_index                                     ; $00C08E |\ Get the index to the sprite positioning array.
    LDX <r_generic_tmp_index.lo                                                 ; $00C091 |/
    LDA <r_copy_field_sprite_to_vram_arg_slot                                   ; $00C093 |\
    ORA #%10000000.b                                                            ; $00C095 | | Store the field sprite slot in the sprite positioning array.
    STA r_field_sprite_positioning.l,X                                          ; $00C097 |/
    PLX                                                                         ; $00C09B | Restore the X register.
    RTS                                                                         ; $00C09C

; _get_field_sprite_positioning_index ($00:C09D)
;
; Given an X coordinate in $060C and a Y coordinate in $060E, returns the 16-bit
; index to that coordinate in the sprite positioning array in $063D.
_get_field_sprite_positioning_index:
    LDA <r_generic_arg_y_lo                                                     ; $00C09D |\
    STA <r_generic_tmp_index.hi                                                 ; $00C09F | | Set the initial index to the Y coordinate times $100.
    STZ <r_generic_tmp_index.lo                                                 ; $00C0A1 |/
    LSR <r_generic_tmp_index.hi                                                 ; $00C0A3 |\
    ROR <r_generic_tmp_index.lo                                                 ; $00C0A5 | | Divide the index by 8. In effect, we've multiplied the original
    LSR <r_generic_tmp_index.hi                                                 ; $00C0A7 | | Y coordinate by 32 (as there are 32 tiles in a row).
    ROR <r_generic_tmp_index.lo                                                 ; $00C0A9 | |
    LSR <r_generic_tmp_index.hi                                                 ; $00C0AB | |
    ROR <r_generic_tmp_index.lo                                                 ; $00C0AD |/
    LDA <r_generic_tmp_index.lo                                                 ; $00C0AF |\
    CLC                                                                         ; $00C0B1 | | Add the X coordinate to the result.
    ADC <r_generic_arg_x_lo                                                     ; $00C0B2 | |
    STA <r_generic_tmp_index.lo                                                 ; $00C0B4 |/
    RTS                                                                         ; $00C0B6

; _copy_npc_field_sprite_to_vram ($00:C0B7)
;
; Given an NPC number in the accumulator, copies the sprite corresponding to
; that NPC to VRAM. Returns the loaded sprite number in $0606. The one-byte
; NPC number references a different NPC if the map plane is one instead of zero.
_copy_npc_field_sprite_to_vram:
    STA <r_generic_tmp_index.lo                                                 ; $00C0B7 |\ Set the initial index to the value passed in the accumulator.
    STZ <r_generic_tmp_index.hi                                                 ; $00C0B9 |/
    LDA r_map_properties.bank_flags.w                                           ; $00C0BB |\
    BMI +                                                                       ; $00C0BE | | If the high NPC bank flag is set or if the current map plane is
    LDA r_map_plane.w                                                           ; $00C0C0 | | non-zero add $100 to the index.
    BEQ ++                                                                      ; $00C0C3 | |
+   INC <r_generic_tmp_index.hi                                                 ; $00C0C5 |/
++  LDX <r_generic_tmp_index                                                    ; $00C0C7 |\
    LDA bank12.npc_sprite_mapping_data.l,X                                      ; $00C0C9 | | Using that index, determine the correct sprite index.
    STA <r_copy_npc_field_sprite_to_vram_result                                 ; $00C0CD |/
    JSR _copy_field_sprite_to_vram                                              ; $00C0CF | Load that sprite to VRAM.
    RTS                                                                         ; $00C0D2

; _copy_field_sprite_to_vram ($00:C0D3)
;
; Copies a field sprite to VRAM, in the slot passed in $06AE. The index of the
; sprite to copy is passed in the accumulator. Note that this function always
; fills 1024 bytes (eight 16x16 sprites) in VRAM, regardless of the size of
; the passed sprite. Sprite sets range from one to eight tiles, depending on
; index.
_copy_field_sprite_to_vram:
    CMP #FIELD_SPRITE_MOVING_NPC.b                                              ; $00C0D3 |\
    BCS +                                                                       ; $00C0D5 | | Check the passed sprite index to see if it is a player sprite.
    ASL A                                                                       ; $00C0D7 | | Calculate a zero-based index and multiply by 8.
    ASL A                                                                       ; $00C0D8 | |
    ASL A                                                                       ; $00C0D9 | |
    LDX #bank1B.field_sprite_player_data.w - $8000                              ; $00C0DA | |
    JMP ++                                                                      ; $00C0DD |/
+   CMP #FIELD_SPRITE_STANDING_NPC.b                                            ; $00C0E0 |\
    BCS +                                                                       ; $00C0E2 | | Check the index for a moving NPC. Calculate a zero-based index and
    SEC                                                                         ; $00C0E4 | | multiply by 4.
    SBC #FIELD_SPRITE_MOVING_NPC.b                                              ; $00C0E5 | |
    ASL A                                                                       ; $00C0E7 | |
    ASL A                                                                       ; $00C0E8 | |
    LDX #bank1B.field_sprite_moving_npc_data.w - $8000                          ; $00C0E9 | |
    JMP ++                                                                      ; $00C0EC |/
+   CMP #FIELD_SPRITE_STATIC_NPC.b                                              ; $00C0EF |\
    BCS +                                                                       ; $00C0F1 | | Check the index for a standing NPC. Calculate a zero-based index
    SEC                                                                         ; $00C0F3 | | and multiply by 2.
    SBC #FIELD_SPRITE_STANDING_NPC.b                                            ; $00C0F4 | |
    ASL A                                                                       ; $00C0F6 | |
    LDX #bank1B.field_sprite_standing_npc_data.w - $8000                        ; $00C0F7 | |
    JMP ++                                                                      ; $00C0FA |/
+   SEC                                                                         ; $00C0FD |\
    SBC #FIELD_SPRITE_STATIC_NPC.b                                              ; $00C0FE | | If none of these, assume a static NPC.
    LDX #bank1B.field_sprite_static_npc_data.w - $8000                          ; $00C100 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $00C103 |\
    XBA                                                                         ; $00C105 | | Calculate the address to get the sprite's data from. The base
    LSR A                                                                       ; $00C106 | | address is $8000 (at the start of bank $1B). The calculated index
    LSR A                                                                       ; $00C107 | | is the total number of 16x16 tiles the sprite has, each of which
    STA <r_copy_3bpp_to_vram_arg_address                                        ; $00C108 | | is 96 bytes (16*16*3bpp). Add these to the offset set earlier
    LSR A                                                                       ; $00C10A | | based on the type of sprite to get the final address.
    CLC                                                                         ; $00C10B | |
    ADC <r_copy_3bpp_to_vram_arg_address                                        ; $00C10C | |
    STA <r_copy_3bpp_to_vram_arg_address                                        ; $00C10E | |
    TXA                                                                         ; $00C110 | |
    CLC                                                                         ; $00C111 | |
    ADC <r_copy_3bpp_to_vram_arg_address                                        ; $00C112 | |
    CLC                                                                         ; $00C114 | |
    ADC #$8000.w                                                                ; $00C115 | |
    STA <r_copy_3bpp_to_vram_arg_address                                        ; $00C118 | |
    LDA #$0000.w                                                                ; $00C11A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C11D |/
    LDA <r_copy_field_sprite_to_vram_arg_slot                                   ; $00C11F |\
    ASL A                                                                       ; $00C121 | | Calculate the VRAM address by starting with $4200 (the start of
    CLC                                                                         ; $00C122 | | NPC sprites in VRAM), and add the slot number times $200, as each
    ADC #$42.b                                                                  ; $00C123 | | slot is allocated $200 words (enough for eight 16x16 tiles).
    STA <r_copy_3bpp_to_vram_arg_vram_address_hi                                ; $00C125 | |
    STZ <r_copy_3bpp_to_vram_arg_vram_address_lo                                ; $00C127 |/
    LDX #$0200.w                                                                ; $00C129 |\ Transfer $200 words. This will copy excess for sprites with fewer
    STX <r_copy_3bpp_to_vram_arg_words                                          ; $00C12C |/ poses. Potentially useful to copy multiple in one action.
    LDA #:bank1B.field_sprite_player_data.b                                     ; $00C12E |\ Set the bank to $1B.
    STA <r_copy_3bpp_to_vram_arg_bank                                           ; $00C130 |/
    JSL bank15.copy_3bpp_to_vram                                                ; $00C132 | Copy the sprite to VRAM.
    RTS                                                                         ; $00C136

; _check_npc_visible ($00:C137)
;
; Given an NPC number in the accumulator, returns 1 in the accumulator if the
; NPC is currently supposed to be visible and 0 if it is not.
_check_npc_visible:
    PHY                                                                         ; $00C137 | Preserve the contents of the Y register.
    PHA                                                                         ; $00C138 |\
    AND #%00000111.b                                                            ; $00C139 | | Set the bit number to the value of the lower three bits of the
    STA <r_check_npc_visible_tmp_bit                                            ; $00C13B | | parameter passed in the accumulator.
    PLA                                                                         ; $00C13D |/
    LSR A                                                                       ; $00C13E |\
    LSR A                                                                       ; $00C13F | | Set the index to the upper five bits of the passed value, shifted
    LSR A                                                                       ; $00C140 | | to the right.
    STA <r_generic_tmp_index.lo                                                 ; $00C141 |/
    LDA r_map_properties.bank_flags.w                                           ; $00C143 |\
    BMI +                                                                       ; $00C146 | | If the high NPC bank flag is set or if the map plane is non-zero,
    LDA r_map_plane.w                                                           ; $00C148 | | add $20 to the index, to access the underworld NPC statuses.
    BEQ ++                                                                      ; $00C14B | |
+   LDA <r_generic_tmp_index.lo                                                 ; $00C14D | |
    CLC                                                                         ; $00C14F | |
    ADC #$20.b                                                                  ; $00C150 | |
    STA <r_generic_tmp_index.lo                                                 ; $00C152 |/
++  STZ <r_generic_tmp_index.hi                                                 ; $00C154 | Set the high byte of the index to zero.
    LDA <r_check_npc_visible_tmp_bit                                            ; $00C156 |\ Transfer the bit number to the Y register.
    TAY                                                                         ; $00C158 |/
    LDX <r_generic_tmp_index                                                    ; $00C159 | Set the X register to the calculated index.
    LDA r_npc_status.l & $FFFF,X                                                ; $00C15B | Load the byte with the desired NPC status information.
-   CPY #$0000.w                                                                ; $00C15F |\
    BEQ +                                                                       ; $00C162 | | Keep shifting bits out until the desired bit number is reached.
    LSR A                                                                       ; $00C164 | |
    DEY                                                                         ; $00C165 | |
    JMP -                                                                       ; $00C166 |/
+   LSR A                                                                       ; $00C169 |\
    LDA #0.b                                                                    ; $00C16A | | Take the value of the desired bit and add it to zero, returning
    ADC #0.b                                                                    ; $00C16C | | the NPC status in the accumulator.
    PLY                                                                         ; $00C16E |/
    RTS                                                                         ; $00C16F

; _get_field_rng ($00:C170)
;
; Reads the next value from the RNG using the field RNG index. This will repeat
; every 256 reads. The value is left in the accumulator.
_get_field_rng:
    PHX                                                                         ; $00C170 | Save the value in the X register.
    LDA <r_field_rng_index                                                      ; $00C171 |\
    TAX                                                                         ; $00C173 | | Fetch a value from the PRNG.
    LDA bank14.prng_data.l,X                                                    ; $00C174 |/
    INC <r_field_rng_index                                                      ; $00C178 | Increment the field RNG index.
    PLX                                                                         ; $00C17A | Restore the X register.
    RTS                                                                         ; $00C17B

; _decode_event_opcode_custom_effect ($00:C17C)
;
; Handles opcode $FD, which is essentially a code to allow for an expansion of
; the number of opcodes by creating double byte opcodes, though it is typically
; used for visual effects. The byte after the $FD determines the custom effect
; to execute.
_decode_event_opcode_custom_effect:
    JSR _decode_event_get_next_byte                                             ; $00C17C |\
    STZ <r_generic_tmp_index.hi                                                 ; $00C17F | | Fetch the next byte, multiply it by two, and save it to a
    ASL A                                                                       ; $00C181 | | temporary variable.
    ROL <r_generic_tmp_index.hi                                                 ; $00C182 | |
    STA <r_generic_tmp_index.lo                                                 ; $00C184 |/
    LDX <r_generic_tmp_index                                                    ; $00C186 |\
    LDA decode_event_opcode_custom_effect_pointer_data.w + 0,X                  ; $00C188 | | Load the pointer associated with that byte.
    STA <r_generic_tmp_index.lo                                                 ; $00C18B | |
    LDA decode_event_opcode_custom_effect_pointer_data.w + 1,X                  ; $00C18D | |
    STA <r_generic_tmp_index.hi                                                 ; $00C190 |/
    JMP (r_generic_tmp_index.w)                                                 ; $00C192 | Jump to the pointer to handle the opcode.

; decode_event_opcode_custom_effect_pointer_data ($00:C195)
;
; For each custom effect value, has a pointer to the routine to handle that
; custom effect.
decode_event_opcode_custom_effect_pointer_data:
    .addr _decode_event_opcode_custom_effect_red_wings_north_over_ordeals       ; $00C195 | $00
    .addr _decode_event_opcode_custom_effect_red_wings_baron_landing            ; $00C197 | $01
    .addr _decode_event_opcode_custom_effect_bomb_swirl                         ; $00C199 | $02
    .addr _decode_event_opcode_custom_effect_damcyan_bombing                    ; $00C19B | $03
    .addr _decode_event_opcode_custom_effect_girl_battle_and_titan              ; $00C19D | $04
    .addr _decode_event_opcode_custom_effect_set_tent_cabin_sprite              ; $00C19F | $05
    .addr _decode_event_opcode_custom_effect_swirl_sparkle                      ; $00C1A1 | $06
    .addr _decode_event_opcode_custom_effect_swirl_mist                         ; $00C1A3 | $07
    .addr _decode_event_opcode_custom_effect_circling_bombs                     ; $00C1A5 | $08
    .addr _decode_event_opcode_custom_effect_prologue                           ; $00C1A7 | $09
    .addr _decode_event_opcode_custom_effect_map_history_pop                    ; $00C1A9 | $0A
    .addr _decode_event_opcode_custom_effect_map_history_reset                  ; $00C1AB | $0B
    .addr _decode_event_opcode_custom_effect_general_bombing                    ; $00C1AD | $0C
    .addr _decode_event_opcode_custom_effect_enable_ship                        ; $00C1AF | $0D
    .addr _decode_event_opcode_custom_effect_agart_explosion                    ; $00C1B1 | $0E
    .addr _decode_event_opcode_custom_effect_leviatan_tail                      ; $00C1B3 | $0F
    .addr _decode_event_opcode_custom_effect_leviatan_rises                     ; $00C1B5 | $10
    .addr _decode_event_opcode_custom_effect_leviatan_swallows_ship             ; $00C1B7 | $11
    .addr _decode_event_opcode_custom_effect_red_airship_from_right             ; $00C1B9 | $12
    .addr _decode_event_opcode_custom_effect_red_airship_to_left                ; $00C1BB | $13
    .addr _decode_event_opcode_custom_effect_enterprise_red_airship_rising      ; $00C1BD | $14
    .addr _decode_event_opcode_custom_effect_land_enterprise                    ; $00C1BF | $15
    .addr _decode_event_opcode_custom_effect_underground_tanks_vs_airships      ; $00C1C1 | $16
    .addr _decode_event_opcode_custom_effect_downward_airship_chase             ; $00C1C3 | $17
    .addr _decode_event_opcode_custom_effect_rightward_airship_chase            ; $00C1C5 | $18
    .addr _decode_event_opcode_custom_effect_baron_antechamber_shrink_1         ; $00C1C7 | $19
    .addr _decode_event_opcode_custom_effect_baron_antechamber_shrink_2         ; $00C1C9 | $1A
    .addr _decode_event_opcode_custom_effect_baron_antechamber_shrink_3         ; $00C1CB | $1B
    .addr _decode_event_opcode_custom_effect_move_enterprise_to_baron           ; $00C1CD | $1C
    .addr _decode_event_opcode_custom_effect_undo_map_history                   ; $00C1CF | $1D
    .addr _decode_event_opcode_custom_effect_small_explosion_top                ; $00C1D1 | $1E
    .addr _decode_event_opcode_custom_effect_big_whale_whirlpool_raising        ; $00C1D3 | $1F
    .addr _decode_event_opcode_custom_effect_big_whale_to_earth_eblan           ; $00C1D5 | $20
    .addr _decode_event_opcode_custom_effect_giant_attacking                    ; $00C1D7 | $21
    .addr _decode_event_opcode_custom_effect_giant_tanks_approach               ; $00C1D9 | $22
    .addr _decode_event_opcode_custom_effect_giant_airships_approach            ; $00C1DB | $23
    .addr _decode_event_opcode_custom_effect_giant_explosions                   ; $00C1DD | $24
    .addr _decode_event_opcode_custom_effect_giant_airship_land_whale           ; $00C1DF | $25
    .addr _decode_event_opcode_custom_effect_giant_airship_fly_left             ; $00C1E1 | $26
    .addr _decode_event_opcode_custom_effect_giant_airship_to_giant             ; $00C1E3 | $27
    .addr _decode_event_opcode_custom_effect_move_enterprise_to_dwarf_castle    ; $00C1E5 | $28
    .addr _decode_event_opcode_custom_effect_big_whale_whirlpool_intro          ; $00C1E7 | $29
    .addr _decode_event_opcode_custom_effect_big_whale_whirlpool_finish         ; $00C1E9 | $2A
    .addr _decode_event_opcode_custom_effect_enterprise_rising                  ; $00C1EB | $2B
    .addr _decode_event_opcode_custom_effect_enterprise_lowering                ; $00C1ED | $2C
    .addr _decode_event_opcode_custom_effect_fly_big_whale                      ; $00C1EF | $2D
    .addr _decode_event_opcode_custom_effect_hide_enterprise                    ; $00C1F1 | $2E
    .addr _decode_event_opcode_custom_effect_big_whale_earth_moon_travel        ; $00C1F3 | $2F
    .addr _decode_event_opcode_custom_effect_big_whale_to_moon                  ; $00C1F5 | $30
    .addr _decode_event_opcode_custom_effect_cpu_explosion                      ; $00C1F7 | $31
    .addr _decode_event_opcode_custom_effect_legend                             ; $00C1F9 | $32
    .addr _decode_event_opcode_custom_effect_sight                              ; $00C1FB | $33
    .addr _decode_event_opcode_custom_effect_agart_telescope                    ; $00C1FD | $34
    .addr _decode_event_opcode_custom_effect_big_whale_whirlpool_descent        ; $00C1FF | $35
    .addr _decode_event_opcode_custom_effect_babil_explosions                   ; $00C201 | $36
    .addr _decode_event_opcode_custom_effect_ending_legend                      ; $00C203 | $37
    .addr _decode_event_opcode_custom_effect_ending_moon                        ; $00C205 | $38
    .addr _decode_event_opcode_custom_effect_ending_credits                     ; $00C207 | $39
    .addr _decode_event_opcode_custom_effect_small_explosion_center             ; $00C209 | $3A
    .addr _decode_event_opcode_custom_effect_enterprise_left_dive               ; $00C20B | $3B
    .addr _decode_event_opcode_custom_effect_reset                              ; $00C20D | $3C
    .addr _decode_event_opcode_custom_effect_audio_fade_quiet_slow              ; $00C20F | $3D
    .addr _decode_event_opcode_custom_effect_audio_fade_normal_slow             ; $00C211 | $3E
    .addr _decode_event_opcode_custom_effect_everybody_swoon_but_cecil          ; $00C213 | $3F
    .addr _decode_event_opcode_custom_effect_giant_explosion                    ; $00C215 | $40

; _decode_event_opcode_custom_effect_everybody_swoon_but_cecil ($00:C217)
;
; Custom effect that makes all party members swoon except for Cecil. Cecil's HP
; is set explicitly to 1. This is preparation for the Zeromus battle.
_decode_event_opcode_custom_effect_everybody_swoon_but_cecil:
    LDX #0.w                                                                    ; $00C217 | Initialize the X register to zero.
-   LDA r_character_field.1.id.w,X                                              ; $00C21A |\
    AND #%00011111.b                                                            ; $00C21D | | If the character in this slot is Cecil, remove all statuses from
    CMP #CHARACTER_CECIL_2.b                                                    ; $00C21F | | the first byte and load a 1 for his HP into the accumulator.
    BNE +                                                                       ; $00C221 | |
    STZ r_character_field.1.status_1.w,X                                        ; $00C223 | |
    LDA #1.b                                                                    ; $00C226 | |
    JMP ++                                                                      ; $00C228 |/
+   LDA #STATUS_1_SWOON.b                                                       ; $00C22B |\
    STA r_character_field.1.status_1.w,X                                        ; $00C22D | | Otherwise, set only the swoon status in the first byte and load 0.
    LDA #0.b                                                                    ; $00C230 |/
++  STA r_character_field.1.hp_lo.w,X                                           ; $00C232 |\ Store the loaded value as the character's HP.
    STZ r_character_field.1.hp_hi.w,X                                           ; $00C235 |/
    STZ r_character_field.1.status_2.w,X                                        ; $00C238 | Zero out the second status byte.
    JSR _increment_x_by_64                                                      ; $00C23B |\
    CPX #_sizeof_character_field.w * 5                                          ; $00C23E | | Loop until all five slots have been updated.
    BNE -                                                                       ; $00C241 |/
    JMP _decode_event_opcode_done                                               ; $00C243

; _decode_event_opcode_custom_effect_reset ($00:C246)
;
; This custom effect resets the game. It's unknown if it's even used by
; anything.
_decode_event_opcode_custom_effect_reset:
    LDA #%10000000.b                                                            ; $00C246 |\ Set forced blanking on the PPU.
    STA reg_ppu_inidisp.w                                                       ; $00C248 |/
    LDA #%00000000.b                                                            ; $00C24B |\ Disable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00C24D |/
    LDA #%11111111.b                                                            ; $00C250 |\ TODO: Write some unknown bits to the APU. This may have to wait
    STA reg_apu_apuio0.w                                                        ; $00C252 |/       until the sound code is disassembled.
    JMP main                                                                    ; $00C255

; _decode_event_opcode_custom_effect_audio_fade_quiet_slow ($00:C258)
;
; Custom effect that fades the audio out to a quiet level slowly.
_decode_event_opcode_custom_effect_audio_fade_quiet_slow:
    JSR _audio_fade_quiet_slow                                                  ; $00C258 | Fade the audio to quiet volume slowly.
    JMP _decode_event_opcode_done                                               ; $00C25B

; _audio_fade_quiet_slow ($00:C25E)
;
; Sends the command to fade out the audio to a quiet volume level slowly.
_audio_fade_quiet_slow:
    LDA #AUDIO_MODE_VOLUME_FADE_QUIET_SLOW.b                                    ; $00C25E |\
    STA r_play_audio_arg_mode.w                                                 ; $00C260 | | Fade the audio volume to a quieter level slowly.
    JSL bank04.play_audio                                                       ; $00C263 |/
    RTS                                                                         ; $00C267

; _decode_event_opcode_custom_effect_audio_fade_normal_slow ($00:C268)
;
; Custom effect that fades the audio to normal volume slowly.
_decode_event_opcode_custom_effect_audio_fade_normal_slow:
    JSR _audio_fade_normal_slow                                                 ; $00C268 | Fade the audio to normal volume slowly.
    JMP _decode_event_opcode_done                                               ; $00C26B

; _audio_fade_normal_slow ($00:C26E)
;
; Sends the command to fade in the audio from quiet to normal slowly.
_audio_fade_normal_slow:
    LDA #AUDIO_MODE_VOLUME_FADE_NORMAL_SLOW.b                                   ; $00C26E |\
    STA r_play_audio_arg_mode.w                                                 ; $00C270 | | Fade the audio volume back to the normal level slowly.
    JSL bank04.play_audio                                                       ; $00C273 |/
    RTS                                                                         ; $00C277

; _decode_event_opcode_custom_effect_enterprise_left_dive ($00:C278)
;
; This custom effect draws the Enterprise traveling left, and diving.
_decode_event_opcode_custom_effect_enterprise_left_dive:
    STZ <r_movement_frame_counter                                               ; $00C278 |\ Set the movement and map frame counters to zero.
    STZ <r_map_frame_counter                                                    ; $00C27A |/
    LDX #100.w                                                                  ; $00C27C |\ Initialize a frame counter to 100.
    STX <r_generic_frame_counter                                                ; $00C27F |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C281 | Wait for the next complete NMI.
    LDA <r_generic_frame_counter.lo                                             ; $00C284 |\
    CMP #64.b                                                                   ; $00C286 | | If the frame counter is less than 64, set the Enterprise altitude
    BCS +                                                                       ; $00C288 | | to that value divided by four, and set the zoom level to the
    LSR A                                                                       ; $00C28A | | altitude plus 16.
    LSR A                                                                       ; $00C28B | |
    STA <r_enterprise_altitude                                                  ; $00C28C | |
    CLC                                                                         ; $00C28E | |
    ADC #16.b                                                                   ; $00C28F | |
    STA <r_zoom_level                                                           ; $00C291 |/
+   LDA #1.b                                                                    ; $00C293 |\ Enable the calculation of player movement.
    STA <r_player_movement_calculation_enabled                                  ; $00C295 |/
    JSR _init_oam                                                               ; $00C297 | Initialize the OAM.
    LDA #JOYPAD_H_LEFT.b                                                        ; $00C29A |\
    STA <r_joypad_cutscene_hi                                                   ; $00C29C | | Fake a left button press.
    STZ <r_joypad_cutscene_lo                                                   ; $00C29E |/
    LDA #1.b                                                                    ; $00C2A0 |\ Enable the calculation of player movement again.
    STA <r_player_movement_calculation_enabled                                  ; $00C2A2 |/
    JSR _calculate_outdoor_movement_direction                                   ; $00C2A4 | Calculate the outdoor movement direction.
    JSR _do_outdoor_movement                                                    ; $00C2A7 | Execute the outdoor movement.
    JSL bank15.draw_field_sprite_enterprise                                     ; $00C2AA | Draw the Enterprise field sprite.
    LDX <r_generic_frame_counter                                                ; $00C2AE |\
    DEX                                                                         ; $00C2B0 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00C2B1 | |
    BNE -                                                                       ; $00C2B3 |/
    JMP _decode_event_opcode_done                                               ; $00C2B5

; _decode_event_opcode_custom_effect_ending_legend ($00:C2B8)
;
; Animates the legend portion of the ending.
_decode_event_opcode_custom_effect_ending_legend:
    JSR _disable_interrupts                                                     ; $00C2B8 |\ Disable interrupts.
    SEI                                                                         ; $00C2BB |/
    JSL bank13.ending_animate_legend                                            ; $00C2BC | Animate the Mysidian legend part of the ending.
    JSR _enable_interrupts_and_init_ppu                                         ; $00C2C0 | Enable interrupts and initialize the PPU.
    JMP _decode_event_opcode_done                                               ; $00C2C3

; _decode_event_opcode_custom_effect_ending_moon ($00:C2C6)
;
; Animates the moon portion of the ending.
_decode_event_opcode_custom_effect_ending_moon:
    JSR _disable_interrupts                                                     ; $00C2C6 |\ Disable interrupts.
    SEI                                                                         ; $00C2C9 |/
    JSL bank13.ending_animate_moon                                              ; $00C2CA | Animate the moon flying away scene.
    JSR _enable_interrupts_and_init_ppu                                         ; $00C2CE | Enable interrupts and initialize the PPU.
    JMP _decode_event_opcode_done                                               ; $00C2D1

; _decode_event_opcode_custom_effect_ending_credits ($00:C2D4)
;
; Animates the credits and final ending of the game. This routine will never
; return.
_decode_event_opcode_custom_effect_ending_credits:
    JSR _disable_interrupts                                                     ; $00C2D4 |\ Disable interrupts.
    SEI                                                                         ; $00C2D7 |/
    JSL bank13.ending_animate_credits                                           ; $00C2D8 | Animate the ending credits. NOTE: This will never return.
    JSR _enable_interrupts_and_init_ppu                                         ; $00C2DC | Enable interrupts and initialize the PPU.
    JMP _decode_event_opcode_done                                               ; $00C2DF

; _enable_interrupts_and_init_ppu ($00:C2E2)
;
; Does basic basic initialization to enable interrupts and initialize the PPU.
; Executed upon returning from the special animations done during the ending of
; the game.
_enable_interrupts_and_init_ppu:
    JSR init_nmi_irq_handlers                                                   ; $00C2E2 | Initialize the NMI and IRQ handlers.
    JSL bank15.init_ppu                                                         ; $00C2E5 | Initialize the PPU.
    CLI                                                                         ; $00C2E9 | Enable interrupts.
    LDA #%00000000.b                                                            ; $00C2EA |\ Set the PPU brightness to zero and disable forced blanking.
    STA reg_ppu_inidisp.w                                                       ; $00C2EC |/
    LDA #%10000001.b                                                            ; $00C2EF |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00C2F1 |/
    RTS                                                                         ; $00C2F4

; _decode_event_opcode_custom_effect_babil_explosions ($00:C2F5)
;
; Custom effect handler for the explosions that occur when nearing the Tower
; of Bab-il on the first visit. This effect effectively hard codes the Y
; coordinates the player needs to be standing on, and handles all three tiles
; with one set of code.
_decode_event_opcode_custom_effect_babil_explosions:
    LDA #16.b                                                                   ; $00C2F5 |\
    STA r_draw_explosion_arg_count.w                                            ; $00C2F7 | | Configure an explosion effect to draw four simultaneous sprites,
    LDX #32.w                                                                   ; $00C2FA | | with an initial cycle count of 32, using palette 7, a fire
    STX r_draw_explosion_arg_cycles.w                                           ; $00C2FD | | palette and with a small size.
    LDA #7.b                                                                    ; $00C300 | |
    STA r_draw_explosion_arg_palette.w                                          ; $00C302 | |
    STZ r_draw_explosion_arg_smoke.w                                            ; $00C305 | |
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00C308 | |
    STA r_draw_explosion_arg_width.w                                            ; $00C30A | |
    STA r_draw_explosion_arg_height.w                                           ; $00C30D | |
    JSR _init_explosion                                                         ; $00C310 |/
    LDA #1.b                                                                    ; $00C313 |\ Enable the shaking effect.
    STA <r_shaking                                                              ; $00C315 |/
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00C317 |\ Play the Crush/long explosion sound effect.
    JSR _play_sound_effect                                                      ; $00C319 |/
    LDX #192.w                                                                  ; $00C31C |\ Initialize a frame counter to 192.
    STX <r_generic_frame_counter                                                ; $00C31F |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C321 | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00C324 | Initialize the OAM.
    LDA r_current_coordinates.y.w                                               ; $00C327 |\
    SEC                                                                         ; $00C32A | | Set the X register to the current Y coordinate minus 16.
    SBC #16.b                                                                   ; $00C32B | |
    TAX                                                                         ; $00C32D |/
    LDA <r_map_frame_counter                                                    ; $00C32E |\
    LSR A                                                                       ; $00C330 | | Set the Y register to either 0 or 1, alternating between the two
    LSR A                                                                       ; $00C331 | | every 16 frames.
    LSR A                                                                       ; $00C332 | |
    LSR A                                                                       ; $00C333 | |
    AND #%00000001.b                                                            ; $00C334 | |
    TAY                                                                         ; $00C336 |/
    LDA babil_explosion_x_coordinate_data.w,X                                   ; $00C337 |\ Set the X coordinate for the explosion, indexed by the Y coordinate
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00C33A |/ minus 16.
    LDA babil_explosion_y_coordinate_base_data.w,Y                              ; $00C33D |\
    CLC                                                                         ; $00C340 | | Set the Y coordinate for the explosion.
    ADC babil_explosion_y_coordinate_data.w,X                                   ; $00C341 | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00C344 |/
    JSR _draw_explosion                                                         ; $00C347 | Draw the explosion for this frame.
    JSR _draw_outdoor_field_sprites                                             ; $00C34A | Draw the outdoor field sprites.
    LDX <r_generic_frame_counter                                                ; $00C34D |\
    DEX                                                                         ; $00C34F | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00C350 | |
    BNE -                                                                       ; $00C352 |/
    STZ <r_shaking                                                              ; $00C354 | Disable the shaking effect.
    JMP _decode_event_opcode_done                                               ; $00C356

; babil_explosion_x_coordinate_data ($00:C359)
;
; For the explosions that occur outside the Tower of Bab-il during the first
; visit, determines the X coordinate for the explosions. This is indexed by the
; player's current Y coordinate, minus 16.
babil_explosion_x_coordinate_data:
    .db 64                                                                      ; $00C359 | $10: Third explosion
    .db 16                                                                      ; $00C35A | $11: Second explosion
    .db  0                                                                      ; $00C35B | $12: <unused>
    .db  0                                                                      ; $00C35C | $13: <unused>
    .db 16                                                                      ; $00C35D | $14: First Explosion

; babil_explosion_y_coordinate_Data ($00:C35E)
;
; For the explosions that occur outside the Tower of Bab-il during the first
; visit, determines the Y coordinate for the explosions. This is indexed by the
; player's current Y coordinate, minus 16.
babil_explosion_y_coordinate_data:
    .db 160                                                                     ; $00C35E | $10: Third explosion
    .db 144                                                                     ; $00C35F | $11: Second explosion
    .db   0                                                                     ; $00C360 | $12: <unused>
    .db   0                                                                     ; $00C361 | $13: <unused>
    .db  96                                                                     ; $00C362 | $14: First Explosion

; babil_explosion_y_coordinate_base_data ($00:C363)
;
; For the explosions that occur outside the Tower of Bab-il during the first
; visit, determines the base Y coordinate for the explosions. This coordinate is
; adjusted after a few frames to switch drawing the explosions from one
; location to another.
babil_explosion_y_coordinate_base_data:
    .db   0                                                                     ; $00C363
    .db 160                                                                     ; $00C364

; _decode_event_opcode_custom_effect_agart_telescope ($00:C365)
;
; Custom effect for displaying the Agart telescope view.
_decode_event_opcode_custom_effect_agart_telescope:
    JSR _disable_interrupts                                                     ; $00C365 | Disable interrupts.
    JSR _load_earth_moon_transition_sprites                                     ; $00C368 | Load the earth and moon sprites.
    LDA #%00100010.b                                                            ; $00C36B |\ Invert the window on BG1 and BG2 from the default setting.
    STA reg_ppu_w12sel.w                                                        ; $00C36D |/
    LDA #0.b                                                                    ; $00C370 |\ Disable HDMA.
    STA reg_cpu_hdmaen.w                                                        ; $00C372 |/
    LDA #119.b | %10000000                                                      ; $00C375 |\
    STA r_hdma_table.l + 0                                                      ; $00C377 | | Configure the HDMA data for the first 119 scanlines.
    LDA #<bank16.telescope_window_hdma_data                                     ; $00C37B | |
    STA r_hdma_table.l + 1                                                      ; $00C37D | |
    LDA #>bank16.telescope_window_hdma_data                                     ; $00C381 | |
    STA r_hdma_table.l + 2                                                      ; $00C383 |/
    LDA #119.b | %10000000                                                      ; $00C387 |\
    STA r_hdma_table.l + 3                                                      ; $00C389 | | Configure the HDMA table for the next 119 scanlines.
    LDA #<(bank16.telescope_window_hdma_data + 124 * 2)                         ; $00C38D | |
    STA r_hdma_table.l + 4                                                      ; $00C38F | |
    LDA #>(bank16.telescope_window_hdma_data + 124 * 2)                         ; $00C393 | |
    STA r_hdma_table.l + 5                                                      ; $00C395 |/
    LDA #0.b                                                                    ; $00C399 |\ Terminate the HDMA table.
    STA r_hdma_table.l + 6                                                      ; $00C39B |/
    LDA #%01000001.b                                                            ; $00C39F |\
    STA reg_cpu_dmap6.w                                                         ; $00C3A1 | | Configure DMA channel 6 to use the configured HDMA table to
    LDA #<reg_ppu_wh0                                                           ; $00C3A4 | | update the window location registers in the PPU.
    STA reg_cpu_bbad6.w                                                         ; $00C3A6 | |
    LDX #r_hdma_table.w                                                         ; $00C3A9 | |
    STX reg_cpu_a1t6.w                                                          ; $00C3AC | |
    LDA #:r_hdma_table.b                                                        ; $00C3AF | |
    STA reg_cpu_a1b6.w                                                          ; $00C3B1 | |
    LDA #:bank16.telescope_window_hdma_data.b                                   ; $00C3B4 | |
    STA reg_cpu_hdb6.w                                                          ; $00C3B6 |/
    LDA #MAP_AREA_DUNGEON.b                                                     ; $00C3B9 |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $00C3BB |/
    LDA #0.b                                                                    ; $00C3BE |\ Set PPU brightness to zero.
    STA reg_ppu_inidisp.w                                                       ; $00C3C0 |/
    LDA #%10000001.b                                                            ; $00C3C3 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00C3C5 |/
    STZ <r_field_effect_counter                                                 ; $00C3C8 | Initialize a counter to zero.
-   JSR _wait_for_nmi_complete                                                  ; $00C3CA | Wait for the next complete NMI.
    LDA #%01000000.b                                                            ; $00C3CD |\ Enable HDMA on DMA channel 6.
    STA reg_cpu_hdmaen.w                                                        ; $00C3CF |/
    LDA <r_field_effect_counter                                                 ; $00C3D2 |\ Set the PPU brightness.
    STA reg_ppu_inidisp.w                                                       ; $00C3D4 |/
    JSR _draw_moon_and_stars                                                    ; $00C3D7 | Draw the moon and stars.
    INC <r_field_effect_counter                                                 ; $00C3DA |\
    LDA <r_field_effect_counter                                                 ; $00C3DC | | Increment the counter and loop until it reaches maximum
    CMP #16.b                                                                   ; $00C3DE | | brightness.
    BNE -                                                                       ; $00C3E0 |/
-   JSR _wait_for_nmi_complete                                                  ; $00C3E2 | Wait for the next complete NMI.
    LDA #%01000000.b                                                            ; $00C3E5 |\ Enable HDMA on DMA channel 6.
    STA reg_cpu_hdmaen.w                                                        ; $00C3E7 |/
    JSR _draw_moon_and_stars                                                    ; $00C3EA | Draw the moon and stars.
    LDA <r_joypad_pressed_lo                                                    ; $00C3ED |\
    BNE +                                                                       ; $00C3EF | | Loop until a button is pressed.
    LDA <r_joypad_pressed_hi                                                    ; $00C3F1 | |
    BNE +                                                                       ; $00C3F3 | |
    JMP -                                                                       ; $00C3F5 |/
+   LDA #%00001111.b                                                            ; $00C3F8 |\ Initialize the counter to maximum brightness.
    STA <r_field_effect_counter                                                 ; $00C3FA |/
-   JSR _wait_for_nmi_complete                                                  ; $00C3FC | Wait for the next complete NMI.
    LDA #%01000000.b                                                            ; $00C3FF |\ Enable HDMA on DMA channel 6.
    STA reg_cpu_hdmaen.w                                                        ; $00C401 |/
    LDA <r_field_effect_counter                                                 ; $00C404 |\ Set the current PPU brightness.
    STA reg_ppu_inidisp.w                                                       ; $00C406 |/
    JSR _draw_moon_and_stars                                                    ; $00C409 | Draw the moon and stars.
    DEC <r_field_effect_counter                                                 ; $00C40C |\
    LDA <r_field_effect_counter                                                 ; $00C40E | | Decrement the counter and loop until it reaches zero.
    BNE -                                                                       ; $00C410 |/
    LDA #%00110011.b                                                            ; $00C412 |\ Return the window mask settings to default.
    STA reg_ppu_w12sel.w                                                        ; $00C414 |/
    LDA #0.b                                                                    ; $00C417 |\ Disable HDMA.
    STA reg_cpu_hdmaen.w                                                        ; $00C419 |/
    JMP _decode_event_opcode_done                                               ; $00C41C

; _draw_moon_and_stars ($00:C41F)
;
; Draws the moon and a star field, concentrated within the range of 64 to 191
; on both axes.
_draw_moon_and_stars:
    JSR _draw_moon_sprite                                                       ; $00C41F | Draw the moon sprite to the center of the screen.
    LDY #_sizeof_oam_sprite.w * 4                                               ; $00C422 | Initialize the Y register to start at OAM entry 4.
    LDX #0.w                                                                    ; $00C425 | Initialize the X register to zero.
-   JSR _get_field_rng                                                          ; $00C428 |\
    LSR A                                                                       ; $00C42B | | Set the X coordinate to a random number from 64 to 191.
    CLC                                                                         ; $00C42C | |
    ADC #64.b                                                                   ; $00C42D | |
    STA r_oam.1.x.w,Y                                                           ; $00C42F |/
    JSR _get_field_rng                                                          ; $00C432 |\
    LSR A                                                                       ; $00C435 | | Set the Y coordinate to a random number from 64 to 191.
    CLC                                                                         ; $00C436 | |
    ADC #64.b                                                                   ; $00C437 | |
    STA r_oam.1.y.w,Y                                                           ; $00C439 |/
    LDA #<TILE_SINGLE_PIXEL.b                                                   ; $00C43C |\ Set the tile number to the single illuminated pixel.
    STA r_oam.1.tile.w,Y                                                        ; $00C43E |/
    JSR _get_field_rng                                                          ; $00C441 |\
    AND #%00000111.b                                                            ; $00C444 | | Set the palette to a random value from 0 to 7, and set the bit to
    ASL A                                                                       ; $00C446 | | enable the high name table.
    ORA #%00000001.b                                                            ; $00C447 | |
    STA r_oam.1.flags.w,Y                                                       ; $00C449 |/
    INX                                                                         ; $00C44C |\
    INX                                                                         ; $00C44D | | Increment the indexes appropriately and loop until 124 stars have
    INY                                                                         ; $00C44E | | been drawn.
    INY                                                                         ; $00C44F | |
    INY                                                                         ; $00C450 | |
    INY                                                                         ; $00C451 | |
    CPY #_sizeof_oam_sprite.w * 128                                             ; $00C452 | |
    BNE -                                                                       ; $00C455 |/
    RTS                                                                         ; $00C457

; _decode_event_opcode_custom_effect_sight ($00:C458)
;
; Custom effect for the Sight spell.
_decode_event_opcode_custom_effect_sight:
    JSR _audio_fade_quiet_slow                                                  ; $00C458 | Fade the audio volume to a quiet level.
    LDA #32.b                                                                   ; $00C45B |\ Set the zoom level to 32 to start.
    STA <r_zoom_level                                                           ; $00C45D |/
    JSR _init_oam                                                               ; $00C45F | Initialize the OAM.
-   JSR _wait_for_nmi_complete                                                  ; $00C462 | Wait for the next frame.
    STZ reg_cpu_hdmaen.w                                                        ; $00C465 | Disable HDMA.
    INC <r_zoom_level                                                           ; $00C468 | Increment the zoom level.
    JSR _field_effect_zoom_set_mode_7_parameters                                ; $00C46A |\ Set the mode 7 parameters such that the scale is equal to the zoom
    JSR _set_mode_7_transform                                                   ; $00C46D |/ level value.
    LDA <r_zoom_level                                                           ; $00C470 |\
    LSR A                                                                       ; $00C472 | | Set the zoom palette to soften the fine detail colors.
    LSR A                                                                       ; $00C473 | |
    LSR A                                                                       ; $00C474 | |
    INC A                                                                       ; $00C475 | |
    JSL bank15.set_zoom_palette                                                 ; $00C476 |/
    LDA <r_zoom_level                                                           ; $00C47A |\
    CMP #120.b                                                                  ; $00C47C | | Loop until the zoom level reaches 120.
    BNE -                                                                       ; $00C47E |/
-   JSR _wait_for_nmi_complete                                                  ; $00C480 | Wait for the next frame.
    STZ reg_cpu_hdmaen.w                                                        ; $00C483 | Disable HDMA.
    JSR _set_mode_7_transform                                                   ; $00C486 | Set the mode 7 parameters.
    LDA <r_joypad_pressed_lo                                                    ; $00C489 |\
    BNE +                                                                       ; $00C48B | | Loop until a button is pressed.
    LDA <r_joypad_pressed_hi                                                    ; $00C48D | |
    BEQ -                                                                       ; $00C48F |/
+   JSR _audio_fade_normal_slow                                                 ; $00C491 | Fade the audio back to normal.
-   JSR _wait_for_nmi_complete                                                  ; $00C494 | Wait for the next frame.
    STZ reg_cpu_hdmaen.w                                                        ; $00C497 | Disable HDMA.
    DEC <r_zoom_level                                                           ; $00C49A | Decrease the zoom level.
    JSR _field_effect_zoom_set_mode_7_parameters                                ; $00C49C |\ Set the mode 7 parameters.
    JSR _set_mode_7_transform                                                   ; $00C49F |/
    LDA <r_zoom_level                                                           ; $00C4A2 |\
    LSR A                                                                       ; $00C4A4 | | Set the zoom palette.
    LSR A                                                                       ; $00C4A5 | |
    LSR A                                                                       ; $00C4A6 | |
    JSL bank15.set_zoom_palette                                                 ; $00C4A7 |/
    LDA <r_zoom_level                                                           ; $00C4AB |\
    CMP #32.b                                                                   ; $00C4AD | | Loop until the zoom level reaches 32.
    BNE -                                                                       ; $00C4AF |/
    LDA #$10.b                                                                  ; $00C4B1 |\ Set the zoom level back to normal.
    STA <r_zoom_level                                                           ; $00C4B3 |/
    JMP _decode_event_opcode_done                                               ; $00C4B5

; _decode_event_opcode_custom_effect_legend ($00:C4B8)
;
; Custom effect for displaying the Mysidian legend. The USA version has been
; modified to support additional lines.
_decode_event_opcode_custom_effect_legend:
    JSL bank15.init_ppu                                                         ; $00C4B8 | Initialize the PPU.
    LDA #%00001001.b                                                            ; $00C4BC |\ Set BG mode to mode 1 with BG3 at high priority.
    STA reg_ppu_bgmode.w                                                        ; $00C4BE |/
    LDX #$2000.w                                                                ; $00C4C1 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00C4C4 | | Copy the dialog tiles from ROM to VRAM at $2000.
    LDX #bank0A._sizeof_dialog_tile_data.w                                      ; $00C4C6 | |
    STX <r_start_vram_dma_arg_bytes                                             ; $00C4C9 | |
    LDA #:bank0A.dialog_tile_data                                               ; $00C4CB | |
    STA <r_start_vram_dma_arg_bank                                              ; $00C4CD | |
    LDX #bank0A.dialog_tile_data                                                ; $00C4CF | |
    STX <r_start_vram_dma_arg_address                                           ; $00C4D2 | |
    JSL bank15.start_vram_dma                                                   ; $00C4D4 |/
    LDA #%10000000.b                                                            ; $00C4D8 |\ Set the VRAM increment to 1 by 1 after two writes.
    STA reg_ppu_vmainc.w                                                        ; $00C4DA |/
    LDX #$2C00.w                                                                ; $00C4DD |\ Set the target VRAM address to $2C00.
    STX reg_ppu_vmadd.w                                                         ; $00C4E0 |/
    LDX #(32 * 32).w                                                            ; $00C4E3 |\
-   LDA #$FF.b                                                                  ; $00C4E6 | | Fill the right side of BG3 with blank dialog tiles, using palette
    STA reg_ppu_vmdatal_write.w                                                 ; $00C4E8 | | zero with priority 1.
    LDA #%00100000.b                                                            ; $00C4EB | |
    STA reg_ppu_vmdatah_write.w                                                 ; $00C4ED | |
    DEX                                                                         ; $00C4F0 | |
    BNE -                                                                       ; $00C4F1 |/
    LDA #$6A.b                                                                  ; $00C4F3 |\
    STA <r_show_message_id                                                      ; $00C4F5 | | Load the offset for the legend message.
    JSR _load_message_bank_1_hi_offset                                          ; $00C4F7 |/
    STZ <r_dialog_scroll_index                                                  ; $00C4FA | Set the dialog scroll index to zero.
    JSR _load_dialog                                                            ; $00C4FC | Load the first lines of dialog.
    INC <r_upper_dialog_text_pending                                            ; $00C4FF |\
    JSR _draw_upper_dialog_text_if_pending                                      ; $00C501 | | Draw the legend text to the BG3 tilemap area.
    JSR _load_dialog                                                            ; $00C504 | |
    INC <r_upper_dialog_text_pending                                            ; $00C507 | |
    JSR _draw_upper_dialog_text_if_pending                                      ; $00C509 | |
.if FF4_REGION == "USA"                                                         ;         | |
    JSR _load_dialog                                                            ; $00C50C | |
    INC <r_upper_dialog_text_pending                                            ; $00C50F | |
    JSR _draw_upper_dialog_text_if_pending                                      ; $00C511 | |
    JSR _load_dialog                                                            ; $00C514 | |
    INC <r_upper_dialog_text_pending                                            ; $00C517 | |
    JSR _draw_upper_dialog_text_if_pending                                      ; $00C519 | |
.endif                                                                          ;         | |
    STZ <r_load_dialog_bank                                                     ; $00C51C | |
    STZ <r_upper_dialog_text_pending                                            ; $00C51E |/
.if FF4_REGION == "JAPAN"
    LDA #%10000000.b                                                            ; $00C7CA |\ Set the VRAM increment to 1 by 1 after writing the high byte.
    STA reg_ppu_vmainc.w                                                        ; $00C7CC |/
    LDX #VRAM_FIELD_TILEMAP_BG3.w + 32 * 32                                     ; $00C7CF |\ Set the VRAM address to the right side of BG3.
    STX reg_ppu_vmadd.w                                                         ; $00C7D2 |/
    LDX #0.w                                                                    ; $00C7D5 | Initialize the X register to zero.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $00C7D8 |\
    TXA                                                                         ; $00C7DA | | Loop through the top half of the right side of BG3, setting each
    AND #$01C0.w                                                                ; $00C7DB | | successive pair of rows to the next higher palette index, along
    LSR A                                                                       ; $00C7DE | | with setting the priority bit. (In other words, the first two rows
    LSR A                                                                       ; $00C7DF | | use palette zero, the second two use palette one, and so on.)
    LSR A                                                                       ; $00C7E0 | |
    LSR A                                                                       ; $00C7E1 | | This only applies to the Japanese version.
    ORA #$0020.w                                                                ; $00C7E2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C7E5 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $00C7E7 | |
    INX                                                                         ; $00C7EA | |
    CPX #$0200.w                                                                ; $00C7EB | |
    BNE -                                                                       ; $00C7EE |/
    LDA #0.b                                                                    ; $00C7F0 |\ Zero out the high byte of the accumulator.
    XBA                                                                         ; $00C7F2 |/
    LDX #0.w                                                                    ; $00C7F3 | Initialize the X register to zero.
-   LDA #$00.b                                                                  ; $00C7F6 |\
    STA r_cgram_data.1.color2.w + word.lo,X                                     ; $00C7F8 | | Set colors 2 and 4 on the first eight BG3 palettes to a dark blue.
    STA r_cgram_data.1.color4.w + word.lo,X                                     ; $00C7FB | |
    LDA #$40.b                                                                  ; $00C7FE | |
    STA r_cgram_data.1.color2.w + word.hi,X                                     ; $00C800 | |
    STA r_cgram_data.1.color4.w + word.hi,X                                     ; $00C803 | |
    TXA                                                                         ; $00C806 | |
    CLC                                                                         ; $00C807 | |
    ADC #8.b                                                                    ; $00C808 | |
    TAX                                                                         ; $00C80A | |
    CMP #$40.b                                                                  ; $00C80B | |
    BNE -                                                                       ; $00C80D |/
.else
    LDA #$00.b                                                                  ; $00C520 |\
    STA r_cgram_data.1.color2.w + 0                                             ; $00C522 | | Set colors 2 and 4 on the first BG3 palette to a dark blue.
    STA r_cgram_data.1.color4.w + 0                                             ; $00C525 | |
    LDA #$40.b                                                                  ; $00C528 | |
    STA r_cgram_data.1.color2.w + 1                                             ; $00C52A | |
    STA r_cgram_data.1.color4.w + 1                                             ; $00C52D |/
    LDA #$FF.b                                                                  ; $00C530 |\
    STA r_cgram_data.1.color12.w + 0                                            ; $00C532 | | Set color 4 on the third BG3 palette to white.
    LDA #$7F.b                                                                  ; $00C535 | |
    STA r_cgram_data.1.color12.w + 1                                            ; $00C537 |/
.endif
    LDA #$00.b                                                                  ; $00C53A |\
    STA reg_ppu_bg3h0fs.w                                                       ; $00C53C | | Set the BG3 horizontal scroll to $100, to show the right half of
    LDA #$01.b                                                                  ; $00C53F | | the background.
    STA reg_ppu_bg3h0fs.w                                                       ; $00C541 |/
    LDA #<LEGEND_BG3_VERTICAL_SCROLL.b                                          ; $00C544 |\
    STA reg_ppu_bg3v0fs.w                                                       ; $00C546 | | Set the BG3 vertical scroll to roughly center the text vertically.
    LDA #>LEGEND_BG3_VERTICAL_SCROLL.b                                          ; $00C549 | |
    STA reg_ppu_bg3v0fs.w                                                       ; $00C54B |/
    LDA #%10000001.b                                                            ; $00C54E |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00C550 |/
    LDA #%00000011.b                                                            ; $00C553 |\ Fade the PPU in, increasing the brightness every four frames.
    JSR _ppu_fade_in                                                            ; $00C555 |/
    STZ <r_legend_tmp_line_index.lo                                             ; $00C558 |\ Initialize the current line index to zero.
    STZ <r_legend_tmp_line_index.hi                                             ; $00C55A |/
@outer_loop_start:
    STZ <r_legend_tmp_counter.lo                                                ; $00C55C |\ Initialize the current counter to zero.
    STZ <r_legend_tmp_counter.hi                                                ; $00C55E |/
@inner_loop_start:
.if FF4_REGION == "JAPAN"
    JSR _wait_for_nmi_complete                                                  ; $00C835 | For the Japanese version, wait for the next complete NMI.
.endif
    LDA <r_legend_tmp_line_index.lo                                             ; $00C560 |\
    ASL A                                                                       ; $00C562 | | Calculate the current color of the line that is fading in. The
    TAX                                                                         ; $00C563 | | high five bits of the counter value are shifted as needed to set
    REP #FLAG_P_ACCUMULATOR                                                     ; $00C564 | | the red and green channels in the color value. The blue channel is
    LDA <r_legend_tmp_counter                                                   ; $00C566 | | loaded from ROM, indexed by the current line index (multiplied by
    LSR A                                                                       ; $00C568 | | two, as each color is two bytes).
    LSR A                                                                       ; $00C569 | |
    LSR A                                                                       ; $00C56A | | BUG: Using the line index seems to very likely be a bug. The table
    STA <r_legend_tmp_color                                                     ; $00C56B | |      being read from has 32 entries, presumably one for each
    ASL A                                                                       ; $00C56D | |      possible increment of the red and green channels. The line
    ASL A                                                                       ; $00C56E | |      index will never be that large. The result is that the color
    ASL A                                                                       ; $00C56F | |      fades from blue to yellow, instead of to white.
    ASL A                                                                       ; $00C570 | |
    ASL A                                                                       ; $00C571 | | Save the color to a temporary variable.
    ORA <r_legend_tmp_color                                                     ; $00C572 | |
    ORA bank14.blue_to_white_blue_channel_data.l,X                              ; $00C574 | |
    STA <r_legend_tmp_color                                                     ; $00C578 |/
.if FF4_REGION == "JAPAN"
    TXA                                                                         ; $00C852 |\
    ASL A                                                                       ; $00C853 | | Multiply the X register by four.
    ASL A                                                                       ; $00C854 | |
    TAX                                                                         ; $00C855 |/
    LDA <r_legend_tmp_color                                                     ; $00C856 |\ Write the fourth color in the palette for the current line.
    STA r_cgram_data.1.color4.w,X                                               ; $00C858 |/
    LDA #0.w                                                                    ; $00C85B |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C85E |/
    INC <r_legend_tmp_counter                                                   ; $00C860 | Increment the counter.
    BNE @inner_loop_start                                                       ; $00C862
.else
    STA r_cgram_data.1.color8.w                                                 ; $00C57A | Additionally save the color to the 4th color of the second palette.
    LDA #0.w                                                                    ; $00C57D |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C580 |/
    JSR _wait_for_nmi_complete                                                  ; $00C582 | Wait for the next complete NMI.
    LDA #%10000000.b                                                            ; $00C585 |\ Set the VRAM increment to 1 by 1 after writes to $2119.
    STA reg_ppu_vmainc.w                                                        ; $00C587 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00C58A |\
    LDA <r_legend_tmp_line_index                                                ; $00C58C | | Set the target VRAM address to $2C00 plus the line index times 64,
    ASL A                                                                       ; $00C58E | | to move down two rows. (In other words, the corresponding row on
    ASL A                                                                       ; $00C58F | | the right half of BG3.)
    ASL A                                                                       ; $00C590 | |
    ASL A                                                                       ; $00C591 | |
    ASL A                                                                       ; $00C592 | |
    ASL A                                                                       ; $00C593 | |
    CLC                                                                         ; $00C594 | |
    ADC #$2C00.w                                                                ; $00C595 | |
    STA reg_ppu_vmadd.w                                                         ; $00C598 | |
    LDA #0.w                                                                    ; $00C59B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C59E |/
    LDX #64.w                                                                   ; $00C5A0 |\
-   LDA #%00100100.b                                                            ; $00C5A3 | | Write the flags for the current and following row to use palette 1
    STA reg_ppu_vmdatah_write.w                                                 ; $00C5A5 | | and priority 1.
    DEX                                                                         ; $00C5A8 | |
    BNE -                                                                       ; $00C5A9 |/
    INC <r_legend_tmp_counter                                                   ; $00C5AB |\ Increment the counter by two, which will result in a color change
    INC <r_legend_tmp_counter                                                   ; $00C5AD |/ every 4 frames.
    BNE @inner_loop_start                                                       ; $00C5AF | Loop until the counter wraps around to zero.
    LDA #%10000000.b                                                            ; $00C5B1 |\ Set the VRAM increment to 1 by 1 after writes to $2119.
    STA reg_ppu_vmainc.w                                                        ; $00C5B3 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00C5B6 |\
    LDA <r_legend_tmp_line_index                                                ; $00C5B8 | | Once again set the VRAM address to the base address for the
    ASL A                                                                       ; $00C5BA | | current row.
    ASL A                                                                       ; $00C5BB | |
    ASL A                                                                       ; $00C5BC | |
    ASL A                                                                       ; $00C5BD | |
    ASL A                                                                       ; $00C5BE | |
    ASL A                                                                       ; $00C5BF | |
    CLC                                                                         ; $00C5C0 | |
    ADC #$2C00.w                                                                ; $00C5C1 | |
    STA reg_ppu_vmadd.w                                                         ; $00C5C4 | |
    LDA #0.w                                                                    ; $00C5C7 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00C5CA |/
    LDX #64.w                                                                   ; $00C5CC |\
-   LDA #%00101000.b                                                            ; $00C5CF | | Write the flags for the two current rows to change to palette 2.
    STA reg_ppu_vmdatah_write.w                                                 ; $00C5D1 | |
    DEX                                                                         ; $00C5D4 | |
    BNE -                                                                       ; $00C5D5 |/
.endif
    INC <r_legend_tmp_line_index                                                ; $00C5D7 |\
    LDA <r_legend_tmp_line_index                                                ; $00C5D9 | | Increment the line index and loop until it reaches the maximum.
    CMP #LEGEND_LINE_COUNT.b                                                    ; $00C5DB | |
.if FF4_REGION == "JAPAN"                                                       ;         | |
    BNE @outer_loop_start                                                       ; $00C86A | |
.else                                                                           ;         | |
    BEQ +                                                                       ; $00C5DD | |
    JMP @outer_loop_start                                                       ; $00C5DF |/
.endif
+   LDA #%00000011.b                                                            ; $00C5E2 |\ Fade out the PPU, decrementing the brightness every 4 frames.
    JSR _ppu_fade_out                                                           ; $00C5E4 |/
    STZ reg_ppu_bg3h0fs.w                                                       ; $00C5E7 |\
    STZ reg_ppu_bg3h0fs.w                                                       ; $00C5EA | | Set the BG3 scroll registers back to zero.
    STZ reg_ppu_bg3v0fs.w                                                       ; $00C5ED | |
    STZ reg_ppu_bg3v0fs.w                                                       ; $00C5F0 |/
    JSL bank15.load_dialog_palettes                                             ; $00C5F3 | Load the dialog palettes.
    JSL bank15.load_dungeon_palette                                             ; $00C5F7 | Load the palettes for the current map.
    LDA #%10000001.b                                                            ; $00C5FB |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00C5FD |/
    JMP _decode_event_opcode_done                                               ; $00C600

; _decode_event_opcode_custom_effect_big_whale_to_moon ($00:C603)
;
; Custom effect that flies the Big Whale to the moon and immediately lands.
_decode_event_opcode_custom_effect_big_whale_to_moon:
    LDX #(19 + (39 << 8)).w                                                     ; $00C603 |\ Set the Big Whale's moon coordinates to 19, 39.
    STX r_big_whale_moon_coordinates.w                                          ; $00C606 |/
    LDA #MAP_AREA_OVERWORLD.b                                                   ; $00C609 |\ Set the map area to the overworld.
    STA r_map_area.w                                                            ; $00C60B |/
    LDA #1.b                                                                    ; $00C60E |\ Set the flag to do earth moon travel.
    STA <r_do_earth_moon_travel                                                 ; $00C610 |/
    JSR _activate_big_whale                                                     ; $00C612 | Activate the Big Whale.
    LDA #%11111111.b                                                            ; $00C615 |\ Set all bits in the second properties byte for this tile to ensure
    STA <r_tile_properties_current.properties_2                                 ; $00C617 |/ landing is possible.
    JSR _land_big_whale                                                         ; $00C619 | Land the Big Whale.
    LDA #MAP_AREA_MOON.b                                                        ; $00C61C |\ Set the Big Whale plane to the moon.
    STA r_big_whale_plane.w                                                     ; $00C61E |/
    LDX #(19 + (39 << 8)).w                                                     ; $00C621 |\ Set the Big Whale coordinates to 19, 39.
    STX r_big_whale_coordinates.w                                               ; $00C624 |/
    JMP _decode_event_opcode_done                                               ; $00C627

; _decode_event_opcode_custom_effect_hide_enterprise ($00:C62A)
;
; This custom effect hides the Enterprise.
_decode_event_opcode_custom_effect_hide_enterprise:
    STZ r_enterprise_status.w                                                   ; $00C62A | Deactivates the Enterprise.
    JMP _decode_event_opcode_done                                               ; $00C62D

; _decode_event_opcode_custom_effect_big_whale_earth_moon_travel ($00:C630)
;
; Custom effect to handle travel between the earth and moon in the Big Whale.
; Merely sets the flag that will cause the sequence to be rendered and then
; falls through to the flying custom effect.
_decode_event_opcode_custom_effect_big_whale_earth_moon_travel:
    LDA #1.b                                                                    ; $00C630 |\ Set the flag to do earth/moon travel and then fall through to fly
    STA <r_do_earth_moon_travel                                                 ; $00C632 |/ the Big Whale.

; _decode_event_opcode_custom_effect_fly_big_whale ($00:C634)
;
; Custom effect to start flying the Big Whale at its current coordinates.
_decode_event_opcode_custom_effect_fly_big_whale:
    LDX #0.w                                                                    ; $00C634 |\ Reset the map history index to zero.
    STX r_map_history_index.w                                                   ; $00C637 |/
    LDA #VEHICLE_BIG_WHALE.b                                                    ; $00C63A |\ Set the current vehicle to the Big Whale.
    STA r_vehicle.w                                                             ; $00C63C |/
    LDA #MOVEMENT_SPEED_BIG_WHALE.b                                             ; $00C63F |\ Set the movement speed to Big Whale speed.
    STA <r_movement_speed                                                       ; $00C641 |/
    STZ <r_disable_airship_activation_effects                                   ; $00C643 | Make sure airship activation effects are enabled.
    LDX r_big_whale_coordinates.w                                               ; $00C645 |\ Set the current coordinates to the Big Whale coordinates.
    STX r_current_coordinates.w                                                 ; $00C648 |/
    LDA r_big_whale_plane.w                                                     ; $00C64B |\ Change to the appropriate map area for the Big Whale.
    JSR _change_map_area                                                        ; $00C64E |/
    JSR _activate_big_whale                                                     ; $00C651 | Activate the Big Whale.
    JMP _decode_event_opcode_done                                               ; $00C654

; _decode_event_opcode_custom_effect_big_whale_to_earth_eblan ($00:C657)
;
; Custom effect to fly the Big Whale from the moon to earth and to land on the
; Eblan continent in preparation for the Giant of Bab-il events.
_decode_event_opcode_custom_effect_big_whale_to_earth_eblan:
    LDX #(40 + (232 << 8)).w                                                    ; $00C657 |\ Set the Big Whale Earth coordinates to 40, 232 (on the Eblan
    STX r_big_whale_earth_coordinates.w                                         ; $00C65A |/ continent).
    LDX r_big_whale_coordinates.w                                               ; $00C65D |\ Set the current coordinates to the Big Whale coordinates.
    STX r_current_coordinates.w                                                 ; $00C660 |/
    LDA r_big_whale_plane.w                                                     ; $00C663 |\ Change map area to the current Big Whale area.
    JSR _change_map_area                                                        ; $00C666 |/
    LDA #1.b                                                                    ; $00C669 |\ Set the flag to do the earth/moon transition.
    STA <r_do_earth_moon_travel                                                 ; $00C66B |/
    JSR _activate_big_whale                                                     ; $00C66D | Activate the Big Whale.
    LDA #%11111111.b                                                            ; $00C670 |\ Set all bits in the second property byte for the tile to ensure
    STA <r_tile_properties_current.properties_2                                 ; $00C672 |/ landing is possible. NOTE: This seems to be pointless.
    JSR _land_big_whale                                                         ; $00C674 | Land the Big Whale.
    LDA #1.b                                                                    ; $00C677 |\ Set the flag to suppress field sprite shadows.
    STA r_suppress_field_sprite_shadows.w                                       ; $00C679 |/
    LDX #(40 + (232 << 8)).w                                                    ; $00C67C |\ Set the Big Whale coordinates to 40, 232.
    STX r_big_whale_coordinates.w                                               ; $00C67F |/
    JMP _decode_event_opcode_done                                               ; $00C682

; _decode_event_opcode_custom_effect_giant_attacking ($00:C685)
;
; Custom effect that animates the giant taking steps southward and attacking
; three times.
_decode_event_opcode_custom_effect_giant_attacking:
    STZ r_vehicle.w                                                             ; $00C685 | Set the current vehicle to none.
    STZ <r_giant_of_babil_tmp_counter                                           ; $00C688 |\ Initialize the counter and accumulator variable to zero.
    STZ <r_giant_of_babil_tmp_accumulator                                       ; $00C68A |/
    JSR _fill_palettes_10_11_white                                              ; $00C68C | Fill palettes 10 and 11 with white.
-   JSR _wait_for_nmi_complete_field                                            ; $00C68F | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00C692 | Initialize the OAM.
    JSR _init_oam_hi_32_large                                                   ; $00C695 | Set the first 32 OAM sprites to large size.
    INC <r_giant_of_babil_tmp_counter                                           ; $00C698 | Increment the counter.
    LDA <r_giant_of_babil_tmp_accumulator                                       ; $00C69A |\
    CLC                                                                         ; $00C69C | | Add the new counter value to the accumulator.
    ADC <r_giant_of_babil_tmp_counter                                           ; $00C69D | |
    STA <r_giant_of_babil_tmp_accumulator                                       ; $00C69F |/
    BCC +                                                                       ; $00C6A1 |\
    LDX #GIANT_POSE_OFFSET_WALKING_1.w                                          ; $00C6A3 | | If the accumulator variable overflowed, draw the Giant of Bab-il
    LDA #96.b                                                                   ; $00C6A6 | | at 96, 80.
    STA <r_generic_arg_x_lo                                                     ; $00C6A8 | |
    LDA #80.b                                                                   ; $00C6AA | | This results in the Giant of Bab-il flickering in at an increasing
    STA <r_generic_arg_y_lo                                                     ; $00C6AC | | rate.
    JSR _draw_giant_of_babil                                                    ; $00C6AE |/
+   LDA <r_giant_of_babil_tmp_counter                                           ; $00C6B1 |\
    CMP #$FF.b                                                                  ; $00C6B3 | | Loop until the counter reaches 255.
    BNE -                                                                       ; $00C6B5 |/
    JSR _load_giant_of_babil_palette                                            ; $00C6B7 | Load the Giant of Bab-il palette data.
    LDA r_plot_flags.9.w                                                        ; $00C6BA |\
    AND #~PLOT_FLAG_9_TOWER_OF_BABIL_FLASHING.b                                 ; $00C6BD | | Reset the plot flag that causes the Tower of Bab-il to flash.
    STA r_plot_flags.9.w                                                        ; $00C6BF |/
    LDX #3.w                                                                    ; $00C6C2 |\
-   PHX                                                                         ; $00C6C5 | | Animate the giant taking two steps south and attacking, three
    JSR _giant_take_two_steps_south                                             ; $00C6C6 | | times.
    JSR _draw_giant_of_babil_attacking                                          ; $00C6C9 | |
    JSR _disable_color_subtraction                                              ; $00C6CC | |
    PLX                                                                         ; $00C6CF | |
    DEX                                                                         ; $00C6D0 | |
    BNE -                                                                       ; $00C6D1 |/
    JMP _decode_event_opcode_done                                               ; $00C6D3

; _fill_palettes_10_11_white ($00:C6D6)
;
; Fills the first eight colors of palettes 10 and 11 with white.
_fill_palettes_10_11_white:
    LDX #0.w                                                                    ; $00C6D6 |\
-   LDA #$FF.b                                                                  ; $00C6D9 | | Rewrite the first eight colors of palettes 10 and 11 to be all
    STA r_cgram_data.11.w,X                                                     ; $00C6DB | | white.
    STA r_cgram_data.12.w,X                                                     ; $00C6DE | |
    INX                                                                         ; $00C6E1 | |
    CPX #_sizeof_palette.w / 2                                                  ; $00C6E2 | |
    BNE -                                                                       ; $00C6E5 |/
    RTS                                                                         ; $00C6E7

; _draw_giant_of_babil_attacking ($00:C6E8)
;
; Animates the Giant of Bab-il attacking with a series of circular explosions
; centered around the center of the screen.
_draw_giant_of_babil_attacking:
    LDA #1.b                                                                    ; $00C6E8 |\ Tell the explosion code to draw a circular explosion effect.
    STA <r_draw_explosion_arg_circular                                          ; $00C6EA |/
    LDX #GIANT_POSE_OFFSET_ATTACKING.w                                          ; $00C6EC | Set the Giant pose to attacking.
    LDA #96.b                                                                   ; $00C6EF |\
    STA <r_generic_arg_x_lo                                                     ; $00C6F1 | | Set the coordinates to 96, 80.
    LDA #80.b                                                                   ; $00C6F3 | |
    STA <r_generic_arg_y_lo                                                     ; $00C6F5 |/
    JSR _draw_giant_of_babil                                                    ; $00C6F7 | Draw the Giant of Bab-il at those coordinates.
    LDA #%11001111.b                                                            ; $00C6FA |\ Enable a color subtraction to make the background red.
    JSR _enable_color_subtraction                                               ; $00C6FC |/
    JSR _fill_palettes_10_11_white                                              ; $00C6FF | Set the Giant palettes to both be white.
    LDX #32.w                                                                   ; $00C702 |\ Wait for 32 frames.
    JSR _wait_for_x_frames                                                      ; $00C705 |/
    JSR _load_giant_of_babil_palette                                            ; $00C708 | Load the default Giant of Bab-il palettes.
    LDA #16.b                                                                   ; $00C70B |\
    STA r_draw_explosion_arg_count.w                                            ; $00C70D | | Initialize the explosion code to draw four simultaneous sprites
    LDX #36.w                                                                   ; $00C710 | | using the fire palette with center coordinates of 112, 112.
    STX r_draw_explosion_arg_cycles.w                                           ; $00C713 | |
    STZ r_draw_explosion_arg_palette.w                                          ; $00C716 | |
    STZ r_draw_explosion_arg_smoke.w                                            ; $00C719 | |
    LDA #112.b                                                                  ; $00C71C | |
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00C71E | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00C721 | |
    JSR _init_explosion                                                         ; $00C724 |/
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00C727 |\ Play the Crush/long explosion sound effect.
    JSR _play_sound_effect                                                      ; $00C729 |/
    LDA #1.b                                                                    ; $00C72C |\ Enable the shaking effect.
    STA <r_shaking                                                              ; $00C72E |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C730 | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00C733 | Initialize the OAM.
    JSR _init_oam_hi_32_large                                                   ; $00C736 | Set the first 32 OAM entries to be large sprites.
    JSR _draw_explosion                                                         ; $00C739 | Draw the explosions for this frame.
    LDX #GIANT_POSE_OFFSET_ATTACKING.w                                          ; $00C73C |\
    LDA #96.b                                                                   ; $00C73F | | Draw the attacking Giant pose to 96, 80.
    STA <r_generic_arg_x_lo                                                     ; $00C741 | |
    LDA #80.b                                                                   ; $00C743 | |
    STA <r_generic_arg_y_lo                                                     ; $00C745 | |
    JSR _draw_giant_of_babil                                                    ; $00C747 |/
    JSL bank15.draw_field_sprite_big_whale                                      ; $00C74A | Draw the Big Whale sprite.
    LDX r_draw_explosion_arg_cycles.w                                           ; $00C74E |\
    CPX #4.w                                                                    ; $00C751 | | If the explosion cycle counter is equal to 4, set the flag to
    BNE +                                                                       ; $00C754 | | suppress the creation of new explosions.
    LDA #1.b                                                                    ; $00C756 | |
    STA <r_draw_explosion_arg_suppress_new                                      ; $00C758 |/
+   CPX #0.w                                                                    ; $00C75A |\ Loop until the explosion cycle counter reaches zero.
    BNE -                                                                       ; $00C75D |/
    STZ <r_shaking                                                              ; $00C75F | Disable the shaking effect.
    JSR _load_giant_of_babil_palette                                            ; $00C761 | Load the Giant of Bab-il palette.
    STZ <r_draw_explosion_arg_circular                                          ; $00C764 | Reset the circular explosion flag.
    RTS                                                                         ; $00C766

; circular_explosion_coordinate_data ($00:C767)
;
; Data to calculate coordinates for the circular explosion effect. The
; coordinates should be added to the desired center coordinate. This is
; effectively a sin/cos table in 22.5 degree increments with a radius of 60.
circular_explosion_coordinate_data:
    .db   0, -60                                                                ; $00C767
    .db  23, -55                                                                ; $00C769
    .db  42, -42                                                                ; $00C76B
    .db  55, -23                                                                ; $00C76D
    .db  60,   0                                                                ; $00C76F
    .db  55,  23                                                                ; $00C771
    .db  42,  42                                                                ; $00C773
    .db  23,  55                                                                ; $00C775
    .db   0,  60                                                                ; $00C777
    .db -23,  55                                                                ; $00C779
    .db -42,  42                                                                ; $00C77B
    .db -55,  23                                                                ; $00C77D
    .db -60,   0                                                                ; $00C77F
    .db -55, -23                                                                ; $00C781
    .db -42, -42                                                                ; $00C783
    .db -23, -55                                                                ; $00C785

; _giant_take_two_steps_south ($00:C787)
;
; Animates the Giant of Bab-il taking two steps to the south.
_giant_take_two_steps_south:
    STZ <r_giant_of_babil_tmp_counter                                           ; $00C787 | Initialize the counter to zero.
    STZ <r_giant_of_babil_tmp_accumulator                                       ; $00C789 | Initialize the phase value to zero.
    STZ <r_map_frame_counter                                                    ; $00C78B | Initialize the map frame counter to zero.
@loop_start:
    JSR _wait_for_nmi_complete_field                                            ; $00C78D | Wait for the next complete NMI.
    LDA <r_giant_of_babil_tmp_counter                                           ; $00C790 |\ If the counter value is currently zero, skip this next block.
    BEQ +                                                                       ; $00C792 |/
    DEC <r_giant_of_babil_tmp_counter                                           ; $00C794 |\
    LDA <r_giant_of_babil_tmp_counter                                           ; $00C796 | | Otherwise, decrement the counter, and skip the next block if its
    AND #%00000001.b                                                            ; $00C798 | | value mod 2 is 0.
    BEQ +                                                                       ; $00C79A |/
    LDA <r_giant_of_babil_tmp_counter                                           ; $00C79C |\
    LSR A                                                                       ; $00C79E | | Divide the counter by two, and add that value to the base vertical
    STA <r_giant_of_babil_tmp_scroll                                            ; $00C79F | | scroll value to determine the current vertical scroll value.
    LDA <r_scroll_bg1_vertical_lo                                               ; $00C7A1 | |
    CLC                                                                         ; $00C7A3 | | The result is that when this is activated (by the counter being
    ADC <r_giant_of_babil_tmp_scroll                                            ; $00C7A4 | | set to a non-zero value), the vertical scroll alternates between
    STA reg_ppu_bg1v0fs.w                                                       ; $00C7A6 | | the base value and the (shrinking) modified value each frame,
    LDA <r_scroll_bg1_vertical_hi                                               ; $00C7A9 | | causing a rapidly dampening shaking effect.
    ADC #0.b                                                                    ; $00C7AB | |
    STA reg_ppu_bg1v0fs.w                                                       ; $00C7AD |/
+   LDA <r_map_frame_counter                                                    ; $00C7B0 |\
    AND #%01111111.b                                                            ; $00C7B2 | | If the map frame counter mod 128 is zero, increment the phase
    BNE +                                                                       ; $00C7B4 | | variable. If the new value is 3, branch to done.
    INC <r_giant_of_babil_tmp_accumulator                                       ; $00C7B6 | |
    LDA <r_giant_of_babil_tmp_accumulator                                       ; $00C7B8 | |
    CMP #3.b                                                                    ; $00C7BA | |
    BEQ @done                                                                   ; $00C7BC |/
    LDA #JOYPAD_H_DOWN.b                                                        ; $00C7BE |\
    STA <r_joypad_cutscene_hi                                                   ; $00C7C0 | | Otherwise, if the value mod 128 is zero, set the joypad buttons to
    STZ <r_joypad_cutscene_lo                                                   ; $00C7C2 | | press down on the d-pad.
    JMP ++                                                                      ; $00C7C4 |/
+   LDA <r_map_frame_counter                                                    ; $00C7C7 |\
    AND #%00001111.b                                                            ; $00C7C9 | | For other values of the map frame counter, if the map frame
    BNE ++                                                                      ; $00C7CB | | counter mod 16 is zero, reset the joypad buttons to nothing
    STZ <r_joypad_cutscene_hi                                                   ; $00C7CD | | pressed.
    STZ <r_joypad_cutscene_lo                                                   ; $00C7CF |/
++  JSR _init_oam                                                               ; $00C7D1 | Initialize the OAM.
    JSR _init_oam_hi_32_large                                                   ; $00C7D4 | Set the first 32 sprites to be large sprites.
    LDA #1.b                                                                    ; $00C7D7 |\ Enable player movement calculation.
    STA <r_player_movement_calculation_enabled                                  ; $00C7D9 |/
    JSR _calculate_outdoor_movement_direction                                   ; $00C7DB | Calculate the outdoor movement direction.
    JSR _do_outdoor_movement                                                    ; $00C7DE | Handle the movement.
    LDA <r_scroll_bg1_vertical_lo                                               ; $00C7E1 |\
    CLC                                                                         ; $00C7E3 | | If the base BG1 vertical scroll value low byte plus 15 has bit 4
    ADC #15.b                                                                   ; $00C7E4 | | set, use the second walking pose. Otherwise, use the first.
    AND #%00010000.b                                                            ; $00C7E6 | |
    BNE +                                                                       ; $00C7E8 | | This serves to alternate the direction of walking every step.
    LDX #GIANT_POSE_OFFSET_WALKING_1.w                                          ; $00C7EA | |
    JMP ++                                                                      ; $00C7ED | |
+   LDX #GIANT_POSE_OFFSET_WALKING_2.w                                          ; $00C7F0 |/
++  LDA #96.b                                                                   ; $00C7F3 |\
    STA <r_generic_arg_x                                                        ; $00C7F5 | | Draw the Giant to 96, 80.
    LDA #80.b                                                                   ; $00C7F7 | |
    STA <r_generic_arg_y                                                        ; $00C7F9 | |
    JSR _draw_giant_of_babil                                                    ; $00C7FB |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $00C7FE |\
    AND #%00001111.b                                                            ; $00C800 | | If the BG1 vertical scroll value mod 16 is equal to 15, play the
    CMP #15.b                                                                   ; $00C802 | | stepping sound effect.
    BNE +                                                                       ; $00C804 | |
    LDA #AUDIO_EFFECT_GIANT_STEP.b                                              ; $00C806 | |
    JSR _play_sound_effect                                                      ; $00C808 |/
+   JSL bank15.draw_field_sprite_big_whale                                      ; $00C80B | Draw the Big Whale sprite.
    LDA <r_map_frame_counter                                                    ; $00C80F |\
    AND #%01111111.b                                                            ; $00C811 | | If the map frame counter mod 128 is equal to zero, reset the
    BNE +                                                                       ; $00C813 | | counter to 32, to activate the vertical shaking effect.
    LDA #32.b                                                                   ; $00C815 | |
    STA <r_giant_of_babil_tmp_counter                                           ; $00C817 |/
+   JMP @loop_start                                                             ; $00C819 | Jump to the beginning of the loop.
@done:
    RTS                                                                         ; $00C81C

; _decode_event_opcode_custom_effect_giant_tanks_approach ($00:C81D)
;
; Custom effect for the Giant of Bab-il cutscene that animates the tanks
; approaching from the south.
_decode_event_opcode_custom_effect_giant_tanks_approach:
    LDX #48.w                                                                   ; $00C81D |\
    STX <r_calculate_tank_parameters_arg_coordinates.x                          ; $00C820 | | Set the tank base coordinates to 48, 224.
    LDX #224.w                                                                  ; $00C822 | |
    STX <r_calculate_tank_parameters_arg_coordinates.y                          ; $00C825 |/
    LDX #256.w                                                                  ; $00C827 |\
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00C82A | | Set the airship base coordinates to 256, -32.
    LDX #-32.w                                                                  ; $00C82C | |
    STX <r_draw_four_airships_arg_coordinates.y                                 ; $00C82F |/
    JSR _init_giant_targeted_explosion                                          ; $00C831 | Initialize the explosion on the Giant of Bab-il.
    LDX #320.w                                                                  ; $00C834 |\ Initialize the frame counter to 320.
    STX <r_generic_frame_counter                                                ; $00C837 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C839 | Wait for the next complete NMI.
    LDX <r_generic_frame_counter                                                ; $00C83C |\
    CPX #192.w                                                                  ; $00C83E | | If the frame counter value is 192, start playing the Red Wings
    BNE +                                                                       ; $00C841 | | music.
    LDA #AUDIO_TRACK_THE_RED_WINGS.b                                            ; $00C843 | |
    JSR _play_song                                                              ; $00C845 |/
+   JSR _init_oam                                                               ; $00C848 | Initialize the OAM.
    LDX <r_generic_frame_counter                                                ; $00C84B |\
    CPX #192.w                                                                  ; $00C84D | | If the frame counter value is 191 or less, decrement the tank base
    BCS +                                                                       ; $00C850 | | Y coordinates if the map frame counter mod 4 is zero.
    LDA <r_map_frame_counter                                                    ; $00C852 | |
    AND #%00000011.b                                                            ; $00C854 | |
    BNE ++                                                                      ; $00C856 | |
    DEC <r_calculate_tank_parameters_arg_coordinates.y                          ; $00C858 | |
    JMP ++                                                                      ; $00C85A |/
+   JSR _draw_explosion                                                         ; $00C85D |\
    LDX <r_generic_frame_counter                                                ; $00C860 | | Otherwise, draw the explosion for this frame, and if the frame
    CPX #312.w                                                                  ; $00C862 | | counter is 312, play the Crush/long explosion sound effect and set
    BNE ++                                                                      ; $00C865 | | the flag to suppress new explosions.
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00C867 | |
    JSR _play_sound_effect                                                      ; $00C869 | |
    LDA #1.b                                                                    ; $00C86C | |
    STA <r_draw_explosion_arg_suppress_new                                      ; $00C86E |/
++  JSR _draw_giant_of_babil_battle_sprites                                     ; $00C870 | Draw the various sprites.
    LDX <r_generic_frame_counter                                                ; $00C873 |\
    DEX                                                                         ; $00C875 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00C876 | |
    BNE -                                                                       ; $00C878 |/
    JMP _decode_event_opcode_done                                               ; $00C87A

; _draw_giant_of_babil_tanks ($00:C87D)
;
; Draws the Giant of Bab-il tanks in their correct locations, assuming the
; base coordinates have already been set in $EF.F0 and $F1.F2.
_draw_giant_of_babil_tanks:
    STZ <r_generic_tmp_counter                                                  ; $00C87D | Initialize a counter to zero.
-   LDA <r_generic_tmp_counter                                                  ; $00C87F |\
    CLC                                                                         ; $00C881 | | Calculate the tank parameters for this tank to draw the tanks
    ADC #4.b                                                                    ; $00C882 | | horizontally.
    ASL A                                                                       ; $00C884 | |
    TAY                                                                         ; $00C885 | |
    JSR _calculate_tank_parameters                                              ; $00C886 |/
    STZ <r_field_effect_sprite_arg_tile_offset                                  ; $00C889 |\ Draw the tanks pointing upward.
    JSR _draw_vehicle_sprite                                                    ; $00C88B |/
    INC <r_generic_tmp_counter                                                  ; $00C88E |\
    LDA <r_generic_tmp_counter                                                  ; $00C890 | | Increment the counter and loop until all four tanks are drawn.
    CMP #4.b                                                                    ; $00C892 | |
    BNE -                                                                       ; $00C894 |/
    RTS                                                                         ; $00C896

; _decode_event_opcode_custom_effect_giant_airships_approach ($00:C897)
;
; Custom effect for the Giant of Bab-il cutscene that animates the airships
; approaching from the east.
_decode_event_opcode_custom_effect_giant_airships_approach:
    LDX #48.w                                                                   ; $00C897 |\
    STX <r_calculate_tank_parameters_arg_coordinates.x                          ; $00C89A | | Set the base tank coordinates to 48, 176.
    LDX #176.w                                                                  ; $00C89C | |
    STX <r_calculate_tank_parameters_arg_coordinates.y                          ; $00C89F |/
    LDX #256.w                                                                  ; $00C8A1 |\
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00C8A4 | | Set the base airship coordinates to 256, -32.
    LDX #-32.w                                                                  ; $00C8A6 | |
    STX <r_draw_four_airships_arg_coordinates.y                                 ; $00C8A9 |/
    JSR _init_giant_targeted_explosion                                          ; $00C8AB | Initialize the explosion targeting the Giant.
    LDX #448.w                                                                  ; $00C8AE |\ Initialize the frame counter to 448.
    STX <r_generic_frame_counter                                                ; $00C8B1 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C8B3 | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00C8B6 | Initialize the OAM.
    LDX <r_generic_frame_counter                                                ; $00C8B9 |\
    CPX #320.w                                                                  ; $00C8BB | | If the frame counter is less than 320, decrement the airship base
    BCS +                                                                       ; $00C8BE | | X coordinates if the map frame counter mod 4 is zero.
    LDA <r_map_frame_counter                                                    ; $00C8C0 | |
    AND #%00000011.b                                                            ; $00C8C2 | |
    BNE ++                                                                      ; $00C8C4 | |
    LDX <r_draw_four_airships_arg_coordinates.x                                 ; $00C8C6 | |
    DEX                                                                         ; $00C8C8 | |
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00C8C9 | |
    JMP ++                                                                      ; $00C8CB |/
+   JSR _draw_explosion                                                         ; $00C8CE |\
    LDX <r_generic_frame_counter                                                ; $00C8D1 | | Otherwise, draw the explosion and if the frame counter is 440,
    CPX #440.w                                                                  ; $00C8D3 | | play the Crush/long explosion sound effect.
    BNE ++                                                                      ; $00C8D6 | |
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00C8D8 | |
    JSR _play_sound_effect                                                      ; $00C8DA |/
++  JSR _draw_giant_of_babil_battle_sprites                                     ; $00C8DD | Draw the various sprites.
    LDX <r_generic_frame_counter                                                ; $00C8E0 |\
    DEX                                                                         ; $00C8E2 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00C8E3 | |
    BNE -                                                                       ; $00C8E5 |/
    JMP _decode_event_opcode_done                                               ; $00C8E7

; _init_giant_targeted_explosion ($00:C8EA)
;
; Initializes a small explosion targeted at the Giant of Bab-il, rendered to
; 96, 96 on the screen.
_init_giant_targeted_explosion:
    JSR _load_giant_of_babil_palette                                            ; $00C8EA | Load the Giant of Bab-il palettes.
    LDA #8.b                                                                    ; $00C8ED |\ Configure for two simultaneous explosions.
    STA r_draw_explosion_arg_count.w                                            ; $00C8EF |/
    LDX #16.w                                                                   ; $00C8F2 |\ Set the explosion cycle counter to 16.
    STX r_draw_explosion_arg_cycles.w                                           ; $00C8F5 |/
    STZ r_draw_explosion_arg_palette.w                                          ; $00C8F8 |\ Set the explosion to use fire palettes.
    STZ r_draw_explosion_arg_smoke.w                                            ; $00C8FB |/
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00C8FE |\
    STA r_draw_explosion_arg_width.w                                            ; $00C900 | | Set the explosion size to small.
    STA r_draw_explosion_arg_height.w                                           ; $00C903 |/
    LDA #96.b                                                                   ; $00C906 |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00C908 | | Set the explosion coordinates to 96, 96.
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00C90B |/
    JSR _init_explosion                                                         ; $00C90E | Initialize the explosion.
    RTS                                                                         ; $00C911

; _decode_event_opcode_custom_effect_giant_explosions ($00:C912)
;
; Custom effect for the Giant of Bab-il battle that draws explosions happening
; over the Giant, tanks and airships.
_decode_event_opcode_custom_effect_giant_explosions:
    JSR _init_giant_tanks_airships_battle                                       ; $00C912 | Initialize the explosions and coordinates.
    LDX #512.w                                                                  ; $00C915 |\ Initialize the frame counter to 512.
    STX <r_generic_frame_counter                                                ; $00C918 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00C91A | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00C91D | Initialize the OAM.
    LDA <r_map_frame_counter                                                    ; $00C920 |\
    LSR A                                                                       ; $00C922 | | Set the Y register such that it cycles through 0-3 (multiplied by
    LSR A                                                                       ; $00C923 | | two) every 16 frames.
    LSR A                                                                       ; $00C924 | |
    AND #%00000110.b                                                            ; $00C925 | |
    TAY                                                                         ; $00C927 |/
    LDA giant_tanks_airships_battle_explosion_coordinates_data.w + 0,Y          ; $00C928 |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00C92B | | Set the explosion coordinates for this frame.
    LDA giant_tanks_airships_battle_explosion_coordinates_data.w + 1,Y          ; $00C92E | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00C931 |/
    LDA giant_tanks_airships_battle_explosion_size_data.w + 0,Y                 ; $00C934 |\
    STA r_draw_explosion_arg_width.w                                            ; $00C937 | | Set the explosion size for this frame.
    LDA giant_tanks_airships_battle_explosion_size_data.w + 1,Y                 ; $00C93A | |
    STA r_draw_explosion_arg_height.w                                           ; $00C93D |/
    JSR _draw_explosion                                                         ; $00C940 | Draw the explosion for this frame.
    JSR _draw_giant_of_babil_battle_sprites                                     ; $00C943 | Draw the various sprites.
    LDA <r_generic_frame_counter                                                ; $00C946 |\
    AND #%00111111.b                                                            ; $00C948 | | If the frame counter mod 64 is zero, play the Crush/long explosion
    BNE +                                                                       ; $00C94A | | sound.
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00C94C | |
    JSR _play_sound_effect                                                      ; $00C94E |/
+   LDX <r_generic_frame_counter                                                ; $00C951 |\
    DEX                                                                         ; $00C953 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00C954 | |
    BNE -                                                                       ; $00C956 |/
    JMP _decode_event_opcode_done                                               ; $00C958

; giant_tanks_airships_battle_explosion_coordinates_data ($00:C95B)
;
; For the Giant of Bab-il battle, determines the coordinates of the explosion
; at each step.
giant_tanks_airships_battle_explosion_coordinates_data:
    .db 112,  88                                                                ; $00C95B.C95C | $00: Giant
    .db 192,  64                                                                ; $00C95D.C95E | $01: Airships
    .db 112,  88                                                                ; $00C95F.C960 | $02: Giant
    .db  96, 176                                                                ; $00C961.C962 | $03: Tanks

; giant_tanks_airships_battle_explosion_size_data ($00:C963)
;
; For the Giant of Bab-il battle, determines the size of each explosion at each
; step.
giant_tanks_airships_battle_explosion_size_data:
    .db EXPLOSION_SIZE_SMALL, EXPLOSION_SIZE_SMALL                              ; $00C963.C964 | $00: Giant
    .db EXPLOSION_SIZE_SMALL, EXPLOSION_SIZE_LARGE                              ; $00C965.C966 | $01: Airships
    .db EXPLOSION_SIZE_SMALL, EXPLOSION_SIZE_SMALL                              ; $00C967.C968 | $02: Giant
    .db EXPLOSION_SIZE_LARGE, EXPLOSION_SIZE_SMALL                              ; $00C969.C96A | $03: Tanks

; _decode_event_opcode_custom_effect_giant_airship_land_whale ($00:C96B)
;
; Custom effect for the portion of the Giant of Bab-il cutscene where the
; airship lands next to the Big Whale.
_decode_event_opcode_custom_effect_giant_airship_land_whale:
    JSR _init_giant_tanks_airships_battle                                       ; $00C96B | Initialize the explosions and coordinates.
    LDX #0.w                                                                    ; $00C96E |\ Initialize the frame counter to zero.
    STX <r_generic_frame_counter                                                ; $00C971 |/
    STZ <r_map_frame_counter                                                    ; $00C973 | Initialize the map frame counter to zero.
-   JSR _giant_tanks_airships_battle_next_frame                                 ; $00C975 | Wait for the next frame and update the sprites.
    STZ <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00C978 | Set the vehicle X delta to zero.
    LDA <r_generic_frame_counter                                                ; $00C97A |\ Set the vehicle Y delta to the value of the frame counter.
    STA <r_vehicle_shadow_arg_vehicle_delta.y                                   ; $00C97C |/
    STA <r_vehicle_shadow_arg_shadow_delta.y                                    ; $00C97E | Set the shadow Y delta to the value of the frame counter.
    JSR _giant_update_vehicle_shadow_coordinates                                ; $00C980 | Update the vehicle and shadow coordinates.
    LDX <r_generic_frame_counter                                                ; $00C983 |\
    INX                                                                         ; $00C985 | | Loop until the frame counter reaches 32.
    STX <r_generic_frame_counter                                                ; $00C986 | |
    CPX #32.w                                                                   ; $00C988 | |
    BNE -                                                                       ; $00C98B |/
    LDX #0.w                                                                    ; $00C98D |\ Set the frame counter to zero.
    STX <r_generic_frame_counter                                                ; $00C990 |/
    STZ <r_map_frame_counter                                                    ; $00C992 | Initialize the map frame counter to zero.
-   JSR _giant_tanks_airships_battle_next_frame                                 ; $00C994 | Wait for the next NMI and draw the sprites.
    STZ <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00C997 | Set the vehicle and shadow X delta to zero.
    LDA <r_generic_frame_counter.lo                                             ; $00C999 |\
    LSR A                                                                       ; $00C99B | | Set the vehicle Y delta to 32 plus half the frame counter.
    CLC                                                                         ; $00C99C | |
    ADC #32.b                                                                   ; $00C99D | |
    STA <r_vehicle_shadow_arg_vehicle_delta.y                                   ; $00C99F |/
    LDA #32.b                                                                   ; $00C9A1 |\ Set the shadow Y delta to 32.
    STA <r_vehicle_shadow_arg_shadow_delta.y                                    ; $00C9A3 |/
    JSR _giant_update_vehicle_shadow_coordinates                                ; $00C9A5 | Update the vehicle and shadow coordinates.
    LDX <r_generic_frame_counter                                                ; $00C9A8 |\
    INX                                                                         ; $00C9AA | | Increment the frame counter and loop until it reaches 32.
    STX <r_generic_frame_counter                                                ; $00C9AB | |
    CPX #32.w                                                                   ; $00C9AD | |
    BNE -                                                                       ; $00C9B0 |/
    JMP _decode_event_opcode_done                                               ; $00C9B2

; _init_giant_tanks_airships_battle ($00:C9B5)
;
; Initializes the Giant of Bab-il battle versus the tanks and airships, by
; initializing the explosions, the Giant palette, and the coordinates of the
; tanks and airships.
_init_giant_tanks_airships_battle:
    LDA #16.b                                                                   ; $00C9B5 |\ Configure the explosion to use four simultaneous sprites.
    STA r_draw_explosion_arg_count.w                                            ; $00C9B7 |/
    LDX #16.w                                                                   ; $00C9BA |\ Set the explosion cycle counter to 16.
    STX r_draw_explosion_arg_cycles.w                                           ; $00C9BD |/
    STZ r_draw_explosion_arg_palette.w                                          ; $00C9C0 |\ Configure the explosion to use the fire palettes.
    STZ r_draw_explosion_arg_smoke.w                                            ; $00C9C3 |/
    JSR _init_explosion                                                         ; $00C9C6 | Initialize the explosion.
    JSR _load_giant_of_babil_palette                                            ; $00C9C9 | Load the Giant of Bab-il palette.
    LDX #48.w                                                                   ; $00C9CC |\
    STX <r_calculate_tank_parameters_arg_coordinates.x                          ; $00C9CF | | Set the base tank coordinates to 48, 176.
    LDX #176.w                                                                  ; $00C9D1 | |
    STX <r_calculate_tank_parameters_arg_coordinates.y                          ; $00C9D4 |/
    LDX #176.w                                                                  ; $00C9D6 |\
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00C9D9 | | Set the base airship coordinates to 176, -32.
    LDX #-32.w                                                                  ; $00C9DB | |
    STX <r_draw_four_airships_arg_coordinates.y                                 ; $00C9DE |/
    RTS                                                                         ; $00C9E0

; _giant_update_vehicle_shadow_coordinates ($00:C9E1)
;
; Updates the coordinates of the vehicle in OAM entries 44 through 47 and its
; shadow in entries 68 and 69 with the passed deltas. The X delta, applied to
; both the vehicle and shadow is passed in $28. The Y delta for the vehicle is
; passed in $29 and the Y delta for the shadow is passed in $2B.
;
; This is used in the Giant of Bab-il cutscene to manipulate the location of the
; lowest of the four airships, and is not really intended for general use.
_giant_update_vehicle_shadow_coordinates:
    LDY #0.w                                                                    ; $00C9E1 | Initialize the Y register to zero.
-   LDA r_oam.45.x.w,Y                                                          ; $00C9E4 |\
    CLC                                                                         ; $00C9E7 | | Set the vehicle X coordinate to its current value plus the passed
    ADC <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00C9E8 | | delta.
    STA r_oam.45.x.w,Y                                                          ; $00C9EA |/
    LDA r_oam.45.y.w,Y                                                          ; $00C9ED |\
    CLC                                                                         ; $00C9F0 | | Set the vehicle Y coordinate to its current value plus the passed
    ADC <r_vehicle_shadow_arg_vehicle_delta.y                                   ; $00C9F1 | | delta.
    STA r_oam.45.y.w,Y                                                          ; $00C9F3 |/
    LDA <r_map_frame_counter                                                    ; $00C9F6 |\
    AND #%00000001.b                                                            ; $00C9F8 | | If the map frame counter mod 2 is 1 or if this is the third or
    BNE +                                                                       ; $00C9FA | | fourth sprite, skip updating the shadow.
    CPY #8.w                                                                    ; $00C9FC | |
    BCS +                                                                       ; $00C9FF |/
    LDA r_oam.69.x.w,Y                                                          ; $00CA01 |\
    CLC                                                                         ; $00CA04 | | Set the shadow X coordinate to its current value plus the passed X
    ADC <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00CA05 | | delta (shared with vehicle).
    STA r_oam.69.x.w,Y                                                          ; $00CA07 |/
    LDA r_oam.69.y.w,Y                                                          ; $00CA0A |\
    CLC                                                                         ; $00CA0D | | Set the shadow Y coordinate to its current value plus the passed Y
    ADC <r_vehicle_shadow_arg_shadow_delta.y                                    ; $00CA0E | | delta (unique to the shadow).
    STA r_oam.69.y.w,Y                                                          ; $00CA10 |/
+   INY                                                                         ; $00CA13 |\
    INY                                                                         ; $00CA14 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $00CA15 | |
    INY                                                                         ; $00CA16 |/
    CPY #16.w                                                                   ; $00CA17 |\ Loop until all four vehicle sprites have been updated.
    BNE -                                                                       ; $00CA1A |/
    RTS                                                                         ; $00CA1C

; _decode_event_opcode_custom_effect_giant_airship_fly_left ($00:CA1D)
;
; Custom effect for the portion of the Giant of Bab-il cutscene where the
; airship takes off from near the Big Whale and flies left until vertically
; aligned with the Giant.
_decode_event_opcode_custom_effect_giant_airship_fly_left:
    JSR _init_giant_tanks_airships_battle                                       ; $00CA1D | Do basic initialization of coordinates and explosions.
    LDX #32.w                                                                   ; $00CA20 |\ Initialize the frame counter to 32.
    STX <r_generic_frame_counter                                                ; $00CA23 |/
    STZ <r_map_frame_counter                                                    ; $00CA25 | Initialize the map frame counter to zero.
-   JSR _giant_tanks_airships_battle_next_frame                                 ; $00CA27 | Wait for the NMI and draw the sprites.
    STZ <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00CA2A | Set the airship X delta to zero.
    LDA <r_generic_frame_counter                                                ; $00CA2C |\
    LSR A                                                                       ; $00CA2E | | Set the airship Y delta to 32 plus half the frame counter.
    CLC                                                                         ; $00CA2F | |
    ADC #32.b                                                                   ; $00CA30 | |
    STA <r_vehicle_shadow_arg_vehicle_delta.y                                   ; $00CA32 |/
    LDA #32.b                                                                   ; $00CA34 |\ Set the shadow Y delta to 32.
    STA <r_vehicle_shadow_arg_shadow_delta.y                                    ; $00CA36 |/
    JSR _giant_update_vehicle_shadow_coordinates                                ; $00CA38 | Update the coordinates of the fourth airship.
    LDX <r_generic_frame_counter                                                ; $00CA3B |\
    DEX                                                                         ; $00CA3D | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00CA3E | |
    BNE -                                                                       ; $00CA40 |/
    LDX #0.w                                                                    ; $00CA42 |\ Initialize the frame counter to zero.
    STX <r_generic_frame_counter                                                ; $00CA45 |/
    STZ <r_map_frame_counter                                                    ; $00CA47 | Initialize the map frame counter to zero.
-   JSR _giant_tanks_airships_battle_next_frame                                 ; $00CA49 | Wait for the next NMI and update the sprites.
    LDA #0.b                                                                    ; $00CA4C |\
    SEC                                                                         ; $00CA4E | | Set the X delta to zero minus the current frame counter.
    SBC <r_generic_frame_counter                                                ; $00CA4F | |
    STA <r_vehicle_shadow_arg_vehicle_delta.x                                   ; $00CA51 |/
    LDA #32.b                                                                   ; $00CA53 |\ Set the Y delta to 32.
    STA <r_vehicle_shadow_arg_vehicle_delta.y                                   ; $00CA55 |/
    STA <r_vehicle_shadow_arg_shadow_delta.y                                    ; $00CA57 | Set the shadow Y delta to 32.
    JSR _giant_update_vehicle_shadow_coordinates                                ; $00CA59 | Update the vehicle and shadow coordinates.
    LDX <r_generic_frame_counter                                                ; $00CA5C |\
    INX                                                                         ; $00CA5E | | Increment the frame counter and loop until it reaches 96.
    STX <r_generic_frame_counter                                                ; $00CA5F | |
    CPX #96.w                                                                   ; $00CA61 | |
    BNE -                                                                       ; $00CA64 |/
    JMP _decode_event_opcode_done                                               ; $00CA66

; _decode_event_opcode_custom_effect_giant_airship_to_giant ($00:CA69)
;
; Custom effect for the portion of the Giant of Bab-il scene that shows the
; airship flying directly toward the Giant.
_decode_event_opcode_custom_effect_giant_airship_to_giant:
    JSR _init_giant_tanks_airships_battle                                       ; $00CA69 | Initialize the explosions and coordinates.
    LDX #48.w                                                                   ; $00CA6C |\ Initialize the frame counter to 48.
    STX <r_generic_frame_counter                                                ; $00CA6F |/
    STZ <r_map_frame_counter                                                    ; $00CA71 | Initialize the map frame counter to zero.
-   JSR _wait_for_nmi_complete_field                                            ; $00CA73 | Wait for the next complete NMI.
    LDA <r_generic_frame_counter                                                ; $00CA76 |\
    CMP #16.b                                                                   ; $00CA78 | | If the frame counter is less than 16, also use it to set the PPU
    BCS +                                                                       ; $00CA7A | | brightness.
    STA reg_ppu_inidisp.w                                                       ; $00CA7C |/
+   JSR _init_oam                                                               ; $00CA7F | Initialize the OAM.
    JSR _draw_giant_of_babil_battle_sprites                                     ; $00CA82 | Draw the various sprites.
    LDA #104.b                                                                  ; $00CA85 |\ Set the X coordinate to 104.
    STA <r_generic_arg_x_lo                                                     ; $00CA87 |/
    LDA <r_generic_frame_counter                                                ; $00CA89 |\
    CLC                                                                         ; $00CA8B | | Set the Y coordinate to the frame counter plus 128.
    ADC #128.b                                                                  ; $00CA8C | |
    STA <r_generic_arg_y_lo                                                     ; $00CA8E |/
    LDA #%00011000.b                                                            ; $00CA90 |\ Set the tile flags for priority 1 and palette 4.
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00CA92 |/
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00CA94 |\ Set the tiles to draw the Enterprise.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00CA96 |/
    LDY #_sizeof_oam_sprite.w * 44                                              ; $00CA98 | Use OAM entries 44 through 47.
    LDA #TILE_OFFSET_VEHICLE_UP.b                                               ; $00CA9B |\ Configure to draw the Enterprise facing up.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00CA9D |/
    JSR _draw_vehicle_sprite                                                    ; $00CA9F | Draw the airship.
    LDA #240.b                                                                  ; $00CAA2 |\
    STA r_oam.69.y.w                                                            ; $00CAA4 | | Hide the shadow.
    STA r_oam.70.y.w                                                            ; $00CAA7 |/
    LDX <r_generic_frame_counter                                                ; $00CAAA |\
    DEX                                                                         ; $00CAAC | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00CAAD | |
    BNE -                                                                       ; $00CAAF |/
    STZ <r_ppu_brightness                                                       ; $00CAB1 | Set the PPU brightness variable to zero.
    STZ <r_suppress_field_sprite_shadows                                        ; $00CAB3 | Disable the suppression of field sprite shadows.
    JMP _decode_event_opcode_done                                               ; $00CAB5

; _draw_giant_of_babil_battle_sprites ($00:CAB8)
;
; Part of the Giant of Bab-il cutscene, handles drawing the various sprites on
; the screen.
_draw_giant_of_babil_battle_sprites:
    JSR _init_oam_hi_32_large                                                   ; $00CAB8 | Set the first 32 OAM entries to use large sprites.
    JSL bank15.draw_field_sprite_big_whale                                      ; $00CABB | Draw the Big Whale sprite.
    LDX #GIANT_POSE_OFFSET_WALKING_1.w                                          ; $00CABF |\
    LDA #96.b                                                                   ; $00CAC2 | | Draw the Giant in its first walking pose to 96, 80.
    STA <r_generic_arg_x_lo                                                     ; $00CAC4 | |
    LDA #80.b                                                                   ; $00CAC6 | |
    STA <r_generic_arg_y_lo                                                     ; $00CAC8 | |
    JSR _draw_giant_of_babil                                                    ; $00CACA |/
    JSR _draw_giant_of_babil_tanks                                              ; $00CACD | Draw the tanks.
    LDA #%00011000.b                                                            ; $00CAD0 |\
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00CAD2 | | Draw the four airships facing left.
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00CAD4 | |
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00CAD6 | |
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00CAD8 | |
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00CADA | |
    JSR _draw_four_airships                                                     ; $00CADC |/
    RTS                                                                         ; $00CADF

; _giant_tanks_airships_battle_next_frame ($00:CAE0)
;
; Waits for the next complete NMI and draws the various sprites involved in the
; Giant of Bab-il battle.
_giant_tanks_airships_battle_next_frame:
    JSR _wait_for_nmi_complete_field                                            ; $00CAE0 | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00CAE3 | Initialize the OAM.
    JSR _draw_giant_of_babil_battle_sprites                                     ; $00CAE6 | Draw the various sprites.
    RTS                                                                         ; $00CAE9

; _load_giant_of_babil_palette ($00:CAEA)
;
; Loads the Giant of Bab-il palette data to sprite palette 2, as well as an
; all-white palette to sprite palette 3.
_load_giant_of_babil_palette:
    LDX #0.w                                                                    ; $00CAEA |\
-   LDA bank0D.giant_of_babil_palette_data.l,X                                  ; $00CAED | | Load the Giant of Bab-il palette to sprite palette index 2 and the
    STA r_cgram_data.11.w,X                                                     ; $00CAF1 | | white palette to sprite palette index 3.
    LDA bank0D.white_palette_data.l,X                                           ; $00CAF4 | |
    STA r_cgram_data.12.w,X                                                     ; $00CAF8 | |
    INX                                                                         ; $00CAFB | |
    CPX #_sizeof_palette.w / 2                                                  ; $00CAFC | |
    BNE -                                                                       ; $00CAFF |/
    RTS                                                                         ; $00CB01

; _draw_giant_of_babil ($00:CB02)
;
; Given an 8-bit base X coordinate in $0C, an 8-bit base Y coordinate in $0E,
; and an offset in the X register (where the offset is the desired pose times
; $18), draws the Giant of Bab-il to OAM entries 16 through 21.
_draw_giant_of_babil:
    LDY #0.w                                                                    ; $00CB02 | Initialize the Y register to zero.
-   LDA bank14.giant_of_babil_oam_data.l + oam_sprite.x,X                       ; $00CB05 |\
    CLC                                                                         ; $00CB09 | | Set the X coordinate by adding the tile offset to the base
    ADC <r_generic_arg_x_lo                                                     ; $00CB0A | | coordinate.
    STA r_oam.17.x.w,Y                                                          ; $00CB0C |/
    LDA bank14.giant_of_babil_oam_data.l + oam_sprite.y,X                       ; $00CB0F |\
    CLC                                                                         ; $00CB13 | | Set the Y coordinate by adding the tile offset to the base
    ADC <r_generic_arg_y_lo                                                     ; $00CB14 | | coordinate.
    STA r_oam.17.y.w,Y                                                          ; $00CB16 |/
    LDA bank14.giant_of_babil_oam_data.l + oam_sprite.tile,X                    ; $00CB19 |\ Set the tile number directly from ROM.
    STA r_oam.17.tile.w,Y                                                       ; $00CB1D |/
    LDA bank14.giant_of_babil_oam_data.l + oam_sprite.flags,X                   ; $00CB20 |\ Set the flags directly from ROM.
    STA r_oam.17.flags.w,Y                                                      ; $00CB24 |/
    JSR _increment_indexes_by_four                                              ; $00CB27 | Increment the indexes appropriately.
    CPY #_sizeof_oam_sprite.w * 6                                               ; $00CB2A |\ Loop until all six sprites have been set.
    BNE -                                                                       ; $00CB2D |/
    RTS                                                                         ; $00CB2F

; _decode_event_opcode_custom_effect_giant_explosion ($00:CB30)
;
; Custom effect for the Giant of Bab-il exploding.
_decode_event_opcode_custom_effect_giant_explosion:
    JSR _init_giant_tanks_airships_battle                                       ; $00CB30 | Initialize the explosions and coordinates.
    LDA #MAP_EFFECTS_FADE_IN_PENDING.b                                          ; $00CB33 |\ Tell the NMI handler to fade in the PPU.
    STA <r_change_map_area_arg_modify_effects                                   ; $00CB35 |/
    LDX #384.w                                                                  ; $00CB37 |\ Initialize the frame counter to 384.
    STX <r_generic_frame_counter                                                ; $00CB3A |/
-   JSR _wait_for_nmi_complete_field                                            ; $00CB3C | Wait for the next complete NMI.
    LDX <r_generic_frame_counter                                                ; $00CB3F |\
    CPX #16.w                                                                   ; $00CB41 | | If the frame counter is less than 16, use it to also set the PPU
    BCS +                                                                       ; $00CB44 | | brightness.
    TXA                                                                         ; $00CB46 | |
    STA reg_ppu_inidisp.w                                                       ; $00CB47 |/
+   JSR _init_oam                                                               ; $00CB4A | Initialize the OAM.
    LDA #112.b                                                                  ; $00CB4D |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00CB4F | | Draw a very small explosion at 112, 88.
    LDA #88.b                                                                   ; $00CB52 | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00CB54 | |
    LDA #EXPLOSION_SIZE_SMALLEST.b                                              ; $00CB57 | |
    STA r_draw_explosion_arg_width.w                                            ; $00CB59 | |
    STA r_draw_explosion_arg_height.w                                           ; $00CB5C | |
    JSR _draw_explosion                                                         ; $00CB5F |/
    JSR _draw_giant_of_babil_battle_sprites                                     ; $00CB62 | Draw the various sprites.
    LDA <r_generic_frame_counter                                                ; $00CB65 |\
    AND #%00111111.b                                                            ; $00CB67 | | If the frame counter mod 64 is zero, play the Crush/long explosion
    BNE +                                                                       ; $00CB69 | | sound effect.
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00CB6B | |
    JSR _play_sound_effect                                                      ; $00CB6D |/
+   LDX <r_generic_frame_counter                                                ; $00CB70 |\
    DEX                                                                         ; $00CB72 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00CB73 | |
    BNE -                                                                       ; $00CB75 |/
    STZ <r_ppu_brightness                                                       ; $00CB77 | Set the PPU brightness variable to zero.
    JMP _decode_event_opcode_done                                               ; $00CB79

; _decode_event_opcode_custom_effect_big_whale_whirlpool_intro ($00:CB7C)
;
; This custom effect is the first part of the Big Whale whirlpool effect. This
; routine simply animates the whirlpool for 384 frames.
_decode_event_opcode_custom_effect_big_whale_whirlpool_intro:
    JSR _initialize_big_whale_whirlpool                                         ; $00CB7C | Initialize the Big Whale whirlpool effect.
-   JSR _big_whale_whirlpool_next_frame                                         ; $00CB7F | Wait for the next frame and do various updates.
    LDA <r_map_frame_counter                                                    ; $00CB82 |\
    AND #%00000111.b                                                            ; $00CB84 | | If the map frame counter mod 8 isn't zero, do nothing.
    BNE -                                                                       ; $00CB86 |/
    INC <r_field_effect_counter                                                 ; $00CB88 |\
    LDA <r_field_effect_counter                                                 ; $00CB8A | | Increment the field effect counter and loop until it reaches 48.
    CMP #48.b                                                                   ; $00CB8C | |
    BNE -                                                                       ; $00CB8E |/
    JMP _decode_event_opcode_done                                               ; $00CB90

; _decode_event_opcode_custom_effect_big_whale_whirlpool_descent ($00:CB93)
;
; This custom effect animates the descent of the Big Whale back into the ocean
; at the end of the game.
_decode_event_opcode_custom_effect_big_whale_whirlpool_descent:
    JSR _initialize_big_whale_whirlpool                                         ; $00CB93 | Initialize the Big Whale whirlpool effect.
    LDA #1.b                                                                    ; $00CB96 |\ Set the flag to suppress field sprite shadows.
    STA r_suppress_field_sprite_shadows.w                                       ; $00CB98 |/
@loop_start:
    JSR _big_whale_whirlpool_next_frame                                         ; $00CB9B | Wait for the next frame.
    LDA #36.b                                                                   ; $00CB9E |\
    SEC                                                                         ; $00CBA0 | | Set the Big Whale altitude to 36 minus the value of the frame
    SBC <r_field_effect_counter                                                 ; $00CBA1 | | counter.
    STA <r_big_whale_altitude                                                   ; $00CBA3 |/
    JSL bank15.draw_field_sprite_big_whale                                      ; $00CBA5 | Draw the Big Whale field sprite.
    JSR _big_whale_cycle_palette                                                ; $00CBA9 | Cycle the Big Whale palette.
    LDA <r_field_effect_counter                                                 ; $00CBAC |\
    CMP #36.b                                                                   ; $00CBAE | | Skip the next block until the counter reaches 36.
    BCC +                                                                       ; $00CBB0 |/
    LDA #104.b                                                                  ; $00CBB2 |\ Set the X coordinate for the first splash sprite to 104.
    STA r_oam.1.x.w                                                             ; $00CBB4 |/
    LDA #120.b                                                                  ; $00CBB7 |\ Set the X coordinate for the second splash sprite to 120.
    STA r_oam.2.x.w                                                             ; $00CBB9 |/
    STA r_oam.1.y.w                                                             ; $00CBBC |\ Set the Y coordinate for both splash sprites to 120.
    STA r_oam.2.y.w                                                             ; $00CBBF |/
    LDA <r_map_frame_counter                                                    ; $00CBC2 |\
    LSR A                                                                       ; $00CBC4 | | Set the tile numbers for the two sprites such that they are always
    LSR A                                                                       ; $00CBC5 | | different from each other and such that they alternate every
    AND #%00000010.b                                                            ; $00CBC6 | | eight frames.
    CLC                                                                         ; $00CBC8 | |
    ADC #<TILE_BASE_SPLASH                                                      ; $00CBC9 | |
    STA r_oam.1.tile.w                                                          ; $00CBCB | |
    EOR #%00000010.b                                                            ; $00CBCE | |
    STA r_oam.2.tile.w                                                          ; $00CBD0 |/
    LDA #%00110111.b                                                            ; $00CBD3 |\
    STA r_oam.1.flags.w                                                         ; $00CBD5 | | Set the flags for priority 3, palette 3 and high name table.
    STA r_oam.2.flags.w                                                         ; $00CBD8 |/
+   LDA <r_map_frame_counter                                                    ; $00CBDB |\
    AND #%00000111.b                                                            ; $00CBDD | | Loop if the frame counter mod 8 is not zero.
    BNE @loop_start                                                             ; $00CBDF |/
    INC <r_field_effect_counter                                                 ; $00CBE1 |\
    LDA <r_field_effect_counter                                                 ; $00CBE3 | | Increment the field effect counter and loop until it reaches 72.
    CMP #72.b                                                                   ; $00CBE5 | |
    BNE @loop_start                                                             ; $00CBE7 |/
    STZ <r_suppress_field_sprite_shadows                                        ; $00CBE9 | Disable the suppression of field sprite shadows.
    JMP _decode_event_opcode_done                                               ; $00CBEB

; _decode_event_opcode_custom_effect_big_whale_whirlpool_raising ($00:CBEE)
;
; Custom effect for the second phase of the raising of the Big Whale, where the
; Big Whale rises out of the ocean.
_decode_event_opcode_custom_effect_big_whale_whirlpool_raising:
    LDA #1.b                                                                    ; $00CBEE |\ Disable the drawing of field sprite shadows.
    STA r_suppress_field_sprite_shadows.w                                       ; $00CBF0 |/
    JSR _initialize_big_whale_whirlpool                                         ; $00CBF3 | Initialize the Big Whale whirlpool effect.
-   JSR _big_whale_whirlpool_next_frame                                         ; $00CBF6 | Wait for the next frame and do some updates.
    JSR _big_whale_whirlpool_draw_splash                                        ; $00CBF9 | Draw the splash sprites.
    LDA <r_map_frame_counter                                                    ; $00CBFC |\
    AND #%00000111.b                                                            ; $00CBFE | | If the map frame counter mod 8 is zero, increment the effect
    BNE -                                                                       ; $00CC00 | | counter.
    INC <r_field_effect_counter                                                 ; $00CC02 | |
    LDA <r_field_effect_counter                                                 ; $00CC04 | | Loop until the effect counter reaches 50.
    CMP #50.b                                                                   ; $00CC06 | |
    BNE -                                                                       ; $00CC08 |/
    STZ <r_field_effect_counter                                                 ; $00CC0A | Reset the field effect counter to zero.
-   JSR _big_whale_whirlpool_next_frame                                         ; $00CC0C | Wait for the next frame and do some updates.
    LDA <r_field_effect_counter                                                 ; $00CC0F |\
    CMP #72.b                                                                   ; $00CC11 | | If the effect counter is less than 72, set the Big Whale altitude
    BCS +                                                                       ; $00CC13 | | to the effect counter minus 36.
    CLC                                                                         ; $00CC15 | |
    ADC #-36.b                                                                  ; $00CC16 | |
    STA <r_big_whale_altitude                                                   ; $00CC18 |/
+   JSL bank15.draw_field_sprite_big_whale                                      ; $00CC1A | Draw the Big Whale sprite.
    JSR _big_whale_cycle_palette                                                ; $00CC1E | Cycle the Big Whale palette.
    LDA <r_field_effect_counter                                                 ; $00CC21 |\
    CMP #36.b                                                                   ; $00CC23 | | If the field effect counter is less than 36, draw the splash
    BCS +                                                                       ; $00CC25 | | sprites.
    JSR _big_whale_whirlpool_draw_splash                                        ; $00CC27 |/
+   LDA <r_map_frame_counter                                                    ; $00CC2A |\
    AND #%00000111.b                                                            ; $00CC2C | | If the map frame counter mod 8 is zero, increment the field
    BNE -                                                                       ; $00CC2E | | effect counter. Loop until the counter reaches 100.
    INC <r_field_effect_counter                                                 ; $00CC30 | |
    LDA <r_field_effect_counter                                                 ; $00CC32 | |
    CMP #100.b                                                                  ; $00CC34 | |
    BNE -                                                                       ; $00CC36 |/
    STZ <r_suppress_field_sprite_shadows                                        ; $00CC38 | Disable the suppression of field sprite shadows.
    JMP _decode_event_opcode_done                                               ; $00CC3A

; _big_whale_whirlpool_draw_splash ($00:CC3D)
;
; For the Big Whale whirlpool effect, draws the two splash sprites to the OAM in
; entries 0 and 1.
_big_whale_whirlpool_draw_splash:
    LDA #104.b                                                                  ; $00CC3D |\
    STA r_oam.1.x.w                                                             ; $00CC3F | | Set the X coordinates for the two splash sprites to 104 and 120.
    LDA #120.b                                                                  ; $00CC42 | |
    STA r_oam.2.x.w                                                             ; $00CC44 |/
    STA r_oam.1.y.w                                                             ; $00CC47 |\ Set the Y coordinates for the two splash sprites to 120.
    STA r_oam.2.y.w                                                             ; $00CC4A |/
    LDA <r_map_frame_counter                                                    ; $00CC4D |\
    LSR A                                                                       ; $00CC4F | | Set the tile numbers for the two sprites so that they always use
    LSR A                                                                       ; $00CC50 | | the opposite splash sprites of each other and so that they
    AND #%00000010.b                                                            ; $00CC51 | | alternate every eight frames.
    CLC                                                                         ; $00CC53 | |
    ADC #<TILE_BASE_SPLASH                                                      ; $00CC54 | |
    STA r_oam.1.tile.w                                                          ; $00CC56 | |
    EOR #%00000010.b                                                            ; $00CC59 | |
    STA r_oam.2.tile.w                                                          ; $00CC5B |/
    LDA #%00110111.b                                                            ; $00CC5E |\
    STA r_oam.1.flags.w                                                         ; $00CC60 | | Set the flags for priority 3, palette 3 and the high name table.
    STA r_oam.2.flags.w                                                         ; $00CC63 |/
    RTS                                                                         ; $00CC66

; _big_whale_cycle_palette ($00:CC67)
;
; Part of the Big Whale whirlpool effect routines, this routine cycles the Big
; Whale palette to cause a strobing effect.
;
; BUG: This routine very possibly suffers from a bug. The palette data it's
;      reading from is only eight colors, but the code acts as if it's reading
;      16 colors, so it ends up reading the next routine and interpreting its
;      code as additional colors. To fix this, both the initial masking of the
;      map frame counter and the later masking of the Y register need to be
;      adjusted.
_big_whale_cycle_palette:
    LDA <r_map_frame_counter                                                    ; $00CC67 |\
    AND #%00011110.b                                                            ; $00CC69 | | Set the Y register to range from 0 to 15, multiplied by two,
    TAY                                                                         ; $00CC6B | | depending on the value of the frame counter.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00CC6C |/
    LDX #0.w                                                                    ; $00CC6E | Initialize the X register to zero.
-   LDA big_whale_strobe_palette_data.w,Y                                       ; $00CC71 |\ Copy the next color to the palette.
    STA r_cgram_data.16.w,X                                                     ; $00CC74 |/
    TYA                                                                         ; $00CC77 |\
    INC A                                                                       ; $00CC78 | | Increment the source offset by two and take the result mod 32.
    INC A                                                                       ; $00CC79 | |
    AND #%00011111.w                                                            ; $00CC7A | |
    TAY                                                                         ; $00CC7D |/
    INX                                                                         ; $00CC7E |\
    INX                                                                         ; $00CC7F | | Increment the X register twice and loop until 8 colors have been
    CPX #16.w                                                                   ; $00CC80 | | copied.
    BNE -                                                                       ; $00CC83 |/
    LDA #0.w                                                                    ; $00CC85 |\ Reset the accumulator for 8-bit mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00CC88 |/
    RTS                                                                         ; $00CC8A

; big_whale_strobe_palette_data ($00:CC8B)
;
; Eight colors used for strobing the Big Whale while it rises from the sea.
big_whale_strobe_palette_data:
    COLOR  8,  8, 24                                                            ; $00CC8B.CC8C
    COLOR 16,  0, 16                                                            ; $00CC8D.CC8E
    COLOR 24,  8,  8                                                            ; $00CC8F.CC90
    COLOR 31, 16,  0                                                            ; $00CC91.CC92
    COLOR 24, 24,  8                                                            ; $00CC93.CC94
    COLOR 16, 31, 16                                                            ; $00CC95.CC96
    COLOR  8, 24, 24                                                            ; $00CC97.CC98
    COLOR  0, 16, 31                                                            ; $00CC99.CC9A

; _decode_event_opcode_custom_effect_big_whale_whirlpool_finish ($00:CC9B)
;
; The last segment of the custom effects that show the Big Whale rising out of
; the sea.
_decode_event_opcode_custom_effect_big_whale_whirlpool_finish:
    JSR _initialize_big_whale_whirlpool                                         ; $00CC9B | Initialize the Big Whale whirlpool effect.
    LDA #1.b                                                                    ; $00CC9E |\ Set the flag to suppress the drawing of field sprite shadows.
    STA r_suppress_field_sprite_shadows.w                                       ; $00CCA0 |/
    LDX #0.w                                                                    ; $00CCA3 |\
-   LDA r_cgram_data.16.w,X                                                     ; $00CCA6 | | Back up the current eight colors in the Big Whale palette.
    STA r_big_whale_tmp_palette.w,X                                             ; $00CCA9 | |
    INX                                                                         ; $00CCAC | |
    CPX #_sizeof_palette.w / 2                                                  ; $00CCAD | |
    BNE -                                                                       ; $00CCB0 |/
    STZ <r_big_whale_tmp_counter                                                ; $00CCB2 | Initialize a counter to zero.
@loop_start:
    JSR _big_whale_whirlpool_next_frame                                         ; $00CCB4 | Wait for the next frame and do some updates.
    LDA #32.b                                                                   ; $00CCB7 |\ Set the Big Whale altitude to normal flight level.
    STA <r_big_whale_altitude                                                   ; $00CCB9 |/
    JSL bank15.draw_field_sprite_big_whale                                      ; $00CCBB | Draw the Big Whale sprite.
    LDA <r_map_frame_counter                                                    ; $00CCBF |\
    LSR A                                                                       ; $00CCC1 | | If the map frame counter mod 2 is 1, increment the counter.
    BCC +                                                                       ; $00CCC2 | |
    INC <r_big_whale_tmp_counter                                                ; $00CCC4 |/
+   LDA <r_big_whale_tmp_counter                                                ; $00CCC6 |\ If the counter is 128 or greater, branch to separate code.
    BMI +                                                                       ; $00CCC8 |/
    ASL A                                                                       ; $00CCCA |\
    STA <r_big_whale_tmp_value                                                  ; $00CCCB | | Multiply the counter by two and add it to a running counter. If
    LDA <r_field_effect_counter.lo                                              ; $00CCCD | | the result wraps around back to zero, skip ahead to the next
    CLC                                                                         ; $00CCCF | | section. Otherwise, cycle the palette and jump ahead. The result
    ADC <r_big_whale_tmp_value                                                  ; $00CCD0 | | is the strobing palette effect on fewer and fewer frames as the
    STA <r_field_effect_counter.lo                                              ; $00CCD2 | | effect progresses.
    BCS +                                                                       ; $00CCD4 | |
    JSR _big_whale_cycle_palette                                                ; $00CCD6 | |
    JMP ++                                                                      ; $00CCD9 |/
+   AND #%11110001.b                                                            ; $00CCDC |\
    CMP #128.b                                                                  ; $00CCDE | | If using the regular Big Whale palette this frame, and if the
    BNE +                                                                       ; $00CCE0 | | calculated sum, except bits 1, 2 and 3 is equal to 128, enable the
    LDA #1.b                                                                    ; $00CCE2 | | flash palette for this frame.
    STA <r_enable_flash_palette                                                 ; $00CCE4 |/
+   LDX #0.w                                                                    ; $00CCE6 |\
-   LDA r_big_whale_tmp_palette.w,X                                             ; $00CCE9 | | If using the Big Whale palette this frame, copy the Big Whale
    STA r_cgram_data.16.w,X                                                     ; $00CCEC | | palette back into CG-RAM.
    INX                                                                         ; $00CCEF | |
    CPX #16.w                                                                   ; $00CCF0 | |
    BNE -                                                                       ; $00CCF3 |/
++  LDA <r_big_whale_tmp_counter                                                ; $00CCF5 |\
    CMP #255.b                                                                  ; $00CCF7 | | Loop until the counter reaches 255.
    BNE @loop_start                                                             ; $00CCF9 |/
    STZ <r_suppress_field_sprite_shadows                                        ; $00CCFB | Re-enable the field sprite shadows.
    LDA #1.b                                                                    ; $00CCFD |\ Enable the Big Whale.
    STA r_big_whale_status.w                                                    ; $00CCFF |/
    STZ r_big_whale_plane.w                                                     ; $00CD02 | Set the Big Whale on the overworld.
    STZ <r_big_whale_altitude                                                   ; $00CD05 | Set the Big Whale altitude to zero.
    LDX #(150 + (199 << 8)).w                                                   ; $00CD07 |\ Set the Big Whale coordinates to 150, 199 (a few tiles west of
    STX r_big_whale_coordinates.w                                               ; $00CD0A |/ Mysidia).
    JMP _decode_event_opcode_done                                               ; $00CD0D

; _initialize_big_whale_whirlpool ($00:CD10)
;
; Initalizes the Big Whale whirlpool effect by changing the vehicle, setting the
; coordinates, loading the whirlpool palettes, and resetting several counters.
_initialize_big_whale_whirlpool:
    LDA #VEHICLE_BIG_WHALE.b                                                    ; $00CD10 |\ Set the vehicle to the Big Whale.
    STA r_vehicle.w                                                             ; $00CD12 |/
    LDA #DIRECTION_LEFT.b                                                       ; $00CD15 |\ Set the direction to left.
    STA r_direction.w                                                           ; $00CD17 |/
    LDA #88.b                                                                   ; $00CD1A |\
    STA <r_generic_arg_coordinates.x                                            ; $00CD1C | | Set the whirlpool coordinates to 88, 96.
    LDA #96.b                                                                   ; $00CD1E | |
    STA <r_generic_arg_coordinates.y                                            ; $00CD20 |/
    JSR _load_whirlpool_leviatan_palettes                                       ; $00CD22 | Load the whirlpool and Leviatan palettes.
    STZ <r_generic_tmp_counter                                                  ; $00CD25 |\
    STZ <r_map_frame_counter                                                    ; $00CD27 | | Initialize several frame counters to zero.
    STZ <r_field_effect_counter                                                 ; $00CD29 |/
    RTS                                                                         ; $00CD2B

; _big_whale_whirlpool_next_frame ($00:CD2C)
;
; This routine, part of the Big Whale whirlpool effects, handles several of the
; things that must be done every frame. It waits for the next NMI, handles the
; tile animations, initializes the OAM, draws the whirlpool sprite and cycles
; the whirlpool palette.
_big_whale_whirlpool_next_frame:
    JSR _do_tile_animations                                                     ; $00CD2C
    JSR _init_oam                                                               ; $00CD2F
    JSR _init_oam_hi_32_large                                                   ; $00CD32
    JSR _draw_whirlpool_sprite                                                  ; $00CD35
    JSR _whirlpool_cycle_palette                                                ; $00CD38
    RTS                                                                         ; $00CD3B

; _decode_event_opcode_custom_effect_undo_map_history ($00:CD3C)
;
; Removes one entry from the map history. Does not actually change to that map.
; Used to remove an entry from the history that shouldn't be there.
_decode_event_opcode_custom_effect_undo_map_history:
    LDX r_map_history_index.w                                                   ; $00CD3C |\
    DEX                                                                         ; $00CD3F | | Decrement the map history index by 3.
    DEX                                                                         ; $00CD40 | |
    DEX                                                                         ; $00CD41 | |
    STX r_map_history_index.w                                                   ; $00CD42 |/
    JMP _decode_event_opcode_done                                               ; $00CD45

; _decode_event_opcode_custom_effect_move_enterprise_to_baron ($00:CD48)
;
; This custom effect moves the Enterprise to a location outside of Baron.
_decode_event_opcode_custom_effect_move_enterprise_to_baron:
    STZ r_enterprise_plane.w                                                    ; $00CD48 |\
    STZ <r_enterprise_altitude                                                  ; $00CD4B | | Move the Enterprise to the overworld at 102, 158.
    LDX #(102 + (158 << 8)).w                                                   ; $00CD4D | |
    STX r_enterprise_coordinates.w                                              ; $00CD50 |/
    LDA #1.b                                                                    ; $00CD53 |\ Enable the enterprise.
    STA r_enterprise_status.w                                                   ; $00CD55 |/
    JMP _decode_event_opcode_done                                               ; $00CD58

; _decode_event_opcode_custom_effect_move_enterprise_to_dwarf_castle ($00:CD5B)
;
; This custom effect moves the Enterprise to a location outside the Castle of
; Dwarves.
_decode_event_opcode_custom_effect_move_enterprise_to_dwarf_castle:
    LDA #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $00CD5B |\ Set the Enterprise plane to the underworld.
    STA r_enterprise_plane.w                                                    ; $00CD5D |/
    STA r_enterprise_status.w                                                   ; $00CD60 | Set the Enterprise to active.
    STZ <r_enterprise_altitude                                                  ; $00CD63 | Set the Enterprise altitude to zero.
    LDX #(102 + (82 << 8)).w                                                    ; $00CD65
    STX r_enterprise_coordinates.w                                              ; $00CD68
    JMP _decode_event_opcode_done                                               ; $00CD6B

; _decode_event_opcode_custom_effect_baron_antechamber_shrink_1 ($00:CD6E)
;
; This custom effect hides BG1 and sets the scroll registers to show the portion
; of the Baron antechamber map that has shrunk one tile on each side from the
; original version.
_decode_event_opcode_custom_effect_baron_antechamber_shrink_1:
    LDA #%00010110.b                                                            ; $00CD6E |\ Set BG2, BG3 and sprites as the main screen.
    STA reg_ppu_tm.w                                                            ; $00CD70 |/
    LDA #1.b                                                                    ; $00CD73 |\ Disable the automatic update of the background scroll registers.
    STA <r_disable_background_scroll_updates                                    ; $00CD75 |/
    LDX #0.w                                                                    ; $00CD77 |\ Set the BG2 horizontal scroll to zero.
    STX <r_scroll_bg2_horizontal                                                ; $00CD7A |/
    LDX #(512 + 224).w                                                          ; $00CD7C |\
    STX <r_scroll_bg2_vertical                                                  ; $00CD7F | | Set the BG1 vertical scroll to 720.
    JSR _set_bg2_vertical_scroll_value_minus_16                                 ; $00CD81 |/
    JMP _decode_event_opcode_done                                               ; $00CD84

; _decode_event_opcode_custom_effect_baron_antechamber_shrink_2 ($00:CD87)
;
; Custom effect for the second step of the Baron antechamber shrinking on the
; party.
_decode_event_opcode_custom_effect_baron_antechamber_shrink_2:
    LDX #256.w                                                                  ; $00CD87 |\
    STX <r_scroll_bg2_horizontal                                                ; $00CD8A | | Set the vertical and horizontal scroll values to switch to the
    LDX #(512 + 224).w                                                          ; $00CD8C | | version of the map on the lower right.
    STX <r_scroll_bg2_vertical                                                  ; $00CD8F | |
    JSR _set_bg2_vertical_scroll_value_minus_16                                 ; $00CD91 |/
    JMP _decode_event_opcode_done                                               ; $00CD94

; _decode_event_opcode_custom_effect_baron_antechamber_shrink_3 ($00:CD97)
;
; Custom effect for the third step of the Baron antechamber shrinking on the
; party.
_decode_event_opcode_custom_effect_baron_antechamber_shrink_3:
    LDX #256.w                                                                  ; $00CD97 |\
    STX <r_scroll_bg2_horizontal                                                ; $00CD9A | | Set the vertical and horizontal scroll values to switch to the
    LDX #(256 + 224).w                                                          ; $00CD9C | | version of the map on the upper right.
    STX <r_scroll_bg2_vertical                                                  ; $00CD9F | |
    JSR _set_bg2_vertical_scroll_value_minus_16                                 ; $00CDA1 |/
    JMP _decode_event_opcode_done                                               ; $00CDA4

; _set_bg2_vertical_scroll_value_minus_16 ($00:CDA7)
;
; Sets the BG2 vertical scroll register to the configured 16-bit value in $0660
; minus 16, which effectively moves it down one 16x16 row.
_set_bg2_vertical_scroll_value_minus_16:
    JSR _wait_for_nmi_complete                                                  ; $00CDA7 | Wait for the next complete NMI.
    LDA <r_scroll_bg2_vertical_lo                                               ; $00CDAA |\
    SEC                                                                         ; $00CDAC | | Set the BG2 vertical scroll register to the configured value minus
    SBC #16.b                                                                   ; $00CDAD | | 16.
    STA reg_ppu_bg2v0fs.w                                                       ; $00CDAF | |
    LDA <r_scroll_bg2_vertical_hi                                               ; $00CDB2 | |
    SBC #0.b                                                                    ; $00CDB4 | |
    STA reg_ppu_bg2v0fs.w                                                       ; $00CDB6 |/
    RTS                                                                         ; $00CDB9

; _decode_event_opcode_custom_effect_leviatan_swallows_ship ($00:CDBA)
;
; Handles the custom effect that depicts the ship being swallowed by Leviatan.
_decode_event_opcode_custom_effect_leviatan_swallows_ship:
    JSR _init_whirlpool_leviatan                                                ; $00CDBA | Initialize the whirlpool and Leviatan effect.
    LDA #%10000001.b                                                            ; $00CDBD |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00CDBF |/
    LDA #$0F.b                                                                  ; $00CDC2 |\ Set the PPU brightness to maximum.
    STA reg_ppu_inidisp.w                                                       ; $00CDC4 |/
    STZ <r_movement_speed                                                       ; $00CDC7 | Set the movement speed to zero.
    STZ <r_generic_tmp_counter                                                  ; $00CDC9 | Initialize a counter to zero.
    STZ <r_leviatan_tmp_counter                                                 ; $00CDCB | Initialize the Leviatan counter to zero.
    STZ <r_map_frame_counter                                                    ; $00CDCD | Initialize the map frame counter to zero.
@loop_start:
    LDA <r_map_frame_counter                                                    ; $00CDCF |\
    LSR A                                                                       ; $00CDD1 | | Set the direction to change every eight frames.
    LSR A                                                                       ; $00CDD2 | |
    LSR A                                                                       ; $00CDD3 | |
    AND #%00000011.b                                                            ; $00CDD4 | |
    STA r_direction.w                                                           ; $00CDD6 |/
    JSR _whirlpool_wait_for_next_frame                                          ; $00CDD9 | Wait for the next frame, update tile animations and cycle palettes.
    LDA <r_map_frame_counter                                                    ; $00CDDC |\
    AND #%00000001.b                                                            ; $00CDDE | | Set the movement direction to either left or none, depending on
    BNE +                                                                       ; $00CDE0 | | the value of the frame counter.
    LDA #MOVEMENT_DIRECTION_LEFT.b                                              ; $00CDE2 | |
    JMP ++                                                                      ; $00CDE4 | |
+   LDA #MOVEMENT_DIRECTION_NONE.b                                              ; $00CDE7 | |
++  STA <r_movement_direction                                                   ; $00CDE9 |/
    JSR _do_outdoor_movement                                                    ; $00CDEB | Handle outdoor movement.
    JSR _draw_whirlpool_sprite                                                  ; $00CDEE | Update the location of the whirlpool sprite.
    LDA <r_event_base_coordinate.x                                              ; $00CDF1 |\
    STA r_oam.17.x.w                                                            ; $00CDF3 | | Set the X coordinates of the splash and Leviatan sprites to move
    STA r_oam.1.x.w                                                             ; $00CDF6 | | along with the whirlpool sprites.
    CLC                                                                         ; $00CDF9 | |
    ADC #16.b                                                                   ; $00CDFA | |
    STA r_oam.18.x.w                                                            ; $00CDFC | |
    STA r_oam.2.x.w                                                             ; $00CDFF | |
    CLC                                                                         ; $00CE02 | |
    ADC #16.b                                                                   ; $00CE03 | |
    STA r_oam.19.x.w                                                            ; $00CE05 | |
    STA r_oam.3.x.w                                                             ; $00CE08 | |
    CLC                                                                         ; $00CE0B | |
    ADC #16.b                                                                   ; $00CE0C | |
    STA r_oam.20.x.w                                                            ; $00CE0E | |
    STA r_oam.4.x.w                                                             ; $00CE11 |/
    LDA #104.b                                                                  ; $00CE14 |\
    CLC                                                                         ; $00CE16 | | Set the Leviatan sprites Y coordinates to 104 plus the current
    ADC <r_leviatan_tmp_counter                                                 ; $00CE17 | | Leviatan counter or 120, whichever is less.
    CMP #120.b                                                                  ; $00CE19 | |
    BCC +                                                                       ; $00CE1B | |
    LDA #120.b                                                                  ; $00CE1D | |
+   STA r_oam.17.y.w                                                            ; $00CE1F | |
    STA r_oam.18.y.w                                                            ; $00CE22 | |
    STA r_oam.19.y.w                                                            ; $00CE25 | |
    STA r_oam.20.y.w                                                            ; $00CE28 |/
    LDA #<TILE_BASE_LEVIATAN                                                    ; $00CE2B |\
    STA r_oam.17.tile.w                                                         ; $00CE2D | | Set the tile numbers for the Leviatan sprites.
    LDA #<TILE_BASE_LEVIATAN + 2                                                ; $00CE30 | |
    STA r_oam.18.tile.w                                                         ; $00CE32 | |
    LDA #<TILE_BASE_LEVIATAN + 4                                                ; $00CE35 | |
    STA r_oam.19.tile.w                                                         ; $00CE37 | |
    LDA #<TILE_BASE_LEVIATAN + 6                                                ; $00CE3A | |
    STA r_oam.20.tile.w                                                         ; $00CE3C |/
    LDA #%00110111.b                                                            ; $00CE3F |\
    STA r_oam.17.flags.w                                                        ; $00CE41 | | Set the tile flags for the Leviatan and splash sprites to use the
    STA r_oam.1.flags.w                                                         ; $00CE44 | | high name table using palette 3 and priority 3.
    STA r_oam.18.flags.w                                                        ; $00CE47 | |
    STA r_oam.2.flags.w                                                         ; $00CE4A | |
    STA r_oam.19.flags.w                                                        ; $00CE4D | |
    STA r_oam.3.flags.w                                                         ; $00CE50 | |
    STA r_oam.20.flags.w                                                        ; $00CE53 | |
    STA r_oam.4.flags.w                                                         ; $00CE56 |/
    LDA #112.b                                                                  ; $00CE59 |\
    STA r_oam.1.y.w                                                             ; $00CE5B | | Set the Y coordinate for the splash sprites to 112.
    STA r_oam.2.y.w                                                             ; $00CE5E | |
    STA r_oam.3.y.w                                                             ; $00CE61 | |
    STA r_oam.4.y.w                                                             ; $00CE64 |/
    LDA <r_map_frame_counter                                                    ; $00CE67 |\
    LSR A                                                                       ; $00CE69 | | Set the tile numbers for the four splash sprites to alternate
    LSR A                                                                       ; $00CE6A | | between $34 and $36 moving left to right, and also to alternate
    AND #%00000010.b                                                            ; $00CE6B | | every eight frames.
    CLC                                                                         ; $00CE6D | |
    ADC #<TILE_BASE_SPLASH                                                      ; $00CE6E | |
    STA r_oam.1.tile.w                                                          ; $00CE70 | |
    EOR #%00000010.b                                                            ; $00CE73 | |
    STA r_oam.2.tile.w                                                          ; $00CE75 | |
    EOR #%00000010.b                                                            ; $00CE78 | |
    STA r_oam.3.tile.w                                                          ; $00CE7A | |
    EOR #%00000010.b                                                            ; $00CE7D | |
    STA r_oam.4.tile.w                                                          ; $00CE7F |/
    LDA <r_map_frame_counter                                                    ; $00CE82 |\
    AND #%00000111.b                                                            ; $00CE84 | | Increment the Leviatan counter every 8 frames.
    BNE +                                                                       ; $00CE86 | |
    INC <r_leviatan_tmp_counter                                                 ; $00CE88 |/
+   LDA <r_map_frame_counter                                                    ; $00CE8A |\
    AND #%00000011.b                                                            ; $00CE8C | | Increment the base X coordinate of the whirlpool effect every four
    BNE +                                                                       ; $00CE8E | | frames.
    INC <r_event_base_coordinate.x                                              ; $00CE90 |/
+   LDA <r_leviatan_tmp_counter                                                 ; $00CE92 |\
    CMP #32.b                                                                   ; $00CE94 | | Loop until the Leviatan counter reaches 32.
    BEQ +                                                                       ; $00CE96 | |
    JMP @loop_start                                                             ; $00CE98 |/
+   STZ r_ship_status.w                                                         ; $00CE9B | Disable the ship.
    JMP _decode_event_opcode_done                                               ; $00CE9E

; _decode_event_opcode_custom_effect_leviatan_rises ($00:CEA1)
;
; Custom effect that depicts Leviatan rising out of the ocean on the left side
; of the screen.
_decode_event_opcode_custom_effect_leviatan_rises:
    JSR _init_whirlpool_leviatan                                                ; $00CEA1 | Initialize the whirlpool and Leviatan effect.
    LDA #%10000001.b                                                            ; $00CEA4 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00CEA6 |/
    LDA #%00001111.b                                                            ; $00CEA9 |\ Set the PPU to maximum brightness.
    STA reg_ppu_inidisp.w                                                       ; $00CEAB |/
    STZ <r_generic_tmp_counter                                                  ; $00CEAE | Initialize a counter used by the next frame routine to zero.
    STZ <r_leviatan_tmp_counter                                                 ; $00CEB0 | Initialize another counter to zero.
@loop_start:
    LDA #DIRECTION_LEFT.b                                                       ; $00CEB2 |\ Set the current facing direction to left.
    STA r_direction.w                                                           ; $00CEB4 |/
    JSR _whirlpool_wait_for_next_frame                                          ; $00CEB7 | Wait for the next frame and do various updates.
    LDA #16.b                                                                   ; $00CEBA |\
    STA r_oam.17.x.w                                                            ; $00CEBC | | Set the X coordinates for the four OAM entries for the Leviatan
    STA r_oam.1.x.w                                                             ; $00CEBF | | and splash sprites each.
    LDA #32.b                                                                   ; $00CEC2 | |
    STA r_oam.18.x.w                                                            ; $00CEC4 | |
    STA r_oam.2.x.w                                                             ; $00CEC7 | |
    LDA #48.b                                                                   ; $00CECA | |
    STA r_oam.19.x.w                                                            ; $00CECC | |
    STA r_oam.3.x.w                                                             ; $00CECF | |
    LDA #64.b                                                                   ; $00CED2 | |
    STA r_oam.20.x.w                                                            ; $00CED4 | |
    STA r_oam.4.x.w                                                             ; $00CED7 |/
    LDA #120.b                                                                  ; $00CEDA |\
    SEC                                                                         ; $00CEDC | | Set the Y coordinate for four Leviatan sprites to 120 minus the
    SBC <r_leviatan_tmp_counter                                                 ; $00CEDD | | value of the Leviatan counter or 104, whichever is greater.
    CMP #104.b                                                                  ; $00CEDF | |
    BCS +                                                                       ; $00CEE1 | |
    LDA #104.b                                                                  ; $00CEE3 | |
+   STA r_oam.17.y.w                                                            ; $00CEE5 | |
    STA r_oam.18.y.w                                                            ; $00CEE8 | |
    STA r_oam.19.y.w                                                            ; $00CEEB | |
    STA r_oam.20.y.w                                                            ; $00CEEE |/
    LDA #<TILE_BASE_LEVIATAN                                                    ; $00CEF1 |\
    STA r_oam.17.tile.w                                                         ; $00CEF3 | | Set the tile numbers for the four Leviatan sprites.
    LDA #<TILE_BASE_LEVIATAN + 2                                                ; $00CEF6 | |
    STA r_oam.18.tile.w                                                         ; $00CEF8 | |
    LDA #<TILE_BASE_LEVIATAN + 4                                                ; $00CEFB | |
    STA r_oam.19.tile.w                                                         ; $00CEFD | |
    LDA #<TILE_BASE_LEVIATAN + 6                                                ; $00CF00 | |
    STA r_oam.20.tile.w                                                         ; $00CF02 |/
    LDA #%00110111.b                                                            ; $00CF05 |\
    STA r_oam.17.flags.w                                                        ; $00CF07 | | Set the flags for each of the sprites to the high name table using
    STA r_oam.1.flags.w                                                         ; $00CF0A | | palette 3 with priority 3.
    STA r_oam.18.flags.w                                                        ; $00CF0D | |
    STA r_oam.2.flags.w                                                         ; $00CF10 | |
    STA r_oam.19.flags.w                                                        ; $00CF13 | |
    STA r_oam.3.flags.w                                                         ; $00CF16 | |
    STA r_oam.20.flags.w                                                        ; $00CF19 | |
    STA r_oam.4.flags.w                                                         ; $00CF1C |/
    LDA #112.b                                                                  ; $00CF1F |\
    STA r_oam.1.y.w                                                             ; $00CF21 | | Set the Y coordinate for the splash sprites to 112.
    STA r_oam.2.y.w                                                             ; $00CF24 | |
    STA r_oam.3.y.w                                                             ; $00CF27 | |
    STA r_oam.4.y.w                                                             ; $00CF2A |/
    LDA <r_map_frame_counter                                                    ; $00CF2D |\
    LSR A                                                                       ; $00CF2F | | Set the tile numbers for the splash sprites such that they
    LSR A                                                                       ; $00CF30 | | alternate between $E4 and $E6, both spatially, in that they
    AND #%00000010.b                                                            ; $00CF31 | | alternate back and forth from left and to right and temporally,
    CLC                                                                         ; $00CF33 | | in that they switch every eight frames.
    ADC #<TILE_BASE_SPLASH                                                      ; $00CF34 | |
    STA r_oam.1.tile.w                                                          ; $00CF36 | |
    EOR #%00000010.b                                                            ; $00CF39 | |
    STA r_oam.2.tile.w                                                          ; $00CF3B | |
    EOR #%00000010.b                                                            ; $00CF3E | |
    STA r_oam.3.tile.w                                                          ; $00CF40 | |
    EOR #%00000010.b                                                            ; $00CF43 | |
    STA r_oam.4.tile.w                                                          ; $00CF45 |/
    LDA <r_map_frame_counter                                                    ; $00CF48 |\
    AND #%00001111.b                                                            ; $00CF4A | | Every 16 frames, increment the counter.
    BNE +                                                                       ; $00CF4C | |
    INC <r_leviatan_tmp_counter                                                 ; $00CF4E |/
+   LDA <r_leviatan_tmp_counter                                                 ; $00CF50 |\
    CMP #32.b                                                                   ; $00CF52 | | Loop until the counter reaches 32.
    BEQ +                                                                       ; $00CF54 | |
    JMP @loop_start                                                             ; $00CF56 |/
+   JMP _decode_event_opcode_done                                               ; $00CF59

; _decode_event_opcode_custom_effect_leviatan_tail ($00:CF5C)
;
; Implements the custom effect that shows Leviatan's tail rising out of the
; water on the left side of the screen.
_decode_event_opcode_custom_effect_leviatan_tail:
    JSR _init_whirlpool_leviatan                                                ; $00CF5C | Initialize the whirlpool and Leviatan effect.
    LDA #%10000001.b                                                            ; $00CF5F |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00CF61 |/
    LDA #%00001111.b                                                            ; $00CF64 |\ Set PPU brightness to maximum.
    STA reg_ppu_inidisp.w                                                       ; $00CF66 |/
    LDX #512.w                                                                  ; $00CF69 |\ Initialize the overall frame counter to 512, which determines the
    STX <r_generic_frame_counter                                                ; $00CF6C |/ effect length.
    STZ <r_generic_tmp_counter                                                  ; $00CF6E | Initialize a counter (used by the frame wait routine) to zero.
-   LDA #DIRECTION_LEFT.b                                                       ; $00CF70 |\ Set the facing direction to left.
    STA r_direction.w                                                           ; $00CF72 |/
    JSR _whirlpool_wait_for_next_frame                                          ; $00CF75 | Wait for the next frame, update tile animations and cycle palettes.
    LDA #40.b                                                                   ; $00CF78 |\
    STA r_oam.17.x.w                                                            ; $00CF7A | | Set the X coordinate for the splash and Leviatan sprites to 40.
    STA r_oam.1.x.w                                                             ; $00CF7D |/
    LDA <r_map_frame_counter                                                    ; $00CF80 |\
    LSR A                                                                       ; $00CF82 | | Set the Leviatan sprite Y coordinate such that it changes every
    LSR A                                                                       ; $00CF83 | | sixteen frames.
    LSR A                                                                       ; $00CF84 | |
    LSR A                                                                       ; $00CF85 | |
    TAX                                                                         ; $00CF86 | |
    LDA leviatan_tail_sprite_y_coordinate_data.w,X                              ; $00CF87 | |
    STA r_oam.17.y.w                                                            ; $00CF8A |/
    LDA #<TILE_BASE_LEVIATAN                                                    ; $00CF8D |\ Set the Leviatan tile number.
    STA r_oam.17.tile.w                                                         ; $00CF8F |/
    TXA                                                                         ; $00CF92 |\
    AND #%00000100.b                                                            ; $00CF93 | | Set the Leviatan sprite flags to set the high name table, palette
    ASL A                                                                       ; $00CF95 | | 3, priority 3 and to toggle a horizontal flip every 64 frames.
    ASL A                                                                       ; $00CF96 | |
    ASL A                                                                       ; $00CF97 | |
    ASL A                                                                       ; $00CF98 | |
    ORA #%00110111.b                                                            ; $00CF99 | |
    STA r_oam.17.flags.w                                                        ; $00CF9B |/
    LDA #112.b                                                                  ; $00CF9E |\ Set the Y coordinate of the splash sprite to 112.
    STA r_oam.1.y.w                                                             ; $00CFA0 |/
    LDA <r_map_frame_counter                                                    ; $00CFA3 |\
    LSR A                                                                       ; $00CFA5 | | Set the splash tile number to either $E4 or E6, alternating every
    LSR A                                                                       ; $00CFA6 | | eight frames.
    AND #%00000010.b                                                            ; $00CFA7 | |
    CLC                                                                         ; $00CFA9 | |
    ADC #<TILE_BASE_SPLASH                                                      ; $00CFAA | |
    STA r_oam.1.tile.w                                                          ; $00CFAC |/
    LDA #%00110111.b                                                            ; $00CFAF |\ Set the splash tile flags for high name table, palette 3 and
    STA r_oam.1.flags.w                                                         ; $00CFB1 |/ priority 3.
    LDX <r_generic_frame_counter                                                ; $00CFB4 |\
    DEX                                                                         ; $00CFB6 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00CFB7 | |
    BNE -                                                                       ; $00CFB9 |/
    JMP _decode_event_opcode_done                                               ; $00CFBB

; leviatan_tail_sprite_y_coordinate_data ($00:CFBE)
;
; For each frame of the Leviatan animation, determines the Y coordinate of the
; Leviatan tail sprite.
leviatan_tail_sprite_y_coordinate_data:
    .db 116                                                                     ; $00CFBE
    .db 115                                                                     ; $00CFBF
    .db 113                                                                     ; $00CFC0
    .db 111                                                                     ; $00CFC1
    .db 108                                                                     ; $00CFC2
    .db 106                                                                     ; $00CFC3
    .db 105                                                                     ; $00CFC4
    .db 104                                                                     ; $00CFC5
    .db 104                                                                     ; $00CFC6
    .db 105                                                                     ; $00CFC7
    .db 106                                                                     ; $00CFC8
    .db 108                                                                     ; $00CFC9
    .db 111                                                                     ; $00CFCA
    .db 113                                                                     ; $00CFCB
    .db 115                                                                     ; $00CFCC
    .db 116                                                                     ; $00CFCD

; _whirlpool_wait_for_next_frame ($00:CFCE)
;
; During the whirlpool animation, waits for the next frame and performs several
; tasks that need to be done each frame, including the tile animations, drawing
; the outdoor field sprites and cycling the whirlpool palette.
_whirlpool_wait_for_next_frame:
    JSR _do_tile_animations                                                     ; $00CFCE | Wait for the next NMI and do any tile animations.
    JSR _draw_outdoor_field_sprites                                             ; $00CFD1 | Draw the outdoor field sprites.
    JSR _init_oam_hi_32_large                                                   ; $00CFD4 | Set the first 32 sprites to large size.
    JSR _whirlpool_cycle_palette                                                ; $00CFD7 | Cycle the whirlpool palette.
    RTS                                                                         ; $00CFDA

; _init_whirlpool_leviatan ($00:CFDB)
;
; Initializes the whirlpool and Leviatan effect by loading the palettes and
; drawing the initial whirlpool to the OAM.
_init_whirlpool_leviatan:
    LDX #168.w + (144 << 8)                                                     ; $00CFDB |\ Set the current coordinates to 168, 144.
    STX r_current_coordinates.w                                                 ; $00CFDE |/
    LDA #16.b                                                                   ; $00CFE1 |\
    STA <r_event_base_coordinate.x.lo                                           ; $00CFE3 | | Set the base coordinates for the whirlpool effect to 16, 88.
    LDA #88.b                                                                   ; $00CFE5 | |
    STA <r_event_base_coordinate.y.lo                                           ; $00CFE7 |/
    JSL bank15.init_ppu                                                         ; $00CFE9 | Initialize the PPU.
    STZ r_map_area.w                                                            ; $00CFED | Set the map area to the overworld.
    LDA #VEHICLE_SHIP.b                                                         ; $00CFF0 |\ Set the current vehicle to the ship.
    STA r_vehicle.w                                                             ; $00CFF2 |/
    LDA #1.b                                                                    ; $00CFF5 |\ Enable the ship.
    STA r_ship_status.w                                                         ; $00CFF7 |/
    JSR _change_map_overworld                                                   ; $00CFFA | Change to the overworld map.
    LDA #16.b                                                                   ; $00CFFD |\ Set the zoom level to standard.
    STA <r_zoom_level                                                           ; $00CFFF |/
    JSR _load_whirlpool_leviatan_palettes                                       ; $00D001 | Load the whirlpool and Leviatan palettes.
    JSR _init_oam                                                               ; $00D004 | Initialize the OAM.
    JSR _draw_whirlpool_sprite                                                  ; $00D007 | Draw the whirlpool sprite to the OAM.
    RTS                                                                         ; $00D00A

; _load_whirlpool_leviatan_palettes ($00:D00B)
;
; Loads the two palettes used for the whirlpool and Leviatan sprites in the
; post-Fabul cut scene and copies them to the CG-RAM mirror in palettes 10 and
; 11.
_load_whirlpool_leviatan_palettes:
    LDX #0.w                                                                    ; $00D00B | Initialize the X register to zero.
-   LDA bank0D.whirlpool_palette_data.l,X                                       ; $00D00E |\ Copy the whirlpool palette byte to the 11th palette.
    STA r_cgram_data.11.w,X                                                     ; $00D012 |/
    STA r_whirlpool_tmp_palette.w,X                                             ; $00D015 | Also copy it to a temporary array.
    LDA bank0D.leviatan_palette_data.l,X                                        ; $00D018 |\ Copy the Leviatan palette to the 12th palette.
    STA r_cgram_data.12.w,X                                                     ; $00D01C |/
    INX                                                                         ; $00D01F |\
    CPX #_sizeof_palette.w / 2                                                  ; $00D020 | | Increment the X register and loop until the palette is copied.
    BNE -                                                                       ; $00D023 |/
    RTS                                                                         ; $00D025

; _draw_whirlpool_sprite ($00:D026)
;
; Given an 8-bit base X coordinate in $2C and an 8-bit base Y coordinate in $2E,
; draws the whirlpool sprite (a 4x4 grid of 16x16 tiles) to those coordinates
; by writing the relevant entries to the OAM. The OAM data is not copied to the
; PPU.
_draw_whirlpool_sprite:
    LDY #_sizeof_oam_sprite.w * 112                                             ; $00D026 | Initialize the Y register to point to OAM sprite 112.
    LDX #0.w                                                                    ; $00D029 | Initialize the X register to zero.
    STZ <r_generic_arg_x_lo                                                     ; $00D02C |\ Initialize the relative X and Y coordinates to zero.
    STZ <r_generic_arg_y_lo                                                     ; $00D02E |/
-   LDA <r_generic_arg_x_lo                                                     ; $00D030 |\
    CLC                                                                         ; $00D032 | | Set the X coordinate to the base X coordinate plus the relative X
    ADC <r_event_base_coordinate.x.lo                                           ; $00D033 | | coordinate.
    STA r_oam.1.x.w,Y                                                           ; $00D035 |/
    LDA <r_generic_arg_y_lo                                                     ; $00D038 |\
    CLC                                                                         ; $00D03A | | Set the Y coordinate to the base Y coordinate plus the relative Y
    ADC <r_event_base_coordinate.y.lo                                           ; $00D03B | | coordinate.
    STA r_oam.1.y.w,Y                                                           ; $00D03D |/
    LDA bank14.sprite_whirlpool_tile_flags_data.l + 0,X                         ; $00D040 |\
    STA r_oam.1.tile.w,Y                                                        ; $00D044 | | Set the tile and flags directly from ROM.
    LDA bank14.sprite_whirlpool_tile_flags_data.l + 1,X                         ; $00D047 | |
    STA r_oam.1.flags.w,Y                                                       ; $00D04B |/
    LDA <r_generic_arg_x_lo                                                     ; $00D04E |\
    CLC                                                                         ; $00D050 | | Add 16 to the relative X coordinate and wrap it around to zero
    ADC #16.b                                                                   ; $00D051 | | when it reaches 64.
    AND #%00111111.b                                                            ; $00D053 | |
    STA <r_generic_arg_x_lo                                                     ; $00D055 |/
    BNE +                                                                       ; $00D057 |\
    LDA <r_generic_arg_y_lo                                                     ; $00D059 | | If the relative X coordinate wrapped around, add 16 to the
    CLC                                                                         ; $00D05B | | relative Y coordinate.
    ADC #16.b                                                                   ; $00D05C | |
    STA <r_generic_arg_y_lo                                                     ; $00D05E |/
+   INX                                                                         ; $00D060 |\ Increment the X register by two to move to the next entry in ROM.
    INX                                                                         ; $00D061 |/
    INY                                                                         ; $00D062 |\
    INY                                                                         ; $00D063 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $00D064 | |
    INY                                                                         ; $00D065 |/
    CPX #(2 * 16).w                                                             ; $00D066 |\ If 16 tiles have been written, branch to the end.
    BEQ +                                                                       ; $00D069 |/
    CPX #16.w                                                                   ; $00D06B |\
    BNE -                                                                       ; $00D06E | | After writing the first 16 tiles, change the Y register to point
    LDY #_sizeof_oam_sprite.w * 4                                               ; $00D070 | | to OAM entry 4 for the bottom half.
    JMP -                                                                       ; $00D073 |/
+   JSR _init_oam_hi_32_large                                                   ; $00D076 |\
    LDA #%10101010.b                                                            ; $00D079 | | Set the first 32 sprites as well as sprites 112 through 119 to
    STA r_oam_hi.w + (112 / 4)                                                  ; $00D07B | | 16x16.
    STA r_oam_hi.w + (116 / 4)                                                  ; $00D07E |/
    RTS                                                                         ; $00D081

; _whirlpool_cycle_palette ($00:D082)
;
; Cycles the whirlpool palette. An index is used to determine which color from
; indexes 1 through 6 should be used as the base color, and seven colors are
; copied starting from that index, looping back to zero when reaching the end.
_whirlpool_cycle_palette:
    LDA <r_map_frame_counter                                                    ; $00D082 |\
    AND #%00000011.b                                                            ; $00D084 | | Skip this function unless the map frame counter mod 4 is zero.
    BNE ++                                                                      ; $00D086 |/
    INC <r_generic_tmp_counter                                                  ; $00D088 |\
    LDA <r_generic_tmp_counter                                                  ; $00D08A | | Increment the counter and if it reaches 6, reset it to zero.
    CMP #6.b                                                                    ; $00D08C | |
    BNE +                                                                       ; $00D08E | |
    STZ <r_generic_tmp_counter                                                  ; $00D090 |/
+   LDX #0.w                                                                    ; $00D092 | Set the X register to zero.
    LDA <r_generic_tmp_counter                                                  ; $00D095 |\
    ASL A                                                                       ; $00D097 | | Set the Y register to the current value of the counter times two.
    TAY                                                                         ; $00D098 |/
-   LDA r_whirlpool_tmp_palette.color2.w + 0,Y                                  ; $00D099 |\
    STA r_cgram_data.11.color2.w + 0,X                                          ; $00D09C | | Copy the current color to the CG-RAM mirror, using the second
    LDA r_whirlpool_tmp_palette.color2.w + 1,Y                                  ; $00D09F | | color as a base.
    STA r_cgram_data.11.color2.w + 1,X                                          ; $00D0A2 |/
    INX                                                                         ; $00D0A5 |\
    INX                                                                         ; $00D0A6 | | Increment the X register twice and once 7 colors have been copied,
    CPX #_sizeof_palette.w / 2 - 2                                              ; $00D0A7 | | return.
    BEQ ++                                                                      ; $00D0AA |/
    INY                                                                         ; $00D0AC |\
    INY                                                                         ; $00D0AD | | Increment the Y register twice, and if it reaches the desired
    CPY #_sizeof_palette.w / 2 - 2                                              ; $00D0AE | | maximum index, wrap it around to zero to loop back to the start of
    BNE -                                                                       ; $00D0B1 | | the color data.
    LDY #0.w                                                                    ; $00D0B3 | |
    JMP -                                                                       ; $00D0B6 |/
++  RTS                                                                         ; $00D0B9

; _decode_event_opcode_custom_effect_enable_ship ($00:D0BA)
;
; Custom effect that handles enabling the ship and placing its coordinates at
; the Fabul dock.
_decode_event_opcode_custom_effect_enable_ship:
    LDA #1.b                                                                    ; $00D0BA |\ Enable the ship.
    STA r_ship_status.w                                                         ; $00D0BC |/
    LDX #222.w + (56 << 8)                                                      ; $00D0BF |\ Set the ship's coordinates to 222, 56.
    STX r_ship_coordinates.w                                                    ; $00D0C2 |/
    JMP _decode_event_opcode_done                                               ; $00D0C5

; _decode_event_opcode_custom_effect_map_history_pop ($00:D0C8)
;
; Custom effect that handles changing the map to the current top of the map
; history and adjusting the map history index. Does nothing if the map history
; index is already zero.
_decode_event_opcode_custom_effect_map_history_pop:
    LDX r_map_history_index.w                                                   ; $00D0C8 |\ Branch to the end if the map history index is already zero.
    BEQ +                                                                       ; $00D0CB |/
    DEX                                                                         ; $00D0CD |\
    DEX                                                                         ; $00D0CE | | Decrement the map history index by three to update to the next
    DEX                                                                         ; $00D0CF | | map.
    STX r_map_history_index.w                                                   ; $00D0D0 |/
    JSR _map_history_change_map                                                 ; $00D0D3 | Change the current map.
+   JMP _decode_event_opcode_done                                               ; $00D0D6

; _decode_event_opcode_custom_effect_map_history_reset ($00:D0D9)
;
; Custom effect that handles changing the map to the map at the base of the map
; history. Resets the map history index to zero.
_decode_event_opcode_custom_effect_map_history_reset:
    LDX #0.w                                                                    ; $00D0D9 |\ Set the map history index to zero to reset the history.
    STX r_map_history_index.w                                                   ; $00D0DC |/
    JSR _map_history_change_map                                                 ; $00D0DF | Change the current map.
    JMP _decode_event_opcode_done                                               ; $00D0E2

; _map_history_change_map ($00:D0E5)
;
; Changes the current map and coordinates to those stored in the map history at
; the current value of the map history index at $172C.
_map_history_change_map:
    STZ <r_change_map_area_arg_modify_effects                                   ; $00D0E5 | Reset the effect disabling flag when changing map area.
    LDX r_map_history_index.w                                                   ; $00D0E7 |\
    LDA r_map_history.1.map_id.w,X                                              ; $00D0EA | | If the map ID in the history is $FB or above, branch to handle
    CMP #MAP_ID_OVERWORLD.b                                                     ; $00D0ED | | those special codes.
    BCS +                                                                       ; $00D0EF |/
    STA r_map_id.w                                                              ; $00D0F1 | Store the updated map ID.
    LDA #MAP_AREA_DUNGEON.b                                                     ; $00D0F4 |\ Push the map area onto the stack.
    PHA                                                                         ; $00D0F6 |/
    LDA r_map_history.1.x.w,X                                                   ; $00D0F7 |\
    AND #%00111111.b                                                            ; $00D0FA | | Set the X and Y coordinates from the history.
    STA r_current_coordinates.x.w                                               ; $00D0FC | |
    LDA r_map_history.1.y.w,X                                                   ; $00D0FF | |
    STA r_current_coordinates.y.w                                               ; $00D102 |/
    LDA r_map_history.1.x.w,X                                                   ; $00D105 |\
    AND #%11000000.b                                                            ; $00D108 | | Set the direction from the history.
    LSR A                                                                       ; $00D10A | |
    LSR A                                                                       ; $00D10B | |
    LSR A                                                                       ; $00D10C | |
    LSR A                                                                       ; $00D10D | |
    LSR A                                                                       ; $00D10E | |
    LSR A                                                                       ; $00D10F | |
    STA r_direction.w                                                           ; $00D110 |/
    JMP ++                                                                      ; $00D113 | Jump to the common code.
+   SEC                                                                         ; $00D116 |\
    SBC #MAP_ID_OVERWORLD.b                                                     ; $00D117 | | Subtract the base ID and push that as the new map area.
    PHA                                                                         ; $00D119 |/
    LDA r_map_history.1.x.w,X                                                   ; $00D11A |\
    STA r_current_coordinates.x.w                                               ; $00D11D | | Set the new X and Y coordinates from the history.
    LDA r_map_history.1.y.w,X                                                   ; $00D120 | |
    STA r_current_coordinates.y.w                                               ; $00D123 |/
++  PLA                                                                         ; $00D126 |\ Change the map.
    JSR _change_map_area                                                        ; $00D127 |/
    STZ r_play_audio_current_track.w                                            ; $00D12A |\ TODO: Stop the current track or perhaps wait for it to finish?
    JSL bank04.play_audio                                                       ; $00D12D |/
    JSR _play_map_song                                                          ; $00D131 | Play the song associated with the current map.
    STZ <r_enable_triggers                                                      ; $00D134 | Disable triggers.
    RTS                                                                         ; $00D136

; _decode_event_opcode_custom_effect_set_tent_cabin_sprite ($00:D137)
;
; Custom effect handler for the effect when using a Tent or Cabin. The sprite is
; determined by adding $1E8 to the value in $1A03 minus one, times two. This
; effect merely draws the sprite to the first OAM entry.
_decode_event_opcode_custom_effect_set_tent_cabin_sprite:
    JSR _do_tile_animations                                                     ; $00D137 | Do any tile animations.
    JSR _init_oam                                                               ; $00D13A | Initialize the OAM.
    JSR _init_oam_hi_32_large                                                   ; $00D13D | Set 32 sprites to large size.
    LDA r_map_area.w                                                            ; $00D140 |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $00D143 | | If currently outside, draw the outdoor field sprites.
    BEQ +                                                                       ; $00D145 | |
    JSR _draw_outdoor_field_sprites                                             ; $00D147 | |
    JMP +                                                                       ; $00D14A |/
+   LDX #(112 + (112 << 8)).w                                                   ; $00D14D |\ Set the sprite coordinates to 112, 112.
    STX r_oam.1.x.w                                                             ; $00D150 |/
    LDA r_menu_event.w                                                          ; $00D153 |\
    DEC A                                                                       ; $00D156 | | Calculate the tile ID and set it in the OAM.
    ASL A                                                                       ; $00D157 | |
    CLC                                                                         ; $00D158 | |
    ADC #<TILE_BASE_TENT.b                                                      ; $00D159 | |
    STA r_oam.1.tile.w                                                          ; $00D15B |/
    LDA r_menu_event.w                                                          ; $00D15E |\
    ASL A                                                                       ; $00D161 | | Set the tile flags for priority 3 and the high name table.
    ORA #%00110001.b                                                            ; $00D162 | |
    STA r_oam.1.flags.w                                                         ; $00D164 |/
    JMP _decode_event_opcode_done                                               ; $00D167

; _decode_event_opcode_custom_effect_prologue ($00:D16A)
;
; Custom effect handler that handles the display of the prologue text.
_decode_event_opcode_custom_effect_prologue:
    JSR _disable_interrupts                                                     ; $00D16A | Disable NMI and IRQ interrupts and blank the screen.
    LDA #%00010111.b                                                            ; $00D16D |\ Set BG1, BG2, BG3 and sprites as the main screen.
    STA reg_ppu_tm.w                                                            ; $00D16F |/
    STZ reg_ppu_cgswsel.w                                                       ; $00D172 |\ Disable any color math.
    STZ reg_ppu_cgadsub.w                                                       ; $00D175 |/
    JSL bank15.clear_tilemap_vram_high                                          ; $00D178 | Clear the high bytes of the tilemap in VRAM.
    STZ reg_cpu_mdmaen.w                                                        ; $00D17C | Disable DMA.
    LDX #bank08.tileset_prologue_background_data.w                              ; $00D17F |\
    STX reg_cpu_a1t0.w                                                          ; $00D182 | | Copy the prologue background tileset to VRAM.
    LDA #:bank08.tileset_prologue_background_data.b                             ; $00D185 | |
    STA reg_cpu_a1b0.w                                                          ; $00D187 | |
    JSL bank15.copy_3bpp_tileset_to_vram                                        ; $00D18A |/
    LDX #0.w                                                                    ; $00D18E |\
-   LDA bank08.palette_prologue_background_data.l,X                             ; $00D191 | | Copy the palette data for the prologue background to the CG-RAM
    STA r_cgram_data.w,X                                                        ; $00D195 | | staging area.
    INX                                                                         ; $00D198 | |
    CPX #bank08._sizeof_palette_prologue_background_data.w                      ; $00D199 | |
    BNE -                                                                       ; $00D19C |/
    LDA #0.b                                                                    ; $00D19E |\ Write zero to BG1 and the upper half of BG2.
    JSR _clear_vram_bg1_bg2                                                     ; $00D1A0 |/
    LDA #%10000000.b                                                            ; $00D1A3 |\
    STA reg_ppu_vmainc.w                                                        ; $00D1A5 | | Write bytes to BG3 in VRAM, setting each tile to tile zero with a
    LDX #VRAM_PROLOGUE_TILEMAP_BG3.w                                            ; $00D1A8 | | priority of 1.
    STX reg_ppu_vmadd.w                                                         ; $00D1AB | |
    LDY #$2000.w                                                                ; $00D1AE | |
    LDX #$0800.w                                                                ; $00D1B1 | |
-   STY reg_ppu_vmdata_write                                                    ; $00D1B4 | |
    DEX                                                                         ; $00D1B7 | |
    BNE -                                                                       ; $00D1B8 |/
    LDX #VRAM_PROLOGUE_TILEMAP_BG1.w + (32 * 16)                                ; $00D1BA |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00D1BD | | Copy the BG1 tilemap for the prologue background to VRAM for BG1
    LDX #bank08._sizeof_tilemap_prologue_background_bg1_data.w                  ; $00D1BF | | starting on the 17th row (bottom half).
    STX <r_start_vram_dma_arg_bytes                                             ; $00D1C2 | |
    LDX #bank08.tilemap_prologue_background_bg1_data.w                          ; $00D1C4 | |
    STX <r_start_vram_dma_arg_address                                           ; $00D1C7 | |
    LDA #:bank08.tilemap_prologue_background_bg1_data.b                         ; $00D1C9 | |
    STA <r_start_vram_dma_arg_bank                                              ; $00D1CB | |
    JSL bank15.start_vram_dma                                                   ; $00D1CD |/
    LDX #VRAM_PROLOGUE_TILEMAP_BG2.w + (32 * 14)                                ; $00D1D1 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00D1D4 | | Copy the BG2 tilemap for the prologue background to VRAM for BG2
    LDX #bank08._sizeof_tilemap_prologue_background_bg2_data.w                  ; $00D1D6 | | starting on the 15th row.
    STX <r_start_vram_dma_arg_bytes                                             ; $00D1D9 | |
    LDX #bank08.tilemap_prologue_background_bg2_data.w                          ; $00D1DB | |
    STX <r_start_vram_dma_arg_address                                           ; $00D1DE | |
    JSL bank15.start_vram_dma                                                   ; $00D1E0 |/
    LDX #VRAM_PROLOGUE_TILES_OAM.w                                              ; $00D1E4 |\
    STX <r_start_vram_dma_arg_vram_target                                       ; $00D1E7 | | Copy the sprite data for the moon sprite on the prologue
    LDX #bank1A._sizeof_sprite_prologue_background_moon_data.w                  ; $00D1E9 | | background to the OAM tile area of VRAM.
    STX <r_start_vram_dma_arg_bytes                                             ; $00D1EC | |
    LDX #bank1A.sprite_prologue_background_moon_data.w                          ; $00D1EE | |
    STX <r_start_vram_dma_arg_address                                           ; $00D1F1 | |
    LDA #:bank1A.sprite_prologue_background_moon_data.b                         ; $00D1F3 | |
    STA <r_start_vram_dma_arg_bank                                              ; $00D1F5 | |
    JSL bank15.start_vram_dma                                                   ; $00D1F7 |/
    LDX #0.w                                                                    ; $00D1FB |\
-   LDA bank1A.sprite_prologue_background_moon_palette_data.l,X                 ; $00D1FE | | Copy the palette data for the moon sprite to the ninth palette.
    STA r_cgram_data.9.w,X                                                      ; $00D202 | |
    INX                                                                         ; $00D205 | |
    CPX #bank1A._sizeof_sprite_prologue_background_moon_palette_data.w          ; $00D206 | |
    BNE -                                                                       ; $00D209 |/
    JSR _init_oam                                                               ; $00D20B | Initialize the OAM to clear any existing sprite data.
    LDX #$0000.w                                                                ; $00D20E |\
-   LDA bank14.sprite_prologue_background_moon_oam_data.l,X                     ; $00D211 | | Copy the OAM data for the moon sprite to the OAM staging area.
    STA r_oam.w,X                                                               ; $00D215 | |
    INX                                                                         ; $00D218 | |
    CPX #bank14._sizeof_sprite_prologue_background_moon_oam_data.w              ; $00D219 | |
    BNE -                                                                       ; $00D21C |/
    LDX #0.w                                                                    ; $00D21E |\
    STX <r_scroll_bg1_horizontal                                                ; $00D221 | | Set the scroll values for BG1 and BG2 to zero.
    STX <r_scroll_bg1_vertical                                                  ; $00D223 | |
    STX <r_scroll_bg2_horizontal                                                ; $00D225 | |
    STX <r_scroll_bg2_vertical                                                  ; $00D227 |/
    STZ r_map_properties.background_properties.w                                ; $00D229 | Reset the background properties to disable any special effects.
    LDA #%10000001.b                                                            ; $00D22C |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00D22E |/
    LDA #%00000111.b                                                            ; $00D231 |\ Fade in the PPU, changing brightness once every eight frames.
    JSR _ppu_fade_in                                                            ; $00D233 |/
    LDA #1.b                                                                    ; $00D236 |\ Enable the slow dialog scrolling feature.
    STA <r_dialog_prologue_scroll_enable                                        ; $00D238 |/
    LDA #$D0.b                                                                  ; $00D23A |\ Set the message ID to display to the prologue text.
    STA <r_show_message_id                                                      ; $00D23C |/
    JSR _load_message_bank_1_hi_offset                                          ; $00D23E |\ Display the prologue text.
    JSR _show_upper_dialog                                                      ; $00D241 |/
    JSR _close_upper_dialog                                                     ; $00D244 | Close the dialog.
    STZ <r_dialog_prologue_scroll_enable                                        ; $00D247 | Unset the prologue dialog scroll flag.
    JSR _audio_fade_out_slow                                                    ; $00D249 | Tell the audio to begin to fade out.
    LDA #%00000111.b                                                            ; $00D24C |\ Fade out the PPU, again stepping once every eight frames.
    JSR _ppu_fade_out                                                           ; $00D24E |/
    JMP _decode_event_opcode_done                                               ; $00D251

; _decode_event_opcode_custom_effect_agart_explosion ($00:D254)
;
; Custom effect that animates the explosion effect over the Agart mountain.
_decode_event_opcode_custom_effect_agart_explosion:
    JSL bank15.init_ppu                                                         ; $00D254 | Initialize the PPU.
    LDX r_current_coordinates.w                                                 ; $00D258 |\ Preserve the current coordinates.
    PHX                                                                         ; $00D25B |/
    LDX #(105 + (211 << 8)).w                                                   ; $00D25C |\ Set the coordinates to 105, 211 (over the Agart mountain).
    STX r_current_coordinates.w                                                 ; $00D25F |/
    STZ r_map_area.w                                                            ; $00D262 |\ Set the map area to overworld and change the map to the overworld.
    JSR _change_map_overworld                                                   ; $00D265 |/
    LDA #32.b                                                                   ; $00D268 |\ Set the zoom level to 32.
    STA <r_zoom_level                                                           ; $00D26A |/
    LDA #16.b                                                                   ; $00D26C |\ Set the zoom palette.
    JSL bank15.set_zoom_palette                                                 ; $00D26E |/
    LDA #%10000001.b                                                            ; $00D272 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00D274 |/
    LDA #%00000011.b                                                            ; $00D277 |\ Fade the PPU in, incrementing the brightness every four frames.
    JSR _ppu_fade_in                                                            ; $00D279 |/
    LDX #64.w                                                                   ; $00D27C |\ Wait for 64 frames.
    JSR _wait_for_x_frames                                                      ; $00D27F |/
    LDA #1.b                                                                    ; $00D282 |\ Enable the shaking effect.
    STA <r_shaking                                                              ; $00D284 |/
    LDA #32.b                                                                   ; $00D286 |\
    STA r_draw_explosion_arg_count.w                                            ; $00D288 | | Configure the explosion effect to have 8 simultaneous sprites,
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00D28B | | arranged in a small square, centered at 112, 122 lasting for 64
    STA r_draw_explosion_arg_width.w                                            ; $00D28D | | cycles with a smoke effect.
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00D290 | |
    STA r_draw_explosion_arg_height.w                                           ; $00D292 | |
    LDX #112 + (112 << 8).w                                                     ; $00D295 | |
    STX r_draw_explosion_arg_coordinates.w                                      ; $00D298 | |
    LDX #64.w                                                                   ; $00D29B | |
    STX r_draw_explosion_arg_cycles.w                                           ; $00D29E | |
    STZ r_draw_explosion_arg_palette.w                                          ; $00D2A1 | |
    LDA #EXPLOSION_SMOKE.b                                                      ; $00D2A4 | |
    STA r_draw_explosion_arg_smoke.w                                            ; $00D2A6 |/
    LDA #AUDIO_EFFECT_DISINTEGRATE.b                                            ; $00D2A9 |\ Play the disintegration sound effect.
    JSR _play_sound_effect                                                      ; $00D2AB |/
    JSR _init_explosion                                                         ; $00D2AE | Initialize the explosion.
-   JSR _do_tile_animations                                                     ; $00D2B1 | Wait for the NMI and do tile animations.
    JSR _draw_explosion                                                         ; $00D2B4 | Update the explosion for htis frame.
    LDX r_draw_explosion_arg_cycles.w                                           ; $00D2B7 |\
    CPX #16.w                                                                   ; $00D2BA | | Set the PPU brightness based on the explosion cycle counter so it
    BCS +                                                                       ; $00D2BD | | fades out as the explosion nears completion.
    TXA                                                                         ; $00D2BF | |
    STA reg_ppu_inidisp.w                                                       ; $00D2C0 |/
+   LDX r_draw_explosion_arg_cycles.w                                           ; $00D2C3 |\ Loop until the cycle counter reaches zero.
    BNE -                                                                       ; $00D2C6 |/
    PLX                                                                         ; $00D2C8 |\ Restore the original coordinates.
    STX r_current_coordinates.w                                                 ; $00D2C9 |/
    STZ <r_shaking                                                              ; $00D2CC | Disable the shaking effect.
    STZ <r_ppu_brightness                                                       ; $00D2CE | Set the PPU brightness to zero.
    JMP _decode_event_opcode_done                                               ; $00D2D0

; _decode_event_opcode_custom_effect_girl_battle_and_titan ($00:D2D3)
;
; Custom effect handler for the sequence where the party fights Rydia as a child
; and the mountains next to Mist collapse.
_decode_event_opcode_custom_effect_girl_battle_and_titan:
    LDA #BATTLE_FORMATION_GIRL.b                                                ; $00D2D3 |\
    STA r_battle_formation_lo.w                                                 ; $00D2D5 | | Set the formation number for the Girl battle.
    STZ r_battle_formation_hi.w                                                 ; $00D2D8 |/
    LDA r_map_properties.flags.w                                                ; $00D2DB |\
    AND #MAP_PROPERTIES_FLAGS_MAGNETIC | MAP_PROPERTIES_FLAGS_BATTLE_BACKGROUND ; $00D2DE | | Set the battle background based on the map properties.
    STA r_battle_background.w                                                   ; $00D2E0 |/
    JSR _animate_transition_and_start_battle                                    ; $00D2E3 | Execute the battle.
    JSR _audio_fade_out_slow                                                    ; $00D2E6 | Fade out the audio.
    JSL bank15.init_ppu                                                         ; $00D2E9 | Re-initialize the PPU.
    LDX r_current_coordinates.w                                                 ; $00D2ED |\ Preserve the current coordinates.
    PHX                                                                         ; $00D2F0 |/
    LDX #(99 + (119 << 8)).w                                                    ; $00D2F1 |\ Set the current coordinates to 99, 119.
    STX r_current_coordinates.w                                                 ; $00D2F4 |/
    STZ r_map_area.w                                                            ; $00D2F7 |\ Change to the Overworld map.
    JSR _change_map_overworld                                                   ; $00D2FA |/
    LDA #32.b                                                                   ; $00D2FD |\ Set the zoom level to 32.
    STA <r_zoom_level                                                           ; $00D2FF |/
    LDA #%10000001.b                                                            ; $00D301 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00D303 |/
    LDA #%00000011.b                                                            ; $00D306 |\ Fade in the screen, increasing one level every four frames.
    JSR _ppu_fade_in                                                            ; $00D308 |/
    LDX #64.w                                                                   ; $00D30B |\ Wait for 64 frames.
    JSR _wait_for_x_frames                                                      ; $00D30E |/
    LDA #1.b                                                                    ; $00D311 |\ Enable the shaking effect.
    STA <r_shaking                                                              ; $00D313 |/
    LDA #32.b                                                                   ; $00D315 |\
    STA r_draw_explosion_arg_count.w                                            ; $00D317 | | Configure the explosion effect to have 8 simultaneous sprites,
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00D31A | | slightly larger horizontally, centered at 70, 70 lasting for 64
    STA r_draw_explosion_arg_width.w                                            ; $00D31C | | cycles with a smoke effect.
    LDA #EXPLOSION_SIZE_SMALLEST.b                                              ; $00D31F | |
    STA r_draw_explosion_arg_height.w                                           ; $00D321 | |
    LDX #(112 + (112 << 8)).w                                                   ; $00D324 | |
    STX r_draw_explosion_arg_coordinates.w                                      ; $00D327 | |
    LDX #64.w                                                                   ; $00D32A | |
    STX r_draw_explosion_arg_cycles.w                                           ; $00D32D | |
    STZ r_draw_explosion_arg_palette.w                                          ; $00D330 | |
    LDA #EXPLOSION_SMOKE.b                                                      ; $00D333 | |
    STA r_draw_explosion_arg_smoke.w                                            ; $00D335 |/
    LDA #AUDIO_TRACK_RUMBLING.b                                                 ; $00D338 |\
    STA r_play_audio_arg_track.w                                                ; $00D33A | | Play the rumbling audio track.
    LDA #AUDIO_MODE_NORMAL.b                                                    ; $00D33D | |
    STA r_play_audio_arg_mode.w                                                 ; $00D33F | |
    JSL bank04.play_audio                                                       ; $00D342 |/
    JSR _init_explosion                                                         ; $00D346 | Initialize the explosion.
-   JSR _do_tile_animations                                                     ; $00D349 | Do any tile animations.
    JSR _draw_explosion                                                         ; $00D34C | Draw the current explosion.
    LDX r_draw_explosion_arg_cycles.w                                           ; $00D34F |\
    CPX #16.w                                                                   ; $00D352 | | If the cycle counter is 15 or less, transfer the value into the
    BCS +                                                                       ; $00D355 | | PPU brightness register, and begin to fade out the audio.
    TXA                                                                         ; $00D357 | |
    STA reg_ppu_inidisp.w                                                       ; $00D358 | |
    JSR _audio_fade_out_slow                                                    ; $00D35B |/
+   LDX r_draw_explosion_arg_cycles.w                                           ; $00D35E |\ Loop until the cycle counter reaches zero.
    BNE -                                                                       ; $00D361 |/
    PLX                                                                         ; $00D363 |\ Restore the original coordinates.
    STX r_current_coordinates.w                                                 ; $00D364 |/
    STZ <r_shaking                                                              ; $00D367 | Disable the shaking effect.
    STZ <r_ppu_brightness                                                       ; $00D369 | Set the PPU brightness to zero.
    JMP _decode_event_opcode_done                                               ; $00D36B

; _decode_event_opcode_custom_effect_damcyan_bombing ($00:D36E)
;
; Custom effect that animates the bombing of Damcyan.
_decode_event_opcode_custom_effect_damcyan_bombing:
    LDA #4.b                                                                    ; $00D36E |\ Set the explosion palette index to 4.
    STA r_draw_explosion_arg_palette.w                                          ; $00D370 |/
    STZ r_draw_explosion_arg_smoke.w                                            ; $00D373 | Disable the use of the smoke palette for explosions.
    JSR _init_explosion                                                         ; $00D376 | Initialize the explosion variables.
    LDX #0.w                                                                    ; $00D379 |\
    LDA #$FF.b                                                                  ; $00D37C | | Loop through the explosion area in memory, setting everything to
-   STA r_explosions.w,X                                                        ; $00D37E | | $FF to disable that entry.
    INX                                                                         ; $00D381 | |
    INX                                                                         ; $00D382 | |
    INX                                                                         ; $00D383 | |
    INX                                                                         ; $00D384 | |
    CPX #_sizeof_r_explosions.w                                                 ; $00D385 | |
    BNE -                                                                       ; $00D388 |/
    LDA #AUDIO_TRACK_AIRSHIP_RIGHT_TO_LEFT.b                                    ; $00D38A |\ Play the audio track that pans an airship sound from right to left.
    JSR _play_song                                                              ; $00D38C |/
    LDX #256.w                                                                  ; $00D38F |\ Initialize the X coordinate of the effect to 256.
    STX <r_event_base_coordinate.x                                              ; $00D392 |/
    LDX #16.w                                                                   ; $00D394 |\ Initialize the base Y coordinate of the effect to 16.
    STX <r_event_base_coordinate.y                                              ; $00D397 |/
-   JSR _do_tile_animations                                                     ; $00D399 | Wait for the next frame and do any tile animations.
    JSR _init_oam                                                               ; $00D39C | Initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $00D39F | Draw the outdoor field sprites.
    LDA <r_zoom_level                                                           ; $00D3A2 |\
    SEC                                                                         ; $00D3A4 | | Set the current zoom palette based on the current zoom level.
    SBC #16.b                                                                   ; $00D3A5 | |
    JSL bank15.set_zoom_palette                                                 ; $00D3A7 |/
    LDA r_map_frame_counter.w                                                   ; $00D3AB |\
    AND #%00000011.b                                                            ; $00D3AE | | Loop back unless the map frame counter is divisible by four.
    BNE -                                                                       ; $00D3B0 |/
    LDA <r_zoom_level                                                           ; $00D3B2 |\
    INC A                                                                       ; $00D3B4 | | Increment the zoom level and loop until it reaches 32.
    STA <r_zoom_level                                                           ; $00D3B5 | |
    CMP #32.b                                                                   ; $00D3B7 | |
    BNE -                                                                       ; $00D3B9 |/
@loop_start:
    JSR _do_tile_animations                                                     ; $00D3BB | Wait for the next frame and do any tile animations.
    JSR _event_replace_damcyan_with_ruined_castle                               ; $00D3BE | Replaces Damcyan with the ruined castle if the X coordinate is 96.
    JSR _init_oam_lower                                                         ; $00D3C1 | Initialize the lower half of the OAM.
    JSR _set_oam_large_64                                                       ; $00D3C4 | Set the lower 64 OAM sprites to be large sized.
    STZ <r_generic_tmp_counter                                                  ; $00D3C7 | Initialize the counter to zero.
-   LDA <r_generic_tmp_counter                                                  ; $00D3C9 |\
    ASL A                                                                       ; $00D3CB | | Set the Y register to the counter times two.
    TAY                                                                         ; $00D3CC |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00D3CD |\
    LDA <r_event_base_coordinate.x                                              ; $00D3CF | | Calculate the X coordinate for this airship.
    CLC                                                                         ; $00D3D1 | |
    ADC damcyan_bombing_airship_x_coordinate_offset_data.w,Y                    ; $00D3D2 | |
    STA <r_generic_arg_x                                                        ; $00D3D5 |/
    LDA <r_event_base_coordinate.y                                              ; $00D3D7 |\
    CLC                                                                         ; $00D3D9 | | Calculate the Y coordinate for this airship.
    ADC damcyan_bombing_airship_y_coordinate_offset_data.w,Y                    ; $00D3DA | |
    STA <r_generic_arg_y                                                        ; $00D3DD |/
    LDA <r_generic_tmp_counter                                                  ; $00D3DF |\
    AND #$00FF.w                                                                ; $00D3E1 | | Set the Y register to the counter times 16 plus 256. This value is
    ASL A                                                                       ; $00D3E4 | | used by the vehicle sprite routine as the OAM offset.
    ASL A                                                                       ; $00D3E5 | |
    ASL A                                                                       ; $00D3E6 | |
    ASL A                                                                       ; $00D3E7 | |
    ORA #$0100.w                                                                ; $00D3E8 | |
    TAY                                                                         ; $00D3EB | |
    LDA #$0000.w                                                                ; $00D3EC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00D3EF |/
    LDA #%00011100.b                                                            ; $00D3F1 |\ Set the sprite tile flags for priority 1 with palette 6.
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00D3F3 |/
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00D3F5 |\ Set the tile base for that of the Enterprise.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00D3F7 |/
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00D3F9 |\ Set the tile offset to draw the airships going left.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00D3FB |/
    JSR _draw_vehicle_sprite                                                    ; $00D3FD | Draw the airship.
    INC <r_generic_tmp_counter                                                  ; $00D400 |\
    LDA <r_generic_tmp_counter                                                  ; $00D402 | | Increment the counter and loop until it reaches 3.
    CMP #3.b                                                                    ; $00D404 | |
    BNE -                                                                       ; $00D406 |/
    STZ <r_shaking                                                              ; $00D408 | Disable the shaking effect.
    LDA <r_event_base_coordinate.x                                              ; $00D40A |\
    CMP #64.b                                                                   ; $00D40C | | If the current X coordinate is less than 64 or 144 or greater,
    BCC @skip_explosions                                                        ; $00D40E | | skip drawing the explosions.
    CMP #144.b                                                                  ; $00D410 | |
    BCS @skip_explosions                                                        ; $00D412 |/
    LDA #1.b                                                                    ; $00D414 |\ Enable the shaking effect if drawing explosions.
    STA <r_shaking                                                              ; $00D416 |/
    LDA <r_event_base_coordinate.x                                              ; $00D418 |\
    AND #%00000111.b                                                            ; $00D41A | | Skip drawing new explosions unless the X coordinate mod 8 is zero.
    BNE @skip_explosions                                                        ; $00D41C |/
    INC <r_enable_flash_palette                                                 ; $00D41E | Enable the flash palette on new explosion frames.
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00D420 |\ Play the Crush/long explosion sound effect.
    JSR _play_sound_effect                                                      ; $00D422 |/
    LDX #0.w                                                                    ; $00D425 | Initialize the X register to zero.
-   LDA r_explosions.1.cycle.w,X                                                ; $00D428 |\
    CMP #$FF.b                                                                  ; $00D42B | | Loop until finding an explosion entry that is either unused or
    BEQ +                                                                       ; $00D42D | | that has reached a cycle of 6 or greater.
    CMP #6.b                                                                    ; $00D42F | |
    BCS +                                                                       ; $00D431 | |
    INX                                                                         ; $00D433 | |
    INX                                                                         ; $00D434 | |
    INX                                                                         ; $00D435 | |
    INX                                                                         ; $00D436 | |
    JMP -                                                                       ; $00D437 |/
+   STZ r_explosions.1.cycle.w,X                                                ; $00D43A |\
    STZ r_explosions.2.cycle.w,X                                                ; $00D43D | | Set the cycle for this explosion and the two following to zero.
    STZ r_explosions.3.cycle.w,X                                                ; $00D440 |/
    LDA <r_event_base_coordinate.x                                              ; $00D443 |\
    CLC                                                                         ; $00D445 | | Set the X coordinates for the three explosions to the base
    ADC #32.b                                                                   ; $00D446 | | coordinate plus 32 (for the first and third) and plus 16 (for the
    STA r_explosions.1.coordinates.x.w,X                                        ; $00D448 | | second).
    STA r_explosions.3.coordinates.x.w,X                                        ; $00D44B | |
    SEC                                                                         ; $00D44E | |
    SBC #16.b                                                                   ; $00D44F | |
    STA r_explosions.2.coordinates.x.w,X                                        ; $00D451 |/
    LDA #72.b                                                                   ; $00D454 |\
    STA r_explosions.1.coordinates.y.w,X                                        ; $00D456 | | Set the Y coordinates for the three explosions to 72, 88 and 104.
    LDA #88.b                                                                   ; $00D459 | |
    STA r_explosions.2.coordinates.y.w,X                                        ; $00D45B | |
    LDA #104.b                                                                  ; $00D45E | |
    STA r_explosions.3.coordinates.y.w,X                                        ; $00D460 |/
@skip_explosions:
    STZ <r_field_effect_counter.lo                                              ; $00D463 |\ Initialize the effect counter to zero.
    STZ <r_field_effect_counter.hi                                              ; $00D465 |/
-   LDX <r_field_effect_counter                                                 ; $00D467 |\
    LDA r_explosions.1.cycle.w,X                                                ; $00D469 | | Skip this explosion if unused or if it has reached the end.
    BMI +                                                                       ; $00D46C | |
    CMP #6.b                                                                    ; $00D46E | |
    BCS +                                                                       ; $00D470 |/
    JSR _draw_explosion_sprite                                                  ; $00D472 | Draw this explosion sprite.
    LDA <r_map_frame_counter                                                    ; $00D475 |\
    AND #%00000111.b                                                            ; $00D477 | | If the map frame counter mod 8 is zero, increment the cycle for
    BNE +                                                                       ; $00D479 | | this explosion.
    LDX <r_field_effect_counter                                                 ; $00D47B | |
    INC r_explosions.1.cycle.w,X                                                ; $00D47D |/
+   LDX <r_field_effect_counter                                                 ; $00D480 |\
    INX                                                                         ; $00D482 | | Increment the counter by four to move to the next explosion and
    INX                                                                         ; $00D483 | | loop until the entire set has been checked.
    INX                                                                         ; $00D484 | |
    INX                                                                         ; $00D485 | |
    STX <r_field_effect_counter                                                 ; $00D486 | |
    CPX #_sizeof_r_explosions.w                                                 ; $00D488 | |
    BNE -                                                                       ; $00D48B |/
    LDA <r_map_frame_counter                                                    ; $00D48D |\
    AND #%00000001.b                                                            ; $00D48F | | If the map frame counter mod 2 is zero, decrement the base X
    BNE +                                                                       ; $00D491 | | coordinate.
    LDX <r_event_base_coordinate.x                                              ; $00D493 | |
    DEX                                                                         ; $00D495 | |
    STX <r_event_base_coordinate.x                                              ; $00D496 |/
    CPX #-34.w                                                                  ; $00D498 |\
    BEQ ++                                                                      ; $00D49B | | If the base X coordinate reaches -34, skip ahead. Otherwise, loop
+   LDA <r_event_base_coordinate.x                                              ; $00D49D | | back to do the next iteration.
    CMP #176.b                                                                  ; $00D49F | |
    BCC +                                                                       ; $00D4A1 | | NOTE: There is an unused check against an X coordinate of 176.
+   JMP @loop_start                                                             ; $00D4A3 |/
++  LDA #AUDIO_TRACK_RUN.b                                                      ; $00D4A6 |\ Change the music to "Run!".
    JSR _play_song                                                              ; $00D4A8 |/
-   JSR _do_tile_animations                                                     ; $00D4AB | Wait a frame and do any tile animations.
    JSR _init_oam                                                               ; $00D4AE | Initialize the OAM.
    JSR _draw_outdoor_field_sprites                                             ; $00D4B1 | Draw the outdoor field sprites.
    LDA <r_zoom_level                                                           ; $00D4B4 |\
    SEC                                                                         ; $00D4B6 | | Set the zoom palette based on the zoom level.
    SBC #16.b                                                                   ; $00D4B7 | |
    JSL bank15.set_zoom_palette                                                 ; $00D4B9 |/
    LDA r_map_frame_counter.w                                                   ; $00D4BD |\
    AND #%00000011.b                                                            ; $00D4C0 | | Every four frames, decrease the zoom level and loop until it
    BNE -                                                                       ; $00D4C2 | | reaches the minimum value.
    LDA <r_zoom_level                                                           ; $00D4C4 | |
    DEC A                                                                       ; $00D4C6 | |
    STA <r_zoom_level                                                           ; $00D4C7 | |
    CMP #16.b                                                                   ; $00D4C9 | |
    BNE -                                                                       ; $00D4CB |/
    JMP _decode_event_opcode_done                                               ; $00D4CD

; _event_replace_damcyan_with_ruined_castle ($00:D4D0)
;
; Part of an event opcode custom effect, replaces the Damcyan tiles in VRAM
; with the ruiend castle tiles if the value in $062C is 96 (which aligns with
; when the airships are above the castle).
_event_replace_damcyan_with_ruined_castle:
    LDA <r_event_base_coordinate.x                                              ; $00D4D0 |\
    CMP #96.b                                                                   ; $00D4D2 | | Return unless the X coordinate is exactly 96.
    BNE +                                                                       ; $00D4D4 |/
    STZ reg_ppu_vmainc.w                                                        ; $00D4D6 | Set the VRAM increment to 1 by 1 after one byte written.
    LDA #0.b                                                                    ; $00D4D9 |\
    TAX                                                                         ; $00D4DB | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $00D4DC |/
-   LDA damcyan_tile_vram_address_data.w + 0,Y                                  ; $00D4DD |\
    STA reg_ppu_vmaddl.w                                                        ; $00D4E0 | | Set the VRAM address for the current row.
    LDA damcyan_tile_vram_address_data.w + 1,Y                                  ; $00D4E3 | |
    STA reg_ppu_vmaddh.w                                                        ; $00D4E6 |/
    LDA bank14.ruined_castle_tile_data.l + 0,X                                  ; $00D4E9 |\
    STA reg_ppu_vmdatal_write.w                                                 ; $00D4ED | | Set the new tiles by loading the tile numbers from ROM.
    LDA bank14.ruined_castle_tile_data.l + 1,X                                  ; $00D4F0 | |
    STA reg_ppu_vmdatal_write.w                                                 ; $00D4F4 | |
    LDA bank14.ruined_castle_tile_data.l + 2,X                                  ; $00D4F7 | |
    STA reg_ppu_vmdatal_write.w                                                 ; $00D4FB | |
    LDA bank14.ruined_castle_tile_data.l + 3,X                                  ; $00D4FE | |
    STA reg_ppu_vmdatal_write.w                                                 ; $00D502 |/
    INY                                                                         ; $00D505 |\
    INY                                                                         ; $00D506 | | Increment the indexes and loop until all 16 tiles have been
    INX                                                                         ; $00D507 | | changed.
    INX                                                                         ; $00D508 | |
    INX                                                                         ; $00D509 | |
    INX                                                                         ; $00D50A | |
    CPX #16.w                                                                   ; $00D50B | |
    BNE -                                                                       ; $00D50E |/
+   RTS                                                                         ; $00D510

; damcyan_bombing_airship_x_coordinate_offset_data ($00:D511)
;
; For each of the three airships in the Damcyan bombing, determines the offset
; to the X coordinate for that airship relative to the base X coordinate of the
; effect.
damcyan_bombing_airship_x_coordinate_offset_data:
    .dw 16                                                                      ; $00D511.D512
    .dw  0                                                                      ; $00D513.D514
    .dw 16                                                                      ; $00D515.D516

; damcyan_bombing_airship_y_coordinate_offset_data ($00:D517)
;
; For each of the three airships in the Damcyan bombing, determines the offset
; to the Y coordinate for that airship relative to the base Y coordinate of the
; effect.
damcyan_bombing_airship_y_coordinate_offset_data:
    .dw 16                                                                      ; $00D517.D518
    .dw 32                                                                      ; $00D519.D51A
    .dw 48                                                                      ; $00D51B.D51C

; damcyan_tile_vram_address_data ($00:D51D)
;
; For each row of the Damcyan castle tiles, determines the VRAM address of the
; first tile in the tilemap.
damcyan_tile_vram_address_data:
    .addr $396C                                                                 ; $00D51D.D51E
    .addr $39EC                                                                 ; $00D51F.D520
    .addr $3A6C                                                                 ; $00D521.D522
    .addr $3AEC                                                                 ; $00D523.D524

; _decode_event_opcode_custom_effect_cpu_explosion ($00:D525)
;
; Custom effect for the explosion of the Giant's CPU after the battle.
_decode_event_opcode_custom_effect_cpu_explosion:
    LDA #96.b                                                                   ; $00D525 |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00D527 | | Draw a small explosion at 96, 72.
    LDA #72.b                                                                   ; $00D52A | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00D52C | |
    JSR _draw_small_explosion                                                   ; $00D52F |/
    JSR _wait_for_nmi_complete                                                  ; $00D532 | Wait for the next complete NMI.
    LDA #%10000000.b                                                            ; $00D535 |\ Set the VRAM increment to 1 by 1 after writing to $2119.
    STA reg_ppu_vmainc.w                                                        ; $00D537 |/
    LDX #0.w                                                                    ; $00D53A | Initialize the X register to zero.
-   TXA                                                                         ; $00D53D |\
    AND #%00000011.b                                                            ; $00D53E | | Skip ahead if the counter mod 4 is not zero.
    BNE +                                                                       ; $00D540 |/
    TXA                                                                         ; $00D542 |\
    LSR A                                                                       ; $00D543 | | Set the new VRAM address by dividing the counter by four and
    LSR A                                                                       ; $00D544 | | multiplying by two, and then indexing the VRAM offset data.
    ASL A                                                                       ; $00D545 | |
    TAY                                                                         ; $00D546 | |
    LDA giant_cpu_vram_tilemap_offset_data.w + 0,Y                              ; $00D547 | |
    STA reg_ppu_vmaddl.w                                                        ; $00D54A | |
    LDA giant_cpu_vram_tilemap_offset_data.w + 1,Y                              ; $00D54D | |
    STA reg_ppu_vmaddh.w                                                        ; $00D550 |/
+   LDA #$01.b                                                                  ; $00D553 |\ Replace the tile number with $01.
    STA reg_ppu_vmdatal_write.w                                                 ; $00D555 |/
    LDA #%00010101.b                                                            ; $00D558 |\ Set the flags for palette 5 and to add $100 to the tile number.
    STA reg_ppu_vmdatah_write.w                                                 ; $00D55A |/
    INX                                                                         ; $00D55D |\
    TXA                                                                         ; $00D55E | | Increment the X register and loop until all 16 tiles are updated.
    CMP #16.b                                                                   ; $00D55F | |
    BNE -                                                                       ; $00D561 |/
    JMP _decode_event_opcode_done                                               ; $00D563

; giant_cpu_vram_tilemap_offset_data ($00:D566)
;
; For each row of the CPU tiles in the Giant of Bab-il CPU map, determines the
; VRAM offset for the first tile in each of the four rows.
giant_cpu_vram_tilemap_offset_data:
    .dw $1800 + 16 + 18 * 32                                                    ; $00D566.D567
    .dw $1800 + 16 + 19 * 32                                                    ; $00D568.D569
    .dw $1800 + 16 + 20 * 32                                                    ; $00D56A.D56B
    .dw $1800 + 16 + 21 * 32                                                    ; $00D56C.D56D

; _draw_small_explosion ($00:D56E)
;
; Draws a small explosion with the upper left coordinates of the effect passed
; in $0AD4 and $0AD5.
_draw_small_explosion:
    LDA #32.b                                                                   ; $00D56E |\ Configure the explosion to do eight simultaneous sprites.
    STA r_draw_explosion_arg_count.w                                            ; $00D570 |/
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00D573 |\
    STA r_draw_explosion_arg_width.w                                            ; $00D575 | | Set the explosion size to small.
    STA r_draw_explosion_arg_height.w                                           ; $00D578 |/
    LDX #48.w                                                                   ; $00D57B |\ Set the explosion cycle counter to 48.
    STX r_draw_explosion_arg_cycles.w                                           ; $00D57E |/
    LDA #6.b                                                                    ; $00D581 |\
    STA r_draw_explosion_arg_palette.w                                          ; $00D583 | | Use palette 6 with the smoke flag disabled.
    STZ r_draw_explosion_arg_smoke.w                                            ; $00D586 |/
    JSR _init_explosion                                                         ; $00D589 | Initialize the explosion.
-   JSR _do_tile_animations                                                     ; $00D58C | Do the tile animations.
    JSR _set_random_vertical_scroll_offset                                      ; $00D58F | Set the vertical scroll offset to randomly offset to eight.
    JSR _draw_explosion                                                         ; $00D592 | Draw the explosion for this frame.
    LDA <r_map_frame_counter                                                    ; $00D595 |\
    AND #%00111111.b                                                            ; $00D597 | | If the map frame counter mod 64 is zero, play the Crush/long
    BNE +                                                                       ; $00D599 | | explosion sound effect.
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00D59B | |
    JSR _play_sound_effect                                                      ; $00D59D |/
+   LDX r_draw_explosion_arg_cycles.w                                           ; $00D5A0 |\ Loop until the cycle counter reaches zero.
    BNE -                                                                       ; $00D5A3 |/
    JSR _init_oam_lower                                                         ; $00D5A5 | Initialize the lower OAM to clear the sprites.
    RTS                                                                         ; $00D5A8

; _decode_event_opcode_custom_effect_small_explosion_top ($00:D5A9)
;
; This custom effect draws a small explosion at the top of the screen.
_decode_event_opcode_custom_effect_small_explosion_top:
    LDA #112.b                                                                  ; $00D5A9 |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00D5AB | | Draw a small explosion at 112, 16.
    LDA #16.b                                                                   ; $00D5AE | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00D5B0 | |
    JSR _draw_small_explosion                                                   ; $00D5B3 |/
    JMP _decode_event_opcode_done                                               ; $00D5B6

; _decode_event_opcode_custom_effect_small_explosion_center ($00:D5B9)
;
; This custom effect draws a small explosion roughly centered in the screen.
_decode_event_opcode_custom_effect_small_explosion_center:
    LDA #112.b                                                                  ; $00D5B9 |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00D5BB | | Draw a small explosion at 112, 112.
    LDA #112.b                                                                  ; $00D5BE | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00D5C0 | |
    JSR _draw_small_explosion                                                   ; $00D5C3 |/
    JMP _decode_event_opcode_done                                               ; $00D5C6

; _decode_event_opcode_custom_effect_general_bombing ($00:D5C9)
;
; This custom effect simply animates eight sets of explosions occurring at
; various locations on the screen.
_decode_event_opcode_custom_effect_general_bombing:
    STZ <r_generic_tmp_counter                                                  ; $00D5C9 | Initialize a counter to zero.
--  LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00D5CB |\ Play the Crush/long explosion sound effect.
    JSR _play_sound_effect                                                      ; $00D5CD |/
    LDA #32.b                                                                   ; $00D5D0 |\
    STA r_draw_explosion_arg_count.w                                            ; $00D5D2 | | Configure the explosion effect to draw 8 explosions, with an
    LDA #EXPLOSION_SIZE_SMALL.b                                                 ; $00D5D5 | | effect of the second smallest size in both directions, lasting for
    STA r_draw_explosion_arg_width.w                                            ; $00D5D7 | | eight cycles, using palette 6, with the fire palette and not the
    STA r_draw_explosion_arg_height.w                                           ; $00D5DA | | smoke palette.
    LDX #8.w                                                                    ; $00D5DD | |
    STX r_draw_explosion_arg_cycles.w                                           ; $00D5E0 | |
    LDA #6.b                                                                    ; $00D5E3 | |
    STA r_draw_explosion_arg_palette.w                                          ; $00D5E5 | |
    STZ r_draw_explosion_arg_smoke.w                                            ; $00D5E8 |/
    LDA <r_generic_tmp_counter                                                  ; $00D5EB |\
    ASL A                                                                       ; $00D5ED | | Set the upper left coordinates for the current set of explosions
    TAX                                                                         ; $00D5EE | | by reading the values from ROM.
    LDA bank14.fabul_bombing_coordinates_data.l + coordinates.x,X               ; $00D5EF | |
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00D5F3 | |
    LDA bank14.fabul_bombing_coordinates_data.l + coordinates.y,X               ; $00D5F6 | |
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00D5FA |/
    JSR _init_explosion                                                         ; $00D5FD | Initialize the explosion.
-   JSR _do_tile_animations                                                     ; $00D600 | Wait for the next frame and do any tile animations.
    JSR _set_random_vertical_scroll_offset                                      ; $00D603 | Set the eight pixel vertical scroll offset randomly.
    JSR _draw_explosion                                                         ; $00D606 | Draw the current explosion.
    LDX r_draw_explosion_arg_cycles.w                                           ; $00D609 |\
    CPX #4.w                                                                    ; $00D60C | | Once the explosion reaches the fourth cycle, set the flag to
    BNE +                                                                       ; $00D60F | | suppress new explosions.
    LDA #$01.b                                                                  ; $00D611 | |
    STA <r_draw_explosion_arg_suppress_new                                      ; $00D613 |/
+   CPX #0.w                                                                    ; $00D615 |\ Loop until the cycle counter reaches zero.
    BNE -                                                                       ; $00D618 |/
    INC <r_generic_tmp_counter                                                  ; $00D61A |\
    LDA <r_generic_tmp_counter                                                  ; $00D61C | | Increment the main counter and loop until all eight sets of
    CMP #8.b                                                                    ; $00D61E | | explosions have been animated.
    BNE --                                                                      ; $00D620 |/
    JMP _decode_event_opcode_done                                               ; $00D622

; _decode_event_opcode_custom_effect_circling_bombs ($00:D625)
;
; Handles the circling bombs custom effect, which serves as the second phase of
; the Package cutscene, with four Bombs flying in the sky, circling around the
; village.
_decode_event_opcode_custom_effect_circling_bombs:
    LDA #AUDIO_EFFECT_LONG_FIRE.b                                               ; $00D625 |\ Play a persistent fiery sound effect.
    JSR _play_sound_effect                                                      ; $00D627 |/
    LDA #96.b                                                                   ; $00D62A |\ Set the effect magnitude to 96.
    STA <r_zoom_level                                                           ; $00D62C |/
    STZ <r_generic_tmp_counter                                                  ; $00D62E | Initialize the counter to zero.
    STZ <r_map_frame_counter                                                    ; $00D630 | Initialize the map frame counter to zero.
@outer_loop_start:
    JSR _wait_for_nmi_complete                                                  ; $00D632 | Wait for the next frame.
    LDA <r_map_frame_counter                                                    ; $00D635 |\
    AND #%00011100.b                                                            ; $00D637 | | Set the Y register to a value based on the map frame counter that
    LSR A                                                                       ; $00D639 | | increases by one every 4 frames.
    LSR A                                                                       ; $00D63A | |
    TAY                                                                         ; $00D63B |/
    LDA <r_ppu_color_subtraction_target                                         ; $00D63C |\
    AND #%11100000.b                                                            ; $00D63E | | Set the current intensity of the color effect by reading the
    ORA field_effect_bomb_color_subtraction_intensity_data.w,Y                  ; $00D640 | | data from ROM based on the calculated value.
    STA reg_ppu_coldata.w                                                       ; $00D643 |/
    LDA <r_map_frame_counter                                                    ; $00D646 |\
    AND #%00001111.b                                                            ; $00D648 | | If the current frame mod 16 is zero, increment the other counter.
    BNE +                                                                       ; $00D64A | |
    INC <r_generic_tmp_counter                                                  ; $00D64C |/
+   JSR _init_oam_hi_32_large                                                   ; $00D64E | Set the first 32 sprites as large size.
    STZ <r_field_effect_swirl_current_sprite_lo                                 ; $00D651 | Set the current sprite index to zero.
@inner_loop_start:
    LDA <r_field_effect_swirl_current_sprite_lo                                 ; $00D653 |\
    TAY                                                                         ; $00D655 | | Determine the sprite's X coordinate by reading its individual
    LDA field_effect_bomb_sprite_coordinate_sine_data.w,Y                       ; $00D656 | | sine value, adding the current phase and multiplying by three
    CLC                                                                         ; $00D659 | | before passing that value to the routine that calculates
    ADC r_field_effect_swirl_current_phase.w                                    ; $00D65A | | coordinates.
    STA <r_field_effect_swirl_current_coordinate_lo                             ; $00D65D | |
    ASL A                                                                       ; $00D65F | |
    CLC                                                                         ; $00D660 | |
    ADC <r_field_effect_swirl_current_coordinate_lo                             ; $00D661 | |
    JSR _field_effect_swirl_get_sprite_coordinate                               ; $00D663 | |
    JSR _field_effect_swirl_set_sprite_x_coordinate                             ; $00D666 |/
    LDA <r_field_effect_swirl_current_sprite_lo                                 ; $00D669 |\
    TAY                                                                         ; $00D66B | | The Y coordinate is similar, except the index is calculated by
    LDA field_effect_bomb_sprite_coordinate_sine_data.w,Y                       ; $00D66C | | reading the value from ROM, adding 64, adding the phase and
    CLC                                                                         ; $00D66F | | multiplying by two.
    ADC #64.b                                                                   ; $00D670 | |
    CLC                                                                         ; $00D672 | |
    ADC r_field_effect_swirl_current_phase.w                                    ; $00D673 | |
    ASL A                                                                       ; $00D676 | |
    JSR _field_effect_swirl_get_sprite_coordinate                               ; $00D677 | |
    JSR _field_effect_swirl_set_sprite_y_coordinate                             ; $00D67A |/
    LDA <r_field_effect_swirl_current_sprite_lo                                 ; $00D67D |\
    AND #%00000011.b                                                            ; $00D67F | | Set the tile number to a loaded value based on the low two bits of
    TAX                                                                         ; $00D681 | | the sprite index.
    LDA field_effect_bomb_sprite_tile_data.w,X                                  ; $00D682 | |
    STA r_oam.1.tile.w,Y                                                        ; $00D685 |/
    CMP #FIELD_EFFECT_SPRITE_FIRE.b                                             ; $00D688 |\
    BNE +                                                                       ; $00D68A | | If the sprite is the fire sprite and if the frame counter's third
    LDA <r_map_frame_counter                                                    ; $00D68C | | bit is set, load tile flags for horizontal flip, priority 3,
    AND #%00000100.b                                                            ; $00D68E | | palette 4 and the high name table.
    BEQ +                                                                       ; $00D690 | | BUG: This value is immediately overwritten by the next LDA.
    LDA #%01111001.b                                                            ; $00D692 |/
+   LDA #%00111001.b                                                            ; $00D694 | Otherwise, load similar flags, except without the flip.
    STA r_oam.1.flags.w,Y                                                       ; $00D696 | Set the flags for the sprite.
    INC <r_field_effect_swirl_current_sprite_lo                                 ; $00D699 |\
    LDA <r_field_effect_swirl_current_sprite_lo                                 ; $00D69B | | Increment the sprite index and repeat the inner loop until all 16
    CMP #16.b                                                                   ; $00D69D | | sprites have been updated.
    BEQ +                                                                       ; $00D69F | |
    JMP @inner_loop_start                                                       ; $00D6A1 |/
+   INC r_field_effect_swirl_current_phase.w                                    ; $00D6A4 | Increment the phase value.
    LDA <r_map_frame_counter                                                    ; $00D6A7 |\
    AND #%00000011.b                                                            ; $00D6A9 | | Every four frames, check the value of the secondary counter. If
    BNE ++                                                                      ; $00D6AB | | the value is less than 18, decrement the effect magnitude.
    LDA <r_generic_tmp_counter                                                  ; $00D6AD | | Otherwise, increment the effect magnitude.
    CMP #18.b                                                                   ; $00D6AF | |
    BCS +                                                                       ; $00D6B1 | |
    DEC <r_zoom_level                                                           ; $00D6B3 | |
    JMP ++                                                                      ; $00D6B5 | |
+   INC <r_zoom_level                                                           ; $00D6B8 |/
++  LDA <r_zoom_level                                                           ; $00D6BA |\
    CMP #98.b                                                                   ; $00D6BC | | Loop until the effect magnitude reaches 98.
    BEQ +                                                                       ; $00D6BE | |
    JMP @outer_loop_start                                                       ; $00D6C0 |/
+   LDA #AUDIO_EFFECT_NONE.b                                                    ; $00D6C3 |\ Terminate the sound effect.
    JSR _play_sound_effect                                                      ; $00D6C5 |/
    JMP _decode_event_opcode_done                                               ; $00D6C8

; field_effect_bomb_color_subtraction_intensity_data ($00:D6CB)
;
; Eight different values of intensity used by the bomb effect to determine the
; intensity of the color subtraction effect.
field_effect_bomb_color_subtraction_intensity_data:
    .db 20                                                                      ; $00D6CB
    .db 24                                                                      ; $00D6CC
    .db 28                                                                      ; $00D6CD
    .db 31                                                                      ; $00D6CE
    .db 28                                                                      ; $00D6CF
    .db 24                                                                      ; $00D6D0
    .db 20                                                                      ; $00D6D1
    .db 16                                                                      ; $00D6D2

; field_effect_bomb_sprite_coordinate_sine_data ($00:D6D3)
;
; For each of the 16 sprites during the seocnd phase of the Package bomb effect,
; contains the base index used to generate the sine indexes for that sprite's
; coordinates.
field_effect_bomb_sprite_coordinate_sine_data:
    .db $06                                                                     ; $00D6D3
    .db $04                                                                     ; $00D6D4
    .db $02                                                                     ; $00D6D5
    .db $00                                                                     ; $00D6D6
    .db $46                                                                     ; $00D6D7
    .db $44                                                                     ; $00D6D8
    .db $42                                                                     ; $00D6D9
    .db $40                                                                     ; $00D6DA
    .db $86                                                                     ; $00D6DB
    .db $84                                                                     ; $00D6DC
    .db $82                                                                     ; $00D6DD
    .db $80                                                                     ; $00D6DE
    .db $C6                                                                     ; $00D6DF
    .db $C4                                                                     ; $00D6E0
    .db $C2                                                                     ; $00D6E1
    .db $C0                                                                     ; $00D6E2

; field_effect_bomb_sprite_tile_data ($00:D6E3)
;
; For each fo the four sprites of each segment of the Package bomb effect,
; determines the tile number of the sprite.
field_effect_bomb_sprite_tile_data:
    .db FIELD_EFFECT_SPRITE_BOMB                                                ; $00D6E3
    .db FIELD_EFFECT_SPRITE_FIRE                                                ; $00D6E4
    .db FIELD_EFFECT_SPRITE_FIRE                                                ; $00D6E5
    .db FIELD_EFFECT_SPRITE_FIRE                                                ; $00D6E6

; _field_effect_swirl_set_sprite_x_coordinate ($00:D6E7)
;
; Given the low byte of a sprite X coordinate in the accumulator, the high byte
; in $23, and the offset for the desired sprite in the Y register, sets the X
; coordinate for that sprite, including setting the high bit if necessary.
_field_effect_swirl_set_sprite_x_coordinate:
    STA r_oam.1.x.w,Y                                                           ; $00D6E7 | Set the X coordinate to the passed parameter.
    LDA <r_field_effect_swirl_current_coordinate_hi                             ; $00D6EA |\
    AND #%00000001.b                                                            ; $00D6EC | | If the value is negative, set the high X coordinate bit in the
    BEQ +                                                                       ; $00D6EE | | high OAM, to treat the coordinate as negative.
    LDA #0.b                                                                    ; $00D6F0 | |
    JSL bank15.set_oam_hi_x                                                     ; $00D6F2 |/
+   RTS                                                                         ; $00D6F6

; _field_effect_swirl_set_sprite_y_coordinate ($00:D6F7)
;
; Given the sprite Y coordinate in $0623 and the offset for the desired sprite
; in the Y register, sets the Y coordinate for that sprite, ensuring sprites
; that should not be visible are set to an out of range coordinate.
_field_effect_swirl_set_sprite_y_coordinate:
    LDX <r_field_effect_swirl_current_coordinate                                ; $00D6F7 |\
    CPX #$3FF0.w                                                                ; $00D6F9 | | If the calculated coordinate is outside the range -16 to 239, set
    BCS +                                                                       ; $00D6FC | | the coordinate explicitly to 240.
    CPX #$00F0.w                                                                ; $00D6FE | |
    BCC +                                                                       ; $00D701 | |
    LDA #240.b                                                                  ; $00D703 | |
    STA r_oam.1.y.w,Y                                                           ; $00D705 | |
    JMP ++                                                                      ; $00D708 |/
+   LDA <r_field_effect_swirl_current_coordinate_lo                             ; $00D70B |\ Otherwise, use the low byte of the calculated value.
    STA r_oam.1.y.w,Y                                                           ; $00D70D |/
++  RTS                                                                         ; $00D710

; _decode_event_opcode_custom_effect_bomb_swirl ($00:D711)
;
; Custom effect for the swirling Bomb effect during the Package cutscene.
_decode_event_opcode_custom_effect_bomb_swirl:
    STZ <r_zoom_level                                                           ; $00D711 | Initialize the effect magnitude to zero.
    LDX #0.w                                                                    ; $00D713 |\ Set the current phase to zero.
    STX r_field_effect_swirl_current_phase.w                                    ; $00D716 |/
    STX <r_field_effect_counter                                                 ; $00D719 | Set the counter to zero.
    LDA #FIELD_EFFECT_SPRITE_BOMB.b                                             ; $00D71B |\ Set the tile to the bomb sprite.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00D71D |/
    LDA #8.b                                                                    ; $00D71F |\ Set the sprite count to 8.
    STA <r_field_effect_sprite_arg_count                                        ; $00D721 |/
    LDA #%00111001.b                                                            ; $00D723 |\ Set the tile flags for priority 3, palette 4 and the high name
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00D725 |/ table.
-   JSR _wait_for_nmi_complete                                                  ; $00D727 | Wait for the next frame.
    JSR _field_effect_swirl_update_sprites                                      ; $00D72A | Update the swirl effect sprites.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00D72D |\
    LDA r_field_effect_swirl_current_phase.w                                    ; $00D72F | | Increment the phase by one.
    INC A                                                                       ; $00D732 | |
    STA r_field_effect_swirl_current_phase.w                                    ; $00D733 |/
    LDA <r_field_effect_counter                                                 ; $00D736 |\
    INC A                                                                       ; $00D738 | | Increment the counter by one.
    STA <r_field_effect_counter                                                 ; $00D739 |/
    LSR A                                                                       ; $00D73B |\
    LSR A                                                                       ; $00D73C | | Set the new magnitude to the counter divided by four taken mod
    AND #$00FF.w                                                                ; $00D73D | | 256.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00D740 | |
    STA <r_zoom_level                                                           ; $00D742 |/
    CMP #95.b                                                                   ; $00D744 |\
    BEQ +                                                                       ; $00D746 | | Loop until the magnitude reaches 95.
    JMP -                                                                       ; $00D748 |/
+   JMP _decode_event_opcode_done                                               ; $00D74B

; _decode_event_opcode_custom_effect_swirl_sparkle ($00:D74E)
;
; Handles the custom effect that does a swirling sparkle effect.
_decode_event_opcode_custom_effect_swirl_sparkle:
    LDA #%00111001.b                                                            ; $00D74E |\ Set the sprite flags to have priority 3, using palette 4 and using
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00D750 |/ the high name table.
    LDA #FIELD_EFFECT_SPRITE_SPARKLE.b                                          ; $00D752 |\ Set the effect sprite to the sparkle and render the effect.
    JMP _decode_event_opcode_custom_effect_swirl_common                         ; $00D754 |/

; _decode_event_opcode_custom_effect_swirl_mist ($00:D757)
;
; Handles the custom effect that does a swirling mist effect.
_decode_event_opcode_custom_effect_swirl_mist:
    LDA #%00110101.b                                                            ; $00D757 |\ Set the sprite flags to have priority 3, using palette 2 and using
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00D759 |/ the high name table.
    LDA #FIELD_EFFECT_SPRITE_MIST.b                                             ; $00D75B | Set the effect sprite to the mist sprite and fall through.

; _decode_event_opcode_custom_effect_swirl_common ($00:D75D)
;
; This is code common to both the Mist and sparkle swirl effects.
_decode_event_opcode_custom_effect_swirl_common:
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00D75D |/
    LDA #95.b                                                                   ; $00D75F |\ Set the magnitude of the effect to 95. The set value here is
    STA <r_zoom_level                                                           ; $00D761 |/ actually half the ultimate magnitude in pixels.
    LDX #380.w                                                                  ; $00D763 |\
    STX r_field_effect_swirl_current_phase.w                                    ; $00D766 | | Initialize the phase parameter and counter to 380, which aligns
    STX <r_field_effect_counter                                                 ; $00D769 |/  with the initial zoom level number.
    LDA #16.b                                                                   ; $00D76B |\ Draw sixteen sprites.
    STA <r_field_effect_sprite_arg_count                                        ; $00D76D |/
-   JSR _do_tile_animations                                                     ; $00D76F | Do any tile animations.
    JSR _field_effect_swirl_update_sprites                                      ; $00D772 | Update the swirl effect sprites.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00D775 |\
    LDA r_field_effect_swirl_current_phase.w                                    ; $00D777 | | Decrement the phase by two.
    DEC A                                                                       ; $00D77A | |
    DEC A                                                                       ; $00D77B | |
    STA r_field_effect_swirl_current_phase.w                                    ; $00D77C |/
    LDA <r_field_effect_counter                                                 ; $00D77F |\
    DEC A                                                                       ; $00D781 | | Decrement the counter by two.
    DEC A                                                                       ; $00D782 | |
    STA <r_field_effect_counter                                                 ; $00D783 |/
    LSR A                                                                       ; $00D785 |\
    LSR A                                                                       ; $00D786 | | Set the current magnitude of the effect to the counter divided by
    AND #$00FF.w                                                                ; $00D787 | | four, taken mod 256.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00D78A | |
    STA <r_zoom_level                                                           ; $00D78C |/
    BEQ +                                                                       ; $00D78E |\ Loop until the magnitude reaches zero.
    JMP -                                                                       ; $00D790 |/
+   JSR _init_oam_lower                                                         ; $00D793 | Reset the OAM.
    JMP _decode_event_opcode_done                                               ; $00D796

; _field_effect_swirl_update_sprites ($00:D799)
;
; Updates the sprites in the swirl effect.
_field_effect_swirl_update_sprites:
    JSR _init_oam_hi_32_large                                                   ; $00D799 | Set the first 32 sprites to 16x16.
    STZ <r_field_effect_swirl_current_sprite_lo                                 ; $00D79C |\ Initialize the current sprite index to zero.
    STZ <r_field_effect_swirl_current_sprite_hi                                 ; $00D79E |/
@loop_start:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00D7A0 |\
    LDA <r_field_effect_swirl_current_sprite                                    ; $00D7A2 | | Determine the current sine index for the current sprite. This is a
    ASL A                                                                       ; $00D7A4 | | slightly complicated calculation that ensures that the sprites
    ASL A                                                                       ; $00D7A5 | | with higher indexes rotate faster. The multiplication essentially
    ASL A                                                                       ; $00D7A6 | | multiplies the current phase by a value starting at 1, depending
    ASL A                                                                       ; $00D7A7 | | on the sprite index.
    ASL A                                                                       ; $00D7A8 | |
    CLC                                                                         ; $00D7A9 | |
    ADC #$0100.w                                                                ; $00D7AA | |
    STA <r_bank15_math_multiply_16bit_arg_1                                     ; $00D7AD | |
    LDA r_field_effect_swirl_current_phase.w                                    ; $00D7AF | |
    STA <r_bank15_math_multiply_16bit_arg_2                                     ; $00D7B2 | |
    LDA #0.w                                                                    ; $00D7B4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00D7B7 | |
    JSL bank15.math_multiply_16bit                                              ; $00D7B9 |/
    LDA <r_bank15_math_multiply_16bit_result_md                                 ; $00D7BD |\
    JSR _field_effect_swirl_get_sprite_coordinate                               ; $00D7BF | | Set the X coordinate of the sprite.
    JSR _field_effect_swirl_set_sprite_x_coordinate                             ; $00D7C2 |/
    LDA <r_bank15_math_multiply_16bit_result_md                                 ; $00D7C5 |\
    CLC                                                                         ; $00D7C7 | | Add 64 to the sine index to rotate 90 degrees and use that to set
    ADC #64.b                                                                   ; $00D7C8 | | the Y coordinate of the sprite.
    JSR _field_effect_swirl_get_sprite_coordinate                               ; $00D7CA | |
    JSR _field_effect_swirl_set_sprite_y_coordinate                             ; $00D7CD |/
    LDA <r_field_effect_sprite_arg_tile_base                                    ; $00D7D0 |\
    CMP #FIELD_EFFECT_SPRITE_SPARKLE.b                                          ; $00D7D2 | | If the base tile number is $C0, add either 0 or 2 to the tile
    BNE +                                                                       ; $00D7D4 | | number depending on the current value of the map frame counter,
    LDA <r_map_frame_counter                                                    ; $00D7D6 | | such that it changes every two frames.
    AND #%00000010.b                                                            ; $00D7D8 | |
    CLC                                                                         ; $00D7DA | |
    ADC <r_field_effect_sprite_arg_tile_base                                    ; $00D7DB |/
+   STA r_oam.1.tile.w,Y                                                        ; $00D7DD | Set the tile to the loaded value.
    LDA <r_field_effect_sprite_arg_tile_flags                                   ; $00D7E0 |\ Set the sprite flags.
    STA r_oam.1.flags.w,Y                                                       ; $00D7E2 |/
    INC <r_field_effect_swirl_current_sprite                                    ; $00D7E5 |\
    LDA <r_field_effect_swirl_current_sprite                                    ; $00D7E7 | | Increment the sprite index and loop until it reaches the maximum.
    CMP <r_field_effect_sprite_arg_count                                        ; $00D7E9 | |
    BEQ +                                                                       ; $00D7EB | |
    JMP @loop_start                                                             ; $00D7ED |/
+   RTS                                                                         ; $00D7F0

; _field_effect_swirl_get_sprite_coordinate ($00:D7F1)
;
; Given a value in the accumulator that corresponds to a position in a sine wave
; with a period of 256, calculates the appropriate coordinate for that value.
; The returned values are centered around 112. The full 16-bit result is stored
; in $22, but the low byte is loaded into the accumulator. The Y register is
; set to the current sprite index in $0620 times four. Note that if the value
; is negative, the full 16-bit value is not properly sign extended.cv g
_field_effect_swirl_get_sprite_coordinate:
    JSR _field_effect_swirl_get_sine_value                                      ; $00D7F1 | Get the sine value for the passed parameter.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00D7F4 |\
    TYA                                                                         ; $00D7F6 | | Divide the returned value by four, add 112, and save that in the
    LSR A                                                                       ; $00D7F7 | | result variable. If the sine value was negative, the upper byte
    LSR A                                                                       ; $00D7F8 | | won't be properly sign extended, but with the range of values
    CLC                                                                         ; $00D7F9 | | being worked with here, that's fine.
    ADC #112.w                                                                  ; $00D7FA | |
    STA <r_field_effect_swirl_current_coordinate                                ; $00D7FD | |
    LDA #0.w                                                                    ; $00D7FF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00D802 |/
    LDA <r_field_effect_swirl_current_sprite_lo                                 ; $00D804 |\
    ASL A                                                                       ; $00D806 | | Set the Y register to the current sprite times four (to index OAM
    ASL A                                                                       ; $00D807 | | data).
    TAY                                                                         ; $00D808 |/
    LDA <r_field_effect_swirl_current_coordinate_lo                             ; $00D809 | Load the coordinate mod 256 into the accumulator.
    RTS                                                                         ; $00D80B

; _init_oam_hi_32_large ($00:D80C)
;
; Sets bits in the high OAM table to make the first thirty-two sprites be 16x16
; instead of 8x8.
_init_oam_hi_32_large:
    LDA #%10101010.b                                                            ; $00D80C |\
    LDX #0.w                                                                    ; $00D80E | | Set the sprite size flag for the first 32 OAM entries to large.
-   STA r_oam_hi.w,X                                                            ; $00D811 | |
    INX                                                                         ; $00D814 | |
    CPX #(32 / 4).w                                                             ; $00D815 | |
    BNE -                                                                       ; $00D818 |/
    RTS                                                                         ; $00D81A

; _decode_event_opcode_custom_effect_red_wings_north_over_ordeals ($00:D81B)
;
; Executes the first event sequence of the game, which shows the Red Wings
; flying north over Mt.Ordeals toward Fabul. Because that's totally the way to
; Baron from Mysidia.
_decode_event_opcode_custom_effect_red_wings_north_over_ordeals:
    LDA #225.b                                                                  ; $00D81B |\
    STA r_current_coordinates.x.w                                               ; $00D81D | | Set the initial coordinates to 225, 254 (south of Mt.Ordeals).
    LDA #254.b                                                                  ; $00D820 | |
    STA r_current_coordinates.y.w                                               ; $00D822 |/
    JSR _show_enterprise_on_overworld                                           ; $00D825 | Change map to the overworld and set the vehicle to the Enterprise.
    LDX #$0080.w                                                                ; $00D828 |\ Wait for 128 frames.
    JSR _wait_for_x_frames                                                      ; $00D82B |/
-   JSR _wait_for_nmi_complete_field                                            ; $00D82E |\
    JSR _ppu_increase_brightness                                                ; $00D831 | | Show the five Red Wings airships traveling upward, while
    LDA #JOYPAD_H_UP.b                                                          ; $00D834 | | increasing brightness until it reaches full brightness. Ensure
    STA <r_joypad_cutscene_hi                                                   ; $00D836 | | player movement calculation is enabled.
    LDA #1.b                                                                    ; $00D838 | |
    STA <r_player_movement_calculation_enabled                                  ; $00D83A | |
    JSR _draw_opening_red_wings                                                 ; $00D83C | |
    LDA <r_ppu_brightness                                                       ; $00D83F | |
    CMP #$0F.b                                                                  ; $00D841 | |
    BNE -                                                                       ; $00D843 |/
    LDX #$01E0.w                                                                ; $00D845 |\
    STX <r_decode_event_opcode_red_wings_north_over_ordeals_index               ; $00D848 | | Continue traveling up for another 480 frames.
-   JSR _wait_for_nmi_complete_field                                            ; $00D84A | |
    LDA #JOYPAD_H_UP.b                                                          ; $00D84D | |
    STA <r_joypad_cutscene_hi                                                   ; $00D84F | |
    JSR _draw_opening_red_wings                                                 ; $00D851 | |
    LDX <r_decode_event_opcode_red_wings_north_over_ordeals_index               ; $00D854 | |
    DEX                                                                         ; $00D856 | |
    STX <r_decode_event_opcode_red_wings_north_over_ordeals_index               ; $00D857 | |
    BNE -                                                                       ; $00D859 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00D85B |\
    JSR _ppu_decrease_brightness                                                ; $00D85E | | Decrease the brightness every eight frames until it reaches zero,
    LDA #JOYPAD_H_UP.b                                                          ; $00D861 | | while continuing to move upward.
    STA <r_joypad_cutscene_hi                                                   ; $00D863 | |
    JSR _draw_opening_red_wings                                                 ; $00D865 | |
    LDA <r_ppu_brightness                                                       ; $00D868 | |
    BNE -                                                                       ; $00D86A |/
    LDA #MAP_AREA_DUNGEON.b                                                     ; $00D86C |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $00D86E |/
    STZ <r_movement_speed                                                       ; $00D871 | Set the movement speed to walking speed.
    STZ r_vehicle.w                                                             ; $00D873 | Set the vehicle to no vehicle.
    JMP _decode_event_opcode_done                                               ; $00D876

; _decode_event_opcode_custom_effect_red_wings_baron_landing ($00:D879)
;
; Animates the Red Wings flying north over Agart to Baron, where they begin to
; land.
_decode_event_opcode_custom_effect_red_wings_baron_landing:
    LDA #101.b                                                                  ; $00D879 |\
    STA r_current_coordinates.x.w                                               ; $00D87B | | Set the current coordinates to 101, 0 (somewhat south of Agart).
    LDA #0.b                                                                    ; $00D87E | |
    STA r_current_coordinates.y.w                                               ; $00D880 |/
    JSR _show_enterprise_on_overworld                                           ; $00D883 | Switch to showing the Enterprise on the overworld.
-   JSR _wait_for_nmi_complete_field                                            ; $00D886 |\
    JSR _ppu_increase_brightness                                                ; $00D889 | | Loop, increasing the brightness each frame, while the Red Wings
    LDA #JOYPAD_H_UP.b                                                          ; $00D88C | | fly north, until the brightness reaches maximum. The PPU will
    STA <r_joypad_cutscene_hi                                                   ; $00D88E | | increase brightness every eight frames, so this segment takes a
    JSR _draw_opening_red_wings                                                 ; $00D890 | | total of 128 frames.
    LDA <r_ppu_brightness                                                       ; $00D893 | |
    CMP #$0F.b                                                                  ; $00D895 | |
    BNE -                                                                       ; $00D897 |/
    LDX #272.w                                                                  ; $00D899 |\
    STX <r_generic_frame_counter                                                ; $00D89C | | Loop for 272 frames, continuing to fly the Red Wings north. After
-   JSR _wait_for_nmi_complete_field                                            ; $00D89E | | this and the previous segment, the airships will have traveled
    LDA #JOYPAD_H_UP.b                                                          ; $00D8A1 | | 100 tiles, which places them directly above Baron.
    STA <r_joypad_cutscene_hi                                                   ; $00D8A3 | |
    JSR _draw_opening_red_wings                                                 ; $00D8A5 | |
    LDX <r_generic_frame_counter                                                ; $00D8A8 | |
    DEX                                                                         ; $00D8AA | |
    STX <r_generic_frame_counter                                                ; $00D8AB | |
    BNE -                                                                       ; $00D8AD |/
    LDX #64.w                                                                   ; $00D8AF |\
    STX <r_generic_frame_counter                                                ; $00D8B2 | | Loop for 64 frames, doing nothing.
-   JSR _wait_for_nmi_complete_field                                            ; $00D8B4 | |
    STZ <r_joypad_cutscene_hi                                                   ; $00D8B7 | |
    JSR _draw_opening_red_wings                                                 ; $00D8B9 | |
    LDX <r_generic_frame_counter                                                ; $00D8BC | |
    DEX                                                                         ; $00D8BE | |
    STX <r_generic_frame_counter                                                ; $00D8BF | |
    BNE -                                                                       ; $00D8C1 |/
    JSR _audio_fade_out_slow                                                    ; $00D8C3 | Begin to fade out the audio slowly.
-   JSR _wait_for_nmi_complete_field                                            ; $00D8C6 |\
    STZ <r_joypad_cutscene_hi                                                   ; $00D8C9 | | Loop, decreasing the brightness, and setting the zoom level based
    JSR _ppu_decrease_brightness                                                ; $00D8CB | | on the brightness to produce a landing while fading out effect.
    LDA <r_ppu_brightness                                                       ; $00D8CE | |
    CLC                                                                         ; $00D8D0 | |
    ADC #16.b                                                                   ; $00D8D1 | |
    STA <r_zoom_level                                                           ; $00D8D3 | |
    JSR _draw_opening_red_wings                                                 ; $00D8D5 | |
    LDA <r_ppu_brightness                                                       ; $00D8D8 | |
    BNE -                                                                       ; $00D8DA |/
    LDA #MAP_AREA_DUNGEON.b                                                     ; $00D8DC |\ Set the map area to dungeon.
    STA r_map_area.w                                                            ; $00D8DE |/
    STZ <r_movement_speed                                                       ; $00D8E1 | Set the movement speed to walking.
    STZ r_vehicle.w                                                             ; $00D8E3 | Unset the vehicle byte.
    JMP _decode_event_opcode_done                                               ; $00D8E6

; _draw_opening_red_wings ($00:D8E9)
;
; Draws the fleet of Red Wings airships during the opening sequence. Also
; calculates movement direction and executes that movement, which means that in
; theory, no other function should do so during this frame.
_draw_opening_red_wings:
    JSR _init_oam                                                               ; $00D8E9 | Initialize the OAM.
    STZ <r_joypad_cutscene_lo                                                   ; $00D8EC | Set the cutscene joypad low byte to zero.
    LDA #1.b                                                                    ; $00D8EE |\ Enable calculation of player movement.
    STA <r_player_movement_calculation_enabled                                  ; $00D8F0 |/
    JSR _calculate_outdoor_movement_direction                                   ; $00D8F2 | Calculate the movement direction.
    JSR _do_outdoor_movement                                                    ; $00D8F5 | Execute the movement, if any.
    LDY #$0000.w                                                                ; $00D8F8 | Initialize the Y register to zero.
-   TYA                                                                         ; $00D8FB |\
    LSR A                                                                       ; $00D8FC | | Determine the X register by dividing the Y register by 8. (Divide
    LSR A                                                                       ; $00D8FD | | by 16 and then multiply by 2, as each entry has 2 bytes.)
    LSR A                                                                       ; $00D8FE | |
    TAX                                                                         ; $00D8FF |/
    LDA opening_red_wings_coordinate_data.w,X                                   ; $00D900 |\ Set the airship and shadow X coordinate.
    STA <r_generic_arg_x_lo                                                     ; $00D903 |/
    LDA opening_red_wings_coordinate_data.w + 1,X                               ; $00D905 |\ Set the airship and shadow Y coordinate.
    STA <r_generic_arg_y_lo                                                     ; $00D908 |/
    JSR _draw_field_sprite_shadow                                               ; $00D90A | Draw the airship's shadow.
    LDA #%00011100.b                                                            ; $00D90D |\ Set the flags to set the low priority bit and set the palette to 6.
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00D90F |/
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00D911 |\ Set the base tile offset to the Enterprise.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00D913 |/
    STZ <r_generic_arg_x_hi                                                     ; $00D915 |\ Zero out the high coordinate bytes.
    STZ <r_generic_arg_y_hi                                                     ; $00D917 |/
    STZ <r_field_effect_sprite_arg_tile_offset                                  ; $00D919 | Zero the tile offset (draw the airships going up).
    JSR _draw_vehicle_sprite                                                    ; $00D91B | Draw the airship.
    CPY #$0050.w                                                                ; $00D91E |\ Repeat until all five have been drawn.
    BNE -                                                                       ; $00D921 |/
    RTS                                                                         ; $00D923

; _ppu_decrease_brightness ($00:D924)
;
; Decreases the PPU brightness by one step if the current map frame counter is
; a multiple of eight.
_ppu_decrease_brightness:
    LDA <r_map_frame_counter                                                    ; $00D924 |\
    AND #%00000111.b                                                            ; $00D926 | | Only change brightness if the frame counter mod 8 is zero.
    BNE +                                                                       ; $00D928 |/
    LDA <r_ppu_brightness                                                       ; $00D92A |\
    BEQ +                                                                       ; $00D92C | | Decrease the brightness unless it's already at zero. Always set
    DEC <r_ppu_brightness                                                       ; $00D92E | | the register with the value stored in RAM.
+   LDA <r_ppu_brightness                                                       ; $00D930 | |
    STA reg_ppu_inidisp                                                         ; $00D932 |/
    RTS                                                                         ; $00D935

; _ppu_increase_brightness ($00:D936)
;
; Increases the PPU brightness by one step if the current map frame counter is
; a multiple of eight.
_ppu_increase_brightness:
    LDA <r_map_frame_counter                                                    ; $00D936 |\
    AND #%00000111.b                                                            ; $00D938 | | Only change brightness if the frame counter mod 8 is zero.
    BNE +                                                                       ; $00D93A |/
    LDA <r_ppu_brightness                                                       ; $00D93C |\
    CMP #$0F.b                                                                  ; $00D93E | | If the current brightness is less than $0F, increment the value
    BEQ +                                                                       ; $00D940 | | in RAM.
    INC <r_ppu_brightness                                                       ; $00D942 |/
+   LDA <r_ppu_brightness                                                       ; $00D944 |\ Load the brightness stored in RAM and set the register.
    STA reg_ppu_inidisp                                                         ; $00D946 |/
    RTS                                                                         ; $00D949

; _show_enterprise_on_overworld ($00:D94A)
;
; Loads the overworld map and sets the current vehicle to the Enterprise. The
; vehicle speed is set to half the normal airship speed. The screen is left
; with zero brightness.
_show_enterprise_on_overworld:
    STZ r_map_area.w                                                            ; $00D94A | Set the map area to 0 (overworld).
    LDA #VEHICLE_ENTERPRISE.b                                                   ; $00D94D |\ Set the current vehicle to the Enterprise.
    STA r_vehicle.w                                                             ; $00D94F |/
    JSR _change_map_overworld                                                   ; $00D952 | Change the map to the overworld.
    LDA #$20.b                                                                  ; $00D955 |\ Set the zoom level to $20 (full zoom for Enterprise).
    STA <r_zoom_level                                                           ; $00D957 |/
    LDA #$10.b                                                                  ; $00D959 |\ Set the zoom palette level to $10 (fully zoomed out).
    JSL bank15.set_zoom_palette                                                 ; $00D95B |/
    LDA #2.b                                                                    ; $00D95F |\ Set movement speed to 2^2 pixels per frame (4 frames per tile).
    STA <r_movement_speed                                                       ; $00D961 |/ This is half of the usual airship speed.
    LDA #%10000001.b                                                            ; $00D963 |\ Enable NMI and joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00D965 |/
    STZ reg_ppu_inidisp                                                         ; $00D968 |\ Set brightness to zero and disable forced blanking.
    STZ <r_ppu_brightness                                                       ; $00D96B |/
    STZ <r_movement_frame_counter                                               ; $00D96D |\ Zero out two of the frame counters.
    STZ <r_map_frame_counter                                                    ; $00D96F |/
    RTS                                                                         ; $00D971

; opening_red_wings_coordinate_data ($00:D972)
;
; The on-screen coordinates of the Red Wings airships during the opening scene.
opening_red_wings_coordinate_data:
    .db 112, 112                                                                ; $00D972
    .db 100, 124                                                                ; $00D974
    .db 124, 124                                                                ; $00D976
    .db  84, 140                                                                ; $00D978
    .db 140, 140                                                                ; $00D97A

; _decode_event_opcode_custom_effect_land_enterprise ($00:D97C)
;
; Custom effect to land the Enterprise at its current coordinates.
_decode_event_opcode_custom_effect_land_enterprise:
    LDA #TILE_PROPERTY_2_OUTDOOR_AIRSHIP_LAND.b                                 ; $00D97C |\ Set the tile property to ensure the Enterprise can land here.
    STA <r_tile_properties_current.properties_2                                 ; $00D97E |/
    JSR _land_enterprise                                                        ; $00D980 | Land the Enterprise.
    JMP _decode_event_opcode_done                                               ; $00D983

; _decode_event_opcode_custom_effect_red_airship_from_right ($00:D986)
;
; Custom effect that displays the Enterprise as well as a Red Wings airship that
; flies in from the right.
_decode_event_opcode_custom_effect_red_airship_from_right:
    LDX #256.w                                                                  ; $00D986 |\
    STX <r_generic_arg_coordinates.x                                            ; $00D989 | | Initialize the Red Wings airship coordinates to 256, 112.
    LDX #112.w                                                                  ; $00D98B | |
    STX <r_generic_arg_coordinates.y                                            ; $00D98E |/
    LDX #208.w                                                                  ; $00D990 |\ Initialize the frame counter to 208.
    STX <r_generic_frame_counter                                                ; $00D993 |/
-   JSR _draw_enterprise_and_red_airship                                        ; $00D995 | Draw the Enterprise and Red Wings airship for this frame.
    LDX <r_generic_arg_coordinates.x                                            ; $00D998 |\
    DEX                                                                         ; $00D99A | | Decrement the X coordinate, and if it goes below 112, reset it to
    STX <r_generic_arg_coordinates.x                                            ; $00D99B | | 112.
    CPX #112.w                                                                  ; $00D99D | |
    BCS +                                                                       ; $00D9A0 | |
    LDX #112.w                                                                  ; $00D9A2 | |
    STX <r_generic_arg_coordinates.x                                            ; $00D9A5 |/
+   LDX <r_generic_frame_counter                                                ; $00D9A7 |\
    DEX                                                                         ; $00D9A9 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00D9AA | |
    BNE -                                                                       ; $00D9AC |/
    JMP _decode_event_opcode_done                                               ; $00D9AE

; _decode_event_opcode_custom_effect_red_airship_to_left ($00:D9B1)
;
; Custom effect that displays the Enterprise as well as a red airship that flies
; off to the left.
_decode_event_opcode_custom_effect_red_airship_to_left:
    LDX #112.w                                                                  ; $00D9B1 |\
    STX <r_generic_arg_coordinates.x                                            ; $00D9B4 | | Initialize the red airship coordinates to 112, 112.
    LDX #112.w                                                                  ; $00D9B6 | |
    STX <r_generic_arg_coordinates.y                                            ; $00D9B9 |/
    LDX #208.w                                                                  ; $00D9BB |\ Initialize the frame counter to 208.
    STX <r_generic_frame_counter                                                ; $00D9BE |/
-   JSR _draw_enterprise_and_red_airship                                        ; $00D9C0 | Draw the Enterprise and red airship for this frame.
    LDX <r_generic_frame_counter                                                ; $00D9C3 |\
    DEX                                                                         ; $00D9C5 | | Decrement the frame counter, and if the value is still 128 or
    STX <r_generic_frame_counter                                                ; $00D9C6 | | greater, branch back to start the loop again.
    CPX #128.w                                                                  ; $00D9C8 | |
    BCS -                                                                       ; $00D9CB |/
    LDX <r_generic_arg_coordinates.x                                            ; $00D9CD |\
    DEX                                                                         ; $00D9CF | | Otherwise, decrement the red airship X coordinate and loop until
    STX <r_generic_arg_coordinates.x                                            ; $00D9D0 | | it reaches -16.
    CPX #-16.w                                                                  ; $00D9D2 | |
    BNE -                                                                       ; $00D9D5 |/
    JMP _decode_event_opcode_done                                               ; $00D9D7

; _decode_event_opcode_custom_effect_enterprise_red_airship_rising ($00:D9DA)
;
; Custom effect for the Enterprise and a red airship rising to the top of the
; screen. This routine suffers from a bug that causes it to draw the red airship
; using the Falcon sprite, rather than the Enterprise sprite. This causes a
; discontinuity during the cutscene immediately preceding the visit to Zot.
_decode_event_opcode_custom_effect_enterprise_red_airship_rising:
    LDX #112.w                                                                  ; $00D9DA |\
    STX <r_generic_arg_coordinates.x                                            ; $00D9DD | | Initialize the coordinates to 112, 120.
    LDX #120.w                                                                  ; $00D9DF | |
    STX <r_generic_arg_coordinates.y                                            ; $00D9E2 |/
    LDX #208.w                                                                  ; $00D9E4 |\ Initialize the frame counter to 208.
    STX <r_generic_frame_counter                                                ; $00D9E7 |/
@loop_start:
    JSR _wait_for_nmi_complete_field                                            ; $00D9E9 | Wait for the next complete NMI.
    LDA <r_generic_arg_coordinates.y.lo                                         ; $00D9EC |\
    CMP #16.b                                                                   ; $00D9EE | | If the frame counter has reached less than 16, set the PPU
    BCS +                                                                       ; $00D9F0 | | brightness to that value.
    STA reg_ppu_inidisp.w                                                       ; $00D9F2 |/
+   JSR _draw_enterprise                                                        ; $00D9F5 | Draw the Enterprise to the current coordinates.
    LDX <r_generic_arg_coordinates.x                                            ; $00D9F8 |\
    STX <r_generic_arg_x                                                        ; $00D9FA | | Calculate new coordinates that are 8 pixels above the Enterprise
    LDA <r_generic_arg_coordinates.y.lo                                         ; $00D9FC | | coordinates.
    SEC                                                                         ; $00D9FE | |
    SBC #8.b                                                                    ; $00D9FF | |
    STA <r_generic_arg_y_lo                                                     ; $00DA01 | |
    LDA <r_generic_arg_coordinates.y.hi                                         ; $00DA03 | |
    SBC #0.b                                                                    ; $00DA05 | |
    STA <r_generic_arg_y_hi                                                     ; $00DA07 |/
    LDA #%00011100.b                                                            ; $00DA09 |\ Set the tile flags to use the red palette (palette 4) and priority
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DA0B |/ 1.
    LDA #TILE_BASE_FALCON.b                                                     ; $00DA0D |\ BUG: Set the base tile to the Falcon (should be the Enterprise for
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DA0F |/      consistency.)
    LDY #_sizeof_oam_sprite.w * 100                                             ; $00DA11 | Use OAM entries starting at 100.
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00DA14 |\ Set the tile offset to draw the vehicle facing left.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DA16 |/
    JSR _draw_vehicle_sprite                                                    ; $00DA18 | Draw the red airship.
    LDY #112.w                                                                  ; $00DA1B |\
    STY <r_generic_arg_y                                                        ; $00DA1E | | Draw one shadow at a Y coordinate of 112.
    LDY #_sizeof_oam_sprite.w * 84                                              ; $00DA20 | |
    JSR _draw_field_sprite_shadow                                               ; $00DA23 |/
    LDY #104.w                                                                  ; $00DA26 |\
    STY <r_generic_arg_y                                                        ; $00DA29 | | Draw another shadow at a Y coordinate of 104.
    LDY #_sizeof_oam_sprite.w * 88                                              ; $00DA2B | |
    JSR _draw_field_sprite_shadow                                               ; $00DA2E |/
    LDX <r_generic_frame_counter                                                ; $00DA31 |\
    DEX                                                                         ; $00DA33 | | Decrement the frame counter and if it's still 128 or greater,
    STX <r_generic_frame_counter                                                ; $00DA34 | | jump to the next iteration.
    CPX #128.w                                                                  ; $00DA36 | |
    BCS @loop_start                                                             ; $00DA39 |/
    LDX <r_generic_arg_coordinates.y                                            ; $00DA3B |\
    DEX                                                                         ; $00DA3D | | Otherwise, decrement the Y coordinate and loop until it reaches
    STX <r_generic_arg_coordinates.y                                            ; $00DA3E | | zero.
    CPX #0.w                                                                    ; $00DA40 | |
    BNE @loop_start                                                             ; $00DA43 |/
    STZ <r_ppu_brightness                                                       ; $00DA45 | Set the PPU brightness to zero.
    JMP _decode_event_opcode_done                                               ; $00DA47

; _decode_event_opcode_custom_effect_enterprise_rising ($00:DA4A)
;
; This custom effect draws the Enterprise flying upward toward the top of the
; screen and is used when reentering the Tower of Zot.
_decode_event_opcode_custom_effect_enterprise_rising:
    LDX #112.w                                                                  ; $00DA4A |\
    STX <r_generic_arg_coordinates.x                                            ; $00DA4D | | Initially set the coordinates to 112, 120.
    LDX #120.w                                                                  ; $00DA4F | |
    STX <r_generic_arg_coordinates.y                                            ; $00DA52 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00DA54 | Wait for the next complete NMI.
    LDA <r_generic_arg_coordinates.y.lo                                         ; $00DA57 |\
    CMP #16.b                                                                   ; $00DA59 | | If the Y coordinate is less than 16, use it to set the PPU
    BCS +                                                                       ; $00DA5B | | brightness.
    STA reg_ppu_inidisp.w                                                       ; $00DA5D |/
+   JSR _draw_enterprise                                                        ; $00DA60 | Draw the Enterprise at the current coordinates.
    LDY #120.w                                                                  ; $00DA63 |\
    STY <r_generic_arg_y                                                        ; $00DA66 | | Draw the shadow of the Enterprise at a Y coordinate of 120.
    LDY #_sizeof_oam_sprite.w * 84                                              ; $00DA68 | |
    JSR _draw_field_sprite_shadow                                               ; $00DA6B |/
    LDX <r_generic_arg_coordinates.y                                            ; $00DA6E |\
    DEX                                                                         ; $00DA70 | | Decrement the Y coordinate.
    STX <r_generic_arg_coordinates.y                                            ; $00DA71 |/
    CPX #0.w                                                                    ; $00DA73 |\ Loop until it reaches zero.
    BNE -                                                                       ; $00DA76 |/
    STZ <r_ppu_brightness                                                       ; $00DA78 | Set the PPU brightness to zero.
    JMP _decode_event_opcode_done                                               ; $00DA7A

; _decode_event_opcode_custom_effect_enterprise_lowering ($00:DA7D)
;
; Custom effect for the Enterprise coming down from the top of the screen to the
; middle. Used when departing the Tower of Zot before completing it.
_decode_event_opcode_custom_effect_enterprise_lowering:
    LDA #%00001111.b                                                            ; $00DA7D |\ Set the PPU brightness variable to maximum.
    STA <r_ppu_brightness                                                       ; $00DA7F |/
    LDX #112.w                                                                  ; $00DA81 |\
    STX <r_generic_arg_coordinates.x                                            ; $00DA84 | | Set the initial coordinates to 112, 0.
    LDX #0.w                                                                    ; $00DA86 | |
    STX <r_generic_arg_coordinates.y                                            ; $00DA89 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00DA8B | Wait for the next complete NMI.
    LDA <r_generic_arg_coordinates.y.lo                                         ; $00DA8E |\
    CMP #16.b                                                                   ; $00DA90 | | If the Y coordinate is less than 16, set the PPU brightness using
    BCS +                                                                       ; $00DA92 | | that value.
    STA reg_ppu_inidisp.w                                                       ; $00DA94 |/
+   JSR _draw_enterprise                                                        ; $00DA97 | Draw the Enterprise at the current coordinates.
    LDY #120.w                                                                  ; $00DA9A |\
    STY <r_generic_arg_y                                                        ; $00DA9D | | Draw the Enterprise shadow at a Y coordinate of 120.
    LDY #_sizeof_oam_sprite.w * 84                                              ; $00DA9F | |
    JSR _draw_field_sprite_shadow                                               ; $00DAA2 |/
    LDX <r_generic_arg_coordinates.y                                            ; $00DAA5 |\
    INX                                                                         ; $00DAA7 | | Increment the Y coordinate.
    STX <r_generic_arg_coordinates.y                                            ; $00DAA8 |/
    CPX #120.w                                                                  ; $00DAAA |\ Loop until it reaches 120.
    BNE -                                                                       ; $00DAAD |/
    JMP _decode_event_opcode_done                                               ; $00DAAF

; _draw_enterprise ($00:DAB2)
;
; Given a 16-bit X coordinate in $2C and a 16-bit Y coordinate in $2E, draws
; the Enterprise to those on-screen coordinates.
_draw_enterprise:
    JSR _init_oam                                                               ; $00DAB2 | Initialize the OAM.
    LDX <r_generic_arg_coordinates.x                                            ; $00DAB5 |\
    STX <r_generic_arg_x                                                        ; $00DAB7 | | Set the coordinates to the passed coordinates.
    LDX <r_generic_arg_coordinates.y                                            ; $00DAB9 | |
    STX <r_generic_arg_y                                                        ; $00DABB |/
    LDA #%00011000.b                                                            ; $00DABD |\ Set the tile flags to use palette 4 with priority 1.
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DABF |/
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00DAC1 |\ Set the tile base to draw the Enterprise.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DAC3 |/
    LDY #_sizeof_oam_sprite.w * 96                                              ; $00DAC5 | Start with OAM index 96.
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00DAC8 |\ Draw the Enterprise facing left.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DACA |/
    JSR _draw_vehicle_sprite                                                    ; $00DACC | Draw the actual sprite.
    RTS                                                                         ; $00DACF

; _draw_enterprise_and_red_airship ($00:DAD0)
;
; Given a 16-bit X coordinate in $2C and a 16-bit Y coordinate in $2E, draws the
; Enterprise to its correct location and a red version of the airship to the
; provided coordinates.
_draw_enterprise_and_red_airship:
    JSR _wait_for_nmi_complete_field                                            ; $00DAD0 | Wait for the next complete NMI.
    JSR _init_oam                                                               ; $00DAD3 | Initialize the OAM.
    JSL bank15.draw_field_sprite_enterprise                                     ; $00DAD6 | Draw the player Enterprise sprite.
    LDX <r_generic_arg_coordinates.x                                            ; $00DADA |\
    STX <r_generic_arg_x                                                        ; $00DADC | | Set the enemy airship coordinates to the passed coordinates.
    LDX <r_generic_arg_coordinates.y                                            ; $00DADE | |
    STX <r_generic_arg_y                                                        ; $00DAE0 |/
    LDA #%00011100.b                                                            ; $00DAE2 |\ Set the tile flags to use palette 6 with priority 1 (which is a red
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DAE4 |/ palette).
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00DAE6 |\ Draw the Enterprise sprite.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DAE8 |/
    LDY #_sizeof_oam_sprite.w * 96                                              ; $00DAEA | Use OAM entry 96.
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00DAED |\ Set the offset to draw the airship facing left.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DAEF |/
    JSR _draw_vehicle_sprite                                                    ; $00DAF1 | Draw the enemy airship.
    LDY #112.w                                                                  ; $00DAF4 |\
    STY <r_generic_arg_y                                                        ; $00DAF7 | | Draw a shadow at the same X coordinate as the airship but at a Y
    LDY #_sizeof_oam_sprite.w * 80                                              ; $00DAF9 | | coordinate of 112.
    JSR _draw_field_sprite_shadow                                               ; $00DAFC |/
    RTS                                                                         ; $00DAFF

; _decode_event_opcode_custom_effect_downward_airship_chase ($00:DB00)
;
; This custom effect displays a downward traveling airship chase. The map should
; be loaded before calling this effect.
_decode_event_opcode_custom_effect_downward_airship_chase:
    JSR _change_vehicle_to_enterprise                                           ; $00DB00 | Change the vehicle to the Enterprise.
    LDX #192.w                                                                  ; $00DB03 |\ Initialize the frame counter to 192.
    STX <r_generic_frame_counter                                                ; $00DB06 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00DB08 | Wait for the next complete NMI.
    LDX <r_generic_frame_counter                                                ; $00DB0B |\
    CPX #15.w                                                                   ; $00DB0D | | If the frame counter is 15 or less, use it to set the PPU
    BCS +                                                                       ; $00DB10 | | brightness to fade out the screen as the effect approaches
    TXA                                                                         ; $00DB12 | | completion.
    STA reg_ppu_inidisp.w                                                       ; $00DB13 |/
+   JSR _init_oam                                                               ; $00DB16 | Initialize the OAM.
    JSL bank15.draw_field_sprite_enterprise                                     ; $00DB19 | Draw the Enterprise.
    JSR _set_vertical_chasing_airship_coordinates                               ; $00DB1D | Set the coordinates of the chasing airship.
    LDA #TILE_OFFSET_VEHICLE_DOWN.b                                             ; $00DB20 |\ Draw the chasing airship facing down.
    JSR _draw_red_airship                                                       ; $00DB22 |/
    LDA #JOYPAD_H_DOWN.b                                                        ; $00DB25 |\
    STA <r_joypad_cutscene_hi                                                   ; $00DB27 | | Fake a down press on the d-pad to move downward.
    STZ <r_joypad_cutscene_lo                                                   ; $00DB29 |/
    JSR _do_outdoor_airship_movement                                            ; $00DB2B | Handle the movement.
    LDX <r_generic_frame_counter                                                ; $00DB2E |\
    DEX                                                                         ; $00DB30 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00DB31 | |
    BNE -                                                                       ; $00DB33 |/
    STZ <r_ppu_brightness                                                       ; $00DB35 | Set the PPU brightness variable to zero.
    JMP _decode_event_opcode_done                                               ; $00DB37

; _decode_event_opcode_custom_effect_rightward_airship_chase ($00:DB3A)
;
; This custom effect displays a rightward traveling airship chase. The map
; should be loaded before calling this effect.
_decode_event_opcode_custom_effect_rightward_airship_chase:
    JSR _change_vehicle_to_enterprise                                           ; $00DB3A | Change the vehicle to the Enterprise.
    LDX #182.w                                                                  ; $00DB3D |\ Initialize the frame counter to 182.
    STX <r_generic_frame_counter                                                ; $00DB40 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00DB42 | Wait for the next complete NMI.
    LDX <r_generic_frame_counter                                                ; $00DB45 |\
    CPX #15.w                                                                   ; $00DB47 | | If the frame counter is 15 or less, use it to set the PPU
    BCS +                                                                       ; $00DB4A | | brightness.
    TXA                                                                         ; $00DB4C | |
    STA reg_ppu_inidisp.w                                                       ; $00DB4D |/
+   JSR _init_oam                                                               ; $00DB50 | Initialize the OAM.
    JSL bank15.draw_field_sprite_enterprise                                     ; $00DB53 | Draw the Enterprise field sprite.
    JSR _set_vertical_chasing_airship_coordinates                               ; $00DB57 |\
    LDX <r_generic_arg_coordinates.x                                            ; $00DB5A | | Set the coordinates by calculating the vertical chasing airship
    LDY <r_generic_arg_coordinates.y                                            ; $00DB5C | | coordinates, and then swapping them.
    STX <r_generic_arg_coordinates.y                                            ; $00DB5E | |
    STY <r_generic_arg_coordinates.x                                            ; $00DB60 |/
    LDA #TILE_OFFSET_VEHICLE_RIGHT.b                                            ; $00DB62 |\ Draw the red airship traveling rightward.
    JSR _draw_red_airship                                                       ; $00DB64 |/
    LDA #JOYPAD_H_RIGHT.b                                                       ; $00DB67 |\
    STA <r_joypad_cutscene_hi                                                   ; $00DB69 | | Fake a fight d-pad press.
    STZ <r_joypad_cutscene_lo                                                   ; $00DB6B |/
    JSR _do_outdoor_airship_movement                                            ; $00DB6D | Handle the movement.
    LDX <r_generic_frame_counter                                                ; $00DB70 |\
    DEX                                                                         ; $00DB72 | | Decrement the frame counter and loop until it reaches zero.
    STX <r_generic_frame_counter                                                ; $00DB73 | |
    BNE -                                                                       ; $00DB75 |/
    STZ <r_ppu_brightness                                                       ; $00DB77 | Set the PPU brightness variable to zero.
    JMP _decode_event_opcode_done                                               ; $00DB79

; _change_vehicle_to_enterprise ($00:DB7C)
;
; Changes the current vehicle to the Enterprise and sets various parameters for
; a vehicle already in flight.
_change_vehicle_to_enterprise:
    LDA #VEHICLE_ENTERPRISE.b                                                   ; $00DB7C |\ Set the vehicle to the Enterprise.
    STA r_vehicle.w                                                             ; $00DB7E |/
    LDA #16.b                                                                   ; $00DB81 |\ Set the Enterprise altitude to 16.
    STA <r_enterprise_altitude                                                  ; $00DB83 |/
    LDA #$0F.b                                                                  ; $00DB85 |\ Set the airship animation speed to normal.
    STA r_airship_animation_speed.w                                             ; $00DB87 |/
    LDA #MOVEMENT_SPEED_ENTERPRISE.b                                            ; $00DB8A |\ Set the movement speed to the Enterprise speed.
    STA <r_movement_speed                                                       ; $00DB8C |/
    LDA #$20.b                                                                  ; $00DB8E |\ Set the zoom level to normal for flight.
    STA <r_zoom_level                                                           ; $00DB90 |/
    RTS                                                                         ; $00DB92

; _do_outdoor_airship_movement ($00:DB93)
;
; Simple wrapper around the outdoor movement functions to automatically enable
; movement calculation, calculate the movement (based on inputs), and execute
; the movement, while ensuring the zoom level is appropriate for a flying
; airship.
_do_outdoor_airship_movement:
    LDA #1.b                                                                    ; $00DB93 |\ Enable player movement calculation.
    STA <r_player_movement_calculation_enabled                                  ; $00DB95 |/
    JSR _calculate_outdoor_movement_direction                                   ; $00DB97 | Calculate the outdoor movement direction.
    JSR _do_outdoor_movement                                                    ; $00DB9A | Do the outdoor movement.
    LDA #ZOOM_LEVEL_AIRSHIP_FLIGHT.b                                            ; $00DB9D |\ Set the zoom level to airship flight level.
    STA <r_zoom_level                                                           ; $00DB9F |/
    RTS                                                                         ; $00DBA1

; _set_vertical_chasing_airship_coordinates ($00:DBA2)
;
; Sets the 16-bit coordinates of a chasing airship to $062C and $062E. This
; includes a small side-to-side movement of the chasing airship, assuming the
; chase is in the vertical direction.
_set_vertical_chasing_airship_coordinates:
    LDA <r_map_frame_counter                                                    ; $00DBA2 |\
    LSR A                                                                       ; $00DBA4 | | Set the X coordinate to 112 plus an offset derived from the frame
    LSR A                                                                       ; $00DBA5 | | counter to produce the side-to-side movement.
    AND #%00011111.b                                                            ; $00DBA6 | |
    TAX                                                                         ; $00DBA8 | |
    LDA bank14.airship_side_movement_data.l,X                                   ; $00DBA9 | |
    CLC                                                                         ; $00DBAD | |
    ADC #112.b                                                                  ; $00DBAE | |
    STA <r_generic_arg_coordinates.x.lo                                         ; $00DBB0 | |
    STZ <r_generic_arg_coordinates.x.hi                                         ; $00DBB2 |/
    LDA #80.b                                                                   ; $00DBB4 |\
    STA <r_generic_arg_coordinates.y.lo                                         ; $00DBB6 | | Set the Y coordinate to 80.
    STZ <r_generic_arg_coordinates.y.hi                                         ; $00DBB8 |/
    RTS                                                                         ; $00DBBA

; _draw_red_airship ($00:DBBB)
;
; Draws a red version of the Enterprise at the coordinates passed in $062C.2D
; and $062E.2F. The tile offset to set the desired direction should be passed in
; the accumulator.
_draw_red_airship:
    PHA                                                                         ; $00DBBB | Preserve the value in the accumulator.
    LDY #_sizeof_oam_sprite.w * 116                                             ; $00DBBC | Set the Y register to use OAM entry index 116.
    LDA #%00011100.b                                                            ; $00DBBF |\ Set the tile flags for priority 1 and palette 6 (the red palette).
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DBC1 |/
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00DBC3 |\ Set the tile base to that of the Enterprise.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DBC5 |/
    LDX <r_generic_arg_coordinates.x                                            ; $00DBC7 |\
    STX <r_generic_arg_x                                                        ; $00DBC9 | | Set the coordinates.
    LDX <r_generic_arg_coordinates.y                                            ; $00DBCB | |
    STX <r_generic_arg_y                                                        ; $00DBCD |/
    LDA #ZOOM_LEVEL_AIRSHIP_FLIGHT.b                                            ; $00DBCF |\ Set the zoom level to flight level.
    STA <r_zoom_level                                                           ; $00DBD1 |/
    PLA                                                                         ; $00DBD3 |\ Set the tile offset to the passed value.
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DBD4 |/
    JSR _draw_vehicle_sprite                                                    ; $00DBD6 | Draw the vehicle.
    LDY #_sizeof_oam_sprite.w * 100                                             ; $00DBD9 |\ Set the vehicle shadow starting at OAM index 100.
    JSR _draw_field_sprite_shadow                                               ; $00DBDC |/
    RTS                                                                         ; $00DBDF

; _decode_event_opcode_custom_effect_underground_tanks_vs_airships ($00:DBE0)
;
; Custom effect for the tanks vs. airships scene that occurs immediately upon
; arriving in the underground. This specifically renders the battle between the
; tanks and airships.
_decode_event_opcode_custom_effect_underground_tanks_vs_airships:
    LDA #32.b                                                                   ; $00DBE0 |\ Configure for eight simultaneous explosions.
    STA r_draw_explosion_arg_count.w                                            ; $00DBE2 |/
    LDA #EXPLOSION_SIZE_LARGEST.b                                               ; $00DBE5 |\
    STA r_draw_explosion_arg_width.w                                            ; $00DBE7 | | Do the largest range of explosions.
    STA r_draw_explosion_arg_height.w                                           ; $00DBEA |/
    LDX #64.w                                                                   ; $00DBED |\ Initialize the cycle counter to 64.
    STX r_draw_explosion_arg_cycles.w                                           ; $00DBF0 |/
    LDA #1.b                                                                    ; $00DBF3 |\ Use palette for fire.
    STA r_draw_explosion_arg_palette.w                                          ; $00DBF5 |/
    STZ r_draw_explosion_arg_smoke.w                                            ; $00DBF8 | Disable the smoke flag.
    LDA #64.b                                                                   ; $00DBFB |\
    STA r_draw_explosion_arg_coordinates.x.w                                    ; $00DBFD | | Set the upper left explosion coordinates to 64, 64.
    STA r_draw_explosion_arg_coordinates.y.w                                    ; $00DC00 |/
    JSR _init_explosion                                                         ; $00DC03 | Initialize the explosion.
    LDX #255.w                                                                  ; $00DC06 |\
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00DC09 | | Initialize the base coordinates for the airships to 255, 0.
    LDX #0.w                                                                    ; $00DC0B | |
    STX <r_draw_four_airships_arg_coordinates.y                                 ; $00DC0E |/
@loop_start:
    JSR _do_tile_animations                                                     ; $00DC10 | Do any tile animations.
    JSR _init_oam                                                               ; $00DC13 | Initialize the OAM.
    LDX <r_draw_four_airships_arg_coordinates.x                                 ; $00DC16 |\
    DEX                                                                         ; $00DC18 | | Decrement the current X coordinate.
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00DC19 |/
    CPX #192.w                                                                  ; $00DC1B |\
    BCS +                                                                       ; $00DC1E | | If the X coordinate has gone past 192, reset the value to 192,
    LDX #192.w                                                                  ; $00DC20 | | enable shaking, draw an explosion, and if the current map frame
    STX <r_draw_four_airships_arg_coordinates.x                                 ; $00DC23 | | counter mod 64 is zero, play the Crush/long explosion sound
    LDA #1.b                                                                    ; $00DC25 | | effect.
    STA <r_shaking                                                              ; $00DC27 | |
    JSR _draw_explosion                                                         ; $00DC29 | |
    LDA <r_map_frame_counter                                                    ; $00DC2C | |
    AND #%00111111.b                                                            ; $00DC2E | |
    BNE +                                                                       ; $00DC30 | |
    LDA #AUDIO_EFFECT_CRUSH.b                                                   ; $00DC32 | |
    JSR _play_sound_effect                                                      ; $00DC34 |/
+   LDX #112.w                                                                  ; $00DC37 |\
    STX <r_generic_arg_x                                                        ; $00DC3A | | Draw the Enterprise facing downward at 112, 112 at OAM index 112.
    STX <r_generic_arg_y                                                        ; $00DC3C | |
    LDY #_sizeof_oam_sprite.w * 112                                             ; $00DC3E | | NOTE: For some reason, they used palette 6, which is generally for
    LDA #%00011100.b                                                            ; $00DC41 | |       red airships, instead of palette 4, usually used for the
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DC43 | |       Enterprise.
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00DC45 | |
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DC47 | |
    LDA #TILE_OFFSET_VEHICLE_DOWN.b                                             ; $00DC49 | |
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DC4B | |
    JSR _draw_vehicle_sprite                                                    ; $00DC4D |/
    LDA #128.b                                                                  ; $00DC50 |\
    STA <r_generic_arg_y_lo                                                     ; $00DC52 | | Draw a shadow at 112, 128.
    LDY #_sizeof_oam_sprite.w * 96                                              ; $00DC54 | |
    JSR _draw_field_sprite_shadow                                               ; $00DC57 |/
    LDA #%00011100.b                                                            ; $00DC5A |\
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DC5C | | Draw the four Red Wings airships using the Enterprise tile, facing
    LDA #TILE_BASE_ENTERPRISE.b                                                 ; $00DC5E | | left, using the red airship palette.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DC60 | |
    LDA #TILE_OFFSET_VEHICLE_LEFT.b                                             ; $00DC62 | |
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DC64 | |
    JSR _draw_four_airships                                                     ; $00DC66 |/
    LDA #0.b                                                                    ; $00DC69 |\
    SEC                                                                         ; $00DC6B | | Set the base coordinates for the four tanks to the mirrored
    SBC <r_draw_four_airships_arg_coordinates.x.lo                              ; $00DC6C | | coordinates for the airships.
    STA <r_calculate_tank_parameters_arg_coordinates.x.lo                       ; $00DC6E | |
    STZ <r_calculate_tank_parameters_arg_coordinates.x.hi                       ; $00DC70 | |
    STZ <r_calculate_tank_parameters_arg_coordinates.y.lo                       ; $00DC72 | |
    STZ <r_calculate_tank_parameters_arg_coordinates.y.hi                       ; $00DC74 |/
    STZ <r_generic_tmp_counter                                                  ; $00DC76 | Initialize a counter to zero.
-   LDA <r_generic_tmp_counter                                                  ; $00DC78 |\
    ASL A                                                                       ; $00DC7A | | Set the Y register to the counter times two.
    TAY                                                                         ; $00DC7B |/
    JSR _calculate_tank_parameters                                              ; $00DC7C | Calculate the coordinates, tile and flags for the tank.
    LDA #TILE_OFFSET_VEHICLE_RIGHT.b                                            ; $00DC7F |\
    STA <r_field_effect_sprite_arg_tile_offset                                  ; $00DC81 | | Draw the tank facing right.
    JSR _draw_vehicle_sprite                                                    ; $00DC83 |/
    INC <r_generic_tmp_counter                                                  ; $00DC86 |\
    LDA <r_generic_tmp_counter                                                  ; $00DC88 | | Increment the counter and loop until all four tanks have been
    CMP #4.b                                                                    ; $00DC8A | | drawn.
    BNE -                                                                       ; $00DC8C |/
    LDX r_draw_explosion_arg_cycles.w                                           ; $00DC8E |\
    BEQ +                                                                       ; $00DC91 | | Loop until the explosion cycle counter reaches zero.
    JMP @loop_start                                                             ; $00DC93 |/
+   STZ <r_shaking                                                              ; $00DC96 | Disable the shaking effect.
    JMP _decode_event_opcode_done                                               ; $00DC98

; airship_formation_x_coordinate_offset_data ($00:DC9B)
;
; For cutscenes that display airship formations, determines the offsets to add
; to the base X coordinate to determine the current X coordinate for each of the
; tanks.
airship_formation_x_coordinate_offset_data:
    .dw   0                                                                     ; $00DC9B.DC9C
    .dw  24                                                                     ; $00DC9D.DC9E
    .dw   0                                                                     ; $00DC9F.DCA0
    .dw  24                                                                     ; $00DCA1.DCA2

; airship_formation_y_coordinate_offset_data ($00:DC9B)
;
; For cutscenes that display airship formations, determines the offsets to add
; to the base Y coordinate to determine the current Y coordinate for each of the
; tanks.
airship_formation_y_coordinate_offset_data:
    .dw  64                                                                     ; $00DCA3.DCA4
    .dw  96                                                                     ; $00DCA5.DCA6
    .dw 128                                                                     ; $00DCA7.DCA8
    .dw 160                                                                     ; $00DCA9.DCAA

; tank_formation_x_coordinate_offset_data ($00:DCAB)
;
; For cutscenes that display tank formations, determines the offsets to add to
; the base X coordinate to determine the current X coordinate for each of the
; tanks. The first four entries are for a vertical formation, and the second
; four entries are for a horizontal formation.
tank_formation_x_coordinate_offset_data:
    .dw  -8                                                                     ; $00DCAB.DCAC
    .dw -48                                                                     ; $00DCAD.DCAE
    .dw  -8                                                                     ; $00DCAF.DCB0
    .dw -48                                                                     ; $00DCB1.DCB2
    .dw  32                                                                     ; $00DCB3.DCB4
    .dw  50                                                                     ; $00DCB5.DCB6
    .dw  68                                                                     ; $00DCB7.DCB8
    .dw  86                                                                     ; $00DCB9.DCBA

; tank_formation_x_coordinate_offset_data ($00:DCAB)
;
; For cutscenes that display tank formations, determines the offsets to add to
; the base Y coordinate to determine the current Y coordinate for each of the
; tanks. The first four entries are for a vertical formation, and the second
; four entries are for a horizontal formation.
tank_formation_y_coordinate_offset_data:
    .dw  80                                                                     ; $00DCBB.DCBC
    .dw 112                                                                     ; $00DCBD.DCBE
    .dw 144                                                                     ; $00DCBF.DCC0
    .dw 192                                                                     ; $00DCC1.DCC2
    .dw   8                                                                     ; $00DCC3.DCC4
    .dw  24                                                                     ; $00DCC5.DCC6
    .dw   8                                                                     ; $00DCC7.DCC8
    .dw  24                                                                     ; $00DCC9.DCCA

; _draw_four_airships ($00:DCCB)
;
; Given the 16-bit base X coordinate in $F3 and the 16-bit base Y coordinate in
; $F5, draws four airships arranged in a vertical zig-zag pattern in their
; proper locations. The exact tiles and palette can be configured with the
; variables in $068F, $0691 and $0692.
_draw_four_airships:
    STZ <r_generic_tmp_counter                                                  ; $00DCCB | Initialize the counter to zero.
-   LDA <r_generic_tmp_counter                                                  ; $00DCCD |\
    ASL A                                                                       ; $00DCCF | | Set the Y register to the counter multiplied by two.
    TAY                                                                         ; $00DCD0 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00DCD1 |\
    LDA airship_formation_x_coordinate_offset_data.w,Y                          ; $00DCD3 | | Set the X coordinate for the current airship by adding the offset
    CLC                                                                         ; $00DCD6 | | to the base coordinate.
    ADC <r_draw_four_airships_arg_coordinates.x                                 ; $00DCD7 | |
    STA <r_generic_arg_x                                                        ; $00DCD9 |/
    LDA airship_formation_y_coordinate_offset_data.w,Y                          ; $00DCDB |\
    CLC                                                                         ; $00DCDE | | Set the Y coordinate for the current airship by adding the offset
    ADC <r_draw_four_airships_arg_coordinates.y                                 ; $00DCDF | | to the base coordinate.
    STA <r_generic_arg_y                                                        ; $00DCE1 |/
    LDA <r_generic_tmp_counter                                                  ; $00DCE3 |\
    AND #%11111111.w                                                            ; $00DCE5 | | Set the Y register to the airship number times sixteen, plus 128,
    ASL A                                                                       ; $00DCE8 | | which will correspond to an OAM entry of 32 plus the airship
    ASL A                                                                       ; $00DCE9 | | number times four.
    ASL A                                                                       ; $00DCEA | |
    ASL A                                                                       ; $00DCEB | |
    ORA #%10000000.w                                                            ; $00DCEC | |
    TAY                                                                         ; $00DCEF | |
    LDA #0.w                                                                    ; $00DCF0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00DCF3 |/
    JSR _draw_vehicle_sprite                                                    ; $00DCF5 | Draw the current airship.
    LDA <r_generic_arg_y_lo                                                     ; $00DCF8 |\
    CLC                                                                         ; $00DCFA | | Draw a shadow for the current airship 16 pixels below the ship.
    ADC #16.b                                                                   ; $00DCFB | |
    STA <r_generic_arg_y_lo                                                     ; $00DCFD | |
    JSR _draw_field_sprite_shadow                                               ; $00DCFF |/
    INC <r_generic_tmp_counter                                                  ; $00DD02 |\
    LDA <r_generic_tmp_counter                                                  ; $00DD04 | | Increment the counter and loop until all four airships have been
    CMP #4.b                                                                    ; $00DD06 | | drawn.
    BNE -                                                                       ; $00DD08 |/
    RTS                                                                         ; $00DD0A

; _calculate_tank_parameters ($00:DD0B)
;
; Given the base coordinates for the tank formation in $EF and $F1 and an offset
; to the correct tank data in the Y register, calculates the coordinates and
; sets up the tile base and palette to draw the tank. The Y register should
; contain either the tank number (0 through 3) to draw vertical tanks or the
; tank number plus 4 (4 through 7) to draw horizontal tanks, multiplied by two.
_calculate_tank_parameters:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00DD0B |\
    LDA tank_formation_x_coordinate_offset_data.w,Y                             ; $00DD0D | | Set the X coordinate to the base X coordinate plus the offset for
    CLC                                                                         ; $00DD10 | | the current tank.
    ADC <r_calculate_tank_parameters_arg_coordinates.x                          ; $00DD11 | |
    STA <r_generic_arg_x                                                        ; $00DD13 |/
    LDA tank_formation_y_coordinate_offset_data.w,Y                             ; $00DD15 |\
    CLC                                                                         ; $00DD18 | | Set the Y coordinate to the base Y coordinate plus the offset for
    ADC <r_calculate_tank_parameters_arg_coordinates.y                          ; $00DD19 | | the current tank.
    STA <r_generic_arg_y                                                        ; $00DD1B |/
    TYA                                                                         ; $00DD1D |\
    AND #%00000111.w                                                            ; $00DD1E | | Set the Y register to point to the appropriate OAM entry for the
    LSR A                                                                       ; $00DD21 | | tank: entry 81 plus the tank number.
    AND #%11111111.w                                                            ; $00DD22 | |
    ASL A                                                                       ; $00DD25 | |
    ASL A                                                                       ; $00DD26 | |
    ASL A                                                                       ; $00DD27 | |
    ASL A                                                                       ; $00DD28 | |
    CLC                                                                         ; $00DD29 | |
    ADC #_sizeof_oam_sprite.w * 81                                              ; $00DD2A | |
    TAY                                                                         ; $00DD2D | |
    LDA #0.w                                                                    ; $00DD2E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00DD31 |/
    LDA #%00011000.b                                                            ; $00DD33 |\ Configure the flags to use palette 4, to draw yellow tanks.
    STA <r_field_effect_sprite_arg_tile_flags                                   ; $00DD35 |/
    LDA #TILE_BASE_TANK.b                                                       ; $00DD37 |\ Set the tile base to draw a tank.
    STA <r_field_effect_sprite_arg_tile_base                                    ; $00DD39 |/
    RTS                                                                         ; $00DD3B

; _draw_vehicle_sprite ($00:DD3C)
;
; Draws a vehicle sprite at the 16-bit X coordinate in $060C and the 8-bit Y
; coordinate in $060E. The desired vehicle's first tile number should be placed
; in $068F. Any desired offset (to select the direction of the vehicle) should
; be placed in $0692. Any flags (such as priority or palette) should be placed
; in $0691. Finally, the index to the target OAM entries should be in the Y
; register.
_draw_vehicle_sprite:
    LDA <r_map_frame_counter                                                    ; $00DD3C |\
    AND #%00000010.b                                                            ; $00DD3E | | Determine the offset into the OAM data by taking the given tile
    ASL A                                                                       ; $00DD40 | | offset (to select direction) and adding 16 on frames with bit 1
    ASL A                                                                       ; $00DD41 | | set.
    ASL A                                                                       ; $00DD42 | |
    CLC                                                                         ; $00DD43 | |
    ADC <r_field_effect_sprite_arg_tile_offset                                  ; $00DD44 | |
    TAX                                                                         ; $00DD46 |/
-   LDA bank15.field_sprite_vehicle_oam_data.l,X                                ; $00DD47 |\
    CLC                                                                         ; $00DD4B | | Set the X coordinate by adding the tile X coordinate and the
    ADC <r_generic_arg_x_lo                                                     ; $00DD4C | | target sprite X coordinate.
    STA r_oam.1.x,Y                                                             ; $00DD4E | |
    LDA <r_generic_arg_x_hi                                                     ; $00DD51 | |
    ADC #0.b                                                                    ; $00DD53 | |
    AND #%00000001.b                                                            ; $00DD55 | |
    BEQ +                                                                       ; $00DD57 | |
    LDA #0.b                                                                    ; $00DD59 | |
    JSL bank15.set_oam_hi_x                                                     ; $00DD5B |/
+   LDA bank15.field_sprite_vehicle_oam_data.l + 1,X                            ; $00DD5F |\
    CLC                                                                         ; $00DD63 | | Set the Y coordinate by adding the tile coordinate and the passed
    ADC <r_generic_arg_y_lo                                                     ; $00DD64 | | coordinate. Also subtract a number based on the zoom level to
    SEC                                                                         ; $00DD66 | | produce a lifting effect while at altitude.
    SBC <r_zoom_level                                                           ; $00DD67 | |
    CLC                                                                         ; $00DD69 | |
    ADC #8.b                                                                    ; $00DD6A | |
    STA r_oam.1.y,Y                                                             ; $00DD6C |/
    LDA bank15.field_sprite_vehicle_oam_data.l + 2,X                            ; $00DD6F |\
    CLC                                                                         ; $00DD73 | | The tile number is simply the base plus the offset in the data.
    ADC <r_field_effect_sprite_arg_tile_base                                    ; $00DD74 | |
    STA r_oam.1.tile,Y                                                          ; $00DD76 |/
    LDA bank15.field_sprite_vehicle_oam_data.l + 3,X                            ; $00DD79 |\
    ORA <r_field_effect_sprite_arg_tile_flags                                   ; $00DD7D | | Set the flags, ORing in the passed flags.
    STA r_oam.1.flags,Y                                                         ; $00DD7F |/
    JSR _increment_indexes_by_four                                              ; $00DD82 | Increment the indexes by four.
    TXA                                                                         ; $00DD85 |\
    AND #%00001111.b                                                            ; $00DD86 | | Keep looping until all 16 bytes have been set.
    BNE -                                                                       ; $00DD88 |/
    RTS                                                                         ; $00DD8A

; _draw_field_sprite_shadow ($00:DD8B)
;
; Draws a shadow to the 16-bit X coordinate passed in $060C and the 8-bit Y
; coordinate passed in $060E. The size of the shadow is determined by the
; current zoom level. The tiles used in OAM are set to the offset to the 21st
; entry plus the value in Y.
_draw_field_sprite_shadow:
    LDA <r_zoom_level                                                           ; $00DD8B |\
    CMP #$20.b                                                                  ; $00DD8D | | Execute this function if the zoom level is exactly $20 (max
    BEQ +                                                                       ; $00DD8F | | airship) or if the map frame counter is even. (This results in a
    LDA <r_map_frame_counter                                                    ; $00DD91 | | solid shadow at zoom level $20 and a blinking shadow at all other
    LSR A                                                                       ; $00DD93 | | levels).
    BCC +                                                                       ; $00DD94 | |
    RTS                                                                         ; $00DD96 |/
+   LDA <r_zoom_level                                                           ; $00DD97 |\
    SEC                                                                         ; $00DD99 | | Determine the index into the shadow sprite data by taking the zoom
    SBC #$10.b                                                                  ; $00DD9A | | level minus $10 except the lowest two bits.
    AND #%11111100.b                                                            ; $00DD9C | |
    TAX                                                                         ; $00DD9E |/
    LDA <r_generic_arg_x_lo                                                     ; $00DD9F |\
    STA r_oam.21.x,Y                                                            ; $00DDA1 | | Set the X coordinate of this tile to the X coordinate given as a
    LDA <r_generic_arg_x_hi                                                     ; $00DDA4 | | parameter.
    AND #%00000001.b                                                            ; $00DDA6 | |
    BEQ +                                                                       ; $00DDA8 | |
    LDA #20.b                                                                   ; $00DDAA | |
    JSL bank15.set_oam_hi_x                                                     ; $00DDAC |/
+   LDA <r_generic_arg_y_lo                                                     ; $00DDB0 |\ Set the Y coordinate to the parameter.
    STA r_oam.21.y,Y                                                            ; $00DDB2 |/
    LDA bank15.field_sprite_shadow_oam_data.l,X                                 ; $00DDB5 |\
    STA r_oam.21.tile,Y                                                         ; $00DDB9 | | Load the tile number and flags from the shadow data in ROM.
    LDA bank15.field_sprite_shadow_oam_data.l + 1,X                             ; $00DDBC | |
    STA r_oam.21.flags,Y                                                        ; $00DDC0 |/
    LDA <r_generic_arg_x_lo                                                     ; $00DDC3 |\
    CLC                                                                         ; $00DDC5 | | Set the X coordinate of the second tile to the passed parameter
    ADC #8.b                                                                    ; $00DDC6 | | plus eight.
    STA r_oam.22.x,Y                                                            ; $00DDC8 | |
    LDA <r_generic_arg_x_hi                                                     ; $00DDCB | |
    ADC #0.b                                                                    ; $00DDCD | |
    AND #%00000001.b                                                            ; $00DDCF | |
    BEQ +                                                                       ; $00DDD1 | |
    LDA #21.b                                                                   ; $00DDD3 | |
    JSL bank15.set_oam_hi_x                                                     ; $00DDD5 |/
+   LDA <r_generic_arg_y_lo                                                     ; $00DDD9 |\ Set the Y coordinate to the passed parameter.
    STA r_oam.22.y,Y                                                            ; $00DDDB |/
    LDA bank15.field_sprite_shadow_oam_data.l + 2,X                             ; $00DDDE |\
    STA r_oam.22.tile,Y                                                         ; $00DDE2 | | Set the tile number and flags by loading from ROM.
    LDA bank15.field_sprite_shadow_oam_data.l + 3,X                             ; $00DDE5 | |
    STA r_oam.22.flags,Y                                                        ; $00DDE9 |/
    RTS                                                                         ; $00DDEC

; _init_explosion ($00:DDED)
;
; Loads the palette for an explosion. The loaded palette and where it is placed
; is based on $0ACD and $0ACE. If $0ACE is zero, the fire palette will be loaded
; and placed in the sprite palette number in $0ACD. If $0ACE is non-zero, smoke
; palette data will instead be loaded and placed in the sprite palette number in
; $0ACD plus one.
;
; Also generates an initial explosion data table with 16 entries, occurring in
; four sets of -1, -2, -3 and -4.
_init_explosion:
    STZ <r_draw_explosion_arg_suppress_new                                      ; $00DDED | Unset the supression of new explosions.
    LDA r_draw_explosion_arg_palette.w                                          ; $00DDEF |\
    ASL A                                                                       ; $00DDF2 | | Determine the palette index by multiplying by 32.
    ASL A                                                                       ; $00DDF3 | |
    ASL A                                                                       ; $00DDF4 | |
    ASL A                                                                       ; $00DDF5 | |
    ASL A                                                                       ; $00DDF6 | |
    TAY                                                                         ; $00DDF7 |/
    LDX #$0000.w                                                                ; $00DDF8 |\
-   LDA r_draw_explosion_arg_smoke.w                                            ; $00DDFB | | For each of the 16 colors, fetch the color and store it in the
    BNE +                                                                       ; $00DDFE | | correct palette. If $0ACE is zero, the fire palette data will be
    LDA bank0D.explosion_fire_palette_data.l,X                                  ; $00DE00 | | loaded into the given sprite palette number. If $0ACE is non-zero,
    STA r_cgram_data.9,Y                                                        ; $00DE04 | | the smoke palette data will be loaded into the given sprite
    JMP ++                                                                      ; $00DE07 | | palette number plus one.
+   LDA bank0D.explosion_smoke_palette_data.l,X                                 ; $00DE0A | |
    STA r_cgram_data.10,Y                                                       ; $00DE0E | |
++  INY                                                                         ; $00DE11 | |
    INX                                                                         ; $00DE12 | |
    CPX #bank0D._sizeof_explosion_fire_palette_data.w                           ; $00DE13 | |
    BNE -                                                                       ; $00DE16 |/
    LDX #$0000.w                                                                ; $00DE18 |\
-   TXA                                                                         ; $00DE1B | | For each of the 16 entries in the explosions table, set the
    LSR A                                                                       ; $00DE1C | | initial cycle. This sets up 16 entries in a repeating pattern of
    LSR A                                                                       ; $00DE1D | | -1, -2, -3, -4.
    AND #%00000011.b                                                            ; $00DE1E | |
    EOR #%11111111.b                                                            ; $00DE20 | |
    STA r_explosions.1.cycle.w,X                                                ; $00DE22 | |
    INX                                                                         ; $00DE25 | |
    INX                                                                         ; $00DE26 | |
    INX                                                                         ; $00DE27 | |
    INX                                                                         ; $00DE28 | |
    CPX #$0040.w                                                                ; $00DE29 | |
    BNE -                                                                       ; $00DE2C |/
    RTS                                                                         ; $00DE2E

; _draw_explosion ($00:DE2F)
;
; Draws the current frame of an explosion. This function takes numerous
; parameters. The 8-bit palette to use should be in $0ACD. $0ACE should be zero
; if drawing a fire explosion, and some non-zero value if drawing a smoke
; explosion. For practical reasons involving the weird way the palettes are
; handled, $0ACE should probably be set to $02 if drawing smoke.
;
; $0ACF contains the 8-bit simultaneous number of explosions multiplied by four.
; $0AD0 and $0AD1 each contain a number ranging from 0-3 specifying which size
; setting to use for the width and height, respectively. $0AD2 will be
; decremented on frames where the animation is updated, so it can be used as
; a cycle counter. It is a 16-bit number. $0AD4 and $0AD5 contain the X and Y
; coordinates, respectively. $06C7 determines if the coordinates are determined
; randomly or based on a circular pattern. If set to zero, the coordinates are
; randomly determined and the given coordinates are the upper left bound. If
; non-zero, the coordinates are determined based on a circular pattern and the
; given coordinates represent the center. $06E5 should be set to suppress the
; creation of new explosion sprites (while allowing existing ones to complete).
_draw_explosion:
    JSR _init_oam_lower                                                         ; $00DE2F | Initialize the lower half of the OAM.
    JSR _set_oam_large_32                                                       ; $00DE32 | Set the first 32 sprites to be 16x16.
    LDX #$0000.w                                                                ; $00DE35 |\
    STX <r_draw_explosion_index                                                 ; $00DE38 | | Initialize the explosion index.
@loop_start:                                                                    ;         | |
    LDX <r_draw_explosion_index                                                 ; $00DE3A |/
    LDA <r_map_frame_counter                                                    ; $00DE3C |\
    AND #%00000111.b                                                            ; $00DE3E | | On frames evenly divisible by 8, increment the explosion's cycle
    BNE +                                                                       ; $00DE40 | | counter.
    INC r_explosions.1.cycle.w,X                                                ; $00DE42 |/
+   LDA r_explosions.1.cycle.w,X                                                ; $00DE45 |\
    BPL +                                                                       ; $00DE48 | | If the cycle counter is negative, skip to the relevant code.
    JMP @negative                                                               ; $00DE4A |/
+   BEQ +                                                                       ; $00DE4D |\
    CMP #4.b                                                                    ; $00DE4F | | If the cycle counter is positive, and reaches four, reset that
    BNE +++                                                                     ; $00DE51 | | explosion. Only continue if the frame counter is divisible by
+   LDA <r_map_frame_counter                                                    ; $00DE53 | | eight.
    AND #%00000111.b                                                            ; $00DE55 | |
    BNE +++                                                                     ; $00DE57 |/
    LDA <r_draw_explosion_arg_suppress_new                                      ; $00DE59 |\ If new explosions are suppressed, skip to the suppression section.
    BNE @suppress                                                               ; $00DE5B |/
    STZ r_explosions.1.cycle.w,X                                                ; $00DE5D | Set the explosion cycle to zero (in case it was four).
    LDA <r_draw_explosion_arg_circular                                          ; $00DE60 |\ Determine if the coordinates should be random or circular.
    BNE +                                                                       ; $00DE62 |/
    LDA r_draw_explosion_arg_width.w                                            ; $00DE64 |\
    TAX                                                                         ; $00DE67 | | Set the X coordinate to a random value based on the target
    JSR _get_field_rng                                                          ; $00DE68 | | coordinates and the desired width.
    AND explosion_size_mask_data.w,X                                            ; $00DE6B | |
    CLC                                                                         ; $00DE6E | |
    ADC r_draw_explosion_arg_coordinates.x.w                                    ; $00DE6F | |
    LDX <r_draw_explosion_index                                                 ; $00DE72 | |
    STA r_explosions.1.coordinates.x.w,X                                        ; $00DE74 |/
    LDA r_draw_explosion_arg_height.w                                           ; $00DE77 |\
    TAX                                                                         ; $00DE7A | | Set the Y coordinate in a similar fashion.
    JSR _get_field_rng                                                          ; $00DE7B | |
    AND explosion_size_mask_data.w,X                                            ; $00DE7E | |
    CLC                                                                         ; $00DE81 | |
    ADC r_draw_explosion_arg_coordinates.y.w                                    ; $00DE82 | |
    LDX <r_draw_explosion_index                                                 ; $00DE85 | |
    STA r_explosions.1.coordinates.y.w,X                                        ; $00DE87 | |
    JMP +++                                                                     ; $00DE8A |/
+   LDA <r_draw_explosion_arg_circular                                          ; $00DE8D |\
    DEC A                                                                       ; $00DE8F | | Calculate the index by taking the circular value, subtracting one,
    AND #%00001111.b                                                            ; $00DE90 | | taking the low four bits and multiplying by two.
    ASL A                                                                       ; $00DE92 | |
    TAY                                                                         ; $00DE93 |/
    LDA circular_explosion_coordinate_data,Y                                    ; $00DE94 |\
    CLC                                                                         ; $00DE97 | | Set the X coordinate based on the loaded data.
    ADC r_draw_explosion_arg_coordinates.x.w                                    ; $00DE98 | |
    STA r_explosions.1.coordinates.x.w,X                                        ; $00DE9B |/
    LDA circular_explosion_coordinate_data + 1,Y                                ; $00DE9E |\
    CLC                                                                         ; $00DEA1 | | Repeat with the Y coordinate.
    ADC r_draw_explosion_arg_coordinates.y.w                                    ; $00DEA2 | |
    STA r_explosions.1.coordinates.y.w,X                                        ; $00DEA5 |/
    INC <r_draw_explosion_arg_circular                                          ; $00DEA8 | Increment the circular index.
+++ JSR _draw_explosion_sprite                                                  ; $00DEAA | Draw the actual sprite.
    JMP @negative                                                               ; $00DEAD | Skip the supression code.
@suppress:
    LDA #$FF.b                                                                  ; $00DEB0 |\ If suppressing new explosions, set the cycle to $FF.
    STA r_explosions.1.cycle.w,X                                                ; $00DEB2 |/
@negative:
    LDA <r_draw_explosion_index                                                 ; $00DEB5 |\
    CLC                                                                         ; $00DEB7 | | Increment the explosion index.
    ADC #_sizeof_explosion_entry.b                                              ; $00DEB8 | |
    STA <r_draw_explosion_index                                                 ; $00DEBA |/
    CMP r_draw_explosion_arg_count.w                                            ; $00DEBC |\
    BEQ +                                                                       ; $00DEBF | | Loop until the index matches the desired count.
    JMP @loop_start                                                             ; $00DEC1 |/
+   LDA <r_map_frame_counter                                                    ; $00DEC4 |\
    AND #%00000111.b                                                            ; $00DEC6 | | On frames divisible by eight, decrement the cycle counter.
    BNE +                                                                       ; $00DEC8 | |
    LDX r_draw_explosion_arg_cycles.w                                           ; $00DECA | |
    DEX                                                                         ; $00DECD | |
    STX r_draw_explosion_arg_cycles.w                                           ; $00DECE |/
+   RTS                                                                         ; $00DED1

; _draw_explosion_sprite ($00:DED2)
;
; Draws a single sprite of an explosion. The X register should be set to the
; index of the desired explosion to draw in the explosions array in RAM.
_draw_explosion_sprite:
    LDA r_explosions.1.cycle.w,X                                                ; $00DED2 |\
    TAY                                                                         ; $00DED5 | | Determine the index to the correct source OAM data, depending on
    LDA explosion_sprite_index_data,Y                                           ; $00DED6 | | the current cycle of the explosion.
    TAY                                                                         ; $00DED9 |/
    LDA r_explosions.1.coordinates.x.w,X                                        ; $00DEDA |\
    STA <r_draw_explosion_sprite_x                                              ; $00DEDD | | Load the coordinates and save to local variables.
    LDA r_explosions.1.coordinates.y.w,X                                        ; $00DEDF | |
    STA <r_draw_explosion_sprite_y                                              ; $00DEE2 |/
    LDA <r_draw_explosion_index                                                 ; $00DEE4 |\
    ASL A                                                                       ; $00DEE6 | | Set the OAM index to the current explosion index times four.
    ASL A                                                                       ; $00DEE7 | | The X register now contains the sprite data index and the Y
    TAX                                                                         ; $00DEE8 | | register contains the OAM index.
    PHX                                                                         ; $00DEE9 | |
    PHY                                                                         ; $00DEEA | |
    PLX                                                                         ; $00DEEB | |
    PLY                                                                         ; $00DEEC |/
-   LDA <r_draw_explosion_sprite_x                                              ; $00DEED |\
    CLC                                                                         ; $00DEEF | | Set the X coordinate of the sprite to the coordinate given in the
    ADC bank14.explosion_oam_data.l,X                                           ; $00DEF0 | | OAM data plus our target coordinate.
    STA r_oam.1.x,Y                                                             ; $00DEF4 |/
    LDA bank14.explosion_oam_data.l + 1,X                                       ; $00DEF7 |\
    CMP #$FF.b                                                                  ; $00DEFB | | If the given Y coordinate is $FF, it is instead drawn at 240, so
    BEQ +                                                                       ; $00DEFD | | it is invisible. Otherwise, the given value is added to the given
    LDA <r_draw_explosion_sprite_y                                              ; $00DEFF | | target coordinate.
    CLC                                                                         ; $00DF01 | |
    ADC bank14.explosion_oam_data.l + 1,X                                       ; $00DF02 | |
    JMP ++                                                                      ; $00DF06 | |
+   LDA #240.b                                                                  ; $00DF09 | |
++  STA r_oam.1.y,Y                                                             ; $00DF0B |/
    LDA bank14.explosion_oam_data.l + 2,X                                       ; $00DF0E |\ Simply copy over the tile number.
    STA r_oam.1.tile,Y                                                          ; $00DF12 |/
    LDA r_draw_explosion_arg_palette.w                                          ; $00DF15 |\
    ASL A                                                                       ; $00DF18 | | Use the given flags, but add in the palette data. For whatever
    ORA r_draw_explosion_arg_smoke.w                                            ; $00DF19 | | reason, the smoke and fire palettes are designed to not overlap.
    ORA bank14.explosion_oam_data.l + 3,X                                       ; $00DF1C | |
    STA r_oam.1.flags,Y                                                         ; $00DF20 |/
    JSR _increment_indexes_by_four                                              ; $00DF23 |\
    TXA                                                                         ; $00DF26 | | Increment all the index registers by four, and loop until 16 bytes
    AND #%00001111.b                                                            ; $00DF27 | | have been set.
    BNE -                                                                       ; $00DF29 |/
    RTS                                                                         ; $00DF2B

; explosion_sprite_index_data ($00:DF2C)
;
; For each cycle of an explosion, contains the index of the data needed to draw
; that phase of the explosion to the OAM.
explosion_sprite_index_data:
    .db $00                                                                     ; $00DF2C | $00
    .db $10                                                                     ; $00DF2D | $01
    .db $20                                                                     ; $00DF2E | $02
    .db $30                                                                     ; $00DF2F | $03
    .db $20                                                                     ; $00DF30 | $04
    .db $30                                                                     ; $00DF31 | $05
    .db $20                                                                     ; $00DF32 | $06
    .db $30                                                                     ; $00DF33 | $07

; explosion_size_mask_data ($00:DF34)
;
; Contains masks to use when generating a random value to add to a coordinate
; for explosions. Each mask corresponds to a different size, from largest to
; smallest.
explosion_size_mask_data:
    .db %01111100                                                               ; $00DF34 | $00: 124
    .db %00111100                                                               ; $00DF35 | $01: 60
    .db %00011100                                                               ; $00DF36 | $02: 28
    .db %00001100                                                               ; $00DF37 | $03: 12

; _set_oam_large_32 ($00:DF38)
;
; Configures the OAM to set the size of the lower 32 sprites to be the larger
; available size.
_set_oam_large_32:
    LDX #0.w                                                                    ; $00DF38 |\
    LDA #%10101010.b                                                            ; $00DF3B | | Set each of the lower 32 sprites in the OAM to use the larger size
-   STA r_oam_hi.w,X                                                            ; $00DF3D | | of sprite.
    INX                                                                         ; $00DF40 | |
    CPX #_sizeof_r_oam_hi.w / 4                                                 ; $00DF41 | |
    BNE -                                                                       ; $00DF44 |/
    RTS                                                                         ; $00DF46

; _set_oam_large_64 ($00:DF47)
;
; Configures the OAM to set the size of the lower 64 sprites to be the larger
; available size.
_set_oam_large_64:
    LDX #0.w                                                                    ; $00DF47 |\
    LDA #%10101010.b                                                            ; $00DF4A | | Set each of the lower 64 sprites in the OAM to use the larger size
-   STA r_oam_hi.w,X                                                            ; $00DF4C | | of sprite.
    INX                                                                         ; $00DF4F | |
    CPX #_sizeof_r_oam_hi.w / 2                                                 ; $00DF50 | |
    BNE -                                                                       ; $00DF53 |/
    RTS                                                                         ; $00DF55

; _wait_for_x_frames ($00:DF56)
;
; Waits until the number of frames passed in the X register have passed.
_wait_for_x_frames:
    STX <r_wait_for_x_frames_frames                                             ; $00DF56
-   JSR _wait_for_nmi_complete_field                                            ; $00DF58
    LDX <r_wait_for_x_frames_frames                                             ; $00DF5B
    DEX                                                                         ; $00DF5D
    STX <r_wait_for_x_frames_frames                                             ; $00DF5E
    BNE -                                                                       ; $00DF60
    RTS                                                                         ; $00DF62

; _decode_event ($00:DF63)
;
; Given an event number in the accumulator, decodes and executes that event.
_decode_event:
    STZ <r_generic_tmp_index.hi                                                 ; $00DF63 |\
    ASL A                                                                       ; $00DF65 | | Calculate the offset to the event data by multiplying the event
    ROL <r_generic_tmp_index.hi                                                 ; $00DF66 | | index by two and using that to index the event offset table. Store
    STA <r_generic_tmp_index.lo                                                 ; $00DF68 | | the result in memory for later use.
    LDX <r_generic_tmp_index                                                    ; $00DF6A | |
    LDA bank12.event_offset_data.l + word.lo,X                                  ; $00DF6C | |
    STA r_decode_event_current_offset.lo.w                                      ; $00DF70 | |
    LDA bank12.event_offset_data.l + word.hi,X                                  ; $00DF73 | |
    STA r_decode_event_current_offset.hi.w                                      ; $00DF77 |/
    LDA #%00001111.b                                                            ; $00DF7A |\ Set PPU brightness to maximum.
    STA <r_ppu_brightness                                                       ; $00DF7C |/
@loop_start:
    LDY #0.w                                                                    ; $00DF7E | Initialize the Y register to zero.
    LDA #1.b                                                                    ; $00DF81 |\ Initialize the event repeat count to 1.
    STA r_decode_event_repeat_count.w                                           ; $00DF83 |/
    LDX r_decode_event_current_offset.w                                         ; $00DF86 | Set the X register to the current event offset.
    LDA bank12.event_data.l,X                                                   ; $00DF89 | Read the next opcode.
    CMP #EVENT_OPCODE_END.b                                                     ; $00DF8D |\
    BNE ++                                                                      ; $00DF8F | | If reaching an end opcode, increment the field sprite slot until
    LDA r_field_sprite_slot.w                                                   ; $00DF91 | | it references a non-empty slot, set the flag that indicates an
    STZ <r_generic_tmp_index.lo                                                 ; $00DF94 | | event completed and return.
    LSR A                                                                       ; $00DF96 | |
    ROR <r_generic_tmp_index.lo                                                 ; $00DF97 | |
    LSR A                                                                       ; $00DF99 | |
    ROR <r_generic_tmp_index.lo                                                 ; $00DF9A | |
    STA <r_generic_tmp_index.hi                                                 ; $00DF9C | |
    LDX <r_generic_tmp_index                                                    ; $00DF9E | |
    LDA r_character_field.1.id.w,X                                              ; $00DFA0 | |
    BNE +                                                                       ; $00DFA3 | |
    JSL bank15.increment_field_sprite_slot                                      ; $00DFA5 | |
+   LDA #1.b                                                                    ; $00DFA9 | |
    STA <r_event_complete                                                       ; $00DFAB | |
    RTS                                                                         ; $00DFAD |/
++  CMP #EVENT_OPCODE_REPEAT.b                                                  ; $00DFAE |\ Skip this next block if the opcode isn't the repeat opcode ($EB).
    BNE +                                                                       ; $00DFB0 |/
    INX                                                                         ; $00DFB2 |\
    LDA bank12.event_data.l,X                                                   ; $00DFB3 | | Read the next byte and save that as the repeat count.
    STA r_decode_event_repeat_count.w                                           ; $00DFB7 |/
    INX                                                                         ; $00DFBA |\
    LDA bank12.event_data.l,X                                                   ; $00DFBB | | The next byte is the number of opcodes to repeat, so save that.
    STA <r_generic_tmp_2                                                        ; $00DFBF |/
    INX                                                                         ; $00DFC1 |\
-   LDA bank12.event_data.l,X                                                   ; $00DFC2 | | Copy the desired number of repeated opcodes into the destination
    STA r_decode_event_bytes.w,Y                                                ; $00DFC6 | | array.
    INX                                                                         ; $00DFC9 | |
    INY                                                                         ; $00DFCA | |
    DEC <r_generic_tmp_2                                                        ; $00DFCB | |
    BNE -                                                                       ; $00DFCD |/
    JMP @process                                                                ; $00DFCF | Jump to process the opcodes.
+   CMP #EVENT_OPCODE_FIRST_DOUBLE_BYTE.b                                       ; $00DFD2 |\
    BCC @single                                                                 ; $00DFD4 | | Dispatch to the correct code based on the number of bytes for the
    CMP #EVENT_OPCODE_ADD_SPELL.b                                               ; $00DFD6 | | opcode. All opcodes less than $DB have only the single byte. $E2
    BEQ @triple                                                                 ; $00DFD8 | | has three bytes in total, and $FE has five. All others have two
    CMP #EVENT_OPCODE_LOAD_MAP.b                                                ; $00DFDA | | bytes.
    BNE @double                                                                 ; $00DFDC |/
    STA r_decode_event_bytes.w,Y                                                ; $00DFDE |\
    INX                                                                         ; $00DFE1 | | For opcode $FE, copy the first two bytes.
    INY                                                                         ; $00DFE2 | |
    LDA bank12.event_data.l,X                                                   ; $00DFE3 | |
    STA r_decode_event_bytes.w,Y                                                ; $00DFE7 | |
    INX                                                                         ; $00DFEA | |
    INY                                                                         ; $00DFEB | |
    LDA bank12.event_data.l,X                                                   ; $00DFEC |/
@triple:
    STA r_decode_event_bytes.w,Y                                                ; $00DFF0 |\
    INX                                                                         ; $00DFF3 | | For opcodes with at least three bytes, copy the next byte.
    INY                                                                         ; $00DFF4 | |
    LDA bank12.event_data.l,X                                                   ; $00DFF5 |/
@double:
    STA r_decode_event_bytes.w,Y                                                ; $00DFF9 |\
    INX                                                                         ; $00DFFC | | For opcodes with at least two bytes, copy the next byte.
    INY                                                                         ; $00DFFD | |
    LDA bank12.event_data.l,X                                                   ; $00DFFE |/
@single:
    STA r_decode_event_bytes.w,Y                                                ; $00E002 |\
    INX                                                                         ; $00E005 | | For all opcodes, store the final byte.
    INY                                                                         ; $00E006 |/
@process:
    STX r_decode_event_current_offset.w                                         ; $00E007 | Store the current event offset.
    LDA #EVENT_OPCODE_END.b                                                     ; $00E00A |\ Ensure the sequence of bytes is terminated with an end opcode.
    STA r_decode_event_bytes.w,Y                                                ; $00E00C |/
-   JSR _decode_event_opcode                                                    ; $00E00F |\
    DEC r_decode_event_repeat_count.w                                           ; $00E012 | | Execute the event the number of specified repeated times.
    BNE -                                                                       ; $00E015 |/
    JMP @loop_start                                                             ; $00E017 | Jump back to move to the next opcode.

; _decode_event_opcode ($00:E01A)
;
; Handles the processing of one or more event opcodes, as stored in the array at
; $09D5. In general, is designed to process a single opcode and its parameters
; before returning. However, for opcodes less than $D0 (which manipulate NPCs
; and the player sprite), it will set the appropriate parameters for the sprite
; in question, and loop to process any further opcodes of that type. Once all
; are processed, it then waits for all sprites to conclude their animations
; before returning (while calling the necessary routines each frame to actually
; process the animations).
_decode_event_opcode:
    LDX #0.w                                                                    ; $00E01A |\ Initialize the current index to zero.
    STX <r_decode_event_index                                                   ; $00E01D |/
    LDA r_decode_event_bytes.w,X                                                ; $00E01F |\ Read the first opcode and save it to a temporary variable.
    STA r_decode_event_current_opcode.w                                         ; $00E022 |/
    CMP #EVENT_OPCODE_FIRST_OTHER.b                                             ; $00E025 |\
    BCC @start                                                                  ; $00E027 | | If the opcode is >= $D0, branch to the code to handle those.
    JMP @other                                                                  ; $00E029 |/
@start:
    LDX <r_decode_event_index                                                   ; $00E02C |\
    LDA r_decode_event_bytes.w,X                                                ; $00E02E | | Read the current opcode.
    STA r_decode_event_current_opcode.w                                         ; $00E031 |/
    CMP #EVENT_OPCODE_END.b                                                     ; $00E034 |\
    BNE +                                                                       ; $00E036 | | If the end opcode, branch to the ending code.
    JMP @end                                                                    ; $00E038 |/
+   CMP #EVENT_OPCODE_FIRST_PLAYER.b                                            ; $00E03B |\
    BCS +                                                                       ; $00E03D | | Otherwise, jump to the player code is the opcode is $C0 or greater
    JSR _decode_event_opcode_npc                                                ; $00E03F | | or the NPC code otherwise.
    JMP ++                                                                      ; $00E042 | |
+   JSR _decode_event_opcode_player                                             ; $00E045 |/
++  LDX <r_decode_event_index                                                   ; $00E048 |\
    INX                                                                         ; $00E04A | | Increment the event index and loop to the next opcode.
    STX <r_decode_event_index                                                   ; $00E04B | |
    JMP @start                                                                  ; $00E04D |/
@end:
    JSR _wait_for_nmi_complete_field                                            ; $00E050 | Wait for the next NMI to be complete.
    STZ <r_player_movement_calculation_enabled                                  ; $00E053 | Disable player movement calculation.
    JSR _init_oam                                                               ; $00E055 | Initialize the OAM.
    JSR _update_current_tile_properties                                         ; $00E058 | Update the tile properties for the current tile.
    LDA r_map_area.w                                                            ; $00E05B |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $00E05E | | Branch ahead if the current map area is a dungeon.
    BEQ +                                                                       ; $00E060 |/
    JSR _do_outdoor_movement                                                    ; $00E062 | Apply the movement for this frame.
    JSR _draw_outdoor_field_sprites                                             ; $00E065 | Draw the outdoor field sprites.
    LDA <r_movement_speed                                                       ; $00E068 |\
    TAX                                                                         ; $00E06A | | Loop until the current movement frame counter, masked by the speed
    LDA <r_movement_frame_counter                                               ; $00E06B | | specific mask, is zero.
    AND movement_speed_mask_data.w,X                                            ; $00E06D | |
    BNE @end                                                                    ; $00E070 |/
    STZ <r_movement_direction                                                   ; $00E072 | Set the movement direction to none.
    JMP @common                                                                 ; $00E074 | Jump to the common code.
+   JSR _do_outdoor_movement                                                    ; $00E077 | For dungeons, handle the movement for this frame.
    JSR _do_npc_movement                                                        ; $00E07A | Handle the NPC movement.
    JSL bank15.draw_dungeon_field_sprite_player                                 ; $00E07D | Draw the player field sprite.
    JSR _draw_field_sprite_npcs                                                 ; $00E081 | Draw the NPCs.
    LDA <r_movement_direction                                                   ; $00E084 |\
    BEQ +                                                                       ; $00E086 | | If a movement direction is configured, repeat this loop until the
    LDA <r_movement_speed                                                       ; $00E088 | | movement frame counter masked by the speed-specific mask is zero.
    TAX                                                                         ; $00E08A | |
    LDA <r_movement_frame_counter                                               ; $00E08B | |
    AND movement_speed_mask_data.w,X                                            ; $00E08D | |
    BNE @end                                                                    ; $00E090 |/
    STZ <r_movement_direction                                                   ; $00E092 | Set the movement direction to none.
+   LDX #0.w                                                                    ; $00E094 |\ Initialize the NPC offset to zero.
    STX <r_generic_tmp_index                                                    ; $00E097 |/
    LDA r_npc_count.w                                                           ; $00E099 |\ If this map has no NPCs, skip the next block.
    BEQ @common                                                                 ; $00E09C |/
    TAY                                                                         ; $00E09E | Transfer the NPC count to the Y register.
-   LDX <r_generic_tmp_index                                                    ; $00E09F |\
    LDA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E0A1 | | If the current NPC still has a frame counter limit, loop again.
    BNE @end                                                                    ; $00E0A4 |/
    STZ r_npc_properties.1.flags.w,X                                            ; $00E0A6 | Reset the NPC's flags.
    LDA <r_generic_tmp_index.lo                                                 ; $00E0A9 |\
    CLC                                                                         ; $00E0AB | | Loop through all of the map's NPCs.
    ADC #_sizeof_npc_properties.b                                               ; $00E0AC | |
    STA <r_generic_tmp_index.lo                                                 ; $00E0AE | |
    DEY                                                                         ; $00E0B0 | |
    BNE -                                                                       ; $00E0B1 |/
@common:
    LDA #1.b                                                                    ; $00E0B3 |\
    STA <r_player_movement_calculation_enabled                                  ; $00E0B5 | | Enable player movement calculation and return.
    RTS                                                                         ; $00E0B7 |/
@other:
    SEC                                                                         ; $00E0B8 |\
    SBC #EVENT_OPCODE_FIRST_OTHER.b                                             ; $00E0B9 | | For opcodes of $D0 and greater, set the X register to the opcode
    STZ <r_generic_tmp_index.hi                                                 ; $00E0BB | | minus $D0 times two.
    ASL A                                                                       ; $00E0BD | |
    ROL <r_generic_tmp_index.hi                                                 ; $00E0BE | |
    STA <r_generic_tmp_index.lo                                                 ; $00E0C0 | |
    LDX <r_generic_tmp_index                                                    ; $00E0C2 |/
    LDA decode_event_opcode_offset_data.w + 0,X                                 ; $00E0C4 |\
    STA <r_generic_tmp_index.lo                                                 ; $00E0C7 | | Load the offset for the handler and jump to it.
    LDA decode_event_opcode_offset_data.w + 1,X                                 ; $00E0C9 | |
    STA <r_generic_tmp_index.hi                                                 ; $00E0CC | |
    LDX <r_decode_event_index                                                   ; $00E0CE | |
    JMP (r_generic_tmp_index)                                                   ; $00E0D0 |/
_decode_event_opcode_done:
    JSR _wait_for_nmi_complete_field                                            ; $00E0D3 | Wait for the next complete NMI.
    RTS                                                                         ; $00E0D6

; _decode_event_opcode_npc ($00:E0D7)
;
; Handles opcodes $00 through $BF, which cause the various NPCs to do things.
; The upper four bits of the opcode are the placement number, and the lower four
; bits encode the action.
_decode_event_opcode_npc:
    STA <r_decode_event_opcode_npc_tmp_opcode                                   ; $00E0D7 | Save the opcode for later use.
    LSR A                                                                       ; $00E0D9 |\
    LSR A                                                                       ; $00E0DA | | Set the Y register to the NPC placement number (by extracting the
    LSR A                                                                       ; $00E0DB | | upper four bits from the opcode).
    LSR A                                                                       ; $00E0DC | |
    TAY                                                                         ; $00E0DD | |
    LDA #0.b                                                                    ; $00E0DE |/
-   CPY #0.w                                                                    ; $00E0E0 |\
    BEQ +                                                                       ; $00E0E3 | | Determine the offset to the NPC data by multiplying the placement
    DEY                                                                         ; $00E0E5 | | number by the size of the NPC properties record. Transfer this
    CLC                                                                         ; $00E0E6 | | result both to a temporary variable and to the X register.
    ADC #_sizeof_npc_properties.b                                               ; $00E0E7 | |
    JMP -                                                                       ; $00E0E9 | |
+   TAX                                                                         ; $00E0EC | |
    STX r_decode_event_opcode_npc_tmp_offset.w                                  ; $00E0ED |/
    LDA #64.b                                                                   ; $00E0F0 |\ Set the NPC's frame counter limit to 64, to allow it to move
    STA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E0F2 |/ exactly one tile (four NPC frames per frame).
    LDA <r_decode_event_opcode_npc_tmp_opcode                                   ; $00E0F5 |\
    AND #%00001111.b                                                            ; $00E0F7 | | If the operation number is zero through three, set the NPC's
    CMP #EVENT_OPCODE_NPC_FACE_UP.b                                             ; $00E0F9 | | movement direction by adding one (as movement directions are 1-4).
    BCS ++                                                                      ; $00E0FB | | If direction changes are enabled, set the NPC's facing direction
    INC A                                                                       ; $00E0FD | | as well, by subtracting one from the movement direction. Set the
    STA r_npc_properties.1.movement_direction.w,X                               ; $00E0FE | | flag to erase any map title. Finally, jump to nearly the end of
    LDA <r_disable_direction_change                                             ; $00E101 | | the function.
    BNE +                                                                       ; $00E103 | |
    LDA r_npc_properties.1.movement_direction.w,X                               ; $00E105 | |
    DEC A                                                                       ; $00E108 | |
    STA r_npc_properties.1.direction.w,X                                        ; $00E109 | |
+   LDA <r_map_title_erase_pending                                              ; $00E10C | |
    BNE +                                                                       ; $00E10E | |
    INC <r_map_title_erase_pending                                              ; $00E110 | |
+   JMP @erase_then_done                                                        ; $00E112 |/
++  CMP #EVENT_OPCODE_NPC_TOGGLE_VISIBILITY.b                                   ; $00E115 |\
    BCS +                                                                       ; $00E117 | | If the operation number is 4 through 7, subtract four and use that
    SEC                                                                         ; $00E119 | | to set the NPC's facing direction, before jumping to the end.
    SBC #4.b                                                                    ; $00E11A | |
    STA r_npc_properties.1.direction.w,X                                        ; $00E11C | |
    JMP @done                                                                   ; $00E11F |/
+   CMP #EVENT_OPCODE_NPC_TOGGLE_VISIBILITY.b                                   ; $00E122 |\ If the operation is not exactly 8, skip to the next block.
    BNE +++                                                                     ; $00E124 |/
    STZ r_npc_properties.1.movement_direction.w,X                               ; $00E126 | Set the movement direction to none.
    LDA r_npc_properties.1.y.w,X                                                ; $00E129 |\
    STA <r_generic_tmp_index.hi                                                 ; $00E12C | | Determine the index by multiplying the Y coordinate by 32 and
    STZ <r_generic_tmp_index.lo                                                 ; $00E12E | | adding the X coordinate. This is used to index the field sprite
    LSR <r_generic_tmp_index.hi                                                 ; $00E130 | | positioning array.
    ROR <r_generic_tmp_index.lo                                                 ; $00E132 | |
    LSR <r_generic_tmp_index.hi                                                 ; $00E134 | |
    ROR <r_generic_tmp_index.lo                                                 ; $00E136 | |
    LSR <r_generic_tmp_index.hi                                                 ; $00E138 | |
    ROR <r_generic_tmp_index.lo                                                 ; $00E13A | |
    LDA <r_generic_tmp_index.lo                                                 ; $00E13C | |
    CLC                                                                         ; $00E13E | |
    ADC r_npc_properties.1.x.w,X                                                ; $00E13F | |
    STA <r_generic_tmp_index.lo                                                 ; $00E142 |/
    LDA <r_decode_event_opcode_npc_tmp_opcode                                   ; $00E144 |\
    LSR A                                                                       ; $00E146 | | Calculate the field sprite positioning value by taking the NPC
    LSR A                                                                       ; $00E147 | | placement number and adding $80.
    LSR A                                                                       ; $00E148 | |
    LSR A                                                                       ; $00E149 | |
    CLC                                                                         ; $00E14A | |
    ADC #$80.b                                                                  ; $00E14B | |
    STA <r_generic_tmp_1                                                        ; $00E14D |/
    LDA r_npc_properties.1.visible.w,X                                          ; $00E14F |\
    BEQ ++                                                                      ; $00E152 | | If the target NPC is currently visible, set them to invisible and
    STZ r_npc_properties.1.visible.w,X                                          ; $00E154 | | remove them from the field sprite positioning array, if the sprite
    PHX                                                                         ; $00E157 | | at that location matches the target number.
    LDX <r_generic_tmp_index                                                    ; $00E158 | |
    LDA r_field_sprite_positioning.l,X                                          ; $00E15A | |
    CMP <r_generic_tmp_1                                                        ; $00E15E | |
    BNE +                                                                       ; $00E160 | |
    LDA #0.b                                                                    ; $00E162 | |
    STA r_field_sprite_positioning.l,X                                          ; $00E164 | |
+   PLX                                                                         ; $00E168 | |
    JMP @done                                                                   ; $00E169 |/
++  LDA #1.b                                                                    ; $00E16C |\
    STA r_npc_properties.1.visible.w,X                                          ; $00E16E | | If the NPC is invisible, make them visible and set the number in
    PHX                                                                         ; $00E171 | | the field sprite positioning array. Afterward, jump to the end.
    LDX <r_generic_tmp_index                                                    ; $00E172 | |
    LDA <r_generic_tmp_1                                                        ; $00E174 | |
    STA r_field_sprite_positioning.l,X                                          ; $00E176 | |
    PLX                                                                         ; $00E17A | |
    JMP @done                                                                   ; $00E17B |/
+++ CMP #EVENT_OPCODE_NPC_JUMP_SIDEWAYS.b                                       ; $00E17E |\ Skip the next block if the operation number isn't 9.
    BNE +++                                                                     ; $00E180 |/
    LDA r_npc_properties.1.direction.w,X                                        ; $00E182 |\
    AND #DIRECTION_HORIZONTAL.b                                                 ; $00E185 | | If the NPC is facing right, set both their movement direction and
    BEQ +                                                                       ; $00E187 | | their facing direction to right.
    LDA r_npc_properties.1.direction.w,X                                        ; $00E189 | |
    AND #DIRECTION_DOWN_LEFT.b                                                  ; $00E18C | |
    BNE ++                                                                      ; $00E18E | |
    LDA #MOVEMENT_DIRECTION_RIGHT.b                                             ; $00E190 | |
    STA r_npc_properties.1.movement_direction.w,X                               ; $00E192 | |
    DEC A                                                                       ; $00E195 | |
    STA r_npc_properties.1.direction.w,X                                        ; $00E196 |/
+   LDA #NPC_FLAGS_JUMPING.b                                                    ; $00E199 |\
    STA r_npc_properties.1.flags.w,X                                            ; $00E19B | | If the NPC is facing up, down or right, set the jumping flag and
    LDA #128.b                                                                  ; $00E19E | | set the frame counter limit to 128, before jumping to nearly the
    STA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E1A0 | | end.
    JMP @erase_then_done                                                        ; $00E1A3 |/
++  LDA #MOVEMENT_DIRECTION_LEFT.b                                              ; $00E1A6 |\
    STA r_npc_properties.1.movement_direction.w,X                               ; $00E1A8 | | If the NPC is facing left, set the movement and facing directions
    DEC A                                                                       ; $00E1AB | | to left, set the jumping flag, set the frame counter limit to 128,
    STA r_npc_properties.1.direction.w,X                                        ; $00E1AC | | and then jump to nearly the end.
    LDA #NPC_FLAGS_JUMPING.b                                                    ; $00E1AF | |
    STA r_npc_properties.1.flags.w,X                                            ; $00E1B1 | |
    LDA #128.b                                                                  ; $00E1B4 | |
    STA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E1B6 | |
    JMP @erase_then_done                                                        ; $00E1B9 |/
+++ CMP #EVENT_OPCODE_NPC_SPIN.b                                                ; $00E1BC |\
    BNE +                                                                       ; $00E1BE | | If the opcode is $0A, zero out the NPC's frame counter, set the
    STZ r_npc_properties.1.frame_counter.w,X                                    ; $00E1C0 | | spinning flag, set the frame counter limit to 64, and jump to the
    LDA #NPC_FLAGS_SPINNING.b                                                   ; $00E1C3 | | end.
    STA r_npc_properties.1.flags.w,X                                            ; $00E1C5 | |
    LDA #64.b                                                                   ; $00E1C8 | |
    STA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E1CA | |
    JMP @done                                                                   ; $00E1CD |/
+   CMP #EVENT_OPCODE_NPC_SPIN_JUMP.b                                           ; $00E1D0 |\
    BNE +                                                                       ; $00E1D2 | | If the opcode is $0B, zero out the NPC's frame counter, set both
    STZ r_npc_properties.1.frame_counter.w,X                                    ; $00E1D4 | | the spinning and jumping flags, set the frame counter limit to
    LDA #NPC_FLAGS_JUMPING.b | NPC_FLAGS_SPINNING                               ; $00E1D7 | | 128 and jump to the end.
    STA r_npc_properties.1.flags.w,X                                            ; $00E1D9 | |
    LDA #128.b                                                                  ; $00E1DC | |
    STA r_npc_properties.1.frame_counter_limit.w,X                              ; $00E1DE | |
    JMP @done                                                                   ; $00E1E1 |/
+   CMP #EVENT_OPCODE_NPC_WAVE_2.b                                              ; $00E1E4 |\
    BNE +                                                                       ; $00E1E6 | | If the opcode is $0C, set the direction to the second waving
    LDA #DIRECTION_WAVING_2.b                                                   ; $00E1E8 | | direction and jump to the end.
    STA r_npc_properties.1.direction.w,X                                        ; $00E1EA | |
    JMP @done                                                                   ; $00E1ED |/
+   CMP #EVENT_OPCODE_NPC_WAVE_1.b                                              ; $00E1F0 |\
    BNE +                                                                       ; $00E1F2 | | If the opcode is $0D, set the direction to the first waving
    LDA #DIRECTION_WAVING_1.b                                                   ; $00E1F4 | | direction and jump to the end.
    STA r_npc_properties.1.direction.w,X                                        ; $00E1F6 | |
    JMP @done                                                                   ; $00E1F9 |/
+   CMP #EVENT_OPCODE_NPC_BOW.b                                                 ; $00E1FC |\
    BNE +                                                                       ; $00E1FE | | If the opcode is $0E, set the direction to bowing and jump to the
    LDA #DIRECTION_BOWING.b                                                     ; $00E200 | | end.
    STA r_npc_properties.1.direction.w,X                                        ; $00E202 | |
    JMP @done                                                                   ; $00E205 |/
+   LDA #DIRECTION_LYING.b                                                      ; $00E208 |\
    STA r_npc_properties.1.direction.w,X                                        ; $00E20A | | Otherwise, set the direction to lying and jump to the end.
    JMP @done                                                                   ; $00E20D |/
@erase_then_done:
    LDA r_npc_properties.1.x.w,X                                                ; $00E210 |\
    STA <r_generic_arg_x_lo                                                     ; $00E213 | | Remove this sprite from the sprite positioning array.
    LDA r_npc_properties.1.y.w,X                                                ; $00E215 | |
    STA <r_generic_arg_y_lo                                                     ; $00E218 | |
    JSR _clear_sprite_position                                                  ; $00E21A |/
@done:
    STZ r_npc_properties.1.frame_counter.w,X                                    ; $00E21D | Reset the NPC's frame counter.
    RTS                                                                         ; $00E220

; _decode_event_opcode_player ($00:E221)
;
; Handles event opcodes $C0 through $CF, which produce various effects on the
; player field sprite.
_decode_event_opcode_player:
    CMP #EVENT_OPCODE_PLAYER_FACE.b                                             ; $00E221 |\
    BCS +                                                                       ; $00E223 | | If the opcode is in the movement range, subtract the base to
    SEC                                                                         ; $00E225 | | determine the direction of movement and set the joypad accordingly
    SBC #EVENT_OPCODE_PLAYER_MOVE.b                                             ; $00E226 | | by reading the correct button presses from ROM.
    ASL A                                                                       ; $00E228 | |
    TAY                                                                         ; $00E229 | |
    LDA direction_joypad_data,Y                                                 ; $00E22A | |
    STA <r_joypad_cutscene_lo                                                   ; $00E22D | |
    LDA direction_joypad_data + 1,Y                                             ; $00E22F | |
    STA <r_joypad_cutscene_hi                                                   ; $00E232 | |
    JMP @next                                                                   ; $00E234 |/
+   STZ <r_joypad_cutscene_lo                                                   ; $00E237 |\ Otherwise, there is no movement.
    STZ <r_joypad_cutscene_hi                                                   ; $00E239 |/
    CMP #EVENT_OPCODE_PLAYER_SET_INVISIBLE.b                                    ; $00E23B |\
    BCS +                                                                       ; $00E23D | | If the opcode is in the face range, subtract the base to determine
    SEC                                                                         ; $00E23F | | the direction and then set the direction.
    SBC #EVENT_OPCODE_PLAYER_FACE.b                                             ; $00E240 | |
    STA r_direction.w                                                           ; $00E242 | |
    JMP @next                                                                   ; $00E245 |/
+   CMP #EVENT_OPCODE_PLAYER_SET_INVISIBLE.b                                    ; $00E248 |\
    BNE +                                                                       ; $00E24A | | If the opcode is $C8, set the player's sprite to be invisible.
    LDA #$01.b                                                                  ; $00E24C | |
    STA <r_player_field_sprite_invisible                                        ; $00E24E | |
    JMP @next                                                                   ; $00E250 |/
+   CMP #EVENT_OPCODE_PLAYER_SET_VISIBLE.b                                      ; $00E253 |\
    BNE +                                                                       ; $00E255 | | If the opcode is $C9, set the player's sprite to be visible.
    STZ <r_player_field_sprite_invisible                                        ; $00E257 | |
    JMP @next                                                                   ; $00E259 |/
+   CMP #EVENT_OPCODE_PLAYER_POSE_WAVING_2.b                                    ; $00E25C |\
    BNE +                                                                       ; $00E25E | | If the opcode is $CA, set the player's direction to the second
    LDA #DIRECTION_WAVING_2.b                                                   ; $00E260 | | type of wave.
    STA r_direction.w                                                           ; $00E262 | |
    JMP @no_movement                                                            ; $00E265 |/
+   CMP #EVENT_OPCODE_PLAYER_POSE_WAVING_1.b                                    ; $00E268 |\
    BNE +                                                                       ; $00E26A | | If the opcode is $CB, set the player's direction to the first
    LDA #DIRECTION_WAVING_1.b                                                   ; $00E26C | | type of wave.
    STA r_direction.w                                                           ; $00E26E | |
    JMP @no_movement                                                            ; $00E271 |/
+   CMP #EVENT_OPCODE_PLAYER_POSE_BOWING.b                                      ; $00E274 |\
    BNE +                                                                       ; $00E276 | | If the opcode is $CC, set the player's direction to bowing.
    LDA #DIRECTION_BOWING.b                                                     ; $00E278 | |
    STA r_direction.w                                                           ; $00E27A | |
    JMP @no_movement                                                            ; $00E27D |/
+   CMP #EVENT_OPCODE_PLAYER_POSE_LYING.b                                       ; $00E280 |\
    BNE +                                                                       ; $00E282 | | If the opcode is $CD, set the player's direction to lying down.
    LDA #DIRECTION_LYING.b                                                      ; $00E284 | |
    STA r_direction.w                                                           ; $00E286 | |
    JMP @no_movement                                                            ; $00E289 |/
+   CMP #EVENT_OPCODE_PLAYER_TOGGLE_TURNING.b                                   ; $00E28C |\
    BNE +                                                                       ; $00E28E | | If the opcode is $CE, toggle the player's turning.
    LDA <r_disable_direction_change                                             ; $00E290 | |
    EOR #%00000001.b                                                            ; $00E292 | |
    STA <r_disable_direction_change                                             ; $00E294 | |
    JMP @no_movement                                                            ; $00E296 |/
+   LDA <r_enable_spinning                                                      ; $00E299 |\
    BNE +                                                                       ; $00E29B | | If the opcode is $CF, toggle the player's spinning.
    LDA #1.b                                                                    ; $00E29D | |
    JMP ++                                                                      ; $00E29F | |
+   LDA #0.b                                                                    ; $00E2A2 | |
++  STA <r_enable_spinning                                                      ; $00E2A4 |/
@no_movement:
    STZ <r_movement_direction                                                   ; $00E2A6 |\
    STZ <r_joypad_pressed_lo                                                    ; $00E2A8 | | If no movement, zero out the movement direction and joypad.
    STZ <r_joypad_pressed_hi                                                    ; $00E2AA |/
@next:
    STZ <r_movement_frame_counter                                               ; $00E2AC | Reset the movement frame counter.
    LDA r_map_area.w                                                            ; $00E2AE |\
    CMP #MAP_AREA_DUNGEON.b                                                     ; $00E2B1 | | Calculate the final movement direction depending on the type of
    BEQ +                                                                       ; $00E2B3 | | map.
    JSR _calculate_outdoor_movement_direction                                   ; $00E2B5 | |
    JMP ++                                                                      ; $00E2B8 | |
+   JSR _calculate_dungeon_movement_direction                                   ; $00E2BB |/
++  RTS                                                                         ; $00E2BE

; direction_joypad_data ($00:E2BF)
;
; For each possible direction, specifies the necessary buttons to press on the
; joypad to move in that direction. Each direction has two bytes.
direction_joypad_data:
    .db $00, JOYPAD_H_UP                                                        ; $00E2BF.E2C0
    .db $00, JOYPAD_H_RIGHT                                                     ; $00E2C1.E2C2
    .db $00, JOYPAD_H_DOWN                                                      ; $00E2C3.E2C4
    .db $00, JOYPAD_H_LEFT                                                      ; $00E2C5.E2C6

; movement_speed_mask_data ($00:E2C7)
;
; For each movement speed, provides the mask to determine if the movement has
; completed its cycle. It ranges from every 16 frames to every 2 frames.
movement_speed_mask_data:
    .db %00001111                                                               ; $00E2C7 | $00
    .db %00000111                                                               ; $00E2C8 | $01
    .db %00000011                                                               ; $00E2C9 | $02
    .db %00000001                                                               ; $00E2CA | $03

; _decode_event_get_next_byte ($00:E2CB)
;
; Advances the event decoding index in $06B3 and retrieves the next byte from
; the array stored at $09D5.
_decode_event_get_next_byte:
    INX                                                                         ; $00E2CB |\
    STX <r_decode_event_index                                                   ; $00E2CC | | Increment the index and load the next byte.
    LDA r_decode_event_bytes.w,X                                                ; $00E2CE |/
    RTS                                                                         ; $00E2D1

; _decode_event_advance_to_end ($00:E2D2)
;
; Searches the event data starting at the current event offset at $09D3 until it
; finds the next $FF, and then sets the offset to that address. This is
; used by the branching system, which separates different branches with end
; opcodes.
_decode_event_advance_to_end:
    LDX r_decode_event_current_offset.w                                         ; $00E2D2 |\
    INX                                                                         ; $00E2D5 | | Loop through the event data searching for the next end opcode,
-   LDA bank12.event_data.l,X                                                   ; $00E2D6 | | and then set the current offset to that address.
    CMP #EVENT_OPCODE_END.b                                                     ; $00E2DA | |
    BEQ +                                                                       ; $00E2DC | |
    INX                                                                         ; $00E2DE | |
    JMP -                                                                       ; $00E2DF | |
+   STX r_decode_event_current_offset.w                                         ; $00E2E2 |/
    RTS                                                                         ; $00E2E5

; decode_event_opcode_offset_data ($00:E2E6)
;
; For each event opcode of $D0 and greater, provides the offset to the handler
; for that opcode.
decode_event_opcode_offset_data:
    .addr _decode_event_opcode_toggle_shaking                                   ; $00E2E6 | $D0
    .addr _decode_event_opcode_flash_screen                                     ; $00E2E8 | $D1
    .addr _decode_event_opcode_mosaic                                           ; $00E2EA | $D2
    .addr _decode_event_opcode_big_whale_earth_moon_travel                      ; $00E2EC | $D3
    .addr _decode_event_opcode_big_chocobo                                      ; $00E2EE | $D4
    .addr _decode_event_opcode_open_large_door                                  ; $00E2F0 | $D5
    .addr _decode_event_opcode_random_vertical_offset                           ; $00E2F2 | $D6
    .addr _decode_event_opcode_toggle_fast_movement                             ; $00E2F4 | $D7
    .addr _decode_event_opcode_audio_fade_out_slow                              ; $00E2F6 | $D8
    .addr _decode_event_opcode_namingway                                        ; $00E2F8 | $D9
    .addr _decode_event_opcode_ppu_fade                                         ; $00E2FA | $DA
    .addr _decode_event_opcode_toggle_status                                    ; $00E2FC | $DB
    .addr _decode_event_opcode_inn                                              ; $00E2FE | $DC
    .addr _decode_event_opcode_set_player_field_sprite                          ; $00E300 | $DD
    .addr _decode_event_opcode_restore_hp                                       ; $00E302 | $DE
    .addr _decode_event_opcode_restore_mp                                       ; $00E304 | $DF
    .addr _decode_event_opcode_inventory_add_item                               ; $00E306 | $E0
    .addr _decode_event_opcode_inventory_remove_item                            ; $00E308 | $E1
    .addr _decode_event_opcode_add_spell                                        ; $00E30A | $E2
    .addr _decode_event_opcode_remove_status                                    ; $00E30C | $E3
    .addr _decode_event_opcode_add_status                                       ; $00E30E | $E4
    .addr _decode_event_opcode_add_gp                                           ; $00E310 | $E5
    .addr _decode_event_opcode_subtract_gp                                      ; $00E312 | $E6
    .addr _decode_event_opcode_add_character                                    ; $00E314 | $E7
    .addr _decode_event_opcode_remove_character                                 ; $00E316 | $E8
    .addr _decode_event_opcode_wait                                             ; $00E318 | $E9
    .addr _decode_event_opcode_play_song_with_fade_in                           ; $00E31A | $EA
    .addr 0                                                                     ; $00E31C | $EB
    .addr _decode_event_opcode_start_battle                                     ; $00E31E | $EC
    .addr _decode_event_opcode_shop                                             ; $00E320 | $ED
    .addr _decode_event_opcode_show_message_npc                                 ; $00E322 | $EE
    .addr _decode_event_opcode_show_message_bank_0                              ; $00E324 | $EF
    .addr _decode_event_opcode_show_message_bank_1_lo                           ; $00E326 | $F0
    .addr _decode_event_opcode_show_message_bank_1_hi                           ; $00E328 | $F1
    .addr _decode_event_opcode_set_plot_flag                                    ; $00E32A | $F2
    .addr _decode_event_opcode_reset_plot_flag                                  ; $00E32C | $F3
    .addr _decode_event_opcode_activate_npc                                     ; $00E32E | $F4
    .addr _decode_event_opcode_deactivate_npc                                   ; $00E330 | $F5
    .addr _decode_event_opcode_show_message_bank_2                              ; $00E332 | $F6
    .addr _decode_event_opcode_select_item                                      ; $00E334 | $F7
    .addr _decode_event_opcode_show_message_bank_1_hi_yes_no                    ; $00E336 | $F8
    .addr _decode_event_opcode_toggle_color_subtraction                         ; $00E338 | $F9
    .addr _decode_event_opcode_play_song                                        ; $00E33A | $FA
    .addr _decode_event_opcode_play_sound_effect                                ; $00E33C | $FB
    .addr 0                                                                     ; $00E33E | $FC
    .addr _decode_event_opcode_custom_effect                                    ; $00E340 | $FD
    .addr _decode_event_opcode_load_map                                         ; $00E342 | $FE

; _decode_event_opcode_namingway ($00:E344)
;
; Handles opcode $D9, which displays the Namingway menu.
_decode_event_opcode_namingway:
    JSR _fade_out_and_disable_interrupts                                        ; $00E344 | Fade the screen out and disable interrupts.
    JSL bank01.menu_namingway                                                   ; $00E347 | Run the Namingway menu.
    JSR _cleanup_menu_and_reinit_map                                            ; $00E34B | Cleanup the menu, re-enable interrupts, and fade in.
    JMP _decode_event_opcode_done                                               ; $00E34E

; _decode_event_opcode_big_chocobo ($00:E351)
;
; Handles opcode $D4, which displays the Big Chocobo menu.
_decode_event_opcode_big_chocobo:
    JSR _fade_out_and_disable_interrupts                                        ; $00E351 | Fade the screen out and disable interrupts.
    JSL bank01.menu_big_chocobo                                                 ; $00E354 | Run the Big Chocobo menu.
    JSR _cleanup_menu_and_reinit_map                                            ; $00E358 | Cleanup the menu, re-enable interrupts, and fade in.
    JMP _decode_event_opcode_done                                               ; $00E35B

; _decode_event_opcode_shop ($00:E35E)
;
; Handles opcode $ED, which shows the shop indicated by the following byte.
_decode_event_opcode_shop:
    JSR _decode_event_get_next_byte                                             ; $00E35E |\ Fetch the next byte and save that as the shop index.
    STA r_shop_index.w                                                          ; $00E361 |/
    TAX                                                                         ; $00E364 |\
    LDA bank14.shop_type_data.l,X                                               ; $00E365 | | Load the shop type and save that as well.
    STA r_shop_type.w                                                           ; $00E369 |/
    JSR _fade_out_and_disable_interrupts                                        ; $00E36C | Fade out the screen and disable interrupts.
    JSL bank01.menu_shop                                                        ; $00E36F | Execute the shop.
    JSR _cleanup_menu_and_reinit_map                                            ; $00E373 | Reinitialize the PPU, fade in, and re-enable interrupts.
    JMP _decode_event_opcode_done                                               ; $00E376

; _decode_event_opcode_play_song_with_fade_in ($00:E379)
;
; Plays the passed parameter track with the fade-in effect.
_decode_event_opcode_play_song_with_fade_in:
    JSR _decode_event_get_next_byte                                             ; $00E379 |\
    STA r_play_audio_arg_track.w                                                ; $00E37C | | Play the passed parameter track using the fade-in mode.
    LDA #AUDIO_MODE_NORMAL_FADE_IN.b                                            ; $00E37F | |
    STA r_play_audio_arg_mode.w                                                 ; $00E381 | |
    JSL bank04.play_audio                                                       ; $00E384 |/
    JMP _decode_event_opcode_done                                               ; $00E388

; _decode_event_opcode_audio_fade_out_slow ($00:E38B)
;
; Handles event opcode $D8, which fades out the currently playing audio slowly.
_decode_event_opcode_audio_fade_out_slow:
    JSR _audio_fade_out_slow                                                    ; $00E38B | Fade out the audio slowly.
    JMP _decode_event_opcode_done                                               ; $00E38E

; _decode_event_opcode_start_battle ($00:E391)
;
; Handles event opcode $EC, which takes a parameter of the formation number to
; load. Note that the high byte of the formation number will be determined by
; the current map plane.
_decode_event_opcode_start_battle:
    JSR _decode_event_get_next_byte                                             ; $00E391 |\ Get the next byte and save it as the formation number.
    STA r_battle_formation_lo.w                                                 ; $00E394 |/
    LDA r_map_plane.w                                                           ; $00E397 |\
    BEQ +                                                                       ; $00E39A | | Set the high byte of the formation to zero if the map plane is
    LDA #1.b                                                                    ; $00E39C | | zero and one otherwise.
+   STA r_battle_formation_hi.w                                                 ; $00E39E |/
    STZ <r_swapped_party_battle_index                                           ; $00E3A1 | Initialize the swapped party index to zero by default.
    LDY #0.w                                                                    ; $00E3A3 | Initialize the Y register to zero.
-   LDA r_battle_formation_lo.w                                                 ; $00E3A6 |\
    CMP swapped_party_battle_formation_data.w + 0,Y                             ; $00E3A9 | | If the formation is in the list of swapped party formations,
    BNE +                                                                       ; $00E3AC | | branch to the swapped party code. Otherwise, continue to start the
    LDA r_battle_formation_hi.w                                                 ; $00E3AE | | battle.
    CMP swapped_party_battle_formation_data.w + 1,Y                             ; $00E3B1 | |
    BEQ @swapped_party                                                          ; $00E3B4 | |
+   INY                                                                         ; $00E3B6 | |
    INY                                                                         ; $00E3B7 | |
    CPY #_sizeof_swapped_party_battle_formation_data.w                          ; $00E3B8 | |
    BNE -                                                                       ; $00E3BB |/
@start_battle:
    JSR _animate_transition_and_start_battle                                    ; $00E3BD | Animate the transition and start the battle.
    LDA <r_swapped_party_battle_index                                           ; $00E3C0 |\
    BEQ +                                                                       ; $00E3C2 | | Restore the original party if this was a swapped party battle.
    JSR _restore_original_party                                                 ; $00E3C4 |/
+   JSL bank15.init_ppu                                                         ; $00E3C7 | Initialize the field PPU settings.
    JSR _change_map_dungeon_resume                                              ; $00E3CB | Change back to the current dungeon map.
    JSR _do_in_transition                                                       ; $00E3CE | Animate the map fade-in transition.
    JSL bank15.draw_dungeon_field_sprite_player                                 ; $00E3D1 | Draw the player field sprite.
    JSR _draw_field_sprite_npcs                                                 ; $00E3D5 | Draw any NPC sprites.
    LDA #%10000001.b                                                            ; $00E3D8 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00E3DA |/
    JMP _decode_event_opcode_done                                               ; $00E3DD | Jump to the end of the event opcode.
@swapped_party:
    TYA                                                                         ; $00E3E0 | Transfer the swapped party offset to the accumulator.
    CMP #_sizeof_swapped_party_battle_formation_data.b - 2                      ; $00E3E1 |\
    BNE +                                                                       ; $00E3E3 | | If it points to the last entry in the table, subtract two, to
    DEC A                                                                       ; $00E3E5 | | consolidate the Zemus and Zeromus entries into one entry.
    DEC A                                                                       ; $00E3E6 |/
+   LSR A                                                                       ; $00E3E7 | Divide the result by two to convert it to an index.
    STA <r_generic_tmp_1                                                        ; $00E3E8 | Save the result to a temporary variable.
    ORA #%10000000.b                                                            ; $00E3EA |\ Set the flag to ensure the value is non-zero, and save the result
    STA <r_swapped_party_battle_index                                           ; $00E3EC |/ to another variable for later use.
    LDX #0.w                                                                    ; $00E3EE |\
    LDY #0.w                                                                    ; $00E3F1 | | Loop through the five character slots, backing up the character ID
-   LDA r_character_field.1.id.w,X                                              ; $00E3F4 | | for each slot to memory for restoration after the battle.
    STA r_swapped_party_battle_original_character_ids.w,Y                       ; $00E3F7 | |
    JSR _increment_x_by_64                                                      ; $00E3FA | |
    INY                                                                         ; $00E3FD | |
    CPY #5.w                                                                    ; $00E3FE | |
    BNE -                                                                       ; $00E401 |/
    LDA <r_generic_tmp_1                                                        ; $00E403 |\  If this is either the Zemus or initial Zeromus battle, branch to
    CMP #SWAPPED_PARTY_BATTLE_INDEX_ZEMUS_ZEROMUS.b                             ; $00E405 | | the Zeromus-specific code.
    BEQ @zeromus                                                                ; $00E407 |/
    TAY                                                                         ; $00E409 | Transfer the index to the Y register.
    LDX #0.w                                                                    ; $00E40A
@loop_start:
    LDA swapped_party_battle_character_data.w,Y                                 ; $00E40D |\
    CMP #CHARACTER_RYDIA_1.b                                                    ; $00E410 | | If the designated character is child Rydia, branch to that code.
    BEQ @rydia                                                                  ; $00E412 |/
    LDA r_character_field.1.id.w,X                                              ; $00E414 |\
    AND #%00011111.b                                                            ; $00E417 | | If the character in the current slot matches the designated
    CMP swapped_party_battle_character_data.w,Y                                 ; $00E419 | | character, branch ahead.
    BEQ ++                                                                      ; $00E41C |/
    CPY #SWAPPED_PARTY_BATTLE_INDEX_ZEMUS_ZEROMUS.w                             ; $00E41E |\
    BNE +                                                                       ; $00E421 | | If this is the Zemus or Zeromus battle, additionally check the
    CMP swapped_party_battle_character_data.w + 1,Y                             ; $00E423 | | second character. NOTE: This will never execute.
    BEQ ++                                                                      ; $00E426 |/
+   LDA #CHARACTER_NONE.b                                                       ; $00E428 |\ Otherwise, set this character's ID to none to temporarily remove
    STA r_character_field.1.id.w,X                                              ; $00E42A |/ them from the party.
    JMP +                                                                       ; $00E42D | Branch ahead to the next iteration.
++  JSR _reset_character_status                                                 ; $00E430 |\
    LDA r_character_field.1.hp_max_lo.w,X                                       ; $00E433 | | Restore this character's status bytes, restore their HP and MP to
    STA r_character_field.1.hp_lo.w,X                                           ; $00E436 | | maximum, and branch ahead past the Rydia code.
    LDA r_character_field.1.hp_max_hi.w,X                                       ; $00E439 | |
    STA r_character_field.1.hp_hi.w,X                                           ; $00E43C | |
    LDA r_character_field.1.mp_max_lo.w,X                                       ; $00E43F | |
    STA r_character_field.1.mp_lo.w,X                                           ; $00E442 | |
    LDA r_character_field.1.mp_max_hi.w,X                                       ; $00E445 | |
    STA r_character_field.1.mp_hi.w,X                                           ; $00E448 | |
+   JMP +                                                                       ; $00E44B |/
@rydia:
    LDA r_character_field.1.id.w,X                                              ; $00E44E |\
    AND #%00011111.b                                                            ; $00E451 | | If the designed character was child Rydia and this current slot is
    CMP #CHARACTER_RYDIA_1.b                                                    ; $00E453 | | child Rydia, zero out the ID byte to temporarily remove her from
    BNE +                                                                       ; $00E455 | | the party.
    STZ r_character_field.1.id.w,X                                              ; $00E457 |/
+   JSR _increment_x_by_64                                                      ; $00E45A | Increment the X register to the next record.
    CPX #_sizeof_character_field.w * 5                                          ; $00E45D |\ Loop until all five character slots have been examined.
    BNE @loop_start                                                             ; $00E460 |/
    JMP @start_battle                                                           ; $00E462 | Jump to start the actual battle.
@zeromus:
    LDX #0.w                                                                    ; $00E465 |\
-   LDA r_character_field.4.w,X                                                 ; $00E468 | | Copy the entire record for the characters in the last two slots to
    STA r_character_field.9.w,X                                                 ; $00E46B | | the last two slots of the shadow party.
    INX                                                                         ; $00E46E | |
    CPX #_sizeof_character_field.w * 2                                          ; $00E46F | |
    BNE -                                                                       ; $00E472 |/
    LDX #0.w                                                                    ; $00E474 |\
-   STZ r_character_field.1.id.w,X                                              ; $00E477 | | Loop through the five character slots, setting the character IDs
    JSR _increment_x_by_64                                                      ; $00E47A | | for all of them to zero to temporarily empty the party.
    CPX #_sizeof_character_field.w * 5                                          ; $00E47D | |
    BNE -                                                                       ; $00E480 |/
    LDX #_sizeof_character_field.w * 3                                          ; $00E482 |\ Set the character loading target index to the offset for the fourth
    STX <r_load_initial_arg_target_index                                        ; $00E485 |/ record.
    LDA #CHARACTER_STATS_GOLBEZ.b                                               ; $00E487 |\ Load the stats and equipment for Golbez. BUG: Equipment is loaded
    JSR _load_character                                                         ; $00E489 |/ by event byte, so this doesn't actually load his equipment.
    LDX #_sizeof_character_field.w * 4                                          ; $00E48C |\ Set the character loading target index to the offset for the fifth
    STX <r_load_initial_arg_target_index                                        ; $00E48F |/ record.
    LDA #1.b                                                                    ; $00E491 |\ Move the character from the second shadow slot to the last slot.
    JSR _move_character_from_shadow                                             ; $00E493 |/
    LDX #_sizeof_character_field.w * 4                                          ; $00E496 |\ Reset FuSoYa's status bytes.
    JSR _reset_character_status                                                 ; $00E499 |/
    LDA r_character_field.1.hp_max_lo.w,X                                       ; $00E49C |\
    STA r_character_field.1.hp_lo.w,X                                           ; $00E49F | | Restore FuSoYa's HP and MP to maximum.
    LDA r_character_field.1.hp_max_hi.w,X                                       ; $00E4A2 | |
    STA r_character_field.1.hp_hi.w,X                                           ; $00E4A5 | |
    LDA r_character_field.1.mp_max_lo.w,X                                       ; $00E4A8 | |
    STA r_character_field.1.mp_lo.w,X                                           ; $00E4AB | |
    LDA r_character_field.1.mp_max_hi.w,X                                       ; $00E4AE | |
    STA r_character_field.1.mp_hi.w,X                                           ; $00E4B1 |/
    LDX #character_field.armor_head.w                                           ; $00E4B4 |\
-   STZ r_character_field.4.w,X                                                 ; $00E4B7 | | Clear out Golbez's equipment bytes.
    INX                                                                         ; $00E4BA | | NOTE: Is this their "fix" to the bug in loading Golbez's
    CPX #character_field.left_hand_count.w + 1                                  ; $00E4BB | |       equipment from above?
    BNE -                                                                       ; $00E4BE |/
    JMP @start_battle                                                           ; $00E4C0 | Jump to start the battle.

; _restore_original_party ($00:E4C3)
;
; After a swapped party battle, called to restore the original party. The only
; changed value is the character ID, except in the Zemus/Zeromus case, where the
; entire character records are copied back (the only case where substitute
; characters are actually added).
;
; BUG: The first bug in this routine involves a status byte reset it does on
;      the restored characters. Presumably, the person writing the code thought
;      mistakenly that the swapped party battle index was the slot of the
;      kept character or something. As a result, they compare it against the
;      actual slot to determine if that character should have their status bytes
;      reset. The practical effect is minimal, except that certan characters
;      will have their status reset after the four Fabul fights or the Bard
;      fight. (This has been observed in the speedrun where Cecil, if he dies
;      in the Octomamm fight, will exit Damcyan in a half-alive state, as the
;      swoon bit has been cleared, though his HP is still zero.)
;
; BUG: To some extent, this routine is complicit in the "loss of critical hits"
;      bug, though it's not the primary culprit. One possible fix would be for
;      this routine to reload each character's base critical rate and bonus,
;      though that's probably not the cleanest fix (which would probably switch
;      the base values to be permanent, with the derived value moving into the
;      in-battle record only). Changing this routine would also not fix the case
;      where characters lose the ability by being dead at the start of the
;      battle. TODO: Relocate this note to the primary culprit.
_restore_original_party:
    LDA <r_swapped_party_battle_index                                           ; $00E4C3 |\
    AND #%01111111.b                                                            ; $00E4C5 | | Mask out the flag bit to get the actual index.
    STA <r_swapped_party_battle_index                                           ; $00E4C7 |/
    CMP #SWAPPED_PARTY_BATTLE_INDEX_ZEMUS_ZEROMUS.b                             ; $00E4C9 |\ Skip the first block of code unless the battle is either the Zemus
    BNE +                                                                       ; $00E4CB |/ or first Zeromus battle.
    LDX #0.w                                                                    ; $00E4CD |\
-   LDA r_character_field.5.w,X                                                 ; $00E4D0 | | Transfer the character in the fifth slot to the second slot of the
    STA r_character_field.7.w,X                                                 ; $00E4D3 | | shadow party. (Copying FuSoYa back to the shadow party.)
    INX                                                                         ; $00E4D6 | |
    CPX #_sizeof_character_field.w                                              ; $00E4D7 | |
    BNE -                                                                       ; $00E4DA |/
    LDX #0.w                                                                    ; $00E4DC |\
-   LDA r_character_field.9.w,X                                                 ; $00E4DF | | Copy the two records in the last two shadow party slots back to
    STA r_character_field.4.w,X                                                 ; $00E4E2 | | the last two slots in the actual party. (Restoring the characters
    INX                                                                         ; $00E4E5 | | who were previously in those slots.)
    CPX #_sizeof_character_field.w * 2                                          ; $00E4E6 | |
    BNE -                                                                       ; $00E4E9 |/
+   LDX #0.w                                                                    ; $00E4EB |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $00E4EE |/
-   LDA r_swapped_party_battle_original_character_ids.w,Y                       ; $00E4F1 |\ Set this slot's character ID back to the value that was backed up.
    STA r_character_field.1.id.w,X                                              ; $00E4F4 |/
    TYA                                                                         ; $00E4F7 |\
    CMP <r_swapped_party_battle_index                                           ; $00E4F8 | | BUG: Compare the slot number to the swapped party index. This
    BNE +                                                                       ; $00E4FA | |      makes no sense whatsoever. If they match, reset this
    JSR _reset_character_status                                                 ; $00E4FC |/       character's status bytes. Perhaps they thought it was a slot.
+   JSR _increment_x_by_64                                                      ; $00E4FF |\
    INY                                                                         ; $00E502 | | Loop until all five character slots are checked.
    CPY #5.w                                                                    ; $00E503 | |
    BNE -                                                                       ; $00E506 |/
    RTS                                                                         ; $00E508

; swapped_party_battle_character_data ($00:E509)
;
; For each of the swapped party formations, determines the pivotal character.
; In most cases, this is the character that will be retained as the solo
; character for that battle. There are two exceptions: First, if the character
; is Rydia 1, she is removed from the party and the remaining characters are
; left in the battle by themselves. Second, the last two entries are combined
; and used for Zemus and the initial Zeromus battle, in which FuSoYa and Golbez
; are both added into the party, and take on the monster as a duo.
swapped_party_battle_character_data:
    .db CHARACTER_RYDIA_1                                                       ; $00E509
    .db CHARACTER_RYDIA_1                                                       ; $00E50A
    .db CHARACTER_RYDIA_1                                                       ; $00E50B
    .db CHARACTER_CECIL_1                                                       ; $00E50C
    .db CHARACTER_TELLAH_1                                                      ; $00E50D
    .db CHARACTER_CECIL_2                                                       ; $00E50E
    .db CHARACTER_EDWARD                                                        ; $00E50F
    .db CHARACTER_YANG_1                                                        ; $00E510
    .db CHARACTER_TELLAH_3                                                      ; $00E511
    .db CHARACTER_EDGE                                                          ; $00E512
    .db CHARACTER_RYDIA_2                                                       ; $00E513
    .db CHARACTER_FUSOYA                                                        ; $00E514
    .db CHARACTER_GOLBEZ                                                        ; $00E515

; swapped_party_battle_formation_data ($00:E516)
;
; A list of battle formations for which the party is swapped before the battle.
swapped_party_battle_formation_data:
    .dw BATTLE_FORMATION_FABUL_GENERAL                                          ; $00E516.E517
    .dw BATTLE_FORMATION_FABUL_WEEPER                                           ; $00E518.E519
    .dw BATTLE_FORMATION_FABUL_GARGOYLE                                         ; $00E51A.E51B
    .dw BATTLE_FORMATION_DRAGOON                                                ; $00E51C.E51D
    .dw BATTLE_FORMATION_BARD                                                   ; $00E51E.E51F
    .dw BATTLE_FORMATION_D_KNIGHT                                               ; $00E520.E521
    .dw BATTLE_FORMATION_WATERHAG                                               ; $00E522.E523
    .dw BATTLE_FORMATION_IMP_CAP_YANG                                           ; $00E524.E525
    .dw BATTLE_FORMATION_GOLBEZ_TELLAH                                          ; $00E526.E527
    .dw BATTLE_FORMATION_RUBICANT_EDGE                                          ; $00E528.E529
    .dw BATTLE_FORMATION_GOLBEZ_UNUSED                                          ; $00E52A.E52B
    .dw BATTLE_FORMATION_ZEMUS                                                  ; $00E52C.E52D
    .dw BATTLE_FORMATION_ZEROMUS_INITIAL                                        ; $00E52E.E52F

; _increment_x_by_64 ($00:E530)
;
; Increments the X register by 64 ($40). The accumulator will be reset to zero
; afterward.
_increment_x_by_64:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E530 |\ Transfer the X register to the accumulator.
    TXA                                                                         ; $00E532 |/
    CLC                                                                         ; $00E533 |\
    ADC #$0040.w                                                                ; $00E534 | | Add $40 to the accumulator and transfer it back to X.
    TAX                                                                         ; $00E537 |/
    LDA #$0000.w                                                                ; $00E538 |\ Reset the accumulator to zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E53B |/
    RTS                                                                         ; $00E53D

; _reset_character_status ($00:E53E)
;
; Given an offset to a character field record in the X register, resets the
; status bytes of that character to remove all statuses.
_reset_character_status:
    STZ r_character_field.1.status_1.w,X                                        ; $00E53E |\
    STZ r_character_field.1.status_2.w,X                                        ; $00E541 | | Clear the status bytes.
    STZ r_character_field.1.status_3.w,X                                        ; $00E544 | |
    STZ r_character_field.1.status_4.w,X                                        ; $00E547 |/
    RTS                                                                         ; $00E54A

; _decode_event_opcode_toggle_fast_movement ($00:E54B)
;
; Toggles the player movement speed between two settings: normal and fast, where
; fast is equal to the regular speed of the yellow chocobo.
_decode_event_opcode_toggle_fast_movement:
    LDA <r_movement_speed                                                       ; $00E54B |\
    BNE +                                                                       ; $00E54D | | If the movement speed is currently zero, set it to one.
    INC <r_movement_speed                                                       ; $00E54F | |
    JMP _decode_event_opcode_done                                               ; $00E551 |/
+   STZ <r_movement_speed                                                       ; $00E554 | Otherwise, set it to zero.
    JMP _decode_event_opcode_done                                               ; $00E556

; _decode_event_opcode_play_song ($00:E559)
;
; Event opcode that plays the song identified by the following byte.
_decode_event_opcode_play_song:
    JSR _decode_event_get_next_byte                                             ; $00E559 | Load the next byte.
    JSR _play_song                                                              ; $00E55C | Play the song corresponding to that number.
    JMP _decode_event_opcode_done                                               ; $00E55F

; _play_song ($00:E562)
;
; Plays the song identified by the track number passed in the accumulator.
_play_song:
    STA r_play_audio_arg_track.w                                                ; $00E562 |\
    LDA #AUDIO_MODE_NORMAL                                                      ; $00E565 | | Play the song identified by the track number passed in the
    STA r_play_audio_arg_mode.w                                                 ; $00E567 | | accumulator.
    JSL bank04.play_audio                                                       ; $00E56A |/
    RTS                                                                         ; $00E56E

; _decode_event_opcode_play_sound_effect ($00:E56F)
;
; Handles event opcode $FB, which plays the sound effect indicated by the
; following byte.
_decode_event_opcode_play_sound_effect:
    JSR _decode_event_get_next_byte                                             ; $00E56F | Load the next byte.
    JSR _play_sound_effect                                                      ; $00E572 | Play the sound effect corresponding to that number.
    JMP _decode_event_opcode_done                                               ; $00E575

; _decode_event_opcode_add_character ($00:E578)
;
; Handles event opcode $E7, which adds a new character to the party. The
; parameter byte minus one is an index into the table at $00:E69A, which
; determines if the character is new or loaded from the shadow party and
; which character to load. The passed character ID, importantly, will be the
; new value in the first byte of the character record (ignoring the handedness
; bits).
_decode_event_opcode_add_character:
    INX                                                                         ; $00E578 |\ Increment the X register and save that as the new index to the
    STX <r_decode_event_index                                                   ; $00E579 |/ event data.
    LDX #0.w                                                                    ; $00E57B |\ Initialize the character record offset to zero.
    STX <r_generic_tmp_index                                                    ; $00E57E |/
-   LDX <r_generic_tmp_index                                                    ; $00E580 |\
    LDA r_character_field.1.id.w,X                                              ; $00E582 | | Branch ahead if this slot is empty.
    BEQ +                                                                       ; $00E585 |/
    LDA <r_generic_tmp_index.lo                                                 ; $00E587 |\
    CLC                                                                         ; $00E589 | | Add the size of the record to the offset and loop back to check
    ADC #_sizeof_character_field.b                                              ; $00E58A | | the next slot.
    STA <r_generic_tmp_index.lo                                                 ; $00E58C | |
    LDA <r_generic_tmp_index.hi                                                 ; $00E58E | |
    ADC #0.b                                                                    ; $00E590 | |
    STA <r_generic_tmp_index.hi                                                 ; $00E592 | |
    JMP -                                                                       ; $00E594 |/
+   LDX <r_decode_event_index                                                   ; $00E597 |\
    LDA r_decode_event_bytes.w,X                                                ; $00E599 | | Read the next byte and determine how to add the character by
    DEC A                                                                       ; $00E59C | | reading the value from ROM.
    TAY                                                                         ; $00E59D | |
    LDA event_character_add_data.w,Y                                            ; $00E59E |/
    BPL ++                                                                      ; $00E5A1 | If the high bit is not set, branch ahead to load a new character.
    JSR _move_character_from_shadow                                             ; $00E5A3 | Otherwise, start by loading the character from the shadow party.
    LDY <r_generic_tmp_index                                                    ; $00E5A6 |\
    LDA r_character_field.1.id.w,Y                                              ; $00E5A8 | | Preserve any previously set handedness bits, but update the
    AND #%11100000.b                                                            ; $00E5AB | | character ID to the new value.
    LDX <r_decode_event_index                                                   ; $00E5AD | |
    ORA r_decode_event_bytes.w,X                                                ; $00E5AF | |
    STA r_character_field.1.id.w,Y                                              ; $00E5B2 |/
    AND #%00011111.b                                                            ; $00E5B5 |\
    CMP #CHARACTER_RYDIA_2.b                                                    ; $00E5B7 | | If the character is the second incarnation of Rydia, update the
    BNE +                                                                       ; $00E5B9 | | class to the adult Caller class.
    LDA #SPRITE_CLASS_CALLER_ADULT.b                                            ; $00E5BB | |
    STA r_character_field.1.sprite_class.w,Y                                    ; $00E5BD |/
+   LDA r_character_field.1.hp_max_lo.w,Y                                       ; $00E5C0 |\
    STA r_character_field.1.hp_lo.w,Y                                           ; $00E5C3 | | Set the character's HP to the maximum value.
    LDA r_character_field.1.hp_max_hi.w,Y                                       ; $00E5C6 | |
    STA r_character_field.1.hp_hi.w,Y                                           ; $00E5C9 |/
    LDA r_character_field.1.mp_max_lo.w,Y                                       ; $00E5CC |\
    STA r_character_field.1.mp_lo.w,Y                                           ; $00E5CF | | Set the character's MP to the maximum value.
    LDA r_character_field.1.mp_max_hi.w,Y                                       ; $00E5D2 | |
    STA r_character_field.1.mp_hi.w,Y                                           ; $00E5D5 |/
    JSR _load_initial_equipment_event                                           ; $00E5D8 | Load the initial equipment for the character.
    JMP +                                                                       ; $00E5DB |\ If the high bit wasn't set, load the character as the new
++  JSR _load_character                                                         ; $00E5DE |/ character.
+   JMP _decode_event_opcode_done                                               ; $00E5E1

; _move_character_from_shadow ($00:E5E4)
;
; Given an 8-bit shadow party index (0-4) in the accumulator and a 16-bit offset
; to the destination character field record in $3D, moves the record from the
; shadow party to the main party. The shadow party entry is completely erased.
_move_character_from_shadow:
    AND #%01111111.b                                                            ; $00E5E4 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E5E6 | | Multiply the given index by 64 to use it as an offset into the
    ASL A                                                                       ; $00E5E8 | | shadow party character field records.
    ASL A                                                                       ; $00E5E9 | |
    ASL A                                                                       ; $00E5EA | |
    ASL A                                                                       ; $00E5EB | |
    ASL A                                                                       ; $00E5EC | |
    ASL A                                                                       ; $00E5ED | |
    STA <r_generic_tmp_index_2                                                  ; $00E5EE | |
    LDA #0.w                                                                    ; $00E5F0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E5F3 |/
    LDA #_sizeof_character_field.b                                              ; $00E5F5 |\ Initialize the counter to 64 bytes, the size of the field character
    STA <r_generic_tmp_2                                                        ; $00E5F7 |/ record.
    LDY <r_load_initial_arg_target_index                                        ; $00E5F9 | Set the Y register to the destination offset.
    LDX <r_generic_tmp_index_2                                                  ; $00E5FB | Set the X register to the source offset.
-   LDA r_character_field.6.w,X                                                 ; $00E5FD |\
    STA r_character_field.1.w,Y                                                 ; $00E600 | | Copy the entire character record from the shadow party to the main
    STZ r_character_field.6.w,X                                                 ; $00E603 | | party, while zeroing out the actual entry in the shadow party.
    INX                                                                         ; $00E606 | |
    INY                                                                         ; $00E607 | |
    DEC <r_generic_tmp_2                                                        ; $00E608 | |
    BNE -                                                                       ; $00E60A |/
    RTS                                                                         ; $00E60C

; _load_character ($00:E60D)
;
; Loads a new character to the party. The ID of the character to load should be
; passed in the accumulator. Note that the useful values begin at zero, so the
; actual character ID should be have one subtracted from it. The 16-bit offset
; to the target field character record should be passed in $3D. After copying
; the initial stats, this routine will also call the routine to load the
; initial equipment. However, that will load the character ID by reading the
; current event bytes in $09D5 with the index in $B3, regardless of what is
; passed here.
_load_character:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E60D |\
    ASL A                                                                       ; $00E60F | | Multiply the passed character ID by 32 and then save the result to
    ASL A                                                                       ; $00E610 | | a temporary variable. This value will index the initial stats data
    ASL A                                                                       ; $00E611 | | in ROM.
    ASL A                                                                       ; $00E612 | |
    ASL A                                                                       ; $00E613 | |
    STA <r_generic_tmp_index_2                                                  ; $00E614 | |
    LDA #0.w                                                                    ; $00E616 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E619 |/
    LDA #20.b                                                                   ; $00E61B |\
    STA <r_generic_tmp_2                                                        ; $00E61D | | Copy the first twenty bytes from the initial stats to the chosen
    LDX <r_generic_tmp_index_2                                                  ; $00E61F | | character record.
    LDY <r_load_initial_arg_target_index                                        ; $00E621 | |
-   LDA bank0F.initial_stats_data.l,X                                           ; $00E623 | |
    STA r_character_field.w,Y                                                   ; $00E627 | |
    INX                                                                         ; $00E62A | |
    INY                                                                         ; $00E62B | |
    DEC <r_generic_tmp_2                                                        ; $00E62C | |
    BNE -                                                                       ; $00E62E |/
    LDA #3.b                                                                    ; $00E630 |\
    STA <r_generic_tmp_2                                                        ; $00E632 | | Copy the next three bytes to the character record. This is done as
    LDX <r_generic_tmp_index_2                                                  ; $00E634 | | a separate operation as there is a gap where several derived stats
    LDY <r_load_initial_arg_target_index                                        ; $00E636 | | are stored.
-   LDA bank0F.initial_stats_data.l + initial_stats.critical_rate,X             ; $00E638 | |
    STA r_character_field.1.critical_rate,Y                                     ; $00E63C | |
    INX                                                                         ; $00E63F | |
    INY                                                                         ; $00E640 | |
    DEC <r_generic_tmp_2                                                        ; $00E641 | |
    BNE -                                                                       ; $00E643 |/
    LDA #9.b                                                                    ; $00E645 |\
    STA <r_generic_tmp_2                                                        ; $00E647 | | Copy the final nine bytes to the appropriate place in the stat
    LDX <r_generic_tmp_index_2                                                  ; $00E649 | | record.
    LDY <r_load_initial_arg_target_index                                        ; $00E64B | |
-   LDA bank0F.initial_stats_data.l + initial_stats.experience,X                ; $00E64D | |
    STA r_character_field.1.experience.w,Y                                      ; $00E651 | |
    INX                                                                         ; $00E654 | |
    INY                                                                         ; $00E655 | |
    DEC <r_generic_tmp_2                                                        ; $00E656 | |
    BNE -                                                                       ; $00E658 |/
    JSR _load_initial_equipment_event                                           ; $00E65A | Load the initial equipment for the character.
    RTS                                                                         ; $00E65D

; _load_initial_equipment_* ($00:E65E)
;
; This family of functions loads the initial equipment for the given character
; and then immediately initializes the in-battle character records and
; calculates all the derived character stats.
;
; The _cecil variant is used at the start of the game, and initializes Cecil.
; The _event variant reads the character ID to be loaded from the event bytes
; at $09D5.
_load_initial_equipment_cecil:
    LDA #CHARACTER_CECIL_1.b - 1                                                ; $00E65E |\ Set the accumulator to zero and then jump to the next part of the
    JMP +                                                                       ; $00E660 |/ function.
_load_initial_equipment_event:
    LDX <r_decode_event_index                                                   ; $00E663 |\
    LDA r_decode_event_bytes.w,X                                                ; $00E665 | | Load the character to be loaded from the event bytes, subtract
    DEC A                                                                       ; $00E668 | | one, and then return if the character is Tellah 3 (joins as Cecil
    CMP #CHARACTER_TELLAH_3.b - 1                                               ; $00E669 | | becomes a Paladin). Otherwise, continue to the next section.
    BNE +                                                                       ; $00E66B | |
    RTS                                                                         ; $00E66D |/
+   STA r_load_initial_equipment_tmp                                            ; $00E66E |\
    ASL A                                                                       ; $00E670 | | The accumulator at this point should contain the desired character
    ASL A                                                                       ; $00E671 | | ID, minus one. ($00 is usually used as an entry to mean no
    ASL A                                                                       ; $00E672 | | character, but the initial equipment data starts at index $00 for
    SEC                                                                         ; $00E673 | | Cecil. In any case, multiply that value by 7 to generate the index
    SBC r_load_initial_equipment_tmp                                            ; $00E674 | | for the initial equipment data.
    TAX                                                                         ; $00E676 |/
    LDA #7.b                                                                    ; $00E677 |\
    STA r_load_initial_equipment_tmp                                            ; $00E679 | | Copy the initial equipment data from the array in ROM to the given
    LDY <r_load_initial_arg_target_index                                        ; $00E67B | | character stat record at the equipment location, which begins with
-   LDA bank0F.initial_equipment_data.l,X                                       ; $00E67D | | the head armor.
    STA r_character_field.1.armor_head,Y                                        ; $00E681 | |
    INX                                                                         ; $00E684 | |
    INY                                                                         ; $00E685 | |
    DEC r_load_initial_equipment_tmp                                            ; $00E686 | |
    BNE -                                                                       ; $00E688 |/
    LSR <r_load_initial_arg_target_index.hi                                     ; $00E68A |\
    ROR <r_load_initial_arg_target_index.lo                                     ; $00E68C | | From the index, calculate the appropriate slot number (by dividing
    LDA <r_load_initial_arg_target_index.lo                                     ; $00E68E | | by 64) and call the stat calculation function.
    LSR A                                                                       ; $00E690 | |
    LSR A                                                                       ; $00E691 | |
    LSR A                                                                       ; $00E692 | |
    LSR A                                                                       ; $00E693 | |
    LSR A                                                                       ; $00E694 | |
    JSL bank03.calculate_character_stats                                        ; $00E695 |/
    RTS                                                                         ; $00E699

; event_character_add_data ($00:E69A)
;
; When adding new characters to the party, determines where the character is
; initialized from. If the high bit is not set, it corresponds directly to an
; index into the initial stats table in bank $0F. If the high bit is set, the
; lower seven bits instead determine which shadow party slot the character will
; be loaded from. The indexes themselves are one lower than the usual character
; indexes, to avoid having a useless entry at $00. The event processing code
; handles this decrement.
event_character_add_data:
    .db CHARACTER_STATS_CECIL_DKNIGHT                                           ; $00E69A | $00: Cecil (dark knight)
    .db CHARACTER_STATS_KAIN                                                    ; $00E69B | $01: Kain (before Mist)
    .db CHARACTER_STATS_RYDIA                                                   ; $00E69C | $02: Rydia (before Fabul)
    .db CHARACTER_STATS_TELLAH                                                  ; $00E69D | $03: Tellah (before Damcyan)
    .db CHARACTER_STATS_EDWARD                                                  ; $00E69E | $04: Edward
    .db CHARACTER_STATS_ROSA                                                    ; $00E69F | $05: Rosa (before Fabul)
    .db CHARACTER_STATS_YANG                                                    ; $00E6A0 | $06: Yang (before Fabul)
    .db CHARACTER_STATS_PALOM                                                   ; $00E6A1 | $07: Palom
    .db CHARACTER_STATS_POROM                                                   ; $00E6A2 | $08: Porom
    .db CHARACTER_LOAD_FROM_SHADOW | 1                                          ; $00E6A3 | $09: Tellah (before Paladin)
    .db CHARACTER_STATS_CECIL_PALADIN                                           ; $00E6A4 | $0A: Cecil (paladin)
    .db CHARACTER_LOAD_FROM_SHADOW | 1                                          ; $00E6A5 | $0B: Tellah (final)
    .db CHARACTER_LOAD_FROM_SHADOW | 3                                          ; $00E6A6 | $0C: Yang (final)
    .db CHARACTER_STATS_CID                                                     ; $00E6A7 | $0D: Cid
    .db CHARACTER_LOAD_FROM_SHADOW | 0                                          ; $00E6A8 | $0E: Kain (before Sealed Cave)
    .db CHARACTER_LOAD_FROM_SHADOW | 2                                          ; $00E6A9 | $0F: Rosa (final)
    .db CHARACTER_LOAD_FROM_SHADOW | 4                                          ; $00E6AA | $10: Rydia (final)
    .db CHARACTER_STATS_EDGE                                                    ; $00E6AB | $11: Edge
    .db CHARACTER_STATS_FUSOYA                                                  ; $00E6AC | $12: FuSoYa
    .db CHARACTER_LOAD_FROM_SHADOW | 0                                          ; $00E6AD | $13: Kain (final)
    .db CHARACTER_STATS_GOLBEZ                                                  ; $00E6AE | $14: Golbez

; _decode_event_opcode_remove_character ($00:E6AF)
;
; Given a character ID as the parameter, removes that character from the party.
; The disposition of the character is determined by a byte in a table later in
; ROM.
_decode_event_opcode_remove_character:
    INX                                                                         ; $00E6AF |\ Increment the event index to skip to the next byte.
    STX <r_decode_event_index                                                   ; $00E6B0 |/
    LDY #0.w                                                                    ; $00E6B2 |\ Initialize the current character offset to zero.
    STY <r_generic_tmp_index                                                    ; $00E6B5 |/
-   LDY <r_generic_tmp_index                                                    ; $00E6B7 |\
    LDA r_character_field.1.id.w,Y                                              ; $00E6B9 | | If the character in this slot matches the parameter byte, branch
    AND #%00011111.b                                                            ; $00E6BC | | ahead to remove the character.
    CMP r_decode_event_bytes.w,X                                                ; $00E6BE | |
    BEQ +                                                                       ; $00E6C1 |/
    LDA <r_generic_tmp_index.lo                                                 ; $00E6C3 |\
    CLC                                                                         ; $00E6C5 | | Otherwise, increment the slot and loop until all character slots
    ADC #_sizeof_character_field.b                                              ; $00E6C6 | | have been checked.
    STA <r_generic_tmp_index.lo                                                 ; $00E6C8 | |
    LDA <r_generic_tmp_index.hi                                                 ; $00E6CA | |
    ADC #0.b                                                                    ; $00E6CC | |
    STA <r_generic_tmp_index.hi                                                 ; $00E6CE | |
    LDY <r_generic_tmp_index                                                    ; $00E6D0 | |
    CPY #_sizeof_character_field.w * 5                                          ; $00E6D2 | |
    BNE -                                                                       ; $00E6D5 |/
    JMP _decode_event_opcode_done                                               ; $00E6D7 | If the character is not found, jump to the end, doing nothing.
+   LDA r_decode_event_bytes.w,X                                                ; $00E6DA |\
    DEC A                                                                       ; $00E6DD | | Otherwise, decrement the character ID to load the byte that
    TAX                                                                         ; $00E6DE | | determines what to do with the character.
    LDA event_character_remove_data.w,X                                         ; $00E6DF |/
    BMI +                                                                       ; $00E6E2 | If the character should be discarded, skip the next block.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E6E4 |\
    ASL A                                                                       ; $00E6E6 | | Calculate the offset into the character records by multiplying
    ASL A                                                                       ; $00E6E7 | | the loaded shadow slot number by 64.
    ASL A                                                                       ; $00E6E8 | |
    ASL A                                                                       ; $00E6E9 | |
    ASL A                                                                       ; $00E6EA | |
    ASL A                                                                       ; $00E6EB | |
    STA <r_generic_tmp_index_2                                                  ; $00E6EC | |
    LDA #0.w                                                                    ; $00E6EE | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E6F1 |/
    LDA #_sizeof_character_field.b                                              ; $00E6F3 |\ Initialize the index to the size of a record.
    STA <r_generic_tmp_2                                                        ; $00E6F5 |/
    LDX <r_generic_tmp_index                                                    ; $00E6F7 |\
    LDY <r_generic_tmp_index_2                                                  ; $00E6F9 | | Copy the record from the located slot in the party to the targeted
-   LDA r_character_field.1.w,X                                                 ; $00E6FB | | shadow party slot.
    STA r_character_field.6.w,Y                                                 ; $00E6FE | |
    INX                                                                         ; $00E701 | |
    INY                                                                         ; $00E702 | |
    DEC <r_generic_tmp_2                                                        ; $00E703 | |
    BNE -                                                                       ; $00E705 |/
    LDX <r_generic_tmp_index_2                                                  ; $00E707 |\
    STZ r_character_field.6.status_1.w,X                                        ; $00E709 | | Unset any status bits on the saved slot.
    STZ r_character_field.6.status_2.w,X                                        ; $00E70C | |
    STZ r_character_field.6.status_3.w,X                                        ; $00E70F | |
    STZ r_character_field.6.status_4.w,X                                        ; $00E712 |/
+   LDX <r_generic_tmp_index                                                    ; $00E715 |\ Zero out the character ID in the original slot to remove the
    STZ r_character_field.1.id.w,X                                              ; $00E717 |/ character.
    JMP _decode_event_opcode_done                                               ; $00E71A

; event_character_remove_data ($00:E71D)
;
; When removing a given character from the party, determines what is done with
; the removed character. First, the index is the character ID minus one, so that
; zero can be used as a useful value. The value itself is either $80 if the
; character should be discarded or the slot number of the shadow party if saving
; to the shadow party.
event_character_remove_data:
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E71D | $00: Cecil (dark knight)
    .db CHARACTER_SAVE_TO_SHADOW | 0                                            ; $00E71E | $01: Kain (before Mist)
    .db CHARACTER_SAVE_TO_SHADOW | 4                                            ; $00E71F | $02: Rydia (before Fabul)
    .db CHARACTER_SAVE_TO_SHADOW | 1                                            ; $00E720 | $03: Tellah (before Damcyan)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E721 | $04: Edward
    .db CHARACTER_SAVE_TO_SHADOW | 2                                            ; $00E722 | $05: Rosa (before Fabul)
    .db CHARACTER_SAVE_TO_SHADOW | 3                                            ; $00E723 | $06: Yang (before Fabul)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E724 | $07: Palom
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E725 | $08: Porom
    .db CHARACTER_SAVE_TO_SHADOW | 1                                            ; $00E726 | $09: Tellah (before Paladin)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E727 | $0A: Cecil (paladin)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E728 | $0B: Tellah (final)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E729 | $0C: Yang (final)
    .db CHARACTER_SAVE_TO_SHADOW | 1                                            ; $00E72A | $0D: Cid
    .db CHARACTER_SAVE_TO_SHADOW | 0                                            ; $00E72B | $0E: Kain (before Sealed Cave)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E72C | $0F: Rosa (final)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E72D | $10: Rydia (final)
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E72E | $11: Edge
    .db CHARACTER_SAVE_TO_SHADOW | 1                                            ; $00E72F | $12: FuSoYa
    .db CHARACTER_SAVE_DISCARD                                                  ; $00E730 | $13: Kain (final)

; _decode_event_opcode_toggle_color_subtraction ($00:E731)
;
; Handles event opcode $F9, which toggles the use of the color subtraction
; effect. When enabling the effect, the next byte contains the desired color
; data with the intensity shifted right one bit and bit 4 used to select either
; a slow or fast transition (a slow transition occurs if the bit is set). If
; the effect is enabled, it will be disabled, with the following byte being
; effectively useless.
_decode_event_opcode_toggle_color_subtraction:
    INX                                                                         ; $00E731 |\ Increment the decode event index.
    STX <r_decode_event_index                                                   ; $00E732 |/
    LDA <r_ppu_color_subtraction_intensity                                      ; $00E734 |\
    BNE +                                                                       ; $00E736 | | If color subtraction is currently disabled, read the next byte
    LDA r_decode_event_bytes.w,X                                                ; $00E738 | | and enable it.
    JSR _enable_color_subtraction                                               ; $00E73B | |
    JMP _decode_event_opcode_done                                               ; $00E73E |/
+   JSR _disable_color_subtraction                                              ; $00E741 | Otherwise, disable it. The next byte may simply be useless.
    JMP _decode_event_opcode_done                                               ; $00E744

; _enable_color_subtraction ($00:E747)
;
; Enables the color subtraction mode based on the value in the accumulator. The
; intensity of the effect will be increased until it matches the target value
; provided, and then the intensity is reduced by one.
_enable_color_subtraction:
    PHA                                                                         ; $00E747 |\
    PHA                                                                         ; $00E748 | | Set the target color and intensity based on the value in the
    AND #%11100000.b                                                            ; $00E749 | | accumulator. The value is similar to what would be placed in the
    STA <r_enable_color_subtraction_tmp                                         ; $00E74B | | coldata register, but the intensity has been reduced to four bits
    PLA                                                                         ; $00E74D | | and the now unused bit 4 is used to indicate whether the
    AND #%00001111.b                                                            ; $00E74E | | transition should be done slowly or quickly.
    ASL A                                                                       ; $00E750 | |
    SEC                                                                         ; $00E751 | |
    ADC <r_enable_color_subtraction_tmp                                         ; $00E752 | |
    STA <r_ppu_color_subtraction_target                                         ; $00E754 |/
    PLA                                                                         ; $00E756 |\
    AND #%00010000.b                                                            ; $00E757 | | Calculate the frame mask based on the value of that bit 4.
    BEQ +                                                                       ; $00E759 | |
    LDA #%00000111.b                                                            ; $00E75B | |
+   STA <r_ppu_color_subtraction_frame_mask                                     ; $00E75D |/
    STZ <r_transition_index                                                     ; $00E75F | Zero out the transition index.
    STZ <r_ppu_color_subtraction_intensity                                      ; $00E761 | Start at zero intensity.
-   JSR _do_tile_animations                                                     ; $00E763 | Do tile animations and wait for the next frame.
    STZ reg_ppu_ts                                                              ; $00E766 | Set no screens as sub screen.
    LDA #%10000011.b                                                            ; $00E769 |\ Set color subtraction on BG1 and BG2.
    STA reg_ppu_cgadsub                                                         ; $00E76B |/
    LDA <r_ppu_color_subtraction_target                                         ; $00E76E |\
    AND #%11100000.b                                                            ; $00E770 | | Calculate the current intensity and set the coldata register.
    ORA <r_ppu_color_subtraction_intensity                                      ; $00E772 | |
    STA reg_ppu_coldata                                                         ; $00E774 |/
    INC <r_transition_index                                                     ; $00E777 |\
    LDA <r_transition_index                                                     ; $00E779 | | Increment the transition index and loop until the frame number
    AND <r_ppu_color_subtraction_frame_mask                                     ; $00E77B | | is divisible by eight if the slow transition was set.
    BNE -                                                                       ; $00E77D |/
    INC <r_ppu_color_subtraction_intensity                                      ; $00E77F | Increment the intensity.
    LDA <r_ppu_color_subtraction_target                                         ; $00E781 |\
    AND #%00011111.b                                                            ; $00E783 | | Loop until the intensity matches the target intensity.
    CMP <r_ppu_color_subtraction_intensity                                      ; $00E785 | |
    BNE -                                                                       ; $00E787 |/
    DEC <r_ppu_color_subtraction_intensity                                      ; $00E789 | Reduce the intensity by one. TODO: Why?
    RTS                                                                         ; $00E78B

; _disable_color_subtraction ($00:E78C)
;
; Disables the color subtraction mode and returns the color math settings to
; normal. The effect is gradual and depends on the speed that the subtraction
; was enabled.
_disable_color_subtraction:
    STZ <r_transition_index                                                     ; $00E78C | Zero out the transition index.
-   JSR _do_tile_animations                                                     ; $00E78E | Do any tile animations and wait for the next frame.
    LDA <r_ppu_color_subtraction_target                                         ; $00E791 |\
    AND #%11100000.b                                                            ; $00E793 | | Set the coldata register with the color and current intensity.
    ORA <r_ppu_color_subtraction_intensity                                      ; $00E795 | |
    STA reg_ppu_coldata                                                         ; $00E797 |/
    INC <r_transition_index                                                     ; $00E79A |\
    LDA <r_transition_index                                                     ; $00E79C | | Loop until the correct number of frames has passed (either one or
    AND <r_ppu_color_subtraction_frame_mask                                     ; $00E79E | | eight).
    BNE -                                                                       ; $00E7A0 |/
    DEC <r_ppu_color_subtraction_intensity                                      ; $00E7A2 |\ Decrease the intensity and loop until it goes negative.
    BPL -                                                                       ; $00E7A4 |/
    STZ <r_ppu_color_subtraction_intensity                                      ; $00E7A6 | Set the intensity to zero.
    LDA #%00010001.b                                                            ; $00E7A8 |\ Set BG1 and OBJ as sub screen.
    STA reg_ppu_ts                                                              ; $00E7AA |/
    LDA r_map_properties.background_properties.w                                ; $00E7AD |\
    LSR A                                                                       ; $00E7B0 | | If bit 0 of the background properties is set, set color math on
    BCC +                                                                       ; $00E7B1 | | the sub screen with addition and 1/2 properties on BG1 and BG2.
    LDA #%00000010.b                                                            ; $00E7B3 | |
    STA reg_ppu_cgswsel                                                         ; $00E7B5 | |
    LDA #%01000011.b                                                            ; $00E7B8 | |
    STA reg_ppu_cgadsub                                                         ; $00E7BA | |
    JMP ++                                                                      ; $00E7BD |/
+   STZ reg_ppu_cgadsub                                                         ; $00E7C0 | Otherwise, disable color math.
++  RTS                                                                         ; $00E7C3

; _decode_event_opcode_ppu_fade ($00:E7C4)
;
; Either fades the PPU in or fades it out depending on the current brightness.
; The resulting fade is relatively slow, only changing every eight frames.
_decode_event_opcode_ppu_fade:
    LDA <r_ppu_brightness                                                       ; $00E7C4 |\
    BNE +                                                                       ; $00E7C6 | | If the PPU brightness is zero, fade in the PPU, changing every
    LDA #%00000111.b                                                            ; $00E7C8 | | eight frames.
    JSR _ppu_fade_in                                                            ; $00E7CA | |
    JMP _decode_event_opcode_done                                               ; $00E7CD |/
+   LDA #%00000111.b                                                            ; $00E7D0 |\
    JSR _ppu_fade_out                                                           ; $00E7D2 | | Otherwise, fade out the PPU, changing every eight frames.
    JMP _decode_event_opcode_done                                               ; $00E7D5 |/

; _decode_event_opcode_add_spell ($00:E7D8)
;
; Handles opcode $E2, which adds the spell number in the second parameter byte
; to the spell list specified by the first parameter byte.
_decode_event_opcode_add_spell:
    INX                                                                         ; $00E7D8 |\ Fetch the first parameter byte.
    LDA r_decode_event_bytes.w,X                                                ; $00E7D9 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E7DC |\
    ASL A                                                                       ; $00E7DE | | Set the Y register to that parameter times 24, which is the offset
    ASL A                                                                       ; $00E7DF | | to that particular spell list.
    ASL A                                                                       ; $00E7E0 | |
    STA <r_generic_tmp_index_3                                                  ; $00E7E1 | |
    ASL A                                                                       ; $00E7E3 | |
    CLC                                                                         ; $00E7E4 | |
    ADC <r_generic_tmp_index_3                                                  ; $00E7E5 | |
    TAY                                                                         ; $00E7E7 | |
    LDA #0.w                                                                    ; $00E7E8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E7EB |/
-   LDA r_spell_lists.w,Y                                                       ; $00E7ED |\
    BEQ +                                                                       ; $00E7F0 | | Search through the spell list until an empty spot is found.
    INY                                                                         ; $00E7F2 | |
    JMP -                                                                       ; $00E7F3 |/
+   JSR _decode_event_get_next_byte                                             ; $00E7F6 |\ Get the next byte and save that to that location in the spell list.
    STA r_spell_lists.w,Y                                                       ; $00E7F9 |/
    JMP _decode_event_opcode_done                                               ; $00E7FC

; _decode_event_opcode_restore_hp ($00:E7FF)
;
; Handles event opcode $DE, which restores HP to the entire party. The parameter
; byte is multiplied by 10 to determine the amount of HP to add. No character
; will be restored higher than their maximum HP. If the parameter byte is $FE,
; then the party will instead be restored to full. In either case, characters
; with the swoon status will not be restored.
_decode_event_opcode_restore_hp:
    JSR _decode_event_get_next_byte                                             ; $00E7FF |\
    CMP #EVENT_PARAMETER_RESTORE_HP_MAX.b                                       ; $00E802 | | Read the next byte, and if it's $FE, branch to fully cure.
    BEQ @full                                                                   ; $00E804 |/
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $00E806 |\
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $00E808 | | Otherwise, start by multiplying the parameter byte by 10.
    LDA #10.b                                                                   ; $00E80A | |
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $00E80C | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $00E80E | |
    JSL bank15.math_multiply_16bit                                              ; $00E810 |/
    LDX #0.w                                                                    ; $00E814 | Initialize the X register to zero.
-   LDA r_character_field.1.status_1.w,X                                        ; $00E817 |\ If the character has the swoon status, branch ahead to skip this
    BMI ++                                                                      ; $00E81A |/ slot.
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E81C |\
    LDA r_character_field.1.hp.w,X                                              ; $00E81E | | Add the character's current HP to the previously calculated value.
    CLC                                                                         ; $00E821 | |
    ADC <r_bank15_math_multiply_16bit_result                                    ; $00E822 |/
    CMP r_character_field.1.hp_max.w,X                                          ; $00E824 |\
    BCC +                                                                       ; $00E827 | | If the result is greater than the maximum HP, use maximum HP.
    LDA r_character_field.1.hp_max.w,X                                          ; $00E829 |/
+   STA r_character_field.1.hp.w,X                                              ; $00E82C |\
    LDA #0.w                                                                    ; $00E82F | | Save the result as the character's new HP.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E832 |/
++  JSR _increment_x_by_64                                                      ; $00E834 |\
    CPX #_sizeof_character_field.w * 5                                          ; $00E837 | | Loop until all five characters are done.
    BNE -                                                                       ; $00E83A |/
    JMP _decode_event_opcode_done                                               ; $00E83C
@full:
    LDX #0.w                                                                    ; $00E83F |\
-   LDA r_character_field.1.status_1.w,X                                        ; $00E842 | | Loop through the five character slots, setting each character's
    BMI +                                                                       ; $00E845 | | current HP to maximum. If the character is swooned, no HP is
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E847 | | restored.
    LDA r_character_field.1.hp_max.w,X                                          ; $00E849 | |
    STA r_character_field.1.hp.w,X                                              ; $00E84C | |
    LDA #0.w                                                                    ; $00E84F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E852 | |
+   JSR _increment_x_by_64                                                      ; $00E854 | |
    CPX #_sizeof_character_field.w * 5                                          ; $00E857 | |
    BNE -                                                                       ; $00E85A |/
    JMP _decode_event_opcode_done                                               ; $00E85C

; _decode_event_opcode_restore_mp ($00:E85F)
;
; Handles event opcode $DF, which restores the specified amount of MP to entire
; party. The number of MP restored is equal to the parameter byte times ten. If
; the parameter is set to $FE, each character's MP is instead restored to
; maximum. As with HP, characters with the swoon status will not be restored.
_decode_event_opcode_restore_mp:
    JSR _decode_event_get_next_byte                                             ; $00E85F | Read the next byte as the parameter.
    CMP #EVENT_PARAMETER_RESTORE_MP_MAX.b                                       ; $00E862 |\ If set to $FE, branch to the full healing code.
    BEQ @full                                                                   ; $00E864 |/
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $00E866 |\
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $00E868 | | Otherwise, start by multiplying the parameter by 10 as the amount
    LDA #10.b                                                                   ; $00E86A | | of MP to recover to each living character.
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $00E86C | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $00E86E | |
    JSL bank15.math_multiply_16bit                                              ; $00E870 |/
    LDX #0.w                                                                    ; $00E874 |\
-   LDA r_character_field.1.status_1.w,X                                        ; $00E877 | | Loop through the five characters, adding the specified number of
    BMI ++                                                                      ; $00E87A | | MP to the character's current MP total. If the value would exceed
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E87C | | their maximum HP, instead set their current MP to maximum. If the
    LDA r_character_field.1.mp.w,X                                              ; $00E87E | | character has the swoon status, do nothing.
    CLC                                                                         ; $00E881 | |
    ADC <r_bank15_math_multiply_16bit_result                                    ; $00E882 | |
    CMP r_character_field.1.mp_max.w,X                                          ; $00E884 | |
    BCC +                                                                       ; $00E887 | |
    LDA r_character_field.1.mp_max.w,X                                          ; $00E889 | |
+   STA r_character_field.1.mp.w,X                                              ; $00E88C | |
    LDA #0.w                                                                    ; $00E88F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E892 | |
++  JSR _increment_x_by_64                                                      ; $00E894 | |
    CPX #_sizeof_character_field.w * 5                                          ; $00E897 | |
    BNE -                                                                       ; $00E89A |/
    JMP _decode_event_opcode_done                                               ; $00E89C
@full:
    LDX #0.w                                                                    ; $00E89F |\
-   LDA r_character_field.1.status_1.w,X                                        ; $00E8A2 | | Loop through the five characters, setting their current MP to
    BMI +                                                                       ; $00E8A5 | | their maximum MP value. If the character has the swoon status, do
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E8A7 | | nothing.
    LDA r_character_field.1.mp_max.w,X                                          ; $00E8A9 | |
    STA r_character_field.1.mp.w,X                                              ; $00E8AC | |
    LDA #0.w                                                                    ; $00E8AF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E8B2 | |
+   JSR _increment_x_by_64                                                      ; $00E8B4 | |
    CPX #_sizeof_character_field.w * 5                                          ; $00E8B7 | |
    BNE -                                                                       ; $00E8BA |/
    JMP _decode_event_opcode_done                                               ; $00E8BC

; _decode_event_opcode_inventory_add_item ($00:E8BF)
;
; Handles opcode $E0, which adds the following byte to the inventory as an item.
; The count is determined automatically: either 10 for arrows or 1 for anything
; else.
_decode_event_opcode_inventory_add_item:
    JSR _decode_event_get_next_byte                                             ; $00E8BF |\
    STA r_current_item.w                                                        ; $00E8C2 | | Read the next byte and add that item to the inventory.
    JSR _inventory_add_item                                                     ; $00E8C5 |/
    JMP _decode_event_opcode_done                                               ; $00E8C8

; _decode_event_opcode_inventory_remove_item ($00:E8CB)
;
; Handles opcode $E1, which removes an item entirely from a player's inventory.
; Notably, it removes the item from either the inventory or the right hand of
; a party member. It will only remove the first instance it finds, so is
; clearly meant to be used only with unique items. If it finds a stack, it
; will remove that entire stack.
;
; NOTE: This does not remove items in the left hands of party members. While
;       in the vanilla game, this is not really a bug, as the only item it
;       would be used on is the Legend sword (in Cecil's right hand), for more
;       general use, this should be extended.
_decode_event_opcode_inventory_remove_item:
    JSR _decode_event_get_next_byte                                             ; $00E8CB |\ Save the parameter byte to a temporary variable.
    STA <r_generic_tmp_1                                                        ; $00E8CE |/
    LDY #0.w                                                                    ; $00E8D0 |\
-   LDA r_inventory.w,Y                                                         ; $00E8D3 | | Search through the inventory for the provided item ID. If found,
    CMP <r_generic_tmp_1                                                        ; $00E8D6 | | branch ahead to the last code in this routine.
    BEQ ++                                                                      ; $00E8D8 | |
    INY                                                                         ; $00E8DA | |
    INY                                                                         ; $00E8DB | |
    CPY #_sizeof_r_inventory.w                                                  ; $00E8DC | |
    BNE -                                                                       ; $00E8DF |/
    LDX #0.w                                                                    ; $00E8E1 |\
-   LDA r_character_field.1.right_hand_item.w,X                                 ; $00E8E4 | | Search through the right hands of the five party members searching
    CMP <r_generic_tmp_1                                                        ; $00E8E7 | | for the item. If found, branch ahead to another section.
    BEQ +                                                                       ; $00E8E9 | |
    JSR _increment_x_by_64                                                      ; $00E8EB | |
    CPX #_sizeof_character_field.w * 5                                          ; $00E8EE | |
    BNE -                                                                       ; $00E8F1 |/
    JMP _decode_event_opcode_done                                               ; $00E8F3 | Otherwise, simply return.
+   STZ r_character_field.1.right_hand_item.w,X                                 ; $00E8F6 |\
    STZ r_character_field.1.right_hand_count.w,X                                ; $00E8F9 | | If found in a party member's right hand, remove it.
    JMP _decode_event_opcode_done                                               ; $00E8FC |/
++  LDA #0.b                                                                    ; $00E8FF |\
    STA r_inventory.1.id.w,Y                                                    ; $00E901 | | If found in the inventory, remove it.
    STA r_inventory.1.count.w,Y                                                 ; $00E904 |/
    JMP _decode_event_opcode_done                                               ; $00E907

; _decode_event_opcode_toggle_status ($00:E90A)
;
; Handles event opcode $DB, which reads the next byte and uses that as a mask of
; bits to toggle in each character's first status byte. This uses exclusive OR,
; so values will be toggled, and not merely set.
_decode_event_opcode_toggle_status:
    JSR _decode_event_get_next_byte                                             ; $00E90A |\ Read the next byte and save it to a temporary variable.
    STA <r_generic_tmp_1                                                        ; $00E90D |/
    LDX #0.w                                                                    ; $00E90F | Initialize the X register to zero.
-   LDA r_character_field.1.status_1.w,X                                        ; $00E912 |\
    EOR <r_generic_tmp_1                                                        ; $00E915 | | Loop through the five character slots, toggling the passed bits
    STA r_character_field.1.status_1.w,X                                        ; $00E917 | | in the first status byte.
    JSR _increment_x_by_64                                                      ; $00E91A | |
    CPX #_sizeof_character_field.w * 5                                          ; $00E91D | |
    BNE -                                                                       ; $00E920 |/
    LDA #1.b                                                                    ; $00E922 |\ Flag the player field sprite as dirty.
    STA <r_player_field_sprite_dirty                                            ; $00E924 |/
    JMP _decode_event_opcode_done                                               ; $00E926

; _decode_event_opcode_remove_status ($00:E929)
;
; Handles event opcode $E3, which reads the next byte and uses that as a mask to
; remove statuses from the first status byte for each character. In other words,
; the parameter is a list of statuses to keep.
_decode_event_opcode_remove_status:
    JSR _decode_event_get_next_byte                                             ; $00E929 |\ Read the next byte and save it in a temporary variable.
    STA <r_generic_tmp_1                                                        ; $00E92C |/
    LDX #0.w                                                                    ; $00E92E | Initialize the X register to zero.
-   LDA r_character_field.1.status_1.w,X                                        ; $00E931 |\
    AND <r_generic_tmp_1                                                        ; $00E934 | | Loop through the five character slots, applying the loaded value
    STA r_character_field.1.status_1.w,X                                        ; $00E936 | | as a mask to remove statuses from the first status byte from each
    JSR _increment_x_by_64                                                      ; $00E939 | | slot.
    CPX #_sizeof_character_field.w * 5                                          ; $00E93C | |
    BNE -                                                                       ; $00E93F |/
    LDA #1.b                                                                    ; $00E941 |\ Flag the player field sprite as dirty.
    STA <r_player_field_sprite_dirty                                            ; $00E943 |/
    JMP _decode_event_opcode_done                                               ; $00E945

; _decode_event_opcode_add_status ($00:E948)
;
; Handles event opcode $E4, which reads the next byte and uses that as a list of
; bits in the first status byte to set, without affecting other bits.
_decode_event_opcode_add_status:
    JSR _decode_event_get_next_byte                                             ; $00E948 |\ Read the next byte and save it to a temporary variable.
    STA <r_generic_tmp_1                                                        ; $00E94B |/
    LDX #0.w                                                                    ; $00E94D | Initialize the X register to zero.
-   LDA r_character_field.1.status_1.w,X                                        ; $00E950 |\
    ORA <r_generic_tmp_1                                                        ; $00E953 | | Loop through the five character slots, applying the loaded value
    STA r_character_field.1.status_1.w,X                                        ; $00E955 | | as a list of status bits to set in the first status byte.
    JSR _increment_x_by_64                                                      ; $00E958 | |
    CPX #_sizeof_character_field * 5.w                                          ; $00E95B | |
    BNE -                                                                       ; $00E95E |/
    LDA #1.b                                                                    ; $00E960 |\ Flag the player field sprite as dirty.
    STA <r_player_field_sprite_dirty                                            ; $00E962 |/
    JMP _decode_event_opcode_done                                               ; $00E964

; _decode_event_opcode_add_gp ($00:E967)
;
; Handles opcode $E5, which given the next byte, adds that value times 100 in GP
; to the party's total. This opcode doesn't appear to be used by the game.
_decode_event_opcode_add_gp:
    JSR _decode_event_get_next_byte                                             ; $00E967 |\
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $00E96A | | Multiply the next byte by 100 to determine the GP amount.
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $00E96C | |
    LDA #100.b                                                                  ; $00E96E | |
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $00E970 | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $00E972 | |
    JSL bank15.math_multiply_16bit                                              ; $00E974 |/
    JSR _add_party_gp                                                           ; $00E978 | Add the value to the party's GP.
    JMP _decode_event_opcode_done                                               ; $00E97B

; _decode_event_opcode_subtract_gp ($00:E97E)
;
; Handles opcode $E6, which subtracts GP from the party's total. This opcode
; does not appear to be used by the game.
_decode_event_opcode_subtract_gp:
    JSR _decode_event_get_next_byte                                             ; $00E97E |\
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $00E981 | | Multiply the next byte by 100 to determine the GP adjustment
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $00E983 | | amount.
    LDA #100                                                                    ; $00E985 | |
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $00E987 | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $00E989 | |
    JSL bank15.math_multiply_16bit                                              ; $00E98B |/
    LDA r_party_gp.lo.w                                                         ; $00E98F |\
    SEC                                                                         ; $00E992 | | Subtract that value from the party's GP total.
    SBC <r_bank15_math_multiply_16bit_result_lo                                 ; $00E993 | |
    STA r_party_gp.lo.w                                                         ; $00E995 | |
    LDA r_party_gp.md.w                                                         ; $00E998 | |
    SBC <r_bank15_math_multiply_16bit_result_md                                 ; $00E99B | |
    STA r_party_gp.md.w                                                         ; $00E99D | |
    LDA r_party_gp.hi.w                                                         ; $00E9A0 | |
    SBC <r_bank15_math_multiply_16bit_result_hi                                 ; $00E9A3 | |
    STA r_party_gp.hi.w                                                         ; $00E9A5 |/
    BCS +                                                                       ; $00E9A8 |\
    STZ r_party_gp.lo.w                                                         ; $00E9AA | | If the result was negative, set the party's GP to zero.
    STZ r_party_gp.md.w                                                         ; $00E9AD | |
    STZ r_party_gp.hi.w                                                         ; $00E9B0 |/
+   JMP _decode_event_opcode_done                                               ; $00E9B3

; _decode_event_opcode_set_player_field_sprite ($00:E9B6)
;
; Handles opcode $DD, which sets the player field sprite to the sprite of the
; character ID provided in the parameter byte. This works by finding which slot
; has the character ID in question. If the provided character is not in the
; party, the game will either softlock or end up loading garbage data.
_decode_event_opcode_set_player_field_sprite:
    JSR _decode_event_get_next_byte                                             ; $00E9B6 |\ Read the next byte and save it in a temporary variable.
    STA <r_generic_tmp_1                                                        ; $00E9B9 |/
    LDX #0.w                                                                    ; $00E9BB |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $00E9BE |/
-   LDA r_character_field.1.id.w,Y                                              ; $00E9C1 |\
    AND #%011111.b                                                              ; $00E9C4 | | If the character in this slot's ID matches the provided parameter,
    CMP <r_generic_tmp_1                                                        ; $00E9C6 | | branch ahead to the final code.
    BEQ +                                                                       ; $00E9C8 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $00E9CA |\
    TYA                                                                         ; $00E9CC | | Otherwise, update the offset and loop back to check the next slot.
    CLC                                                                         ; $00E9CD | |
    ADC #_sizeof_character_field.w                                              ; $00E9CE | |
    TAY                                                                         ; $00E9D1 | |
    LDA #0.w                                                                    ; $00E9D2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00E9D5 | |
    INX                                                                         ; $00E9D7 | |
    JMP -                                                                       ; $00E9D8 |/
+   TXA                                                                         ; $00E9DB |\ Set the player field sprite slot to the found slot.
    STA r_field_sprite_slot.w                                                   ; $00E9DC |/
    LDA #1.b                                                                    ; $00E9DF |\ Make the player field sprite as dirty.
    STA <r_player_field_sprite_dirty                                            ; $00E9E1 |/
    JMP _decode_event_opcode_done                                               ; $00E9E3

; _decode_event_opcode_inn ($00:E9E6)
;
; Handles opcode $DC, which handles the player staying at an inn. Specifically,
; it displays the dialog and if the player does stay at the inn, it will update
; the party's GP. Additionally, this is a branching opcode, depending on if the
; player stays at the inn or not. If the player does not stay at the inn, the
; rest of the event will not be played. (There is no ability to show a different
; sequence of events for a failed stay.) (Note that this does not handle
; animating any of the inn animation. The calling event is expected to do that.)
_decode_event_opcode_inn:
    JSR _decode_event_get_next_byte                                             ; $00E9E6 |\
    ASL A                                                                       ; $00E9E9 | | Read the inn index from the next byte, and based on that, read the
    TAX                                                                         ; $00E9EA | | price of staying at this Inn. Store it as the current number so it
    LDA inn_price_data.w + 0,X                                                  ; $00E9EB | | will display in the welcome dialog.
    STA r_current_number_lo.w                                                   ; $00E9EE | |
    LDA inn_price_data.w + 1,X                                                  ; $00E9F1 | |
    STA r_current_number_md.w                                                   ; $00E9F4 | |
    STZ r_current_number_hi.w                                                   ; $00E9F7 |/
    LDA #MESSAGE_BANK_1_LO_HELLO_WILL_YOU_STAY.b                                ; $00E9FA |\
    STA <r_show_message_id                                                      ; $00E9FC | | Display the inn welcome message.
    JSR _load_message_bank_1_lo_offset                                          ; $00E9FE | |
    JSR _show_upper_dialog                                                      ; $00EA01 |/
    JSR _format_number_prepare_gp                                               ; $00EA04 |\ Format the party's current GP for display.
    JSL bank15.format_number                                                    ; $00EA07 |/
    JSR _transfer_format_number_arg_to_current_number                           ; $00EA0B | Transfer the party's GP to the current number variable. TODO: Why?
    JSR _inn_draw_party_gp_window                                               ; $00EA0E | Draw the GP window.
    JSR _dialog_yes_no_execute                                                  ; $00EA11 | Show the yes/no dialog.
    JSR _inn_erase_party_gp_window                                              ; $00EA14 | Erase the GP window.
    JSR _close_upper_dialog                                                     ; $00EA17 | Close the welcome message.
    JSR _wait_for_nmi_complete                                                  ; $00EA1A |\ Wait for the next frame and erase any dialog.
    JSR _erase_dialog_if_pending                                                ; $00EA1D |/
    LDA <r_yes_no_dialog_result                                                 ; $00EA20 |\
    BEQ +                                                                       ; $00EA22 | | If the player chose no, display the "Come again" dialog and then
    LDA #MESSAGE_BANK_1_LO_COME_AGAIN.b                                         ; $00EA24 | | jump to near the end.
    STA <r_show_message_id                                                      ; $00EA26 | |
    JSR _load_message_bank_1_lo_offset                                          ; $00EA28 | |
    JSR _show_upper_dialog                                                      ; $00EA2B | |
    JSR _close_upper_dialog                                                     ; $00EA2E | |
    JSR _erase_dialog_if_pending                                                ; $00EA31 | |
    JMP ++                                                                      ; $00EA34 |/
+   JSR _format_number_prepare_gp                                               ; $00EA37 |\
    LDX <r_decode_event_index                                                   ; $00EA3A | | Subtract the inn's cost from the party's GP.
    LDA r_decode_event_bytes.w,X                                                ; $00EA3C | |
    ASL A                                                                       ; $00EA3F | |
    TAX                                                                         ; $00EA40 | |
    LDA r_party_gp.lo.w                                                         ; $00EA41 | |
    SEC                                                                         ; $00EA44 | |
    SBC inn_price_data.w + 0,X                                                  ; $00EA45 | |
    STA <r_format_number_arg_lo                                                 ; $00EA48 | |
    LDA r_party_gp.md.w                                                         ; $00EA4A | |
    SBC inn_price_data.w + 1,X                                                  ; $00EA4D | |
    STA <r_format_number_arg_md                                                 ; $00EA50 | |
    LDA r_party_gp.hi.w                                                         ; $00EA52 | |
    SBC #0.b                                                                    ; $00EA55 | |
    STA <r_format_number_arg_hi                                                 ; $00EA57 |/
    BCS +                                                                       ; $00EA59 |\
    LDA #MESSAGE_BANK_1_LO_NOT_ENOUGH_GP.b                                      ; $00EA5B | | If the result of the subtraction is negative, display the not
    STA <r_show_message_id                                                      ; $00EA5D | | enough GP dialog.
    JSR _load_message_bank_1_lo_offset                                          ; $00EA5F | |
    JSR _show_upper_dialog                                                      ; $00EA62 | |
    JSR _close_upper_dialog                                                     ; $00EA65 | |
    JSR _erase_dialog_if_pending                                                ; $00EA68 |/
++  JSR _decode_event_advance_to_end                                            ; $00EA6B |\ If not enough GP or if the player chose no, advance the event to
    JMP _decode_event_opcode_done                                               ; $00EA6E |/ the end (to resume from the second branch) and return.
+   LDA <r_format_number_arg_lo                                                 ; $00EA71 |\
    STA r_party_gp.lo.w                                                         ; $00EA73 | | If the player did stay at the Inn, transfer their new GP value to
    LDA <r_format_number_arg_md                                                 ; $00EA76 | | the party GP variable.
    STA r_party_gp.md.w                                                         ; $00EA78 | |
    LDA <r_format_number_arg_hi                                                 ; $00EA7B | |
    STA r_party_gp.hi.w                                                         ; $00EA7D |/
    JMP _decode_event_opcode_done                                               ; $00EA80

; inn_price_data ($00:EA83)
;
; For each Inn index, determines the price of staying at that Inn. The notation
; on which towns use which inn is not necessarily complete.
inn_price_data:
    .dw   50                                                                    ; $00EA83.EA84 | $00: Baron
    .dw  100                                                                    ; $00EA85.EA86 | $01: Fabul
    .dw  200                                                                    ; $00EA87.EA88 | $02: Mysidia
    .dw  400                                                                    ; $00EA89.EA8A | $03: Toroia
    .dw  500                                                                    ; $00EA8B.EA8C | $04: Silvera
    .dw  600                                                                    ; $00EA8D.EA8E | $05: Castle of Dwarves
    .dw  700                                                                    ; $00EA8F.EA90 | $06: Cave Eblana
    .dw  300                                                                    ; $00EA91.EA92 | $07: Tomra
    .dw 1200                                                                    ; $00EA93.EA94 | $08: Land of Monsters

; _transfer_format_number_arg_to_current_number ($00:EA95)
;
; Copies the 24-bit value at $30 (the format_number argument) to $08F8, which is
; the "current" number, displayed if a dialog uses the number opcode.
_transfer_format_number_arg_to_current_number:
    LDA <r_format_number_arg_lo                                                 ; $00EA95
    STA r_current_number_lo.w                                                   ; $00EA97
    LDA <r_format_number_arg_md                                                 ; $00EA9A
    STA r_current_number_md.w                                                   ; $00EA9C
    LDA <r_format_number_arg_hi                                                 ; $00EA9F
    STA r_current_number_hi.w                                                   ; $00EAA1
    RTS                                                                         ; $00EAA4

; _format_number_prepare_gp ($00:EAA5)
;
; Prepares to format the party GP as a number by copying the current value into
; the argument locations for the number formatting routine at $30 through $32.
_format_number_prepare_gp:
    LDA r_party_gp.lo.w                                                         ; $00EAA5 |\
    STA <r_format_number_arg_lo                                                 ; $00EAA8 | | Transfer the current party GP into the addresses used as an
    LDA r_party_gp.md.w                                                         ; $00EAAA | | argument for the number formatting routine.
    STA <r_format_number_arg_md                                                 ; $00EAAD | |
    LDA r_party_gp.hi.w                                                         ; $00EAAF | |
    STA <r_format_number_arg_hi                                                 ; $00EAB2 |/
    RTS                                                                         ; $00EAB4

; _decode_event_opcode_wait ($00:EAB5)
;
; Handles opcode $E9, which waits the number of frames in the next byte times
; eight.
_decode_event_opcode_wait:
    JSR _decode_event_get_next_byte                                             ; $00EAB5 |\
    STA <r_wait_for_x_frames_frames_lo                                          ; $00EAB8 | | Get the next byte and multiply by eight, using that to initialize
    STZ <r_wait_for_x_frames_frames_hi                                          ; $00EABA | | the frame counter.
    ASL <r_wait_for_x_frames_frames_lo                                          ; $00EABC | |
    ROL <r_wait_for_x_frames_frames_hi                                          ; $00EABE | |
    ASL <r_wait_for_x_frames_frames_lo                                          ; $00EAC0 | |
    ROL <r_wait_for_x_frames_frames_hi                                          ; $00EAC2 | |
    ASL <r_wait_for_x_frames_frames_lo                                          ; $00EAC4 | |
    ROL <r_wait_for_x_frames_frames_hi                                          ; $00EAC6 |/
-   JSR _wait_for_nmi_complete_field                                            ; $00EAC8 | Wait a frame.
    LDA r_map_area.w                                                            ; $00EACB |\
    CMP #MAP_AREA_DUNGEON                                                       ; $00EACE | | If this is outdoors, draw the outdoor field sprites.
    BEQ +                                                                       ; $00EAD0 | |
    JSR _draw_outdoor_field_sprites                                             ; $00EAD2 | |
    JMP ++                                                                      ; $00EAD5 |/
+   JSL bank15.draw_dungeon_field_sprite_player                                 ; $00EAD8 |\ Otherwise, draw the dungeon field sprites.
    JSR _draw_field_sprite_npcs                                                 ; $00EADC |/
++  LDX <r_wait_for_x_frames_frames                                             ; $00EADF |\
    DEX                                                                         ; $00EAE1 | | Decrement the frame counter and wait until the frame counter
    STX <r_wait_for_x_frames_frames                                             ; $00EAE2 | | reaches zero.
    BNE -                                                                       ; $00EAE4 |/
    JMP _decode_event_opcode_done                                               ; $00EAE6

; _decode_event_opcode_show_message_bank_1_hi_yes_no ($00:EAE9)
;
; Handles opcode $F8, which displays a message from the high part of bank 1 and
; then presents the player with a yes/no dialog. If the player selects yes,
; there is no further change and the event continues. If the player selects no,
; the event offset is advanced to the first byte after the next end opcode.
_decode_event_opcode_show_message_bank_1_hi_yes_no:
    JSR _decode_event_get_next_byte                                             ; $00EAE9 |\ Get the next byte and set that as the message ID.
    STA <r_show_message_id                                                      ; $00EAEC |/
    JSR _load_message_bank_1_hi_offset                                          ; $00EAEE | Display the message from the high part of bank 1.
    JSR _show_upper_dialog                                                      ; $00EAF1 | Show the dialog.
    JSR _dialog_yes_no_execute                                                  ; $00EAF4 | Display a yes/no dialog.
    JSR _close_upper_dialog                                                     ; $00EAF7 | Close the dialog.
    JSR _wait_for_nmi_complete                                                  ; $00EAFA | Wait for the next frame.
    JSR _erase_dialog_if_pending                                                ; $00EAFD | Erase the dialog.
    LDA <r_yes_no_dialog_result                                                 ; $00EB00 |\
    BEQ +                                                                       ; $00EB02 | | If the player chose no, advance to the end of this event and
    JSR _decode_event_advance_to_end                                            ; $00EB04 | | increment the offset by one to switch to the no branch.
    INX                                                                         ; $00EB07 | |
    STX r_decode_event_current_offset.w                                         ; $00EB08 |/
+   JMP _decode_event_opcode_done                                               ; $00EB0B

; _decode_event_opcode_select_item ($00:EB0E)
;
; Handles opcode $F7, which presents an item selection dialog to the player,
; and then branches in the script depending on if the user selected the passed
; parameter item. If yes, the script continues from its current location. If no
; item or the wrong item was chosen, the script is advanced to the end to skip
; the remainder of the script.
_decode_event_opcode_select_item:
    INX                                                                         ; $00EB0E |\ Increment the event index.
    STX <r_decode_event_index                                                   ; $00EB0F |/
    JSR _lower_dialog_select_item                                               ; $00EB11 | Present the player with the item select dialog.
    JSR _wait_for_nmi_complete                                                  ; $00EB14 | Wait for the next frame.
    JSR _erase_dialog_if_pending                                                ; $00EB17 | Erase the dialog.
    LDA r_current_item.w                                                        ; $00EB1A |\
    CMP #$FF                                                                    ; $00EB1D | | If the player didn't choose an item, branch to the advance code.
    BEQ +                                                                       ; $00EB1F |/
    LDX <r_decode_event_index                                                   ; $00EB21 |\
    LDA r_decode_event_bytes.w,X                                                ; $00EB23 | | If the chosen item matches the parameter item, branch ahead to
    CMP r_current_item.w                                                        ; $00EB26 | | later code.
    BEQ ++                                                                      ; $00EB29 |/
    LDA #MESSAGE_BANK_1_LO_NOTHING_HAPPENED                                     ; $00EB2B |\
    STA <r_show_message_id                                                      ; $00EB2D | | Otherwise, display the "Nothing happened" dialog.
    JSR _load_message_bank_1_lo_offset                                          ; $00EB2F | |
    JSR _show_upper_dialog                                                      ; $00EB32 | |
    JSR _close_upper_dialog                                                     ; $00EB35 |/
+   JSR _decode_event_advance_to_end                                            ; $00EB38 |\ If no item was chosen or if it didn't match the parameter byte,
    JMP _decode_event_opcode_done                                               ; $00EB3B |/ advance the script to the end to skip the rest.
++  CMP #ITEM_PASS.b                                                            ; $00EB3E |\ If the item is the Pass, skip the item decrement code.
    BEQ @done                                                                   ; $00EB40 |/
    CMP #ITEM_SORT.b                                                            ; $00EB42 |\
    BCS +                                                                       ; $00EB44 | | Otherwise, skip the item decrement code if the item is in the key
    CMP #ITEM_WHISTLE.b                                                         ; $00EB46 | | item range ($ED to $FD).
    BCS @done                                                                   ; $00EB48 |/
+   LDX #0.w                                                                    ; $00EB4A |\
-   LDA r_inventory.1.id.w,X                                                    ; $00EB4D | | Loop through the inventory, searching for a stack of the chosen
    CMP r_current_item.w                                                        ; $00EB50 | | item.
    BEQ +                                                                       ; $00EB53 | |
    INX                                                                         ; $00EB55 | |
    INX                                                                         ; $00EB56 | |
    JMP -                                                                       ; $00EB57 |/
+   DEC r_inventory.1.count.w,X                                                 ; $00EB5A | Decrement the item's count.
    BNE @done                                                                   ; $00EB5D |\ If there are zero left, zero out the item ID.
    STZ r_inventory.1.id.w,X                                                    ; $00EB5F |/
@done:
    JMP _decode_event_opcode_done                                               ; $00EB62

; _decode_event_opcode_random_vertical_offset ($00:EB65)
;
; Handles opcode $D6, which randomly sets the current vertical scroll registers
; for BG1 and BG2 to either the configured value or the configured value plus
; eight. In that sense, if used repeatedly, it is primarily useful for creating
; a vertical shaking effect.
_decode_event_opcode_random_vertical_offset:
    JSR _wait_for_nmi_complete                                                  ; $00EB65 | Wait for the next frame.
    JSR _set_random_vertical_scroll_offset                                      ; $00EB68 | Randomly set the vertical scroll offset to +8 its configured value.
    JMP _decode_event_opcode_done                                               ; $00EB6B

; _set_random_vertical_scroll_offset ($00:EB6E)
;
; Reads a random value from the field RNG, and if it is less than 128, sets the
; BG1 and BG2 vertical scroll registers to the configured 16-bit values in $065C
; and $0660 plus eight. Otherwise, does not touch them at all.
_set_random_vertical_scroll_offset:
    JSR _get_field_rng                                                          ; $00EB6E |\
    CMP #128.b                                                                  ; $00EB71 | | If a random number from 0 to 255 is 128 or greater, return.
    BCS +                                                                       ; $00EB73 |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $00EB75 |\
    CLC                                                                         ; $00EB77 | | Set the BG1 vertical scroll register to the configured value plus
    ADC #8.b                                                                    ; $00EB78 | | eight.
    STA reg_ppu_bg1v0fs.w                                                       ; $00EB7A | |
    LDA <r_scroll_bg1_vertical_hi                                               ; $00EB7D | |
    ADC #0.b                                                                    ; $00EB7F | |
    STA reg_ppu_bg1v0fs.w                                                       ; $00EB81 |/
    LDA <r_scroll_bg2_vertical_lo                                               ; $00EB84 |\
    CLC                                                                         ; $00EB86 | | Set the BG2 vertical scroll register to the configured value plus
    ADC #8.b                                                                    ; $00EB87 | | eight.
    STA reg_ppu_bg2v0fs.w                                                       ; $00EB89 | |
    LDA <r_scroll_bg2_vertical_hi                                               ; $00EB8C | |
    ADC #0.b                                                                    ; $00EB8E | |
    STA reg_ppu_bg2v0fs.w                                                       ; $00EB90 | |
+   RTS                                                                         ; $00EB93 |/

; _decode_event_opcode_toggle_shaking ($00:EB94)
;
; Handles opcode $D0, which toggles the screen shaking effect.
_decode_event_opcode_toggle_shaking:
    LDA <r_shaking                                                              ; $00EB94 |\
    EOR #%00000001.b                                                            ; $00EB96 | | Toggle the shaking flag.
    STA <r_shaking                                                              ; $00EB98 |/
    JMP _decode_event_opcode_done                                               ; $00EB9A

; _decode_event_opcode_flash_screen ($00:EB9D)
;
; Handles opcode $D1, which produces a two frame flash effect.
_decode_event_opcode_flash_screen:
    LDA #2.b                                                                    ; $00EB9D |\ Initialize the counter to 2.
    STA <r_transition_index                                                     ; $00EB9F |/
-   INC <r_enable_flash_palette                                                 ; $00EBA1 |\
    JSR _wait_for_nmi_complete                                                  ; $00EBA3 | | Loop for two frames, enabling the flash palette both frames to
    DEC <r_transition_index                                                     ; $00EBA6 | | produce the flash effect.
    BNE -                                                                       ; $00EBA8 |/
    JMP _decode_event_opcode_done                                               ; $00EBAA

; _copy_alternate_cgram_to_ppu ($00:EBAD)
;
; Use a DMA transfer to copy the alternate CG-RAM data to CG-RAM (replacing the
; first eight palettes).
_copy_alternate_cgram_to_ppu:
    STZ reg_cpu_mdmaen                                                          ; $00EBAD | Reset DMA.
    STZ reg_ppu_cgadd                                                           ; $00EBB0 | Set the CG-RAM address to zero.
    LDA #%00000010.b                                                            ; $00EBB3 |\ Configure DMA to write the value twice to the same address.
    STA reg_cpu_dmap0                                                           ; $00EBB5 |/
    LDA #<reg_ppu_cgdata.b                                                      ; $00EBB8 |\ Set the DMA write address to $2122 (CG-RAM write).
    STA reg_cpu_bbad0                                                           ; $00EBBA |/
    LDA #$00.b                                                                  ; $00EBBD |\ Set the DMA read bank to $00.
    STA reg_cpu_a1b0                                                            ; $00EBBF |/
    LDX #r_alternate_cgram_data.w                                               ; $00EBC2 |\ Set the DMA read address to $0BDB.
    STX reg_cpu_a1t0                                                            ; $00EBC5 |/
    LDX #$0100.w                                                                ; $00EBC8 |\ Set the DMA transfer to copy 256 bytes.
    STX reg_cpu_das0                                                            ; $00EBCB |/
    LDA #%00000001.b                                                            ; $00EBCE |\ Enable the DMA transfer on channel 0.
    STA reg_cpu_mdmaen                                                          ; $00EBD0 |/
    RTS                                                                         ; $00EBD3

; _decode_event_opcode_mosaic ($00:EBD4)
;
; Handles opcode $D2, which does a simple blurring effect using the SNES mosaic
; effect.
_decode_event_opcode_mosaic:
    STZ <r_generic_tmp_counter                                                  ; $00EBD4 | Initialize the counter to zero.
-   JSR _wait_for_nmi_complete                                                  ; $00EBD6 | Wait for the next frame.
    LDA <r_generic_tmp_counter                                                  ; $00EBD9 |\
    LSR A                                                                       ; $00EBDB | | Set the correct mosaic value for this frame by dividing the
    TAX                                                                         ; $00EBDC | | counter by two.
    LDA bank14.effect_mosaic_data.l,X                                           ; $00EBDD | |
    STA reg_ppu_mosaic.w                                                        ; $00EBE1 |/
    INC <r_generic_tmp_counter                                                  ; $00EBE4 |\
    LDA <r_generic_tmp_counter                                                  ; $00EBE6 | | Increment the counter and loop until it reaches 64.
    CMP #64.b                                                                   ; $00EBE8 | |
    BNE -                                                                       ; $00EBEA |/
    JMP _decode_event_opcode_done                                               ; $00EBEC

; _decode_event_opcode_big_whale_earth_moon_travel ($00:EBEF)
;
; Handles opcode $D3, which animates the Big Whale traveling between the earth
; and the moon.
;
; NOTE: This opcode does not appear to be used by the game at all, but may
;       nonetheless be functional.
_decode_event_opcode_big_whale_earth_moon_travel:
    LDA r_map_area.w                                                            ; $00EBEF |\
    BEQ +                                                                       ; $00EBF2 | | Animate the Big Whale traveling between the earth and moon in the
    JMP ++                                                                      ; $00EBF4 | | correct direction.
+   JSR _big_whale_earth_to_moon                                                ; $00EBF7 | |
    JMP +                                                                       ; $00EBFA | |
++  JSR _big_whale_moon_to_earth                                                ; $00EBFD |/
+   STZ <r_transition_index                                                     ; $00EC00 |\
    STZ <r_map_frame_counter                                                    ; $00EC02 | | Initialize several counters to zero.
    STZ <r_movement_frame_counter                                               ; $00EC04 |/
    LDA #%10000001.b                                                            ; $00EC06 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen.w                                                      ; $00EC08 |/
    JSR _wait_for_nmi_complete                                                  ; $00EC0B | Wait for the next complete NMI.
    LDA #%00001111.b                                                            ; $00EC0E |\ Set the PPU brightness to maximum.
    STA reg_ppu_inidisp.w                                                       ; $00EC10 |/
    CLI                                                                         ; $00EC13 | Enable interrupts.
    JMP _decode_event_opcode_done                                               ; $00EC14

; _decode_event_opcode_open_large_door ($00:EC17)
;
; Handles opcode $D5, which opens the first visible large door.
_decode_event_opcode_open_large_door:
    LDA r_current_coordinates.x.w                                               ; $00EC17 |\
    SEC                                                                         ; $00EC1A | | Initialize the X coordinate value to the current X coordinate
    SBC #7.b                                                                    ; $00EC1B | | minus seven.
    STA <r_generic_tmp_index.lo                                                 ; $00EC1D |/
    LDA r_current_coordinates.y.w                                               ; $00EC1F |\
    SEC                                                                         ; $00EC22 | | Subtract seven from the current Y coordinate.
    SBC #7.b                                                                    ; $00EC23 |/
    BPL +                                                                       ; $00EC25 |\
    CLC                                                                         ; $00EC27 | | If the resulting value is negative, set the coordinate value to
    ADC #15.b                                                                   ; $00EC28 | | zero, set the counter to the negative value plus fifteen, and
    STA <r_generic_tmp_2                                                        ; $00EC2A | | branch to the loop start.
    STZ <r_generic_tmp_index.hi                                                 ; $00EC2C | |
    JMP @loop_start                                                             ; $00EC2E |/
+   AND #%00011111.b                                                            ; $00EC31 |\
    STA <r_generic_tmp_index.hi                                                 ; $00EC33 | | Otherwise, set the Y coordinate to the calculated value mod 32 and
    LDA #15.b                                                                   ; $00EC35 | | initialize the counter to 15.
    STA <r_generic_tmp_2                                                        ; $00EC37 |/
@loop_start:
    LDX <r_generic_tmp_index                                                    ; $00EC39 | Set the X register to the coordinate offset.
    LDY #16.w                                                                   ; $00EC3B | Initialize the Y register to 16 (for each column).
-   LDA r_tilemap_data.l,X                                                      ; $00EC3E |\
    CMP #TILEMAP_TILE_LARGE_DOOR_CLOSED_UPPER_LEFT.b                            ; $00EC42 | | Branch ahead if the current tile is an upper left large door tile.
    BEQ ++                                                                      ; $00EC44 |/
    INX                                                                         ; $00EC46 |\
    DEY                                                                         ; $00EC47 | | Loop until all 16 columns have been checked.
    BNE -                                                                       ; $00EC48 |/
    INC <r_generic_tmp_index.hi                                                 ; $00EC4A |\
    LDA <r_generic_tmp_index.hi                                                 ; $00EC4C | | Increment the Y coordinate, and if it reaches 32, jump to the end
    CMP #32.b                                                                   ; $00EC4E | | of the routine. Otherwise, decrement the row counter and loop back
    BCS +                                                                       ; $00EC50 | | to the start of the loop.
    DEC <r_generic_tmp_2                                                        ; $00EC52 | |
    BNE @loop_start                                                             ; $00EC54 | |
+   JMP @done                                                                   ; $00EC56 |/
++  STX <r_generic_tmp_index                                                    ; $00EC59 | Save the current coordinates to a temporary variable.
    LDA #TILEMAP_TILE_LARGE_DOOR_OPEN_UPPER_LEFT.b                              ; $00EC5B |\
    STA r_tilemap_data.l + 0,X                                                  ; $00EC5D | | Update the tilemap values to place an open door in the location
    INC A                                                                       ; $00EC61 | | of a closed door.
    STA r_tilemap_data.l + 1,X                                                  ; $00EC62 | |
    INC A                                                                       ; $00EC66 | |
    STA r_tilemap_data.l + 256,X                                                ; $00EC67 | |
    INC A                                                                       ; $00EC6B | |
    STA r_tilemap_data.l + 257,X                                                ; $00EC6C |/
    JSR _calculate_large_door_vram_addresses                                    ; $00EC70 | Calculate the VRAM addresses for the door's tiles.
    LDX #0.w                                                                    ; $00EC73 |\ Initialize the X and Y registers to zero.
    LDY #0.w                                                                    ; $00EC76 |/
-   REP #FLAG_P_ACCUMULATOR                                                     ; $00EC79 |\
    LDA r_tile_composition_data_dungeon_upper_left.l + ($64 * 2),X              ; $00EC7B | | Load the tile composition data for tile $64 (the opened large door)
    STA r_open_large_door_tiles.w + 0,Y                                         ; $00EC7F | | plus the current value of the X register, and save it to the open
    LDA r_tile_composition_data_dungeon_upper_right.l + ($64 * 2),X             ; $00EC82 | | door tiles array.
    STA r_open_large_door_tiles.w + 2,Y                                         ; $00EC86 | |
    LDA r_tile_composition_data_dungeon_lower_left.l + ($64 * 2),X              ; $00EC89 | |
    STA r_open_large_door_tiles.w + 8,Y                                         ; $00EC8D | |
    LDA r_tile_composition_data_dungeon_lower_right.l + ($64 * 2),X             ; $00EC90 | |
    STA r_open_large_door_tiles.w + 10,Y                                        ; $00EC94 | |
    LDA #0.w                                                                    ; $00EC97 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00EC9A |/
    INX                                                                         ; $00EC9C |\ Increment the X register by two to move to the next tile.
    INX                                                                         ; $00EC9D |/
    TYA                                                                         ; $00EC9E |\
    AND #%00000111.b                                                            ; $00EC9F | | If the Y register mod 8 is equal to zero, add eight to the
    BEQ +                                                                       ; $00ECA1 | | register. (This moves to the next large row of tiles. The ultimate
    TYA                                                                         ; $00ECA3 | | Y register pattern is 0, 4, 16, 20.)
    CLC                                                                         ; $00ECA4 | |
    ADC #8.b                                                                    ; $00ECA5 | |
    TAY                                                                         ; $00ECA7 |/
+   INY                                                                         ; $00ECA8 |\
    INY                                                                         ; $00ECA9 | | Increment the Y register by four.
    INY                                                                         ; $00ECAA | |
    INY                                                                         ; $00ECAB |/
    CPX #8.w                                                                    ; $00ECAC |\ Loop until all four 16x16 tiles are complete.
    BNE -                                                                       ; $00ECAF |/
    LDA #1.b                                                                    ; $00ECB1 |\ Flag the large door opening as pending.
    STA <r_open_large_door_pending                                              ; $00ECB3 |/
    LDA #AUDIO_EFFECT_LARGE_DOOR.b                                              ; $00ECB5 |\ Play the large door sound effect.
    JSR _play_sound_effect                                                      ; $00ECB7 |/
@done:
    JMP _decode_event_opcode_done                                               ; $00ECBA

; _calculate_large_door_vram_addresses ($00:ECBD)
;
; Given the X and Y coordinates for a door in $3D and $3E, respectively, sets
; the values in the array at $0A17 to the VRAM addresses for each of the door's
; tiles. There are eight addresses, and each horizontal pair of 8x8 tiles takes
; up one address.
_calculate_large_door_vram_addresses:
    LDA <r_generic_tmp_index.lo                                                 ; $00ECBD |\
    STA <r_generic_arg_x_lo                                                     ; $00ECBF | | Determine the coordinates from the current index.
    LDA <r_generic_tmp_index.hi                                                 ; $00ECC1 | |
    STA <r_generic_arg_y_lo                                                     ; $00ECC3 |/
    JSR _calculate_dungeon_vram_address                                         ; $00ECC5 |\ Calculate the VRAM address for those coordinates and save it in the
    STX r_open_large_door_vram_addresses.1.w                                    ; $00ECC8 |/ first slot.
    STX r_open_large_door_vram_addresses.3.w                                    ; $00ECCB |\
    LDA r_open_large_door_vram_addresses.1.lo.w                                 ; $00ECCE | | Calculate the third slot's address by adding 32 (one row of 16
    CLC                                                                         ; $00ECD1 | | tiles) to the first slot's address.
    ADC #32.b                                                                   ; $00ECD2 | |
    STA r_open_large_door_vram_addresses.3.lo.w                                 ; $00ECD4 |/
    INC <r_generic_arg_x_lo                                                     ; $00ECD7 |\
    JSR _calculate_dungeon_vram_address                                         ; $00ECD9 | | Repeat a similar process for the tile to the right by incrementing
    STX r_open_large_door_vram_addresses.2.w                                    ; $00ECDC | | the X coordinate.
    STX r_open_large_door_vram_addresses.4.w                                    ; $00ECDF | |
    LDA r_open_large_door_vram_addresses.2.lo.w                                 ; $00ECE2 | |
    CLC                                                                         ; $00ECE5 | |
    ADC #32.b                                                                   ; $00ECE6 | |
    STA r_open_large_door_vram_addresses.4.lo.w                                 ; $00ECE8 |/
    INC <r_generic_arg_y_lo                                                     ; $00ECEB |\
    JSR _calculate_dungeon_vram_address                                         ; $00ECED | | Repeat for the bottom right tile by incrementing the Y coordinate.
    STX r_open_large_door_vram_addresses.6.w                                    ; $00ECF0 | |
    STX r_open_large_door_vram_addresses.8.w                                    ; $00ECF3 | |
    LDA r_open_large_door_vram_addresses.6.lo.w                                 ; $00ECF6 | |
    CLC                                                                         ; $00ECF9 | |
    ADC #32.b                                                                   ; $00ECFA | |
    STA r_open_large_door_vram_addresses.8.lo.w                                 ; $00ECFC |/
    DEC <r_generic_arg_x_lo                                                     ; $00ECFF |\
    JSR _calculate_dungeon_vram_address                                         ; $00ED01 | | Repeat for the bottom left tile by decrementing the X coordinate.
    STX r_open_large_door_vram_addresses.5.w                                    ; $00ED04 | |
    STX r_open_large_door_vram_addresses.7.w                                    ; $00ED07 | |
    LDA r_open_large_door_vram_addresses.5.lo.w                                 ; $00ED0A | |
    CLC                                                                         ; $00ED0D | |
    ADC #32.b                                                                   ; $00ED0E | |
    STA r_open_large_door_vram_addresses.7.lo.w                                 ; $00ED10 |/
    RTS                                                                         ; $00ED13

; _copy_open_large_door_to_vram_if_pending ($00:ED14)
;
; Checks for a non-zero value in $06E2. If it finds one, it copies the 16 tiles
; stored at $0A27 to the eight VRAM addresses stored at $0A17. Each address
; receives two tiles. This routine is actually fairly generic and can be used to
; copy any 16 tiles arranged in pairs of two next to each other. However, it
; appears to be used primarily for opening large doors consisting of four 16x16
; tiles.
_copy_open_large_door_to_vram_if_pending:
    LDA <r_open_large_door_pending                                              ; $00ED14 |\
    BNE +                                                                       ; $00ED16 | | If no large door is waiting to be opened, skip this function
    RTS                                                                         ; $00ED18 | | entirely.
+   STZ <r_open_large_door_pending                                              ; $00ED19 |/
    LDA #%10000000.b                                                            ; $00ED1B |\
    STA reg_ppu_vmainc                                                          ; $00ED1D | | Loop through the eight addresses, copying the two tiles associated
    LDX r_open_large_door_vram_addresses.w + 0                                  ; $00ED20 | | with each address to VRAM.
    STX reg_ppu_vmadd                                                           ; $00ED23 | |
    LDX r_open_large_door_tiles.w + 0                                           ; $00ED26 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED29 | |
    LDX r_open_large_door_tiles.w + 2                                           ; $00ED2C | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED2F | |
    LDX r_open_large_door_vram_addresses.w + 2                                  ; $00ED32 | |
    STX reg_ppu_vmadd                                                           ; $00ED35 | |
    LDX r_open_large_door_tiles.w + 4                                           ; $00ED38 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED3B | |
    LDX r_open_large_door_tiles.w + 6                                           ; $00ED3E | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED41 | |
    LDX r_open_large_door_vram_addresses.w + 4                                  ; $00ED44 | |
    STX reg_ppu_vmadd                                                           ; $00ED47 | |
    LDX r_open_large_door_tiles.w + 8                                           ; $00ED4A | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED4D | |
    LDX r_open_large_door_tiles.w + 10                                          ; $00ED50 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED53 | |
    LDX r_open_large_door_vram_addresses.w + 6                                  ; $00ED56 | |
    STX reg_ppu_vmadd                                                           ; $00ED59 | |
    LDX r_open_large_door_tiles.w + 12                                          ; $00ED5C | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED5F | |
    LDX r_open_large_door_tiles.w + 14                                          ; $00ED62 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED65 | |
    LDX r_open_large_door_vram_addresses.w + 8                                  ; $00ED68 | |
    STX reg_ppu_vmadd                                                           ; $00ED6B | |
    LDX r_open_large_door_tiles.w + 16                                          ; $00ED6E | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED71 | |
    LDX r_open_large_door_tiles.w + 18                                          ; $00ED74 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED77 | |
    LDX r_open_large_door_vram_addresses.w + 10                                 ; $00ED7A | |
    STX reg_ppu_vmadd                                                           ; $00ED7D | |
    LDX r_open_large_door_tiles.w + 20                                          ; $00ED80 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED83 | |
    LDX r_open_large_door_tiles.w + 22                                          ; $00ED86 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED89 | |
    LDX r_open_large_door_vram_addresses.w + 12                                 ; $00ED8C | |
    STX reg_ppu_vmadd                                                           ; $00ED8F | |
    LDX r_open_large_door_tiles.w + 24                                          ; $00ED92 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED95 | |
    LDX r_open_large_door_tiles.w + 26                                          ; $00ED98 | |
    STX reg_ppu_vmdatal_write                                                   ; $00ED9B | |
    LDX r_open_large_door_vram_addresses.w + 14                                 ; $00ED9E | |
    STX reg_ppu_vmadd                                                           ; $00EDA1 | |
    LDX r_open_large_door_tiles.w + 28                                          ; $00EDA4 | |
    STX reg_ppu_vmdatal_write                                                   ; $00EDA7 | |
    LDX r_open_large_door_tiles.w + 30                                          ; $00EDAA | |
    STX reg_ppu_vmdatal_write                                                   ; $00EDAD |/
    RTS                                                                         ; $00EDB0

; _decode_event_opcode_load_map ($00:EDB1)
;
; Handles the event opcode $FE, which loads a map. Overall, it is a five byte
; opcode. The first byte is always $FE. The second byte is the target map ID.
; $FB and above are special values that load the overworld, underworld and the
; moon. The third byte is the target X coordinate. For dungeon targets, the top
; two bits of the third byte are the direction to face. The fourth byte is the
; Y coordinate. The fifth byte is a set of flags. Bits 0-4 encode the target
; vehicle for outdoor maps. If the vehicle is the ship, bits 3 and 4 encode the
; direction. Bit 5 disables transition effects. Bit 6 disables airship
; activation effects. Bit 7 sets the plane map to 1 (to access underworld and
; moon maps).
_decode_event_opcode_load_map:
    LDA r_decode_event_bytes.w + 1,X                                            ; $00EDB1 |\
    CMP #MAP_ID_OVERWORLD                                                       ; $00EDB4 | | If the target map is one of the outdoor codes, branch there.
    BCS @outdoor                                                                ; $00EDB6 |/
    JSR _push_map_history                                                       ; $00EDB8 | Save the current map and coordinates to the map history.
    STZ r_vehicle.w                                                             ; $00EDBB | Set the vehicle to walking, as there are no vehicles in dungeons.
    LDA r_decode_event_bytes.w + 1,X                                            ; $00EDBE |\ Set the new map ID.
    STA r_map_id.w                                                              ; $00EDC1 |/
    LDA r_decode_event_bytes.w + 2,X                                            ; $00EDC4 |\
    AND #%00111111                                                              ; $00EDC7 | | Set the new X coordinate.
    STA r_current_coordinates.x.w                                               ; $00EDC9 |/
    LDA r_decode_event_bytes.w + 2,X                                            ; $00EDCC |\
    AND #%11000000                                                              ; $00EDCF | | Set the new direction.
    LSR A                                                                       ; $00EDD1 | |
    LSR A                                                                       ; $00EDD2 | |
    LSR A                                                                       ; $00EDD3 | |
    LSR A                                                                       ; $00EDD4 | |
    LSR A                                                                       ; $00EDD5 | |
    LSR A                                                                       ; $00EDD6 | |
    STA r_direction.w                                                           ; $00EDD7 |/
    LDA r_decode_event_bytes.w + 3,X                                            ; $00EDDA |\ Set the new Y coordinate.
    STA r_current_coordinates.y.w                                               ; $00EDDD |/
    LDA r_decode_event_bytes.w + 4,X                                            ; $00EDE0 |\
    AND #%00100000                                                              ; $00EDE3 | | Disable transition effects if bit 5 of the flags is set.
    BEQ +                                                                       ; $00EDE5 | |
    LDA #MAP_EFFECTS_FADE_ONLY                                                  ; $00EDE7 | |
    STA <r_change_map_area_arg_modify_effects                                   ; $00EDE9 |/
+   LDA r_decode_event_bytes.w + 4,X                                            ; $00EDEB |\
    BMI +                                                                       ; $00EDEE | | Set the map plane to bit 7 of the flags variable.
    LDA #MAP_PLANE_OVERWORLD                                                    ; $00EDF0 | |
    JMP ++                                                                      ; $00EDF2 | |
+   LDA #MAP_PLANE_UNDERWORLD_MOON                                              ; $00EDF5 | |
++  STA r_map_plane.w                                                           ; $00EDF7 |/
    LDA #MAP_AREA_DUNGEON                                                       ; $00EDFA | Set the map area to dungeon.
    JMP @next                                                                   ; $00EDFC | Skip to the next relevant code.
@outdoor:
    SEC                                                                         ; $00EDFF |\
    SBC #MAP_ID_OVERWORLD                                                       ; $00EE00 | | Determine the map area by subtracting the overworld value.
    PHA                                                                         ; $00EE02 |/
    LDA r_decode_event_bytes.w + 2,X                                            ; $00EE03 |\ Set the new X coordinate.
    STA r_current_coordinates.x.w                                               ; $00EE06 |/
    LDA r_decode_event_bytes.w + 3,X                                            ; $00EE09 |\ Set the new Y coordinate.
    STA r_current_coordinates.y.w                                               ; $00EE0C |/
    LDA r_decode_event_bytes.w + 4,X                                            ; $00EE0F |\
    AND #%01000000                                                              ; $00EE12 | | If bit 6 of the flags is set, disable airship activation effects.
    STA <r_disable_airship_activation_effects                                   ; $00EE14 |/
    LDA r_decode_event_bytes.w + 4,X                                            ; $00EE16 |\
    AND #%00100000                                                              ; $00EE19 | | If bit 5 of the flags is set, disable map transition effects.
    BEQ +                                                                       ; $00EE1B | |
    LDA #MAP_EFFECTS_FADE_ONLY.b                                                ; $00EE1D | |
    STA <r_change_map_area_arg_modify_effects                                   ; $00EE1F |/
+   LDA r_decode_event_bytes.w + 4,X                                            ; $00EE21 |\
    AND #%00011111                                                              ; $00EE24 | | If the target vehicle is the yellow chocobo, loads the new
    DEC A                                                                       ; $00EE26 | | coordinates from the first entry of the map history instead of
    BNE +                                                                       ; $00EE27 | | using the values in the data.
    LDA r_map_history.1.x.w                                                     ; $00EE29 | |
    STA r_current_coordinates.x.w                                               ; $00EE2C | | NOTE: This effectively means that the coordinates are ignored for
    LDA r_map_history.1.y.w                                                     ; $00EE2F | |       the yellow chocobo and allows one event to serve all
    STA r_current_coordinates.y.w                                               ; $00EE32 |/        chocobo forests.
+   LDX #$0000.w                                                                ; $00EE35 |\ Reset the map history index.
    STX r_map_history_index.w                                                   ; $00EE38 |/
    PLA                                                                         ; $00EE3B | Restore the map area to the accumulator.
@next:
    JSR _change_map_area                                                        ; $00EE3C | Change the map area to the new map area.
    LDA r_map_area.w                                                            ; $00EE3F |\
    CMP #MAP_AREA_DUNGEON                                                       ; $00EE42 | | If this is a dungeon, skip to near the end.
    BEQ @done                                                                   ; $00EE44 |/
    LDX <r_decode_event_index                                                   ; $00EE46 |\
    LDA r_decode_event_bytes.w + 4,X                                            ; $00EE48 | | If vehicle is set to walking, set the vehicle and movement speed
    AND #%00011111                                                              ; $00EE4B | | accordingly.
    BNE +                                                                       ; $00EE4D | |
    STZ r_vehicle.w                                                             ; $00EE4F | |
    STZ <r_movement_speed                                                       ; $00EE52 | |
    STZ <r_movement_frame_counter                                               ; $00EE54 | |
    JMP @done                                                                   ; $00EE56 |/
+   DEC A                                                                       ; $00EE59 |\
    BNE +                                                                       ; $00EE5A | | If yellow chocobo, ride the yellow chocobo.
    LDA #$01                                                                    ; $00EE5C | |
    STA r_yellow_chocobo_status.w                                               ; $00EE5E | |
    JSR _ride_yellow_chocobo                                                    ; $00EE61 | |
    JMP @done                                                                   ; $00EE64 |/
+   DEC A                                                                       ; $00EE67 |\
    BNE +                                                                       ; $00EE68 | | If black chocobo, ride the black chocobo.
    LDA #$01                                                                    ; $00EE6A | |
    STA r_black_chocobo_status.w                                                ; $00EE6C | |
    STZ r_black_chocobo_count.w                                                 ; $00EE6F | |
    JSR _ride_black_chocobo                                                     ; $00EE72 | |
    JMP @done                                                                   ; $00EE75 |/
+   DEC A                                                                       ; $00EE78 |\
    BNE +                                                                       ; $00EE79 | | If hovercraft, board the hovercraft.
    LDA #$01                                                                    ; $00EE7B | |
    STA r_hovercraft_status.w                                                   ; $00EE7D | |
    JSR _board_hovercraft                                                       ; $00EE80 | |
    JMP @done                                                                   ; $00EE83 |/
+   DEC A                                                                       ; $00EE86 |\
    BNE +                                                                       ; $00EE87 | | If the Enterprise, board the Enterprise.
    LDA #$01                                                                    ; $00EE89 | |
    STA r_enterprise_status.w                                                   ; $00EE8B | |
    JSR _board_enterprise                                                       ; $00EE8E | |
    JMP @done                                                                   ; $00EE91 |/
+   DEC A                                                                       ; $00EE94 |\
    BNE +                                                                       ; $00EE95 | | If the Falcon, board the Falcon.
    LDA #$01                                                                    ; $00EE97 | |
    STA r_falcon_status.w                                                       ; $00EE99 | |
    JSR _board_falcon                                                           ; $00EE9C | |
    JMP @done                                                                   ; $00EE9F |/
+   DEC A                                                                       ; $00EEA2 |\
    BNE +                                                                       ; $00EEA3 | | If the Big Whale, activate the Big Whale.
    LDA #$01                                                                    ; $00EEA5 | |
    STA r_big_whale_status.w                                                    ; $00EEA7 | |
    JSR _activate_big_whale                                                     ; $00EEAA | |
    JMP @done                                                                   ; $00EEAD |/
+   LDA #$01                                                                    ; $00EEB0 |\
    STA r_ship_status.w                                                         ; $00EEB2 | | If the ship, set the direction to bits 3 and 4 of the flags
    LDX <r_decode_event_index                                                   ; $00EEB5 | | variable and then board the ship.
    LDA r_decode_event_bytes.w + 4,X                                            ; $00EEB7 | |
    AND #%00011000                                                              ; $00EEBA | |
    LSR A                                                                       ; $00EEBC | |
    LSR A                                                                       ; $00EEBD | |
    LSR A                                                                       ; $00EEBE | |
    STA r_direction.w                                                           ; $00EEBF | |
    JSR _board_ship                                                             ; $00EEC2 |/
@done:
    STZ <r_transition_index                                                     ; $00EEC5 | Zero the transition index.
    STZ <r_map_frame_counter                                                    ; $00EEC7 | Zero the map frame counter.
    STZ <r_movement_frame_counter                                               ; $00EEC9 | Zero the movement frame counter.
    LDA #%10000001                                                              ; $00EECB |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00EECD |/
    JSR _do_tile_animations                                                     ; $00EED0 | Do any tile animations.
    CLI                                                                         ; $00EED3 | Enable interrupts.
    LDX <r_decode_event_index                                                   ; $00EED4 |\
    INX                                                                         ; $00EED6 | | Increment the event index by four.
    INX                                                                         ; $00EED7 | |
    INX                                                                         ; $00EED8 | |
    INX                                                                         ; $00EED9 | |
    STX <r_decode_event_index                                                   ; $00EEDA |/
    JMP _decode_event_opcode_done                                               ; $00EEDC

; _change_map_area ($00:EEDF)
;
; Changes the current map area to the parameter passed in the accumulator. If
; $06CA is non-zero, transition effects are disabled. Otherwise, it will tell
; the NMI and IRQ handlers to render the transition effects. Note that even if
; effects are disabled, it will always fade the PPU before doing the change.
_change_map_area:
    PHA                                                                         ; $00EEDF | Save the parameter currently in the accumulator.
    LDA <r_change_map_area_arg_modify_effects                                   ; $00EEE0 |\
    BNE +                                                                       ; $00EEE2 | | If effects are enabled, draw the out transition.
    JSR _do_out_transition                                                      ; $00EEE4 | |
    JMP ++                                                                      ; $00EEE7 |/
+   LDA <r_ppu_brightness                                                       ; $00EEEA |\
    BEQ ++                                                                      ; $00EEEC | | Otherwise, fade the PPU out if the brightness is not already zero.
    LDA #$00.b                                                                  ; $00EEEE | |
    JSR _ppu_fade_out                                                           ; $00EEF0 |/
++  PLA                                                                         ; $00EEF3 |\ Set the new map area.
    STA r_map_area.w                                                            ; $00EEF4 |/
    BNE +                                                                       ; $00EEF7 |\
    JSR _change_map_overworld                                                   ; $00EEF9 | | Change to the overworld if the parameter is set to zero.
    JMP ++                                                                      ; $00EEFC |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $00EEFF |\
    BNE +                                                                       ; $00EF01 | | Change to the underworld if the parameter is set to one.
    JSR _change_map_underworld                                                  ; $00EF03 | |
    JMP ++                                                                      ; $00EF06 |/
+   CMP #MAP_AREA_MOON.b                                                        ; $00EF09 |\
    BNE +                                                                       ; $00EF0B | | Change to the moon if the parameter is set to two.
    JSR _change_map_moon                                                        ; $00EF0D | |
    JMP ++                                                                      ; $00EF10 |/
+   JSR _change_map_dungeon                                                     ; $00EF13 | Otherwise, change to a dungeon map.
++  LDA <r_change_map_area_arg_modify_effects                                   ; $00EF16 |\
    BNE +                                                                       ; $00EF18 | | If effects are enabled, draw the in transition.
    JSR _do_in_transition                                                       ; $00EF1A | |
    JMP ++                                                                      ; $00EF1D |/
+   INC <r_change_map_area_arg_modify_effects                                   ; $00EF20 | Otherwise, increment the value to force the NMI to fade the PPU in.
++  LDA #%10000001.b                                                            ; $00EF22 |\ Enable NMI and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $00EF24 |/
    RTS                                                                         ; $00EF27

; _decode_event_opcode_show_message_bank_0 ($00:EF28)
;
; Handles opcode $EF, which shows the message indicated by the following byte
; from the map-specific dialog. The displayed message will be specific for the
; currently loaded map, unlike other dialog banks.
_decode_event_opcode_show_message_bank_0:
    JSR _decode_event_get_next_byte                                             ; $00EF28 |\ Get the desired message number from the next byte.
    STA <r_show_message_id                                                      ; $00EF2B |/
    JSR _load_message_bank_0_offset                                             ; $00EF2D | Load the offset for the desired message.
    JSR _show_upper_dialog                                                      ; $00EF30 | Show the dialog.
    JSR _close_upper_dialog                                                     ; $00EF33 | Close the dialog.
    JMP _decode_event_opcode_done                                               ; $00EF36

; _decode_event_opcode_show_message_npc ($00:EF39)
;
; Handles opcode $EE, which shows the message indicated by the following byte
; from the loaded NPC-specific message IDs. These message IDs reference the
; map-specific dialog in bank 0.
_decode_event_opcode_show_message_npc:
    JSR _decode_event_get_next_byte                                             ; $00EF39 |\
    TAX                                                                         ; $00EF3C | | Set the message ID from the NPC-specific IDs.
    LDA r_npc_message_ids.w,X                                                   ; $00EF3D | |
    STA <r_show_message_id                                                      ; $00EF40 |/
    JSR _load_message_bank_0_offset                                             ; $00EF42 | Load the offset for the message.
    JSR _show_upper_dialog                                                      ; $00EF45 | Show the dialog.
    JSR _close_upper_dialog                                                     ; $00EF48 | Close the dialog.
    JMP _decode_event_opcode_done                                               ; $00EF4B

; _decode_event_opcode_show_message_bank_1_lo ($00:EF4E)
;
; Handles opcode $F0, and shows the message indicated by the following byte from
; the lower half of bank 1 of dialog.
_decode_event_opcode_show_message_bank_1_lo:
    JSR _decode_event_get_next_byte                                             ; $00EF4E |\ Fetch the next byte and save that as the message ID.
    STA <r_show_message_id                                                      ; $00EF51 |/
    JSR _load_message_bank_1_lo_offset                                          ; $00EF53 | Load the message's bank and offset number.
    JSR _show_upper_dialog                                                      ; $00EF56 | Show the dialog.
    JSR _close_upper_dialog                                                     ; $00EF59 | Close the dialog.
    JMP _decode_event_opcode_done                                               ; $00EF5C

; _decode_event_opcode_show_message_bank_1_hi ($00:EF5F)
;
; Handles opcode $F1, and shows the message indicated by the following byte from
; the upper half of bank 1 of dialog.
_decode_event_opcode_show_message_bank_1_hi:
    JSR _decode_event_get_next_byte                                             ; $00EF5F |\ Fetch the next byte and save that as the message ID.
    STA <r_show_message_id                                                      ; $00EF62 |/
    JSR _load_message_bank_1_hi_offset                                          ; $00EF64 | Load the message's bank and offset number.
    JSR _show_upper_dialog                                                      ; $00EF67 | Show the dialog.
    JSR _close_upper_dialog                                                     ; $00EF6A | Close the dialog.
    JMP _decode_event_opcode_done                                               ; $00EF6D

; _decode_event_opcode_show_message_bank_2 ($00:EF70)
;
; Handles opcode $F6, and shows the message indicated by the following byte from
; bank 2 of dialog.
_decode_event_opcode_show_message_bank_2:
    JSR _decode_event_get_next_byte                                             ; $00EF70 |\ Fetch the next byte and save that as the message ID.
    STA <r_show_message_id                                                      ; $00EF73 |/
    JSR _load_message_bank_2_offset                                             ; $00EF75 | Load the message's bank and offset number.
    JSR _show_upper_dialog                                                      ; $00EF78 | Show the dialog.
    JSR _close_upper_dialog                                                     ; $00EF7B | Close the dialog.
    JMP _decode_event_opcode_done                                               ; $00EF7E

; _decode_event_opcode_set_plot_flag ($00:EF81)
;
; Handles opcode $F2, which sets the plot flag indicated by the parameter byte.
_decode_event_opcode_set_plot_flag:
    JSR _decode_event_get_next_byte                                             ; $00EF81 |\ Set the plot flag indicated by the parameter byte.
    JSR _set_plot_flag                                                          ; $00EF84 |/
    JMP _decode_event_opcode_done                                               ; $00EF87

; _decode_event_opcode_reset_plot_flag ($00:EF8A)
;
; Handles opcode $F3, which resets the plot flag indicated by the parameter
; byte.
_decode_event_opcode_reset_plot_flag:
    JSR _decode_event_get_next_byte                                             ; $00EF8A |\ Reset the plot flag indicated by the parameter byte.
    JSR _reset_plot_flag                                                        ; $00EF8D |/
    JMP _decode_event_opcode_done                                               ; $00EF90

; _decode_event_opcode_activate_npc ($00:EF93)
;
; Handles opcode $F4, which activates the NPC indicated by the following byte.
_decode_event_opcode_activate_npc:
    JSR _decode_event_get_next_byte                                             ; $00EF93 |\ Activate the NPC given by the parameter.
    JSR _activate_npc                                                           ; $00EF96 |/
    JMP _decode_event_opcode_done                                               ; $00EF99

; _decode_event_opcode_deactivate_npc ($00:EF9C)
;
; Handles opcode $F5, which deactivates the NPC indicated by the following byte.
_decode_event_opcode_deactivate_npc:
    JSR _decode_event_get_next_byte                                             ; $00EF9C |\ Deactivate the NPC indicated by the parameter byte.
    JSR _deactivate_npc                                                         ; $00EF9F |/
    JMP _decode_event_opcode_done                                               ; $00EFA2

; _execute_conditional_event ($00:EFA5)
;
; Given the ID for a conditional event in the accumulator, determines which
; event matches the current plot flags and executes that event.
_execute_conditional_event:
    STZ <r_generic_tmp_index.hi                                                 ; $00EFA5 |\
    ASL A                                                                       ; $00EFA7 | | Load the offset for the conditional event beyond the one passed
    ROL <r_generic_tmp_index.hi                                                 ; $00EFA8 | | in the accumulator and save it to a temporary variable.
    STA <r_generic_tmp_index.lo                                                 ; $00EFAA | |
    LDX <r_generic_tmp_index                                                    ; $00EFAC | |
    LDA bank12.conditional_event_offset_data.l + 2 + 0,X                        ; $00EFAE | |
    STA <r_generic_tmp_index_2.lo                                               ; $00EFB2 | |
    LDA bank12.conditional_event_offset_data.l + 2 + 1,X                        ; $00EFB4 | |
    STA <r_generic_tmp_index_2.hi                                               ; $00EFB8 |/
    LDX <r_generic_tmp_index_2                                                  ; $00EFBA |\
    DEX                                                                         ; $00EFBC | | Scan backwards from there to determine the offset for the default
-   LDA bank12.conditional_event_data.l,X                                       ; $00EFBD | | event and store the offset for later use.
    CMP #CONDITIONAL_EVENT_DELIMITER.b                                          ; $00EFC1 | |
    BEQ +                                                                       ; $00EFC3 | |
    DEX                                                                         ; $00EFC5 | |
    JMP -                                                                       ; $00EFC6 | |
+   INX                                                                         ; $00EFC9 | |
    STX r_conditional_event_default_offset.w                                    ; $00EFCA |/
    LDX <r_generic_tmp_index                                                    ; $00EFCD |\
    LDA bank12.conditional_event_offset_data.l + 0,X                            ; $00EFCF | | Load the offset to the data for the passed conditional event ID.
    STA <r_conditional_event_offset.lo                                          ; $00EFD3 | |
    LDA bank12.conditional_event_offset_data.l + 1,X                            ; $00EFD5 | |
    STA <r_conditional_event_offset.hi                                          ; $00EFD9 |/
@loop_start:
    LDX <r_conditional_event_offset                                             ; $00EFDB |\
    LDA bank12.conditional_event_data.l,X                                       ; $00EFDD | | If encountering the delimiter, branch to the done code, as all
    CMP #CONDITIONAL_EVENT_DELIMITER.b                                          ; $00EFE1 | | conditions must have passed.
    BNE +                                                                       ; $00EFE3 | |
    JMP @done                                                                   ; $00EFE5 |/
+   CMP #CONDITIONAL_EVENT_PLOT_FLAG_ON.b                                       ; $00EFE8 |\
    BNE +                                                                       ; $00EFEA | | If encountering the byte that changes the plot flag to check for
    LDX <r_conditional_event_offset                                             ; $00EFEC | | it being on, read the plot flag and if the flag is off, branch to
    INX                                                                         ; $00EFEE | | the not matched code.
    STX <r_conditional_event_offset                                             ; $00EFEF | |
    LDA bank12.conditional_event_data.l,X                                       ; $00EFF1 | |
    JSR _get_plot_flag                                                          ; $00EFF5 | |
    CMP #0.b                                                                    ; $00EFF8 | |
    BEQ @not_matched                                                            ; $00EFFA | |
    JMP ++                                                                      ; $00EFFC |/
+   JSR _get_plot_flag                                                          ; $00EFFF |\
    CMP #0.b                                                                    ; $00F002 | | Otherwise, branch to not matched if the plot flag is on.
    BNE @not_matched                                                            ; $00F004 |/
++  LDX <r_conditional_event_offset                                             ; $00F006 |\
    INX                                                                         ; $00F008 | | If matched, increment the event offset and jump back to the start
    STX <r_conditional_event_offset                                             ; $00F009 | | of the loop.
    JMP @loop_start                                                             ; $00F00B |/
@not_matched:
    LDX <r_conditional_event_offset                                             ; $00F00E |\
-   INX                                                                         ; $00F010 | | Increment the conditional event offset until encountering the next
    LDA bank12.conditional_event_data.l,X                                       ; $00F011 | | delimiter, and then increment once more to point to the event ID.
    CMP #CONDITIONAL_EVENT_DELIMITER.b                                          ; $00F015 | | If this is the done offset, branch to the done code.
    BNE -                                                                       ; $00F017 | |
    INX                                                                         ; $00F019 | | NOTE: The done code expects the offset to point at the delimiter,
    STX <r_conditional_event_offset                                             ; $00F01A | |       so this probably doesn't work as expected. It only matters
    LDX <r_conditional_event_offset                                             ; $00F01C | |       if a conditional event doesn't have an unconditional
    CPX r_conditional_event_default_offset.w                                    ; $00F01E | |       default.
    BEQ @done                                                                   ; $00F021 |/
    LDX <r_conditional_event_offset                                             ; $00F023 |\
    INX                                                                         ; $00F025 | | Increment the offset and branch back to the start of the loop to
    STX <r_conditional_event_offset                                             ; $00F026 | | check the next conditions.
    JMP @loop_start                                                             ; $00F028 |/
@done:
    LDA #1.b                                                                    ; $00F02B |\ Set the flag to indicate a cutscene is active.
    STA <r_cutscene_active                                                      ; $00F02D |/
    STZ <r_movement_direction                                                   ; $00F02F | Reset the player's movement direction to none.
    LDX <r_conditional_event_offset                                             ; $00F031 |\
    LDA bank12.conditional_event_data.l + 1,X                                   ; $00F033 | | Execute the appropriate event.
    BEQ +                                                                       ; $00F037 | |
    JSR _decode_event                                                           ; $00F039 |/
+   STZ <r_cutscene_active                                                      ; $00F03C | Reset the cutscene active flag.
    RTS                                                                         ; $00F03E

; _check_npc_event ($00:F03F)
;
; Given an 8-bit NPC index in the accumulator, determines the correct event to
; execute for that NPC and executes it. (The true NPC index is determined based
; on the map specifying high NPCs or the map plane being non-zero.)
_check_npc_event:
    STZ <r_generic_tmp_index.hi                                                 ; $00F03F |\
    ASL A                                                                       ; $00F041 | | Calculate the offset to find this NPC's pointer. The NPC is
    ROL <r_generic_tmp_index.hi                                                 ; $00F042 | | multiplied by two. If the map properties specify to use high NPCs
    STA <r_generic_tmp_index.lo                                                 ; $00F044 | | or if the map plane is non-zero, increment the high byte by two
    LDA r_map_properties.bank_flags.w                                           ; $00F046 | | to shift to the high NPCs.
    BMI +                                                                       ; $00F049 | |
    LDA r_map_plane.w                                                           ; $00F04B | |
    BEQ ++                                                                      ; $00F04E | |
+   INC <r_generic_tmp_index.hi                                                 ; $00F050 | |
    INC <r_generic_tmp_index.hi                                                 ; $00F052 |/
++  LDX <r_generic_tmp_index                                                    ; $00F054 |\
    LDA bank13.npc_event_offset_data.l + 2,X                                    ; $00F056 | | Calculate the event data offset for the next NPC, in order to scan
    STA <r_generic_tmp_index_2.lo                                               ; $00F05A | | backward from there.
    LDA bank13.npc_event_offset_data.l + 3,X                                    ; $00F05C | |
    STA <r_generic_tmp_index_2.hi                                               ; $00F060 |/
    LDX <r_generic_tmp_index_2                                                  ; $00F062 |\
    DEX                                                                         ; $00F064 | | Scan backwards in the data until finding the last $FF.
-   LDA bank13.npc_event_data.l,X                                               ; $00F065 | |
    CMP #NPC_EVENT_DELIMITER.b                                                  ; $00F069 | |
    BEQ +                                                                       ; $00F06B | |
    DEX                                                                         ; $00F06D | |
    JMP -                                                                       ; $00F06E |/
+   INX                                                                         ; $00F071 |\ Increment the X register to the following event code and set that
    STX r_npc_default_event_offset.w                                            ; $00F072 |/ offset as the default offset.
    INX                                                                         ; $00F075 |\
    LDY #0.w                                                                    ; $00F076 | | Copy the NPC's specific message IDs to an array in memory.
-   CPX <r_generic_tmp_index_2                                                  ; $00F079 | |
    BEQ +                                                                       ; $00F07B | |
    LDA bank13.npc_event_data.l,X                                               ; $00F07D | |
    STA r_npc_message_ids.w,Y                                                   ; $00F081 | |
    INY                                                                         ; $00F084 | |
    INX                                                                         ; $00F085 | |
    JMP -                                                                       ; $00F086 |/
+   LDX <r_generic_tmp_index                                                    ; $00F089 |\
    LDA bank13.npc_event_offset_data.l + 0,X                                    ; $00F08B | | Store the base event offset for this NPC into a temporary
    STA <r_npc_event_offset.lo                                                  ; $00F08F | | variable.
    LDA bank13.npc_event_offset_data.l + 1,X                                    ; $00F091 | |
    STA <r_npc_event_offset.hi                                                  ; $00F095 |/
@loop_start:
    LDX <r_npc_event_offset                                                     ; $00F097 |\
    LDA bank13.npc_event_data.l,X                                               ; $00F099 | | If encountering $FF, branch to the end.
    CMP #NPC_EVENT_DELIMITER.b                                                  ; $00F09D | |
    BNE +                                                                       ; $00F09F | |
    JMP @done                                                                   ; $00F0A1 |/
+   CMP #NPC_EVENT_PLOT_FLAG_ON.b                                               ; $00F0A4 |\
    BNE +                                                                       ; $00F0A6 | | If the current byte is $FE, increment the offset to move to the
    LDX <r_npc_event_offset                                                     ; $00F0A8 | | next byte, and then read that value and check that plot flag. If
    INX                                                                         ; $00F0AA | | the plot flag is off, branch to the not matched code. Otherwise,
    STX <r_npc_event_offset                                                     ; $00F0AB | | branch to go to the next byte and loop again, which will execute
    LDA bank13.npc_event_data.l,X                                               ; $00F0AD | | that event.
    JSR _get_plot_flag                                                          ; $00F0B1 | |
    CMP #0.b                                                                    ; $00F0B4 | |
    BEQ @not_matched                                                            ; $00F0B6 | |
    JMP ++                                                                      ; $00F0B8 |/
+   JSR _get_plot_flag                                                          ; $00F0BB |\
    CMP #0.b                                                                    ; $00F0BE | | Otherwise, treat the byte as a plot flag and check for it being
    BNE @not_matched                                                            ; $00F0C0 |/  off, instead of on.
++  LDX <r_npc_event_offset                                                     ; $00F0C2 |\
    INX                                                                         ; $00F0C4 | | If the plot flag matched, increment the event offset to the
    STX <r_npc_event_offset                                                     ; $00F0C5 | | dividing $FF, and branch back to handle that and the event.
    JMP @loop_start                                                             ; $00F0C7 |/
@not_matched:
    JSR _npc_event_next_delimiter                                               ; $00F0CA |\
    LDX <r_npc_event_offset                                                     ; $00F0CD | | Scan past the $FF to the event byte. If this byte is the default
    CPX r_npc_default_event_offset.w                                            ; $00F0CF | | offset, branch to the done code. Otherwise, increment the offset
    BEQ @done                                                                   ; $00F0D2 | | to point to the next condition and loop back.
    LDX <r_npc_event_offset                                                     ; $00F0D4 | |
    INX                                                                         ; $00F0D6 | | NOTE: The done code expects the offset to point to the byte before
    STX <r_npc_event_offset                                                     ; $00F0D7 | |       the desired event, so I don't think this would work.
    JMP @loop_start                                                             ; $00F0D9 |/        Thankfully, it should only trigger if the default event also
@done:                                                                          ;                   has a condition.
    LDA #1.b                                                                    ; $00F0DC |\ Set the cutscene active flag.
    STA <r_cutscene_active                                                      ; $00F0DE |/
    STZ <r_movement_direction                                                   ; $00F0E0 | Set the movement direction to none.
    LDX <r_npc_event_offset                                                     ; $00F0E2 |\
    LDA bank13.npc_event_data.l + 1,X                                           ; $00F0E4 | | Read the following byte and if it's non-zero, execute it as an
    BEQ +                                                                       ; $00F0E8 | | event.
    JSR _decode_event                                                           ; $00F0EA |/
+   STZ <r_cutscene_active                                                      ; $00F0ED | Reset the cutscene active flag.
    RTS                                                                         ; $00F0EF

; _npc_event_next_delimiter ($00:F0F0)
;
; Updates the NPC event offset at $BC to point past the next delimiter.
_npc_event_next_delimiter:
    LDX <r_npc_event_offset                                                     ; $00F0F0 |\
-   INX                                                                         ; $00F0F2 | | Add to the NPC event offset until finding the next $FF delimiter.
    LDA bank13.npc_event_data.l,X                                               ; $00F0F3 | | Afterward, increment it by one to point to the next event byte.
    CMP #NPC_EVENT_DELIMITER.b                                                  ; $00F0F7 | |
    BNE -                                                                       ; $00F0F9 | |
    INX                                                                         ; $00F0FB | |
    STX <r_npc_event_offset                                                     ; $00F0FC |/
    RTS                                                                         ; $00F0FE

; _reset_plot_flag ($00:F0FF)
;
; Given a plot flag number in the accumulator, resets that plot flag.
_reset_plot_flag:
    JSR _get_plot_flag_index                                                    ; $00F0FF | Get the index and bit for the desired plot flag.
    LDA #%11111110.b                                                            ; $00F102 | Initialize the accumulator to mask out the lowest bit.
-   CPY #0.w                                                                    ; $00F104 |\
    BEQ +                                                                       ; $00F107 | | Given the returned bit number in the Y register, loop that number
    SEC                                                                         ; $00F109 | | of times, shifting a 1 into the accumulator, which essentially
    ROL A                                                                       ; $00F10A | | moves the zero to the position indicated by the desired bit.
    DEY                                                                         ; $00F10B | |
    JMP -                                                                       ; $00F10C |/
+   LDX <r_generic_tmp_index                                                    ; $00F10F | Load the returned index into the X register.
    AND r_plot_flags.w,X                                                        ; $00F111 |\ Unset the given plot flag.
    STA r_plot_flags.w,X                                                        ; $00F114 |/
    RTS                                                                         ; $00F117

; _deactivate_npc ($00:F118)
;
; Given an NPC number in the accumulator, deactivates that NPC by setting its
; status bit in the array at $12E0 to zero.
_deactivate_npc:
    JSR _get_npc_status_index                                                   ; $00F118 | Get the index and bit for the desired NPC status.
    LDA #%11111110.b                                                            ; $00F11B | Initialize the accumulator to mask out the lowest bit.
-   CPY #0.w                                                                    ; $00F11D |\
    BEQ +                                                                       ; $00F120 | | Given the returned bit number in the Y register, loop that number
    SEC                                                                         ; $00F122 | | of times, shifting a 1 into the accumulator, which essentially
    ROL A                                                                       ; $00F123 | | moves the zero to the position indicated by the desired bit.
    DEY                                                                         ; $00F124 | |
    JMP -                                                                       ; $00F125 |/
+   LDX <r_generic_tmp_index                                                    ; $00F128 | Load the returned index into the X register.
    AND r_npc_status.l & $FFFF,X                                                ; $00F12A |\ Unset the given NPC's status flag.
    STA r_npc_status.l & $FFFF,X                                                ; $00F12E |/
    RTS                                                                         ; $00F132

; _set_plot_flag ($00:F133)
;
; Given a plot flag number in the accumulator, sets that plot flag by setting
; the corresponding bit in the array at $1280 to one.
_set_plot_flag:
    JSR _get_plot_flag_index                                                    ; $00F133 | Get the index and bit for the desired plot flag.
    LDA #1.b                                                                    ; $00F136 |\
-   CPY #0.w                                                                    ; $00F138 | | Shift a one into a byte a number of times equal to the bit number
    BEQ +                                                                       ; $00F13B | | (plus one) to create an OR mask to set the bit in question.
    ASL A                                                                       ; $00F13D | |
    DEY                                                                         ; $00F13E | |
    JMP -                                                                       ; $00F13F |/
+   LDX <r_generic_tmp_index                                                    ; $00F142 |\
    ORA r_plot_flags.w,X                                                        ; $00F144 | | Set the plot flag.
    STA r_plot_flags.w,X                                                        ; $00F147 |/
    RTS                                                                         ; $00F14A

; _activate_npc ($00:F14B)
;
; Given an NPC number in the accumulator, activates that NPC by setting its
; status bit in the array at $12E0 to one.
_activate_npc:
    JSR _get_npc_status_index                                                   ; $00F14B | Get the index and bit for the passed NPC.
    LDA #1.b                                                                    ; $00F14E |\
-   CPY #0.w                                                                    ; $00F150 | | Shift a one into a byte a number of times equal to the bit number
    BEQ +                                                                       ; $00F153 | | (plus one) to create an OR mask to set the bit in question.
    ASL A                                                                       ; $00F155 | |
    DEY                                                                         ; $00F156 | |
    JMP -                                                                       ; $00F157 |/
+   LDX <r_generic_tmp_index                                                    ; $00F15A |\
    ORA r_npc_status.l & $FFFF,X                                                ; $00F15C | | Set the NPC's status bit to activate that NPC.
    STA r_npc_status.l & $FFFF,X                                                ; $00F160 |/
    RTS                                                                         ; $00F164

; _get_plot_flag ($00:F165)
;
; Given the number of a plot flag in the accumulator, returns the current value
; of that flag in the accumulator.
_get_plot_flag:
    PHX                                                                         ; $00F165 | Save the value in the X register.
    JSR _get_plot_flag_index                                                    ; $00F166 | Get the index and bit number of the requested plot flag.
    LDX <r_get_plot_flag_index_result                                           ; $00F169 |\ Load the byte of the requested plot flag.
    LDA r_plot_flags.w,X                                                        ; $00F16B |/
-   CPY #$0000.w                                                                ; $00F16E |\
    BEQ +                                                                       ; $00F171 | | Shift bits out of the flag until the correct bit number
    LSR A                                                                       ; $00F173 | | is reached.
    DEY                                                                         ; $00F174 | |
    JMP -                                                                       ; $00F175 |/
+   LSR A                                                                       ; $00F178 |\
    LDA #$00.b                                                                  ; $00F179 | | Put the value of the plot flag in the accumulator.
    ADC #$00.b                                                                  ; $00F17B |/
    PLX                                                                         ; $00F17D | Restore the value of the X register.
    RTS                                                                         ; $00F17E

; _get_plot_flag_index ($00:F17F)
;
; Given a plot flag number in the accumulator, returns the index to the byte in
; the plot flag array at $063D, and returns the bit number of the flag in the Y
; register.
_get_plot_flag_index:
    PHA                                                                         ; $00F17F | Save the accumulator for later use.
    LSR A                                                                       ; $00F180 |\
    LSR A                                                                       ; $00F181 | | Put the value of the three lowest bits in the Y register and put
    LSR A                                                                       ; $00F182 | | the five higher bits in $063D, shifted right three times.
    STA <r_get_plot_flag_index_result_lo                                        ; $00F183 | |
    STZ <r_get_plot_flag_index_result_hi                                        ; $00F185 | |
    PLA                                                                         ; $00F187 | |
    AND #%00000111.b                                                            ; $00F188 | |
    TAY                                                                         ; $00F18A |/
    RTS                                                                         ; $00F18B

; _get_npc_status_index ($00:F18C)
;
; Given an NPC number in the accumulator, returns the index to the byte in the
; NPC status array ($12E0) at $063D, and returns the bit number of that NPC in
; the Y register.
_get_npc_status_index:
    PHA                                                                         ; $00F18C | Preserve the passed value.
    LSR A                                                                       ; $00F18D |\
    LSR A                                                                       ; $00F18E | | Initially set the NPC status index to the passed NPC number
    LSR A                                                                       ; $00F18F | | divided by eight.
    STA <r_generic_tmp_index.lo                                                 ; $00F190 | |
    STZ <r_generic_tmp_index.hi                                                 ; $00F192 |/
    LDA r_map_properties.bank_flags.w                                           ; $00F194 |\
    BMI +                                                                       ; $00F197 | | If the high NPC bank flag is set on this map or if the map plane
    LDA r_map_plane.w                                                           ; $00F199 | | is greater than zero, increase the count by 32 to access the
    BEQ ++                                                                      ; $00F19C | | second bank of NPCs.
+   LDA <r_generic_tmp_index.lo                                                 ; $00F19E | |
    CLC                                                                         ; $00F1A0 | |
    ADC #$20.b                                                                  ; $00F1A1 | |
    STA <r_generic_tmp_index.lo                                                 ; $00F1A3 |/
++  PLA                                                                         ; $00F1A5 |\
    AND #%00000111.b                                                            ; $00F1A6 | | Set the Y register to the NPC index mod 8.
    TAY                                                                         ; $00F1A8 |/
    RTS                                                                         ; $00F1A9

; _calculate_perspective_data ($00:F1AA)
;
; Calculates data used for creating the perspective effect when flying the
; various airships. The base numbers used for the calculation are stored in ROM,
; but separate mode 7 parameters are calculated for each possible zoom level and
; stored in RAM.
_calculate_perspective_data:
    LDA #%00000000.b                                                            ; $00F1AA |\ Set the background mode to mode 0 with 8x8 tiles.
    STA reg_ppu_bgmode                                                          ; $00F1AC |/
    LDX #$0000.w                                                                ; $00F1AF |\
    STX r_calculate_perspective_data_scanline                                   ; $00F1B2 | | Initialize the three variables to zero.
    STX r_calculate_perspective_data_zoom                                       ; $00F1B4 | |
    STX r_calculate_perspective_data_offset                                     ; $00F1B6 |/
-   PHX                                                                         ; $00F1B8 |\
    LDX r_calculate_perspective_data_scanline                                   ; $00F1B9 | | Load the next multiplier from ROM and increment the scanline used
    LDA bank14.airship_perspective_data.l,X                                     ; $00F1BB | | as an index into that data.
    INX                                                                         ; $00F1BF | |
    STX r_calculate_perspective_data_scanline                                   ; $00F1C0 | |
    PLX                                                                         ; $00F1C2 |/
    STA reg_ppu_m7a                                                             ; $00F1C3 |\
    STZ reg_ppu_m7a                                                             ; $00F1C6 | | The base zoom factor is 256 (which corresponds to no zooming). The
    LDA r_calculate_perspective_data_zoom                                       ; $00F1C9 | | multiplier that was just read is (through some roundabout math)
    STA reg_ppu_m7b                                                             ; $00F1CB | | divided by 4 and then multiplied by the zoom level (in a range
    STA reg_ppu_m7b                                                             ; $00F1CE | | from 0 to 16, which isn't the range used by the actual game).
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F1D1 | | This result is then added to the base zoom factor to get the
    LDA reg_ppu_mpym                                                            ; $00F1D3 | | actual zoom factor for this scanline. For the regular airships,
    ASL A                                                                       ; $00F1D6 | | this ultimately ends up ranging from 384 to 768 at max zoom.
    ASL A                                                                       ; $00F1D7 | |
    ASL A                                                                       ; $00F1D8 | | The calculated value is stored at the next index in RAM.
    CLC                                                                         ; $00F1D9 | |
    ADC #$0100                                                                  ; $00F1DA | |
    STA r_airship_perspective_data.l,X                                          ; $00F1DD | |
    LDA #$0000                                                                  ; $00F1E1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F1E4 |/
    INX                                                                         ; $00F1E6 |\
    INX                                                                         ; $00F1E7 | | Increment X by the two bytes we just wrote. Repeat this loop until
    LDY r_calculate_perspective_data_scanline                                   ; $00F1E8 | | 240 bytes have been read. BUG: It seems like it should actually
    CPY #$00F0.w                                                                ; $00F1EA | | read 224 bytes, but who knows.
    BNE -                                                                       ; $00F1ED |/
    JSR _calculate_perspective_data_update_offset                               ; $00F1EF |\
    LDA r_calculate_perspective_data_zoom                                       ; $00F1F2 | | Update the offsets for the next zoom level and keep going until
    CMP #$80                                                                    ; $00F1F4 | | 16 levels have been calculated.
    BNE -                                                                       ; $00F1F6 |/
-   PHX                                                                         ; $00F1F8 |\
    LDX r_calculate_perspective_data_scanline                                   ; $00F1F9 | | Get the next value from ROM.
    LDA bank14.airship_perspective_data.l,X                                     ; $00F1FB | |
    INX                                                                         ; $00F1FF | |
    STX r_calculate_perspective_data_scanline                                   ; $00F200 | |
    PLX                                                                         ; $00F202 |/
    STZ r_calculate_perspective_data_tmp                                        ; $00F203 |\
    ASL A                                                                       ; $00F205 | | This performs the same calculation for the 17th zoom level, but in
    ROL r_calculate_perspective_data_tmp                                        ; $00F206 | | a slightly different way for unknown reasons. The result is the
    ASL A                                                                       ; $00F208 | | same and stored in the next location in RAM.
    ROL r_calculate_perspective_data_tmp                                        ; $00F209 | |
    STA r_airship_perspective_data.l,X                                          ; $00F20B | |
    LDA r_calculate_perspective_data_tmp                                        ; $00F20F | |
    INC A                                                                       ; $00F211 | |
    STA r_airship_perspective_data.l + 1,X                                      ; $00F212 |/
    INX                                                                         ; $00F216 |\
    INX                                                                         ; $00F217 | | Repeat until data for all the scanlines has been calculated. This
    LDY r_calculate_perspective_data_scanline                                   ; $00F218 | | is another case where it does 240 instead of 224 for some reason.
    CPY #$00F0.w                                                                ; $00F21A | |
    BNE -                                                                       ; $00F21D |/
    LDX #$0000.w                                                                ; $00F21F |\
    STX r_calculate_perspective_data_scanline                                   ; $00F222 | | Zero out the variables for the next round.
    STX r_calculate_perspective_data_zoom                                       ; $00F224 | |
    STX r_calculate_perspective_data_offset                                     ; $00F226 |/
-   PHX                                                                         ; $00F228 |\
    LDX r_calculate_perspective_data_scanline                                   ; $00F229 | | Repeat the exact same process as above except with the data for
    LDA bank14.big_whale_perspective_data.l,X                                   ; $00F22B | | the Big Whale instead of the other airships.
    INX                                                                         ; $00F22F | |
    STX r_calculate_perspective_data_scanline                                   ; $00F230 | |
    PLX                                                                         ; $00F232 | |
    STA reg_ppu_m7a                                                             ; $00F233 | |
    STZ reg_ppu_m7a                                                             ; $00F236 | |
    LDA r_calculate_perspective_data_zoom                                       ; $00F239 | |
    STA reg_ppu_m7b                                                             ; $00F23B | |
    STA reg_ppu_m7b                                                             ; $00F23E | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F241 | |
    LDA reg_ppu_mpym                                                            ; $00F243 | |
    ASL A                                                                       ; $00F246 | |
    ASL A                                                                       ; $00F247 | |
    ASL A                                                                       ; $00F248 | |
    CLC                                                                         ; $00F249 | |
    ADC #$0100                                                                  ; $00F24A | |
    STA r_big_whale_perspective_data.l,X                                        ; $00F24D | |
    LDA #$0000                                                                  ; $00F251 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F254 | |
    INX                                                                         ; $00F256 | |
    INX                                                                         ; $00F257 | |
    LDY r_calculate_perspective_data_scanline                                   ; $00F258 | |
    CPY #$00F0.w                                                                ; $00F25A | |
    BNE -                                                                       ; $00F25D | |
    JSR _calculate_perspective_data_update_offset                               ; $00F25F | |
    LDA r_calculate_perspective_data_zoom                                       ; $00F262 | |
    CMP #$80                                                                    ; $00F264 | |
    BNE -                                                                       ; $00F266 | |
-   PHX                                                                         ; $00F268 | |
    LDX r_calculate_perspective_data_scanline                                   ; $00F269 | |
    LDA bank14.big_whale_perspective_data.l,X                                   ; $00F26B | |
    INX                                                                         ; $00F26F | |
    STX r_calculate_perspective_data_scanline                                   ; $00F270 | |
    PLX                                                                         ; $00F272 | |
    STZ r_calculate_perspective_data_tmp                                        ; $00F273 | |
    ASL A                                                                       ; $00F275 | |
    ROL r_calculate_perspective_data_tmp                                        ; $00F276 | |
    ASL A                                                                       ; $00F278 | |
    ROL r_calculate_perspective_data_tmp                                        ; $00F279 | |
    STA r_big_whale_perspective_data.l,X                                        ; $00F27B | |
    LDA r_calculate_perspective_data_tmp                                        ; $00F27F | |
    INC A                                                                       ; $00F281 | |
    STA r_big_whale_perspective_data.l + 1,X                                    ; $00F282 | |
    INX                                                                         ; $00F286 | |
    INX                                                                         ; $00F287 | |
    LDY r_calculate_perspective_data_scanline                                   ; $00F288 | |
    CPY #$00F0.w                                                                ; $00F28A | |
    BNE -                                                                       ; $00F28D |/
    RTS                                                                         ; $00F28F

; _calculate_perspective_data_update_offset ($00:F290)
;
; Called at the end of each loop in the preceding function to update the index
; and offset to the next value.
_calculate_perspective_data_update_offset:
    LDY #$0000.w                                                                ; $00F290 |\
    STY r_calculate_perspective_data_scanline                                   ; $00F293 |/ Set the Y index register to zero.
    LDA r_calculate_perspective_data_zoom                                       ; $00F295 |\
    CLC                                                                         ; $00F297 | | Add 8 to the zoom level.
    ADC #$08                                                                    ; $00F298 | |
    STA r_calculate_perspective_data_zoom                                       ; $00F29A |/
    STA r_calculate_perspective_data_offset_hi                                  ; $00F29C |\
    STZ r_calculate_perspective_data_offset_lo                                  ; $00F29E | | Set the new index to the zoom level times 64. This results in the
    LSR r_calculate_perspective_data_offset_hi                                  ; $00F2A0 | | total offset increasing by $200 every time the zoom level increases.
    ROR r_calculate_perspective_data_offset_lo                                  ; $00F2A2 | | For convenience, the zoom level is stored multiplied by 8.
    LSR r_calculate_perspective_data_offset_hi                                  ; $00F2A4 | |
    ROR r_calculate_perspective_data_offset_lo                                  ; $00F2A6 | |
    LDX r_calculate_perspective_data_offset                                     ; $00F2A8 |/
    RTS                                                                         ; $00F2AA

; _calculate_background_scroll ($00:F2AB)
;
; Calculates the values for the background scroll registers to properly handle
; scrolling the background, specifically on BG2.
_calculate_background_scroll:
    LDA <r_disable_background_scroll_updates                                    ; $00F2AB |\
    BNE +                                                                       ; $00F2AD | | Only execute this function if scrolling is not disabled and the
    LDA r_map_area.w                                                            ; $00F2AF | | current map is a dungeon map.
    CMP #MAP_AREA_DUNGEON                                                       ; $00F2B2 | |
    BNE +                                                                       ; $00F2B4 |/
    LDA r_map_properties.background_properties.w                                ; $00F2B6 |\
    AND #BACKGROUND_PROPERTIES_SCROLL_SPEED.b                                   ; $00F2B9 | | The remainder of the function is only executed if the background
    BNE ++                                                                      ; $00F2BB | | scroll speed is non-zero.
+   RTS                                                                         ; $00F2BD |/
++  LDA r_map_properties.background_properties.w                                ; $00F2BE |\
    AND #%00000110                                                              ; $00F2C1 | | If horizontal or vertical scroll is enabled, branch to that.
    BNE @manual_scroll                                                          ; $00F2C3 |/
    LDA r_map_properties.background_properties.w                                ; $00F2C5 |\
    AND #BACKGROUND_PROPERTIES_SCROLL_SPEED                                     ; $00F2C8 | | Determine whether or not to add to the autoscroll offset. Whether
    LSR A                                                                       ; $00F2CA | | or not the offset is updated on a given frame depends on the
    LSR A                                                                       ; $00F2CB | | configured background scroll speed: 0 and 3 check on every frame.
    LSR A                                                                       ; $00F2CC | | 1 checks every 8 frames, and 2 checks every other frame. If the
    LSR A                                                                       ; $00F2CD | | speed is zero, this part of the code will never be reached
    LSR A                                                                       ; $00F2CE | | anyway.
    LSR A                                                                       ; $00F2CF | |
    TAY                                                                         ; $00F2D0 | |
    LDA <r_map_frame_counter                                                    ; $00F2D1 | |
    AND autoscroll_frame_mask_data,Y                                            ; $00F2D3 | |
    BNE +                                                                       ; $00F2D6 |/
    LDA r_map_properties.background_properties.w                                ; $00F2D8 |\
    AND #BACKGROUND_PROPERTIES_MOVE_DIRECTION.b                                 ; $00F2DB | | Based on the configured move direction, add the appropriate offset
    LSR A                                                                       ; $00F2DD | | into the offset variables to produce the autoscroll effect.
    LSR A                                                                       ; $00F2DE | |
    LSR A                                                                       ; $00F2DF | |
    TAY                                                                         ; $00F2E0 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F2E1 | |
    LDA <r_scroll_horizontal_offset                                             ; $00F2E3 | |
    CLC                                                                         ; $00F2E5 | |
    ADC autoscroll_horizontal_offset,Y                                          ; $00F2E6 | |
    STA <r_scroll_horizontal_offset                                             ; $00F2E9 | |
    LDA <r_scroll_vertical_offset                                               ; $00F2EB | |
    CLC                                                                         ; $00F2ED | |
    ADC autoscroll_vertical_offset,Y                                            ; $00F2EE | |
    STA <r_scroll_vertical_offset                                               ; $00F2F1 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $00F2F3 |\
    LDA <r_scroll_bg1_horizontal                                                ; $00F2F5 | | Add the adjusted offsets into the values stored for the
    CLC                                                                         ; $00F2F7 | | scroll registers.
    ADC <r_scroll_horizontal_offset                                             ; $00F2F8 | |
    STA <r_scroll_bg2_horizontal                                                ; $00F2FA | |
    LDA <r_scroll_bg1_vertical                                                  ; $00F2FC | |
    CLC                                                                         ; $00F2FE | |
    ADC <r_scroll_vertical_offset                                               ; $00F2FF | |
    STA <r_scroll_bg2_vertical                                                  ; $00F301 | |
    LDA #$0000                                                                  ; $00F303 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F306 |/
    JMP @end                                                                    ; $00F308 |
@manual_scroll:
    LDA r_map_properties.background_properties.w                                ; $00F30B |\
    AND #BACKGROUND_PROPERTIES_HORIZONTAL_SCROLL.b                              ; $00F30E | | If horizontal scroll is disabled, skip to the vertical section.
    BEQ @vertical                                                               ; $00F310 |/
    LDX <r_scroll_bg1_horizontal                                                ; $00F312 |\ Set the BG2 horizontal scroll to match BG1.
    STX <r_scroll_bg2_horizontal                                                ; $00F314 |/
    LDA r_map_properties.background_properties.w                                ; $00F316 |\
    AND #BACKGROUND_PROPERTIES_SCROLL_SPEED.b                                   ; $00F319 | | Adjust the BG2 horizontal scroll value depending on the scroll
    CMP #%10000000                                                              ; $00F31B | | speed. For a speed of 1, divide the value in half. For a speed
    BEQ ++                                                                      ; $00F31D | | of 2, keep it the same as BG1. For a speed of 3, double the value.
    CMP #%01000000                                                              ; $00F31F | |
    BEQ +                                                                       ; $00F321 | |
    ASL <r_scroll_bg2_horizontal_lo                                             ; $00F323 | |
    ROL <r_scroll_bg2_horizontal_hi                                             ; $00F325 | |
    JMP ++                                                                      ; $00F327 | |
+   LSR <r_scroll_bg2_horizontal_hi                                             ; $00F32A | |
    ROR <r_scroll_bg2_horizontal_lo                                             ; $00F32C | |
++  LDA r_map_properties.background_properties.w                                ; $00F32E |/
    AND #%00000110                                                              ; $00F331 |\
    CMP #%00000100                                                              ; $00F333 | | If vertical scrolling is also configured, jump to that code.
    BNE @vertical                                                               ; $00F335 | | Otherwise, set the BG2 scroll register to zero and jump to the
    LDX #$0000.w                                                                ; $00F337 | | end.
    STX <r_scroll_bg2_vertical                                                  ; $00F33A | |
    JMP @end                                                                    ; $00F33C |/
@vertical:
    LDA r_map_properties.background_properties.w                                ; $00F33F |\
    AND #BACKGROUND_PROPERTIES_VERTICAL_SCROLL.b                                ; $00F342 | | Check for vertical scrolling to be enabled.
    BEQ @end                                                                    ; $00F344 |/
    LDX <r_scroll_bg1_vertical                                                  ; $00F346 |\
    STX <r_scroll_bg2_vertical                                                  ; $00F348 | | Repeat the process except with vertical instead of horizontal.
    LDA r_map_properties.background_properties.w                                ; $00F34A | |
    AND #BACKGROUND_PROPERTIES_SCROLL_SPEED                                     ; $00F34D | |
    CMP #%10000000                                                              ; $00F34F | |
    BEQ ++                                                                      ; $00F351 | |
    CMP #%01000000                                                              ; $00F353 | |
    BEQ +                                                                       ; $00F355 | |
    ASL <r_scroll_bg2_vertical_lo                                               ; $00F357 | |
    ROL <r_scroll_bg2_vertical_hi                                               ; $00F359 | |
    JMP ++                                                                      ; $00F35B | |
+   LSR <r_scroll_bg2_vertical_hi                                               ; $00F35E | |
    ROR <r_scroll_bg2_vertical_lo                                               ; $00F360 | |
++  LDA r_map_properties.background_properties.w                                ; $00F362 |/
    AND #%00000110                                                              ; $00F365 |\
    CMP #%00000010                                                              ; $00F367 | | If horizontal scrolling is not enabled, zero out the horizontal
    BNE @end                                                                    ; $00F369 | | scroll variable.
    LDX #$0000.w                                                                ; $00F36B | |
    STX <r_scroll_bg2_horizontal                                                ; $00F36E |/
@end:
    RTS                                                                         ; $00F370

; autoscroll_frame_mask_data ($00:F371)
;
; Determines on which frames the background should be scrolled when configured
; to scroll automatically. There are four speeds: none, slow, normal, and fast.
; None and fast check (and scroll in the fast case) on every frame. Normal
; scrolls every other frame. Slow scrolls every eighth frame.
autoscroll_frame_mask_data:
    .db %00000000                                                               ; $00F371 | $0
    .db %00000111                                                               ; $00F372 | $1
    .db %00000001                                                               ; $00F373 | $2
    .db %00000000                                                               ; $00F374 | $3

; autoscroll_horizontal_offset ($00:F375)
;
; Determines what to add to the horizontal scroll register during a check frame
; when autoscrolling.
autoscroll_horizontal_offset:
    .dw  0                                                                      ; $00F375 | $0
    .dw -1                                                                      ; $00F377 | $1
    .dw  0                                                                      ; $00F379 | $2
    .dw  1                                                                      ; $00F37B | $3

; autoscroll_vertical_offset ($00:F37D)
;
; Determines what to add to the vertical scroll register during a check frame
; when autoscrolling.
autoscroll_vertical_offset:
    .dw  1                                                                      ; $00F37D | $0
    .dw  0                                                                      ; $00F37F | $1
    .dw -1                                                                      ; $00F381 | $2
    .dw  0                                                                      ; $00F383 | $3

; _load_tile_composition_data ($00:F385)
;
; Copies tile composition data from the address given in the accumulator (bank)
; and the Y register (address) to the tile composition data array in RAM. 512
; bytes are copied.
_load_tile_composition_data:
    PHA                                                                         ; $00F385 |\ Set the data bank register to the parameter in the accumulator.
    PLB                                                                         ; $00F386 |/
    LDX #$0000.w                                                                ; $00F387 |\
-   LDA 0.w,Y                                                                   ; $00F38A | | Copy the 512 bytes of tile composition data from the address given
    STA r_tile_composition_data_outdoor.l,X                                     ; $00F38D | | in the accumulator (bank) and Y register (address).
    INY                                                                         ; $00F391 | |
    INX                                                                         ; $00F392 | |
    CPX #_sizeof_r_tile_composition_data_outdoor.w                              ; $00F393 | |
    BNE -                                                                       ; $00F396 |/
    LDA #$00.b                                                                  ; $00F398 |\
    PHA                                                                         ; $00F39A | | Set the data bank register to $00.
    PLB                                                                         ; $00F39B |/
    RTS                                                                         ; $00F39C

; _fill_tilemap ($00:F39D)
;
; Fills the tilemap array at $7F:5C71 with the value passed in the accumulator.
_fill_tilemap:
    LDX #$0000.w                                                                ; $00F39D | Initialize the index to zero.
-   STA r_tilemap_data.l,X                                                      ; $00F3A0 |\
    INX                                                                         ; $00F3A4 | | Fill the tilemap data array with the passed value.
    CPX #$4000.w                                                                ; $00F3A5 | |
    BNE -                                                                       ; $00F3A8 |/
    RTS                                                                         ; $00F3AA

; _update_outdoor_pending_tiles ($00:F3AB)
;
; Reads the current movement direction, and based on that, loads a row or column
; of tiles and puts it in the pending tiles area to be copied to VRAM.
_update_outdoor_pending_tiles:
    LDA <r_movement_direction                                                   ; $00F3AB |\
    BNE +                                                                       ; $00F3AD | | Make sure the player is moving.
    RTS                                                                         ; $00F3AF |/
+   AND #MOVEMENT_DIRECTION_VERTICAL.b                                          ; $00F3B0 |\
    BEQ @horizontal                                                             ; $00F3B2 | | Determine if the movement is vertical or horizontal and branch.
    JMP @vertical                                                               ; $00F3B4 |/
@horizontal:
    LDA <r_movement_direction                                                   ; $00F3B7 |\
    AND #MOVEMENT_DIRECTION_POSITIVE.b                                          ; $00F3B9 | | If the player is moving right, add 33 to the current coordinates
    BEQ +                                                                       ; $00F3BB | | to determine the column to load.
    LDA r_current_coordinates.x.w                                               ; $00F3BD | |
    CLC                                                                         ; $00F3C0 | |
    ADC #33.b                                                                   ; $00F3C1 | |
    STA <r_update_pending_tiles_index_lo                                        ; $00F3C3 | |
    JMP ++                                                                      ; $00F3C5 |/
+   LDA r_current_coordinates.x.w                                               ; $00F3C8 |\
    SEC                                                                         ; $00F3CB | | If moving left, subtract 31 instead.
    SBC #31.b                                                                   ; $00F3CC | |
    STA <r_update_pending_tiles_index_lo                                        ; $00F3CE |/
++  LDA r_current_coordinates.y.w                                               ; $00F3D0 |\
    SEC                                                                         ; $00F3D3 | | Set the initial Y coordinate to the current Y coordinate minus 31.
    SBC #31.b                                                                   ; $00F3D4 | | Make sure to take the value mod 64, and then multiply by 256 to
    AND #%00111111.b                                                            ; $00F3D6 | | get the current index (in conjunction with the X coordinate).
    STA <r_update_pending_tiles_index_hi                                        ; $00F3D8 | |
    LDX <r_update_pending_tiles_index                                           ; $00F3DA | |
    STX <r_update_pending_tiles_index_initial                                   ; $00F3DC |/
    LDY #$0000.w                                                                ; $00F3DE |\
-   LDX <r_update_pending_tiles_index                                           ; $00F3E1 | | Load the tile number from the tilemap data.
    LDA r_tilemap_data.l,X                                                      ; $00F3E3 | |
    TAX                                                                         ; $00F3E7 |/
    LDA r_tile_composition_data_outdoor_upper_left.l,X                          ; $00F3E8 |\
    STA r_tilemap_pending_tiles,Y                                               ; $00F3EC | | Copy the sub-tiles to the pending tiles area in RAM.
    LDA r_tile_composition_data_outdoor_lower_left.l,X                          ; $00F3EF | |
    STA r_tilemap_pending_tiles + 1,Y                                           ; $00F3F3 | |
    LDA r_tile_composition_data_outdoor_upper_right.l,X                         ; $00F3F6 | |
    STA r_tilemap_pending_tiles + 128,Y                                         ; $00F3FA | |
    LDA r_tile_composition_data_outdoor_lower_right.l,X                         ; $00F3FD | |
    STA r_tilemap_pending_tiles + 129,Y                                         ; $00F401 |/
    LDA <r_update_pending_tiles_index_hi                                        ; $00F404 |\
    INC A                                                                       ; $00F406 | | Increment the Y coordinate to get the next tile.
    AND #%00111111.b                                                            ; $00F407 | |
    STA <r_update_pending_tiles_index_hi                                        ; $00F409 |/
    INY                                                                         ; $00F40B |\
    INY                                                                         ; $00F40C | | Repeat until the entire column is done.
    CPY #$0080.w                                                                ; $00F40D | |
    BNE -                                                                       ; $00F410 |/
    STZ <r_tilemap_negative_count_hi                                            ; $00F412 |\
    STZ <r_tilemap_positive_count_hi                                            ; $00F414 | | Zero out several high bytes.
    STZ <r_tilemap_negative_address_1_hi                                        ; $00F416 | |
    STZ <r_tilemap_negative_address_2_hi                                        ; $00F418 |/
    LDA <r_update_pending_tiles_index_initial_lo                                ; $00F41A |\
    ASL A                                                                       ; $00F41C | | Set the low byte of the addresses by taking the low byte of the
    AND #%01111111.b                                                            ; $00F41D | | index and multiplying by 2, taking it mod 128. Increment the value
    STA <r_tilemap_positive_address_1_lo                                        ; $00F41F | | to get the low byte of the second addresses.
    STA <r_tilemap_negative_address_1_lo                                        ; $00F421 | |
    INC A                                                                       ; $00F423 | |
    STA <r_tilemap_positive_address_2_lo                                        ; $00F424 | |
    STA <r_tilemap_negative_address_2_lo                                        ; $00F426 |/
    LDA r_current_coordinates.y.w                                               ; $00F428 |\
    SEC                                                                         ; $00F42B | | Set the high byte of the positive addresses by subtracting 31 from
    SBC #31.b                                                                   ; $00F42C | | the Y coordinate.
    AND #%00111111.b                                                            ; $00F42E | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F430 | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F432 |/
    ASL A                                                                       ; $00F434 |\
    STA <r_tilemap_negative_count_lo                                            ; $00F435 | | Calculate the count of tiles on the negative and positive sides.
    LDA #$80.b                                                                  ; $00F437 | |
    SEC                                                                         ; $00F439 | |
    SBC <r_tilemap_negative_count_lo                                            ; $00F43A | |
    STA <r_tilemap_positive_count_lo                                            ; $00F43C |/
    INC <r_tilemap_dirty                                                        ; $00F43E | Flag the tilemap as dirty.
    RTS                                                                         ; $00F440
@vertical:
    LDA <r_movement_direction                                                   ; $00F441 |\
    AND #MOVEMENT_DIRECTION_POSITIVE.b                                          ; $00F443 | | Do essentially the same thing, except adjusted to copy a row
    BNE +                                                                       ; $00F445 | | instead of a column.
    LDA r_current_coordinates.y.w                                               ; $00F447 | |
    SEC                                                                         ; $00F44A | |
    SBC #31.b                                                                   ; $00F44B | |
    STA <r_update_pending_tiles_tmp                                             ; $00F44D | |
    AND #%00111111.b                                                            ; $00F44F | |
    STA <r_update_pending_tiles_index_hi                                        ; $00F451 | |
    JMP ++                                                                      ; $00F453 | |
+   LDA r_current_coordinates.y.w                                               ; $00F456 | |
    CLC                                                                         ; $00F459 | |
    ADC #32.b                                                                   ; $00F45A | |
    STA <r_update_pending_tiles_tmp                                             ; $00F45C | |
    AND #%00111111.b                                                            ; $00F45E | |
    STA <r_update_pending_tiles_index_hi                                        ; $00F460 | |
++  LDA r_current_coordinates.x.w                                               ; $00F462 | |
    SEC                                                                         ; $00F465 | |
    SBC #31.b                                                                   ; $00F466 | |
    STA <r_update_pending_tiles_index_lo                                        ; $00F468 | |
    LDX <r_update_pending_tiles_index                                           ; $00F46A | |
    STX <r_update_pending_tiles_index_initial                                   ; $00F46C | |
    LDY #$0000.w                                                                ; $00F46E | |
-   LDX <r_update_pending_tiles_index                                           ; $00F471 | |
    LDA r_tilemap_data.l,X                                                      ; $00F473 | |
    TAX                                                                         ; $00F477 | |
    LDA r_tile_composition_data_outdoor_upper_left.l,X                          ; $00F478 | |
    STA r_tilemap_pending_tiles,Y                                               ; $00F47C | |
    LDA r_tile_composition_data_outdoor_upper_right.l,X                         ; $00F47F | |
    STA r_tilemap_pending_tiles + 1,Y                                           ; $00F483 | |
    LDA r_tile_composition_data_outdoor_lower_left.l,X                          ; $00F486 | |
    STA r_tilemap_pending_tiles + 128,Y                                         ; $00F48A | |
    LDA r_tile_composition_data_outdoor_lower_right.l,X                         ; $00F48D | |
    STA r_tilemap_pending_tiles + 129,Y                                         ; $00F491 | |
    INY                                                                         ; $00F494 | |
    INY                                                                         ; $00F495 | |
    INC <r_update_pending_tiles_index_lo                                        ; $00F496 | |
    CPY #$0080.w                                                                ; $00F498 | |
    BNE -                                                                       ; $00F49B | |
    STZ <r_tilemap_negative_count_lo                                            ; $00F49D | |
    STZ <r_tilemap_negative_count_hi                                            ; $00F49F | |
    LDA #$80.b                                                                  ; $00F4A1 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F4A3 | |
    STZ <r_tilemap_positive_count_hi                                            ; $00F4A5 | |
    STZ <r_tilemap_negative_address_1_lo                                        ; $00F4A7 | |
    LDA #$80.b                                                                  ; $00F4A9 | |
    STA <r_tilemap_negative_address_2_lo                                        ; $00F4AB | |
    LDA <r_update_pending_tiles_tmp                                             ; $00F4AD | |
    AND #%00111111.b                                                            ; $00F4AF | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F4B1 | |
    STA <r_tilemap_negative_address_1_hi                                        ; $00F4B3 | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F4B5 | |
    STA <r_tilemap_negative_address_2_hi                                        ; $00F4B7 | |
    LDA r_current_coordinates.x.w                                               ; $00F4B9 | |
    SEC                                                                         ; $00F4BC | |
    SBC #31.b                                                                   ; $00F4BD | |
    AND #%00111111.b                                                            ; $00F4BF | |
    ASL A                                                                       ; $00F4C1 | |
    STA <r_tilemap_positive_address_1_lo                                        ; $00F4C2 | |
    CLC                                                                         ; $00F4C4 | |
    ADC #$80.b                                                                  ; $00F4C5 | |
    STA <r_tilemap_positive_address_2_lo                                        ; $00F4C7 | |
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F4C9 | |
    STA <r_tilemap_negative_count_lo                                            ; $00F4CB | |
    LDA #$80.b                                                                  ; $00F4CD | |
    SEC                                                                         ; $00F4CF | |
    SBC <r_tilemap_negative_count_lo                                            ; $00F4D0 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F4D2 | |
    INC <r_tilemap_dirty                                                        ; $00F4D4 |/
    RTS                                                                         ; $00F4D6

; _update_dungeon_pending_tiles ($00:F4D7)
;
; Reads the current movement direction, and based on that, loads a row or column
; of tiles and puts it in the pending tiles area to be copied to VRAM.
_update_dungeon_pending_tiles:
    LDA <r_movement_direction                                                   ; $00F4D7 |\
    BNE +                                                                       ; $00F4D9 | | Skip this function if not moving.
    RTS                                                                         ; $00F4DB |/
+   AND #MOVEMENT_DIRECTION_VERTICAL.b                                          ; $00F4DC |\
    BEQ @horizontal                                                             ; $00F4DE | | Determine if the movement is horizontal or vertical and branch.
    JMP @vertical                                                               ; $00F4E0 |/
@horizontal:
    LDA <r_movement_direction                                                   ; $00F4E3 |\
    AND #MOVEMENT_DIRECTION_POSITIVE.b                                          ; $00F4E5 | | If moving to the right, set the target X coordinate to the current
    BEQ +                                                                       ; $00F4E7 | | X coordinate plus 9.
    LDA r_current_coordinates.x.w                                               ; $00F4E9 | |
    CLC                                                                         ; $00F4EC | |
    ADC #9.b                                                                    ; $00F4ED | |
    STA <r_update_pending_tiles_index_lo                                        ; $00F4EF | |
    JMP ++                                                                      ; $00F4F1 |/
+   LDA r_current_coordinates.x.w                                               ; $00F4F4 |\
    SEC                                                                         ; $00F4F7 | | If moving to the left, set the target X coordinate to the current
    SBC #8.b                                                                    ; $00F4F8 | | X coordinate minus 8.
    STA <r_update_pending_tiles_index_lo                                        ; $00F4FA |/
++  LDA r_current_coordinates.y.w                                               ; $00F4FC |\
    SEC                                                                         ; $00F4FF | | Set the starting Y coordinate to the current Y coordinate mod 64
    SBC #7.b                                                                    ; $00F500 | | minus 7.
    AND #%00111111.b                                                            ; $00F502 | |
    STA <r_update_pending_tiles_index_hi                                        ; $00F504 |/
    LDX <r_update_pending_tiles_index                                           ; $00F506 |\ Save the initial index for later use.
    STX <r_update_dungeon_pending_tiles_index_initial                           ; $00F508 |/
    LDY #$0000.w                                                                ; $00F50A | Initialize the Y register to zero.
-   LDX <r_update_pending_tiles_index                                           ; $00F50D |\
    LDA r_tilemap_data.l,X                                                      ; $00F50F | | Calculate the index into the tile composition data by reading the
    STA <r_update_dungeon_pending_tiles_tmp_index_lo                            ; $00F513 | | tile number and multiplying by two.
    STZ <r_update_dungeon_pending_tiles_tmp_index_hi                            ; $00F515 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F517 | |
    ASL <r_update_dungeon_pending_tiles_tmp_index                               ; $00F519 | |
    LDX <r_update_dungeon_pending_tiles_tmp_index                               ; $00F51B |/
    LDA r_tile_composition_data_dungeon_upper_left.l,X                          ; $00F51D |\
    STA r_tilemap_pending_tiles,Y                                               ; $00F521 | | Store the four subtiles of the tile into the pending tiles area at
    LDA r_tile_composition_data_dungeon_lower_left.l,X                          ; $00F524 | | the relevant locations.
    STA r_tilemap_pending_tiles + 2,Y                                           ; $00F528 | |
    LDA r_tile_composition_data_dungeon_upper_right.l,X                         ; $00F52B | |
    STA r_tilemap_pending_tiles + 64,Y                                          ; $00F52F | |
    LDA r_tile_composition_data_dungeon_lower_right.l,X                         ; $00F532 | |
    STA r_tilemap_pending_tiles + 66,Y                                          ; $00F536 | |
    LDA #$0000.w                                                                ; $00F539 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F53C |/
    LDA <r_update_pending_tiles_index_hi                                        ; $00F53E |\
    INC A                                                                       ; $00F540 | | Increment the Y coordinate and take it mod 64.
    AND #%00111111.b                                                            ; $00F541 | |
    STA <r_update_pending_tiles_index_hi                                        ; $00F543 |/
    INY                                                                         ; $00F545 |\
    INY                                                                         ; $00F546 | | Increment the Y register by four (as four bytes were written at
    INY                                                                         ; $00F547 | | that location.
    INY                                                                         ; $00F548 |/
    CPY #$0040.w                                                                ; $00F549 |\
    BEQ +                                                                       ; $00F54C | | Loop until 32 tiles have been copied.
    JMP -                                                                       ; $00F54E |/
+   STZ <r_tilemap_positive_address_1_lo                                        ; $00F551 |\
    LDA <r_update_dungeon_pending_tiles_index_initial_hi                        ; $00F553 | | Initialize the positive address to the initial Y coordinate mod 16
    AND #%00001111.b                                                            ; $00F555 | | times 64.
    STA <r_tilemap_positive_address_1_hi                                        ; $00F557 | |
    LSR <r_tilemap_positive_address_1_hi                                        ; $00F559 | |
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F55B | |
    LSR <r_tilemap_positive_address_1_hi                                        ; $00F55D | |
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F55F |/
    LDA <r_update_dungeon_pending_tiles_index_initial_lo                        ; $00F561 |\
    AND #%00011111.b                                                            ; $00F563 | | Adjust the X coordinate by taking it mod 32 and multiplying by
    ASL A                                                                       ; $00F565 | | two (each tile has two subtiles in one direction).
    STA <r_update_dungeon_pending_tiles_index_initial_lo                        ; $00F566 |/
    AND #%00100000.b                                                            ; $00F568 |\
    BEQ +                                                                       ; $00F56A | | If the X coordinate was 16 or greater, add $0400 to the VRAM
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F56C | | address (to move to the second half of the tilemap).
    CLC                                                                         ; $00F56E | |
    ADC #$04.b                                                                  ; $00F56F | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F571 |/
+   LDA <r_update_dungeon_pending_tiles_index_initial_lo                        ; $00F573 |\
    AND #%00011111.b                                                            ; $00F575 | | Add the modified X coordinate mod 32 to the VRAM address.
    CLC                                                                         ; $00F577 | |
    ADC <r_tilemap_positive_address_1_lo                                        ; $00F578 | |
    STA <r_tilemap_positive_address_1_lo                                        ; $00F57A |/
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F57C |\
    CLC                                                                         ; $00F57E | | Add $1800 to the VRAM address, as that's the base.
    ADC #$18.b                                                                  ; $00F57F | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F581 |/
    LDA <r_update_dungeon_pending_tiles_index_initial_hi                        ; $00F583 |\
    AND #%00001111.b                                                            ; $00F585 | | Set the negative byte count to the Y coordinate mod 16 times four.
    ASL A                                                                       ; $00F587 | |
    ASL A                                                                       ; $00F588 | |
    STA <r_tilemap_negative_count_lo                                            ; $00F589 | |
    STZ <r_tilemap_negative_count_hi                                            ; $00F58B |/
    LDA #64.b                                                                   ; $00F58D |\
    SEC                                                                         ; $00F58F | | Set the positive byte count to 64 minus the negative count.
    SBC <r_tilemap_negative_count_lo                                            ; $00F590 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F592 | |
    STZ <r_tilemap_positive_count_hi                                            ; $00F594 |/
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F596 |\
    AND #%11111100.b                                                            ; $00F598 | | Set the first negative address to the positive address mod 32
    STA <r_tilemap_negative_address_1_hi                                        ; $00F59A | | plus $1800. (So, the first tile in the column.)
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F59C | |
    AND #%00011111.b                                                            ; $00F59E | |
    STA <r_tilemap_negative_address_1_lo                                        ; $00F5A0 |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F5A2 |\
    INC A                                                                       ; $00F5A4 | | Set the second positive address to the first positive address plus
    STA <r_tilemap_positive_address_2_lo                                        ; $00F5A5 | | one.
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F5A7 | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F5A9 |/
    LDA <r_tilemap_negative_address_1_lo                                        ; $00F5AB |\
    INC A                                                                       ; $00F5AD | | Set the second negative address to the first negative address plus
    STA <r_tilemap_negative_address_2_lo                                        ; $00F5AE | | one.
    LDA <r_tilemap_negative_address_1_hi                                        ; $00F5B0 | |
    STA <r_tilemap_negative_address_2_hi                                        ; $00F5B2 |/
    INC <r_tilemap_dirty                                                        ; $00F5B4 |\ Flag the tilemap as dirty and return.
    RTS                                                                         ; $00F5B6 |/
@vertical:
    LDA <r_movement_direction                                                   ; $00F5B7 |\
    AND #MOVEMENT_DIRECTION_POSITIVE.b                                          ; $00F5B9 | | If moving upward, set the target Y coordinate to the current Y
    BNE +                                                                       ; $00F5BB | | coordinate minus 8 mod 64.
    LDA r_current_coordinates.y.w                                               ; $00F5BD | |
    SEC                                                                         ; $00F5C0 | |
    SBC #8.b                                                                    ; $00F5C1 | |
    AND #%00111111.b                                                            ; $00F5C3 | |
    STA <r_load_dungeon_tilemap_row_arg_coordinates.y                           ; $00F5C5 | |
    JMP ++                                                                      ; $00F5C7 |/
+   LDA r_current_coordinates.y.w                                               ; $00F5CA |\
    CLC                                                                         ; $00F5CD | | If moving downward, set the target Y coordinate to the current Y
    ADC #8.b                                                                    ; $00F5CE | | coordinate plus 8 mod 64.
    AND #%00111111.b                                                            ; $00F5D0 | |
    STA <r_load_dungeon_tilemap_row_arg_coordinates.y                           ; $00F5D2 |/
++  LDA r_current_coordinates.x.w                                               ; $00F5D4 |\
    SEC                                                                         ; $00F5D7 | | Set the starting X coordinate to the current X coordinate minus 7.
    SBC #7.b                                                                    ; $00F5D8 | |
    STA <r_load_dungeon_tilemap_row_arg_coordinates.x                           ; $00F5DA |/
    LDX <r_load_dungeon_tilemap_row_arg_coordinates                             ; $00F5DC |\ Transfer the coordinates into the parameter for the other function.
    STX <r_update_dungeon_tilemap_row_addresses_coordinates                     ; $00F5DE |/
    JSR _load_dungeon_tilemap_row                                               ; $00F5E0 | Load the requested tilemap row.
    JSR _update_dungeon_tilemap_row_addresses                                   ; $00F5E3 | Update the pending tile addresses for that row.
    RTS                                                                         ; $00F5E6

; _load_dungeon_tilemap_row ($00:F5E7)
;
; Using the coordinates passed in $063D, transfers one row of tiles to the
; pending tiles area in RAM.
_load_dungeon_tilemap_row:
    LDY #$0000.w                                                                ; $00F5E7 | Initialize the Y register to zero.
-   LDX <r_load_dungeon_tilemap_row_arg_coordinates                             ; $00F5EA | Initialize the X register to the passed coordinates.
    LDA r_tilemap_data.l,X                                                      ; $00F5EC |\
    STA <r_load_dungeon_tilemap_row_tmp_lo                                      ; $00F5F0 | | Read the tile and calculate its offset to the tile composition
    STZ <r_load_dungeon_tilemap_row_tmp_hi                                      ; $00F5F2 | | data by multiplying by two (as each subtile has two bytes).
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F5F4 | |
    ASL <r_load_dungeon_tilemap_row_tmp                                         ; $00F5F6 | |
    LDX <r_load_dungeon_tilemap_row_tmp                                         ; $00F5F8 |/
    LDA r_tile_composition_data_dungeon_upper_left.l,X                          ; $00F5FA |\
    STA r_tilemap_pending_tiles,Y                                               ; $00F5FE | | Copy the four subtiles to the appropriate places in the pending
    LDA r_tile_composition_data_dungeon_upper_right.l,X                         ; $00F601 | | tiles data.
    STA r_tilemap_pending_tiles + 2,Y                                           ; $00F605 | |
    LDA r_tile_composition_data_dungeon_lower_left.l,X                          ; $00F608 | |
    STA r_tilemap_pending_tiles + 64,Y                                          ; $00F60C | |
    LDA r_tile_composition_data_dungeon_lower_right.l,X                         ; $00F60F | |
    STA r_tilemap_pending_tiles + 66,Y                                          ; $00F613 |/
    LDA #$0000.w                                                                ; $00F616 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F619 | | Increment the Y index by four (two tiles of two bytes each).
    INY                                                                         ; $00F61B | |
    INY                                                                         ; $00F61C | |
    INY                                                                         ; $00F61D | |
    INY                                                                         ; $00F61E |/
    INC <r_load_dungeon_tilemap_row_arg_coordinates.x                           ; $00F61F |\ Increment the current X coordinate, and loop until 32 tiles have
    CPY #$0040.w                                                                ; $00F621 |/ been done.
    BNE -                                                                       ; $00F624
    RTS                                                                         ; $00F626

; _update_dungeon_tilemap_row_addresses ($00:F627)
;
; Updates the addresses and counts used for transferring pending tiles to VRAM.
; Operates assuming a row is being transferred (versus a column).
_update_dungeon_tilemap_row_addresses:
    STZ <r_tilemap_positive_address_1_lo                                        ; $00F627 |\
    LDA <r_update_dungeon_tilemap_row_addresses_coordinates.y                   ; $00F629 | | Set the initial positive VRAM address to the Y coordinate mod 16
    AND #%00001111.b                                                            ; $00F62B | | (as the tilemap in VRAM is 32x16) multiplied by 64 (as each row is
    STA <r_tilemap_positive_address_1_hi                                        ; $00F62D | | 32 subtiles, and there are two rows of subtiles for each Y
    LSR <r_tilemap_positive_address_1_hi                                        ; $00F62F | | coordinate.
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F631 | |
    LSR <r_tilemap_positive_address_1_hi                                        ; $00F633 | |
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F635 |/
    LDA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F637 |\
    AND #%00011111.b                                                            ; $00F639 | | Take the X coordinate mod 32, and multiply by two, storing the
    ASL A                                                                       ; $00F63B | | result back (which is now the subtile X coordinate).
    STA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F63C |/
    AND #%00100000.b                                                            ; $00F63E |\
    BEQ +                                                                       ; $00F640 | | If the original X coordinate was in the range 16-31, add $400 to
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F642 | | the address to switch to the second half of the tilemap.
    CLC                                                                         ; $00F644 | |
    ADC #$04.b                                                                  ; $00F645 | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F647 |/
+   LDA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F649 |\
    AND #%00011111.b                                                            ; $00F64B | | Take the subtile X coordinate mod 32 (as each half of the tilemap
    CLC                                                                         ; $00F64D | | has 32 columns), and add that to the positive VRAM address.
    ADC <r_tilemap_positive_address_1_lo                                        ; $00F64E | |
    STA <r_tilemap_positive_address_1_lo                                        ; $00F650 |/
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F652 |\
    CLC                                                                         ; $00F654 | | Add $1800 to the VRAM address, which is the base address of the
    ADC #$18.b                                                                  ; $00F655 | | tilemap in VRAM.
    STA <r_tilemap_positive_address_1_hi                                        ; $00F657 |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F659 |\
    AND #%00011111.b                                                            ; $00F65B | | Set the negative tile count to the VRAM address mod 32 (to get the
    ASL A                                                                       ; $00F65D | | number of subtiles to the left of the address) and then multiply
    STA <r_tilemap_negative_count_lo                                            ; $00F65E | | by two (because each subtile has two bytes). TODO: This may want
    STZ <r_tilemap_negative_count_hi                                            ; $00F660 |/  to be renamed to reflect it's bytes and not strictly tiles.
    LDA #64.b                                                                   ; $00F662 |\
    SEC                                                                         ; $00F664 | | The positive count is therefore 64 minus the negative count.
    SBC <r_tilemap_negative_count_lo                                            ; $00F665 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F667 | |
    STZ <r_tilemap_positive_count_hi                                            ; $00F669 |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F66B |\
    AND #%11100000.b                                                            ; $00F66D | | The negative address is set by taking the positive address mod 32,
    STA <r_tilemap_negative_address_1_lo                                        ; $00F66F | | to eliminate the column component. $400 is then added to start on
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F671 | | the second tilemap. The result is taken mod $800 to stay within
    CLC                                                                         ; $00F673 | | the VRAM area (wrapping around to the first tilemap if necessary).
    ADC #4.b                                                                    ; $00F674 | | Finally, $1800 is added again (since it was modded away).
    AND #%00000111.b                                                            ; $00F676 | |
    CLC                                                                         ; $00F678 | |
    ADC #$18.b                                                                  ; $00F679 | |
    STA <r_tilemap_negative_address_1_hi                                        ; $00F67B |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F67D |\
    CLC                                                                         ; $00F67F | | Add 32 to the positive address to determine the second positive
    ADC #32.b                                                                   ; $00F680 | | address.
    STA <r_tilemap_positive_address_2_lo                                        ; $00F682 | |
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F684 | |
    ADC #$00.b                                                                  ; $00F686 | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F688 |/
    LDA <r_tilemap_negative_address_1_lo                                        ; $00F68A |\
    CLC                                                                         ; $00F68C | | Repeat with the negative address.
    ADC #32.b                                                                   ; $00F68D | |
    STA <r_tilemap_negative_address_2_lo                                        ; $00F68F | |
    LDA <r_tilemap_negative_address_1_hi                                        ; $00F691 | |
    ADC #0.b                                                                    ; $00F693 | |
    STA <r_tilemap_negative_address_2_hi                                        ; $00F695 |/
    INC <r_tilemap_dirty                                                        ; $00F697 | Flag the tilemap as dirty.
    RTS                                                                         ; $00F699

; _update_dungeon_background_tilemap_row_addresses ($00:F69A)
;
; Updates the addresses used for transferring pending tiles to VRAM. Sets the
; address to write to the X and Y coordinates given in $0643 and $0644,
; respectively on BG2.
_update_dungeon_background_tilemap_row_addresses:
    STZ <r_tilemap_positive_address_1_lo                                        ; $00F69A |\
    LDA <r_update_dungeon_tilemap_row_addresses_coordinates.y                   ; $00F69C | | Set the positive VRAM address initially to the Y coordinate mod 16
    AND #%00001111.b                                                            ; $00F69E | | times 256 (64 after the upcoming division).
    STA <r_tilemap_positive_address_1_hi                                        ; $00F6A0 |/
    LDA <r_update_dungeon_tilemap_row_addresses_coordinates.y                   ; $00F6A2 |\
    AND #%00010000.b                                                            ; $00F6A4 | | If the Y coordinate is 16 or greater, add $2000 to the address.
    BEQ +                                                                       ; $00F6A6 | | This will be equivalent to adding $800 after the upcoming
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F6A8 | | division, which serves to move to the second half on the bottom.
    CLC                                                                         ; $00F6AA | |
    ADC #$20.b                                                                  ; $00F6AB | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F6AD |/
+   LSR <r_tilemap_positive_address_1_hi                                        ; $00F6AF |\
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F6B1 | | Divide the positive address by 4.
    LSR <r_tilemap_positive_address_1_hi                                        ; $00F6B3 | |
    ROR <r_tilemap_positive_address_1_lo                                        ; $00F6B5 |/
    LDA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F6B7 |\
    AND #%00011111.b                                                            ; $00F6B9 | | Set the X coordinate to the X coordinate mod 32 and multiply by
    ASL A                                                                       ; $00F6BB | | two.
    STA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F6BC |/
    AND #%00100000.b                                                            ; $00F6BE |\
    BEQ +                                                                       ; $00F6C0 | | If the original X coordinate was 16 or greater, add $400 to the
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F6C2 | | positive address to move to the second half on the right.
    CLC                                                                         ; $00F6C4 | |
    ADC #$04.b                                                                  ; $00F6C5 | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F6C7 | |
+   LDA <r_update_dungeon_tilemap_row_addresses_coordinates.x                   ; $00F6C9 |/
    AND #%00011111.b                                                            ; $00F6CB |\
    CLC                                                                         ; $00F6CD | | Add the adjusted X coordinate to the VRAM address.
    ADC <r_tilemap_positive_address_1_lo                                        ; $00F6CE | |
    STA <r_tilemap_positive_address_1_lo                                        ; $00F6D0 |/
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F6D2 |\
    CLC                                                                         ; $00F6D4 | | Add $3000 to the VRAM address, as that is the base address for
    ADC #$30.b                                                                  ; $00F6D5 | | BG2.
    STA <r_tilemap_positive_address_1_hi                                        ; $00F6D7 |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F6D9 |\
    CLC                                                                         ; $00F6DB | | Add 32 to the address to determine the address for the second row
    ADC #$20.b                                                                  ; $00F6DC | | of tiles.
    STA <r_tilemap_positive_address_2_lo                                        ; $00F6DE | |
    LDA <r_tilemap_positive_address_1_hi                                        ; $00F6E0 | |
    ADC #$00.b                                                                  ; $00F6E2 | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F6E4 |/
    INC <r_tilemap_dirty                                                        ; $00F6E6
    RTS                                                                         ; $00F6E8

; _copy_outdoor_tilemap_to_vram ($00:F6E9)
;
; Copies a 64x64 section of the current outdoor tilemap to both the decoded
; tilemap data area in RAM as well as the actual tiles to VRAM.
_copy_outdoor_tilemap_to_vram:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F6E9 |\
    LDA r_current_coordinates.y.w                                               ; $00F6EB | | Calculate the BG1 vertical scroll register by taking the current Y
    AND #$00FF.w                                                                ; $00F6EE | | coordinate and multiplying by 16 (the number of pixels per tile).
    SEC                                                                         ; $00F6F1 | | The result is taken mod 2048, which seems pointless since the SNES
    SBC #$0007.w                                                                ; $00F6F2 | | maximum is 1047. Presumably any higher bits are ignored.
    ASL A                                                                       ; $00F6F5 | |
    ASL A                                                                       ; $00F6F6 | |
    ASL A                                                                       ; $00F6F7 | |
    ASL A                                                                       ; $00F6F8 | |
    AND #$07FF.w                                                                ; $00F6F9 | |
    STA <r_scroll_bg1_vertical                                                  ; $00F6FC |/
    LDA r_current_coordinates.x.w                                               ; $00F6FE |\
    AND #$00FF.w                                                                ; $00F701 | | Calculate the BG1 horizontal scroll register in much the same
    SEC                                                                         ; $00F704 | | manner, except using the X coordinate.
    SBC #$0007.w                                                                ; $00F705 | |
    ASL A                                                                       ; $00F708 | |
    ASL A                                                                       ; $00F709 | |
    ASL A                                                                       ; $00F70A | |
    ASL A                                                                       ; $00F70B | |
    AND #$07FF.w                                                                ; $00F70C | |
    STA <r_scroll_bg1_horizontal                                                ; $00F70F | |
    LDA #$0000.w                                                                ; $00F711 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F714 |/
    LDA #64.b                                                                   ; $00F716 |\
    STA <r_copy_outdoor_tilemap_to_vram_index                                   ; $00F718 | | Load 64 rows of the tilemap, starting from the current Y
    LDA r_current_coordinates.y.w                                               ; $00F71A | | coordinate minus 31. The _load_outdoor_tilemap_row function
    STA r_load_outdoor_tilemap_row_arg_y.w                                      ; $00F71D | | handles the subtraction itself, and expects to be passed the
-   JSR _load_outdoor_tilemap_row                                               ; $00F720 | | center coordinate (as it also handles automatically selecting the
    INC r_load_outdoor_tilemap_row_arg_y.w                                      ; $00F723 | | correct row when the player is moving).
    DEC <r_copy_outdoor_tilemap_to_vram_index                                   ; $00F726 | |
    BNE -                                                                       ; $00F728 |/
    LDA #64.b                                                                   ; $00F72A |\
    STA <r_copy_outdoor_tilemap_to_vram_index                                   ; $00F72C | | Prepare for the upcoming loop by initializing the index to 64 (to
    LDA r_current_coordinates.y.w                                               ; $00F72E | | handle 64 rows of tiles) and setting the initial Y coordinate to
    SEC                                                                         ; $00F731 | | our current coordinate minus 31.
    SBC #31.b                                                                   ; $00F732 | |
    STA <r_copy_outdoor_tilemap_to_vram_y                                       ; $00F734 |/
@copy_start:
    LDA <r_copy_outdoor_tilemap_to_vram_y                                       ; $00F736 |\
    AND #%00111111.b                                                            ; $00F738 | | Calculate the initial offset into the tilemap data by multiplying
    STA <r_copy_outdoor_tilemap_to_vram_tilemap_offset_hi                       ; $00F73A | | the Y coordinate mod 64 by 256 and adding the X coordinate minus
    LDA r_current_coordinates.x.w                                               ; $00F73C | | 31.
    SEC                                                                         ; $00F73F | |
    SBC #31.b                                                                   ; $00F740 | |
    STA <r_copy_outdoor_tilemap_to_vram_tilemap_offset_lo                       ; $00F742 | |
    LDX <r_copy_outdoor_tilemap_to_vram_tilemap_offset                          ; $00F744 |/
    LDY #$0000.w                                                                ; $00F746 |\
-   LDX <r_copy_outdoor_tilemap_to_vram_tilemap_offset                          ; $00F749 | | For each of the 64 tiles we are interested in, copy the four sub-
    LDA r_tilemap_data.l,X                                                      ; $00F74B | | tiles to the pending tiles area in RAM.
    TAX                                                                         ; $00F74F | |
    LDA r_tile_composition_data_outdoor_upper_left.l,X                          ; $00F750 | |
    STA r_tilemap_pending_tiles,Y                                               ; $00F754 | |
    LDA r_tile_composition_data_outdoor_upper_right.l,X                         ; $00F757 | |
    STA r_tilemap_pending_tiles + 1,Y                                           ; $00F75B | |
    LDA r_tile_composition_data_outdoor_lower_left.l,X                          ; $00F75E | |
    STA r_tilemap_pending_tiles + 128,Y                                         ; $00F762 | |
    LDA r_tile_composition_data_outdoor_lower_right.l,X                         ; $00F765 | |
    STA r_tilemap_pending_tiles + 129,Y                                         ; $00F769 | |
    INY                                                                         ; $00F76C | |
    INY                                                                         ; $00F76D | |
    INC <r_copy_outdoor_tilemap_to_vram_tilemap_offset_lo                       ; $00F76E | |
    CPY #$0080.w                                                                ; $00F770 | |
    BNE -                                                                       ; $00F773 |/
    STZ <r_tilemap_negative_count_lo                                            ; $00F775 |\
    STZ <r_tilemap_negative_count_hi                                            ; $00F777 | | Start off by assuming all 128 sub-tiles are on the positive side.
    LDA #128.b                                                                  ; $00F779 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F77B | |
    STZ <r_tilemap_positive_count_hi                                            ; $00F77D |/
    STZ <r_tilemap_negative_address_1_lo                                        ; $00F77F |\
    LDA #$80.b                                                                  ; $00F781 | | Set the positive and negative addresses to this row. Set the
    STA <r_tilemap_negative_address_2_lo                                        ; $00F783 | | negative addresses to the top row and bottom row of sub-tiles.
    LDA <r_copy_outdoor_tilemap_to_vram_y                                       ; $00F785 | |
    AND #%00111111.b                                                            ; $00F787 | |
    STA <r_tilemap_positive_address_1_hi                                        ; $00F789 | |
    STA <r_tilemap_negative_address_1_hi                                        ; $00F78B | |
    STA <r_tilemap_positive_address_2_hi                                        ; $00F78D | |
    STA <r_tilemap_negative_address_2_hi                                        ; $00F78F |/
    LDA r_current_coordinates.x.w                                               ; $00F791 |\
    SEC                                                                         ; $00F794 | | Set the positive addresses based on the current X coordinate.
    SBC #31.b                                                                   ; $00F795 | |
    AND #%00111111.b                                                            ; $00F797 | |
    ASL A                                                                       ; $00F799 | |
    STA <r_tilemap_positive_address_1_lo                                        ; $00F79A | |
    CLC                                                                         ; $00F79C | |
    ADC #$80.b                                                                  ; $00F79D | |
    STA <r_tilemap_positive_address_2_lo                                        ; $00F79F |/
    LDA <r_tilemap_positive_address_1_lo                                        ; $00F7A1 |\
    STA <r_tilemap_negative_count_lo                                            ; $00F7A3 | | Adjust the counts based on the actual X coordinate.
    LDA #$80.b                                                                  ; $00F7A5 | |
    SEC                                                                         ; $00F7A7 | |
    SBC <r_tilemap_negative_count_lo                                            ; $00F7A8 | |
    STA <r_tilemap_positive_count_lo                                            ; $00F7AA |/
    STZ reg_ppu_vmainc                                                          ; $00F7AC |\
    JSR _init_dma_bank_0_to_vram                                                ; $00F7AF | | Do a DMA transfer from the pending tiles area to VRAM. This
    STZ reg_cpu_dmap0                                                           ; $00F7B2 | | transfer copies the top row of positive tiles.
    LDX <r_tilemap_positive_address_1                                           ; $00F7B5 | |
    STX reg_ppu_vmadd                                                           ; $00F7B7 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00F7BA | |
    STX reg_cpu_a1t0                                                            ; $00F7BD | |
    LDX <r_tilemap_positive_count                                               ; $00F7C0 | |
    STX reg_cpu_das0                                                            ; $00F7C2 | |
    JSR _enable_dma_0                                                           ; $00F7C5 |/
    LDX <r_tilemap_negative_address_1                                           ; $00F7C8 |\
    STX reg_ppu_vmadd                                                           ; $00F7CA | | Do another transfer to copy the top row of negative tiles, if any.
    STZ reg_cpu_mdmaen                                                          ; $00F7CD | |
    LDX <r_tilemap_negative_count                                               ; $00F7D0 | |
    BEQ +                                                                       ; $00F7D2 | |
    STX reg_cpu_das0                                                            ; $00F7D4 | |
    JSR _enable_dma_0                                                           ; $00F7D7 |/
+   LDX <r_tilemap_positive_address_2                                           ; $00F7DA |\
    STX reg_ppu_vmadd                                                           ; $00F7DC | | Do another transfer to copy the bottom row of positive tiles.
    STZ reg_cpu_mdmaen                                                          ; $00F7DF | |
    LDX #r_tilemap_pending_tiles.w + 128                                        ; $00F7E2 | |
    STX reg_cpu_a1t0                                                            ; $00F7E5 | |
    LDX <r_tilemap_positive_count                                               ; $00F7E8 | |
    STX reg_cpu_das0                                                            ; $00F7EA | |
    JSR _enable_dma_0                                                           ; $00F7ED |/
    LDX <r_tilemap_negative_address_2                                           ; $00F7F0 |\
    STX reg_ppu_vmadd                                                           ; $00F7F2 | | One more transfer to copy the bottom row of negative tiles, if any.
    STZ reg_cpu_mdmaen                                                          ; $00F7F5 | |
    LDX <r_tilemap_negative_count                                               ; $00F7F8 | |
    BEQ +                                                                       ; $00F7FA | |
    STX reg_cpu_das0                                                            ; $00F7FC | |
    JSR _enable_dma_0                                                           ; $00F7FF |/
+   INC <r_copy_outdoor_tilemap_to_vram_y                                       ; $00F802 |\
    DEC <r_copy_outdoor_tilemap_to_vram_index                                   ; $00F804 | | Repeat until all 64 lines have been copied.
    BEQ +                                                                       ; $00F806 | |
    JMP @copy_start                                                             ; $00F808 |/
+   RTS                                                                         ; $00F80B

; _copy_dungeon_tilemap_to_vram ($00:F80C)
;
; Copies a 32x32 section of the current outdoor tilemap to both the decoded
; tilemap data area in RAM as well as the actual tiles to VRAM.
_copy_dungeon_tilemap_to_vram:
    REP #FLAG_P_ACCUMULATOR                                                     ; $00F80C |\
    LDA r_current_coordinates.y.w                                               ; $00F80E | | Calculate the BG1 vertical scroll register by taking the current
    AND #$00FF.w                                                                ; $00F811 | | Y coordinate, subtracting 7, and then multiplying by 16.
    SEC                                                                         ; $00F814 | |
    SBC #$0007.w                                                                ; $00F815 | |
    ASL A                                                                       ; $00F818 | |
    ASL A                                                                       ; $00F819 | |
    ASL A                                                                       ; $00F81A | |
    ASL A                                                                       ; $00F81B | |
    STA <r_scroll_bg1_vertical                                                  ; $00F81C |/
    LDA r_current_coordinates.x.w                                               ; $00F81E |\
    AND #$00FF.w                                                                ; $00F821 | | Calculate the horizontal scroll register in the same way.
    SEC                                                                         ; $00F824 | |
    SBC #$0007.w                                                                ; $00F825 | |
    ASL A                                                                       ; $00F828 | |
    ASL A                                                                       ; $00F829 | |
    ASL A                                                                       ; $00F82A | |
    ASL A                                                                       ; $00F82B | |
    STA <r_scroll_bg1_horizontal                                                ; $00F82C | |
    LDA #$0000.w                                                                ; $00F82E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $00F831 |/
    JSR _load_current_dungeon_tilemap                                           ; $00F833 | Load the tilemap for the current map.
    JSR _replace_open_treasure_tiles                                            ; $00F836 | Replace any open treasure chests with the correct graphic.
    LDA #$10.b                                                                  ; $00F839 |\ Initialize the index to 16.
    STA <r_copy_dungeon_tilemap_to_vram_index                                   ; $00F83B |/
    LDA r_current_coordinates.y.w                                               ; $00F83D |\
    SEC                                                                         ; $00F840 | | Set the initial Y coordinate to the current Y coordinate minus
    SBC #7.b                                                                    ; $00F841 | | seven.
    STA <r_copy_dungeon_tilemap_to_vram_y                                       ; $00F843 |/
-   LDA <r_copy_dungeon_tilemap_to_vram_y                                       ; $00F845 |\
    AND #%00111111.b                                                            ; $00F847 | | Load the current Y coordinate and take it mod 64.
    STA <r_load_dungeon_tilemap_row_arg_coordinates.y                           ; $00F849 |/
    LDA r_current_coordinates.x.w                                               ; $00F84B |\
    SEC                                                                         ; $00F84E | | The X coordinate parameter is the current X coordinate minus 7.
    SBC #7.b                                                                    ; $00F84F | |
    STA <r_load_dungeon_tilemap_row_arg_coordinates.x                           ; $00F851 |/
    LDX <r_load_dungeon_tilemap_row_arg_coordinates                             ; $00F853 |\ Transfer the coordinates into the argument for the other function.
    STX <r_update_dungeon_tilemap_row_addresses_coordinates                     ; $00F855 |/
    JSR _load_dungeon_tilemap_row                                               ; $00F857 | Load the current tilemap row into pending tiles.
    JSR _update_dungeon_tilemap_row_addresses                                   ; $00F85A | Update the pending tile addresses based on the current coordinates.
    LDA #%10000000.b                                                            ; $00F85D |\
    STA reg_ppu_vmainc                                                          ; $00F85F | | Initialize basic DMA settings. Increment VRAM 1 by 1 on high byte.
    JSR _init_dma_bank_0_to_vram                                                ; $00F862 | | Set the DMA write to 2 address L,H.
    LDA #%00000001.b                                                            ; $00F865 | |
    STA reg_cpu_dmap0                                                           ; $00F867 |/
    LDX <r_tilemap_positive_address_1                                           ; $00F86A |\
    STX reg_ppu_vmadd                                                           ; $00F86C | | Copy the first row of positive tiles.
    LDX #r_tilemap_pending_tiles.w                                              ; $00F86F | |
    STX reg_cpu_a1t0                                                            ; $00F872 | |
    LDX <r_tilemap_positive_count                                               ; $00F875 | |
    STX reg_cpu_das0                                                            ; $00F877 | |
    JSR _enable_dma_0                                                           ; $00F87A |/
    LDX <r_tilemap_negative_address_1                                           ; $00F87D |\
    STX reg_ppu_vmadd                                                           ; $00F87F | | Copy the first row of negative tiles, if any.
    STZ reg_cpu_mdmaen                                                          ; $00F882 | |
    LDX <r_tilemap_negative_count                                               ; $00F885 | |
    BEQ +                                                                       ; $00F887 | |
    STX reg_cpu_das0                                                            ; $00F889 | |
    JSR _enable_dma_0                                                           ; $00F88C |/
+   LDX <r_tilemap_positive_address_2                                           ; $00F88F |\
    STX reg_ppu_vmadd                                                           ; $00F891 | | Copy the second row of positive tiles.
    STZ reg_cpu_mdmaen                                                          ; $00F894 | |
    LDX #r_tilemap_pending_tiles.w + 64                                         ; $00F897 | |
    STX reg_cpu_a1t0                                                            ; $00F89A | |
    LDX <r_tilemap_positive_count                                               ; $00F89D | |
    STX reg_cpu_das0                                                            ; $00F89F | |
    JSR _enable_dma_0                                                           ; $00F8A2 |/
    LDX <r_tilemap_negative_address_2                                           ; $00F8A5 |\
    STX reg_ppu_vmadd                                                           ; $00F8A7 | | Copy the second row of negative tiles, if any.
    STZ reg_cpu_mdmaen                                                          ; $00F8AA | |
    LDX <r_tilemap_negative_count                                               ; $00F8AD | |
    BEQ +                                                                       ; $00F8AF | |
    STX reg_cpu_das0                                                            ; $00F8B1 | |
    JSR _enable_dma_0                                                           ; $00F8B4 |/
+   INC <r_copy_dungeon_tilemap_to_vram_y                                       ; $00F8B7 |\
    DEC <r_copy_dungeon_tilemap_to_vram_index                                   ; $00F8B9 | | Increment the row and loop until 16 rows have been transferred.
    BEQ +                                                                       ; $00F8BB | |
    JMP -                                                                       ; $00F8BD |/
+   RTS                                                                         ; $00F8C0

; _copy_dungeon_background_tilemap_to_vram ($00:F8C1)
;
; Loads the current map's background tilemap and transfers it to VRAM to appear
; as BG2.
_copy_dungeon_background_tilemap_to_vram:
    LDA #%10000000.b                                                            ; $00F8C1 |\ Set VRAM increment to 1 by 1 on high byte.
    STA reg_ppu_vmainc                                                          ; $00F8C3 |/
    JSR _init_dma_bank_0_to_vram                                                ; $00F8C6 | Initialize some DMA parameters.
    LDA #%00000001.b                                                            ; $00F8C9 |\ Configure DMA to transfer two bytes.
    STA reg_cpu_dmap0                                                           ; $00F8CB |/
    JSR _load_background_dungeon_tilemap                                        ; $00F8CE | Load the background tilemap to RAM.
    LDA #32.b                                                                   ; $00F8D1 |\ Initialize the loop index to copy 32 rows.
    STA <r_copy_dungeon_background_tilemap_to_vram_index                        ; $00F8D3 |/
    LDA #0.b                                                                    ; $00F8D5 |\ Initialize the row number to zero.
    STA <r_copy_dungeon_background_tilemap_to_vram_y                            ; $00F8D7 |/
-   LDA <r_copy_dungeon_background_tilemap_to_vram_y                            ; $00F8D9 |\
    AND #%00011111.b                                                            ; $00F8DB | | Set the Y coordinate parameter to the current row mod 32.
    STA <r_load_dungeon_tilemap_row_arg_coordinates.y                           ; $00F8DD |/
    LDA #0.b                                                                    ; $00F8DF |\
    STA <r_load_dungeon_tilemap_row_arg_coordinates.x                           ; $00F8E1 | | Set the X coordinate to zero, and then load the corresponding
    LDX <r_load_dungeon_tilemap_row_arg_coordinates                             ; $00F8E3 | | tilemap row to pending tiles, update the VRAM addresses to write
    STX <r_update_dungeon_tilemap_row_addresses_coordinates                     ; $00F8E5 | | to, and then execute the actual transfer.
    JSR _load_dungeon_tilemap_row                                               ; $00F8E7 | |
    JSR _update_dungeon_background_tilemap_row_addresses                        ; $00F8EA | |
    JSR _copy_positive_pending_tiles_to_vram                                    ; $00F8ED |/
    LDA #16.b                                                                   ; $00F8F0 |\
    STA <r_load_dungeon_tilemap_row_arg_coordinates.x                           ; $00F8F2 | | Set the X coordinate to 16, and then repeat, to copy the second
    LDX <r_load_dungeon_tilemap_row_arg_coordinates                             ; $00F8F4 | | half of the tilemap on the right side.
    STX <r_update_dungeon_tilemap_row_addresses_coordinates                     ; $00F8F6 | |
    JSR _load_dungeon_tilemap_row                                               ; $00F8F8 | |
    JSR _update_dungeon_background_tilemap_row_addresses                        ; $00F8FB | |
    JSR _copy_positive_pending_tiles_to_vram                                    ; $00F8FE |/
    INC <r_copy_dungeon_background_tilemap_to_vram_y                            ; $00F901 |\
    DEC <r_copy_dungeon_background_tilemap_to_vram_index                        ; $00F903 | | Update the row and index and loop until all 32 rows have been
    BEQ +                                                                       ; $00F905 | | transferred.
    JMP -                                                                       ; $00F907 |/
+   RTS                                                                         ; $00F90A

; _copy_positive_pending_tiles_to_vram ($00:F90B)
;
; Copies the pending positive row to VRAM. Always copies exactly two rows of
; 32 tiles (or one 16 tile row of 16x16 tiles). Used for loading background
; tilemaps to BG2, though it doesn't specifically require that. Requires some
; DMA parameters to be already correctly set by the caller.
_copy_positive_pending_tiles_to_vram:
    LDX <r_tilemap_positive_address_1                                           ; $00F90B |\
    STX reg_ppu_vmadd                                                           ; $00F90D | | Use a DMA transfer to copy the first row of tiles.
    STZ reg_cpu_mdmaen                                                          ; $00F910 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00F913 | |
    STX reg_cpu_a1t0                                                            ; $00F916 | |
    LDX #64.w                                                                   ; $00F919 | |
    STX reg_cpu_das0                                                            ; $00F91C | |
    JSR _enable_dma_0                                                           ; $00F91F |/
    LDX <r_tilemap_positive_address_2                                           ; $00F922 |\
    STX reg_ppu_vmadd                                                           ; $00F924 | | Repeat with the second row of tiles.
    STZ reg_cpu_mdmaen                                                          ; $00F927 | |
    LDX #r_tilemap_pending_tiles.w + 64                                         ; $00F92A | |
    STX reg_cpu_a1t0                                                            ; $00F92D | |
    LDX #64.w                                                                   ; $00F930 | |
    STX reg_cpu_das0                                                            ; $00F933 | |
    JSR _enable_dma_0                                                           ; $00F936 |/
    RTS                                                                         ; $00F939

; _copy_dungeon_tilemap_changes_to_vram ($00:F93A)
;
; Copies new tiles from RAM to VRAM. The game uses 16x16 tiles, but the SNES
; internally uses 8x8 tiles, so two rows/columns of tiles are actually copied.
; The first set to transfer should be stored at $0ADB. The second set should be
; stored at $0B1B. Each set is further subdivided based on which side of the
; boundary in the tilemap they are on. The 16-bit positive count is stored in
; $95 and will copy tiles to the VRAM addresses stored in $99 and $9D. The
; 16-bit negative count is stored in $97 and will copy tiles to the VRAM
; addresses stored in $9B and $9F.
;
; This version of the function is specific to maps that use mode 0 (dungeons).
_copy_dungeon_tilemap_changes_to_vram:
    LDA <r_movement_direction                                                   ; $00F93A |\
    AND #%00000001                                                              ; $00F93C | | If moving left or right, branch to the next section.
    BNE +                                                                       ; $00F93E | |
    JMP @left_or_right                                                          ; $00F940 |/
+   LDA #%10000000                                                              ; $00F943 |\ Set VRAM increment to 1x1, high byte.
    STA reg_ppu_vmainc                                                          ; $00F945 |/
    JSR _init_dma_bank_0_to_vram                                                ; $00F948 |\
    LDA #%00000001                                                              ; $00F94B | | Copy the first set of tiles on the positive side of the boundary
    STA reg_cpu_dmap0                                                           ; $00F94D | | to VRAM.
    LDX <r_tilemap_positive_address_1                                           ; $00F950 | |
    STX reg_ppu_vmadd                                                           ; $00F952 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00F955 | |
    STX reg_cpu_a1t0                                                            ; $00F958 | |
    LDX <r_tilemap_positive_count                                               ; $00F95B | |
    STX reg_cpu_das0                                                            ; $00F95D | |
    JSR _enable_dma_0                                                           ; $00F960 |/
    LDX <r_tilemap_negative_address_1                                           ; $00F963 |\
    STX reg_ppu_vmadd                                                           ; $00F965 | | If there are any tiles on the negative side, copy those as well.
    LDX <r_tilemap_negative_count                                               ; $00F968 | |
    BEQ +                                                                       ; $00F96A | |
    STX reg_cpu_das0                                                            ; $00F96C | |
    JSR _enable_dma_0                                                           ; $00F96F |/
+   LDX <r_tilemap_positive_address_2                                           ; $00F972 |\
    STX reg_ppu_vmadd                                                           ; $00F974 | | Copy the second row of tiles on the positive side of the boundary
    LDX #r_tilemap_pending_tiles + 64.w                                         ; $00F977 | | to VRAM.
    STX reg_cpu_a1t0                                                            ; $00F97A | |
    LDX <r_tilemap_positive_count                                               ; $00F97D | |
    STX reg_cpu_das0                                                            ; $00F97F | |
    JSR _enable_dma_0                                                           ; $00F982 |/
    LDX <r_tilemap_negative_address_2                                           ; $00F985 |\
    STX reg_ppu_vmadd                                                           ; $00F987 | | If there are any on the negative side, copy those as well.
    LDX <r_tilemap_negative_count                                               ; $00F98A | |
    BEQ +                                                                       ; $00F98C | |
    STX reg_cpu_das0                                                            ; $00F98E | |
    JSR _enable_dma_0                                                           ; $00F991 |/
+   RTS                                                                         ; $00F994
@left_or_right:
    LDA <r_movement_direction                                                   ; $00F995 |\
    BNE +                                                                       ; $00F997 | | Verify that there is a non-zero movement direction.
    RTS                                                                         ; $00F999 |/
+   LDA #%10000001                                                              ; $00F99A |\
    STA reg_ppu_vmainc                                                          ; $00F99C | | Copy the first column of tiles on the positive side of the
    JSR _init_dma_bank_0_to_vram                                                ; $00F99F | | boundary.
    LDA #%00000001                                                              ; $00F9A2 | |
    STA reg_cpu_dmap0                                                           ; $00F9A4 | |
    LDX <r_tilemap_positive_address_1                                           ; $00F9A7 | |
    STX reg_ppu_vmadd                                                           ; $00F9A9 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00F9AC | |
    STX reg_cpu_a1t0                                                            ; $00F9AF | |
    LDX <r_tilemap_positive_count                                               ; $00F9B2 | |
    STX reg_cpu_das0                                                            ; $00F9B4 | |
    JSR _enable_dma_0                                                           ; $00F9B7 |/
    LDX <r_tilemap_negative_address_1                                           ; $00F9BA |\
    STX reg_ppu_vmadd                                                           ; $00F9BC | | Copy any tiles in the first column on the negative side of the
    LDX <r_tilemap_negative_count                                               ; $00F9BF | | boundary.
    BEQ +                                                                       ; $00F9C1 | |
    STX reg_cpu_das0                                                            ; $00F9C3 | |
    JSR _enable_dma_0                                                           ; $00F9C6 |/
+   LDX <r_tilemap_positive_address_2                                           ; $00F9C9 |\
    STX reg_ppu_vmadd                                                           ; $00F9CB | | Copy the second column of tiles on the positive side of the
    LDX #r_tilemap_pending_tiles + 64.w                                         ; $00F9CE | | boundary.
    STX reg_cpu_a1t0                                                            ; $00F9D1 | |
    LDX <r_tilemap_positive_count                                               ; $00F9D4 | |
    STX reg_cpu_das0                                                            ; $00F9D6 | |
    JSR _enable_dma_0                                                           ; $00F9D9 |/
    LDX <r_tilemap_negative_address_2                                           ; $00F9DC |\
    STX reg_ppu_vmadd                                                           ; $00F9DE | | Copy any tiles in the second column on the negative side of the
    LDX <r_tilemap_negative_count                                               ; $00F9E1 | | boundary.
    BEQ +                                                                       ; $00F9E3 | |
    STX reg_cpu_das0                                                            ; $00F9E5 | |
    JSR _enable_dma_0                                                           ; $00F9E8 |/
+   RTS                                                                         ; $00F9EB

; _copy_tilemap_changes_to_vram ($00:F9EC)
;
; Copies new tiles from RAM to VRAM. The game uses 16x16 tiles, but the SNES
; internally uses 8x8 tiles, so two rows/columns of tiles are actually copied.
; The first set to transfer should be stored at $0ADB. The second set should be
; stored at $0B5B. Each set is further subdivided based on which side of the
; boundary in the tilemap they are on. The 16-bit positive count is stored in
; $95 and will copy tiles to the VRAM addresses stored in $99 and $9D. The
; 16-bit negative count is stored in $97 and will copy tiles to the VRAM
; addresses stored in $9B and $9F.
;
; This function is specific to maps that use mode 7 (overworld, underworld, and
; the moon).
_copy_tilemap_changes_to_vram:
    LDA <r_movement_direction                                                   ; $00F9EC |\
    AND #%00000001                                                              ; $00F9EE | | If moving left or right, branch to the next section.
    BNE +                                                                       ; $00F9F0 | |
    JMP @left_or_right                                                          ; $00F9F2 |/
+   STZ reg_ppu_vmainc                                                          ; $00F9F5 |\
    JSR _init_dma_bank_0_to_vram                                                ; $00F9F8 | | Copy the first set of tiles on the positive side of the boundary
    STZ reg_cpu_dmap0                                                           ; $00F9FB | | to VRAM.
    LDX <r_tilemap_positive_address_1                                           ; $00F9FE | |
    STX reg_ppu_vmadd                                                           ; $00FA00 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00FA03 | |
    STX reg_cpu_a1t0                                                            ; $00FA06 | |
    LDX <r_tilemap_positive_count                                               ; $00FA09 | |
    STX reg_cpu_das0                                                            ; $00FA0B | |
    JSR _enable_dma_0                                                           ; $00FA0E |/
    LDX <r_tilemap_negative_address_1                                           ; $00FA11 |\
    STX reg_ppu_vmadd                                                           ; $00FA13 | | If there are tiles on the negative side of the boundary, copy
    LDX <r_tilemap_negative_count                                               ; $00FA16 | | those to VRAM as well.
    BEQ +                                                                       ; $00FA18 | |
    STX reg_cpu_das0                                                            ; $00FA1A | |
    JSR _enable_dma_0                                                           ; $00FA1D |/
+   LDX <r_tilemap_positive_address_2                                           ; $00FA20 |\
    STX reg_ppu_vmadd                                                           ; $00FA22 | | Copy the second row of tiles on the positive side of the boundary
    LDX #r_tilemap_pending_tiles + 128.w                                        ; $00FA25 | | to VRAM.
    STX reg_cpu_a1t0                                                            ; $00FA28 | |
    LDX <r_tilemap_positive_count                                               ; $00FA2B | |
    STX reg_cpu_das0                                                            ; $00FA2D | |
    JSR _enable_dma_0                                                           ; $00FA30 |/
    LDX <r_tilemap_negative_address_2                                           ; $00FA33 |\
    STX reg_ppu_vmadd                                                           ; $00FA35 | | Copy the second row of tiles on the negative side of the boundary,
    LDX <r_tilemap_negative_count                                               ; $00FA38 | | if any, to VRAM.
    BEQ +                                                                       ; $00FA3A | |
    STX reg_cpu_das0                                                            ; $00FA3C | |
    JSR _enable_dma_0                                                           ; $00FA3F |/
+   RTS                                                                         ; $00FA42
@left_or_right:
    LDA <r_movement_direction                                                   ; $00FA43 |\
    BNE +                                                                       ; $00FA45 | | Verify that there was a movement direction.
    RTS                                                                         ; $00FA47 |/
+   LDA #$03                                                                    ; $00FA48 |\ Set VRAM increment to 128x128, low byte.
    STA reg_ppu_vmainc                                                          ; $00FA4A |/
    JSR _init_dma_bank_0_to_vram                                                ; $00FA4D |\
    STZ reg_cpu_dmap0                                                           ; $00FA50 | | Copy the first column of tiles on the positive side of the
    LDX <r_tilemap_positive_address_1                                           ; $00FA53 | | boundary from RAM to VRAM.
    STX reg_ppu_vmadd                                                           ; $00FA55 | |
    LDX #r_tilemap_pending_tiles.w                                              ; $00FA58 | |
    STX reg_cpu_a1t0                                                            ; $00FA5B | |
    LDX <r_tilemap_positive_count                                               ; $00FA5E | |
    STX reg_cpu_das0                                                            ; $00FA60 | |
    JSR _enable_dma_0                                                           ; $00FA63 |/
    LDX <r_tilemap_negative_address_1                                           ; $00FA66 |\
    STX reg_ppu_vmadd                                                           ; $00FA68 | | Copy the first column of tiles on the negative side of the
    LDX <r_tilemap_negative_count                                               ; $00FA6B | | boundary from RAM to VRAM.
    BEQ +                                                                       ; $00FA6D | |
    STX reg_cpu_das0                                                            ; $00FA6F | |
    JSR _enable_dma_0                                                           ; $00FA72 |/
+   LDX <r_tilemap_positive_address_2                                           ; $00FA75 |\
    STX reg_ppu_vmadd                                                           ; $00FA77 | | Copy the second column of tiles on the positive side of the
    LDX #r_tilemap_pending_tiles + 128.w                                        ; $00FA7A | | boundary from RAM to VRAM.
    STX reg_cpu_a1t0                                                            ; $00FA7D | |
    LDX <r_tilemap_positive_count                                               ; $00FA80 | |
    STX reg_cpu_das0                                                            ; $00FA82 | |
    JSR _enable_dma_0                                                           ; $00FA85 |/
    LDX <r_tilemap_negative_address_2                                           ; $00FA88 |\
    STX reg_ppu_vmadd                                                           ; $00FA8A | | Copy the second column of tiles on the negative side of the
    LDX <r_tilemap_negative_count                                               ; $00FA8D | | boundary from RAM to VRAM.
    BEQ +                                                                       ; $00FA8F | |
    STX reg_cpu_das0                                                            ; $00FA91 | |
    JSR _enable_dma_0                                                           ; $00FA94 |/
+   RTS                                                                         ; $00FA97

; _load_outdoor_tilemap_row ($00:FA98)
;
; Based on the current movement direction and the passed in current Y
; coordinate, loads the next row of tiles as appropriate. Note that this
; function appears to be bugged in that it will always load a row even if
; moving horizontally. This doesn't appear to negatively impact anything, but
; is interesting to note.
;
; If the player is not moving or is moving left or up, the passed in row minus
; 31 will be the read row. If the player is moving right or down, it will
; instead be the passed row plus 32.
_load_outdoor_tilemap_row:
    LDA <r_movement_direction                                                   ; $00FA98 |\  BUG?: This looks like a check to only run this function if there
    AND #MOVEMENT_DIRECTION_VERTICAL.b                                          ; $00FA9A | | is vertical movement, but the instruction to return is missing.
    BNE +                                                                       ; $00FA9C |/  There's no negative effect, it's just a waste.
+   LDA r_map_area_outdoor.w                                                    ; $00FA9E |\ Transfer the outdoor map area to the X register.
    TAX                                                                         ; $00FAA1 |/
    LDA <r_movement_direction                                                   ; $00FAA2 |\
    AND #MOVEMENT_DIRECTION_POSITIVE.b                                          ; $00FAA4 | | If the player is moving up (or left, due to the bug), set the
    BNE +                                                                       ; $00FAA6 | | row to load equal to the current Y coordinate minus 31. This is
    LDA r_load_outdoor_tilemap_row_arg_y.w                                      ; $00FAA8 | | also the result if there is no movement happening (such as during
    SEC                                                                         ; $00FAAB | | an initial load).
    SBC #31.b                                                                   ; $00FAAC | |
    AND outdoor_tilemap_coordinate_mask_data.w,X                                ; $00FAAE | |
    JMP ++                                                                      ; $00FAB1 |/
+   LDA r_load_outdoor_tilemap_row_arg_y.w                                      ; $00FAB4 |\
    CLC                                                                         ; $00FAB7 | | If the player is moving down (or right), set the row to load equal
    ADC #32.b                                                                   ; $00FAB8 | | to the current Y coordinate plus 32.
    AND outdoor_tilemap_coordinate_mask_data.w,X                                ; $00FABA |/
++  STA <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FABD |\
    STA <r_replace_overworld_plot_tiles_arg_y                                   ; $00FABF | | Put the target row in both the parameter for the plot-related tile
    STZ <r_load_outdoor_tilemap_row_arg_index_hi                                ; $00FAC1 | | replacement and into the index to load variable. Afterward, set
    STZ <r_unknown_0644                                                         ; $00FAC3 | | the target offset in the tilemap data to the target Y coordinate
    LDA <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FAC5 | | mod 64 (as 64 rows are stored in the tilemap data). Finally,
    AND #%00111111.b                                                            ; $00FAC7 | | multiply the index by two as each row has a two byte offset stored
    STA <r_load_outdoor_tilemap_row_arg_offset_hi                               ; $00FAC9 | | in the table.
    STZ <r_load_outdoor_tilemap_row_arg_offset_lo                               ; $00FACB | |
    ASL <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FACD | | TODO: Identify the purpose of zeroing $0644.
    ROL <r_load_outdoor_tilemap_row_arg_index_hi                                ; $00FACF |/
    LDA r_map_area.w                                                            ; $00FAD1 |\
    BNE +                                                                       ; $00FAD4 | | Call the appropriate tilemap loading function depending on the
    JSR _load_overworld_tilemap_row                                             ; $00FAD6 | | current map area.
    JSL bank15.replace_overworld_plot_tiles                                     ; $00FAD9 | |
    RTS                                                                         ; $00FADD | |
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $00FADE | |
    BNE +                                                                       ; $00FAE0 | |
    JSR _load_underworld_tilemap_row                                            ; $00FAE2 | |
    RTS                                                                         ; $00FAE5 | |
+   JSR _load_moon_tilemap_row                                                  ; $00FAE6 |/
    RTS                                                                         ; $00FAE9

; _load_overworld_tilemap_row ($00:FAEA)
;
; Loads a single row of the overworld tilemap from ROM to the tilemap data array
; in RAM. The desired row can be specified by placing the Y coordinate times two
; in $063D (16 bits). Additionally, the desired destination offset to the
; tilemap data array should be placed in $0640.
;
; The actual decoding process is fairly simple, with most of the data using a
; simple run-length encoding method. If the read value is $80 or greater, the
; tile number is determined from the lower seven bits and the number of tiles is
; determined by the next byte.
;
; If the tile number is $00, $10, $20 or $30, four hardcoded tiles are copied
; instead. Finally, the remaining values are directly copied into the array.
_load_overworld_tilemap_row:
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FAEA |\
    LDA bank16.overworld_tilemap_offset_data.l,X                                ; $00FAEC | | Using the index parameter, load the offset for the row the caller
    STA <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FAF0 | | was interested in, and put that in the X register.
    LDA bank16.overworld_tilemap_offset_data.l + 1,X                            ; $00FAF2 | |
    STA <r_load_outdoor_tilemap_row_arg_index_hi                                ; $00FAF6 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FAF8 |/
@loop_start:
    LDA bank16.overworld_tilemap_data.l,X                                       ; $00FAFA | Load the next byte from the tilemap data.
    BPL ++                                                                      ; $00FAFE |\
    AND #%01111111.b                                                            ; $00FB00 | | If the upppermost bit is set, this byte and the next one encode a
    PHA                                                                         ; $00FB02 | | sequence of multiple bytes, where the lower seven bits of the
    LDA bank16.overworld_tilemap_data.l + 1,X                                   ; $00FB03 | | first byte are the desired tile number, and the second byte is the
    TAY                                                                         ; $00FB07 | | number of tiles minus one.
    INY                                                                         ; $00FB08 | |
    PLA                                                                         ; $00FB09 | | Set these bytes in the tilemap data array indexed by the passed
    LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB0A | | offset.
-   STA r_tilemap_data.l,X                                                      ; $00FB0C | |
    INX                                                                         ; $00FB10 | | The next byte continues to be read until the storage offset is a
    DEY                                                                         ; $00FB11 | | multiple of 256.
    BNE -                                                                       ; $00FB12 | |
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB14 | |
    TXA                                                                         ; $00FB16 | |
    BEQ @end                                                                    ; $00FB17 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB19 | |
    INX                                                                         ; $00FB1B | |
    INX                                                                         ; $00FB1C | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB1D | |
    JMP @loop_start                                                             ; $00FB1F |/
++  CMP #$00.b                                                                  ; $00FB22 |\
    BEQ +                                                                       ; $00FB24 | | Otherwise, check for four special values and dispatch accordingly
    CMP #$10.b                                                                  ; $00FB26 | | if they are found.
    BEQ +                                                                       ; $00FB28 | |
    CMP #$20.b                                                                  ; $00FB2A | |
    BEQ +                                                                       ; $00FB2C | |
    CMP #$30.b                                                                  ; $00FB2E | |
    BEQ +                                                                       ; $00FB30 |/
    LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB32 |\
    STA r_tilemap_data.l,X                                                      ; $00FB34 | | Except for the four special values, all other values with the
    INX                                                                         ; $00FB38 | | highest bit unset are copied verbatim into the destination array.
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB39 | |
    TXA                                                                         ; $00FB3B | |
    BEQ @end                                                                    ; $00FB3C | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB3E | |
    INX                                                                         ; $00FB40 | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB41 | |
    JMP @loop_start                                                             ; $00FB43 |/
+   LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB46 |\
    STA r_tilemap_data.l,X                                                      ; $00FB48 | | For the remaining four special values, first calculate an offset
    INX                                                                         ; $00FB4C | | by dividing the value by 16, and then multiplying by 3.
    LSR A                                                                       ; $00FB4D | |
    LSR A                                                                       ; $00FB4E | |
    LSR A                                                                       ; $00FB4F | |
    STA <r_load_outdoor_tilemap_row_tmp                                         ; $00FB50 | |
    LSR A                                                                       ; $00FB52 | |
    CLC                                                                         ; $00FB53 | |
    ADC <r_load_outdoor_tilemap_row_tmp                                         ; $00FB54 |/
    CLC                                                                         ; $00FB56 |\
    ADC #$70.b                                                                  ; $00FB57 | | The actual values stored are the value of the initial read byte,
    STA r_tilemap_data.l,X                                                      ; $00FB59 | | and then three values calculated by adding 70, 71 and 72 to the
    INX                                                                         ; $00FB5D | | calculated offset. In practical terms, this is used for mountain
    INC A                                                                       ; $00FB5E | | ranges on the overworld, to encode the frequently used tile
    STA r_tilemap_data.l,X                                                      ; $00FB5F | | combinations more efficiently.
    INX                                                                         ; $00FB63 | |
    INC A                                                                       ; $00FB64 | |
    STA r_tilemap_data.l,X                                                      ; $00FB65 |/
    INX                                                                         ; $00FB69 |\
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB6A | | Increment the indexes and repeat the loop until the 256 bytes have
    TXA                                                                         ; $00FB6C | | been filled.
    BEQ @end                                                                    ; $00FB6D | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB6F | |
    INX                                                                         ; $00FB71 | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB72 | |
    JMP @loop_start                                                             ; $00FB74 |/
@end:
    RTS                                                                         ; $00FB77

; _load_underworld_tilemap_row ($00:FB78)
;
; Similar to the above function for the overworld, loads tilemap data from ROM
; to a specified area in the tilemap data array in RAM. It operates identically
; to the overworld version, except that it reads underworld data and that the
; four special four-tile combinations are not available.
_load_underworld_tilemap_row:
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB78 |\
    LDA bank16.underworld_tilemap_offset_data.l,X                               ; $00FB7A | | Determine the index into the tilemap data by loading it from the
    STA <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FB7E | | underworld tilemap offset table in ROM.
    LDA bank16.underworld_tilemap_offset_data.l + 1,X                           ; $00FB80 | |
    STA <r_load_outdoor_tilemap_row_arg_index_hi                                ; $00FB84 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FB86 |/
@loop_start:
    LDA bank16.underworld_tilemap_data.l,X                                      ; $00FB88 |\
    BPL +                                                                       ; $00FB8C | | If the uppermost bit of the first byte is set, this operates the
    AND #%01111111.b                                                            ; $00FB8E | | same as the overworld code above.
    PHA                                                                         ; $00FB90 | |
    LDA bank16.underworld_tilemap_data.l + 1,X                                  ; $00FB91 | |
    TAY                                                                         ; $00FB95 | |
    INY                                                                         ; $00FB96 | |
    PLA                                                                         ; $00FB97 | |
    LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FB98 | |
-   STA r_tilemap_data.l,X                                                      ; $00FB9A | |
    INX                                                                         ; $00FB9E | |
    DEY                                                                         ; $00FB9F | |
    BNE -                                                                       ; $00FBA0 | |
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBA2 | |
    TXA                                                                         ; $00FBA4 | |
    BEQ ++                                                                      ; $00FBA5 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBA7 | |
    INX                                                                         ; $00FBA9 | |
    INX                                                                         ; $00FBAA | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBAB | |
    JMP @loop_start                                                             ; $00FBAD |/
+   LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBB0 |\
    STA r_tilemap_data.l,X                                                      ; $00FBB2 | | Otherwise, the byte is stored directly in the tilemap data. The
    INX                                                                         ; $00FBB6 | | major difference from the overworld version is that there is no
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBB7 | | special set of bytes to write four tile combinations.
    TXA                                                                         ; $00FBB9 | |
    BEQ ++                                                                      ; $00FBBA | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBBC | |
    INX                                                                         ; $00FBBE | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBBF | |
    JMP @loop_start                                                             ; $00FBC1 |/
++  RTS                                                                         ; $00FBC4

; _load_moon_tilemap_row ($00:FBC5)
;
; Similar to the above function for the underworld, loads tilemap data from ROM
; to a specified area in the tilemap data array in RAM. It operates identically
; to the underworld version, except that it has special handling for the fact
; that the moon map is only 64 tiles wide instead of 256.
_load_moon_tilemap_row:
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBC5 |\
    LDA bank16.moon_tilemap_offset_data.l,X                                     ; $00FBC7 | | Determine the index into the tilemap data by reading the offset
    STA <r_load_outdoor_tilemap_row_arg_index_lo                                ; $00FBCB | | from the tilemap offset table.
    LDA bank16.moon_tilemap_offset_data.l + 1,X                                 ; $00FBCD | |
    STA <r_load_outdoor_tilemap_row_arg_index_hi                                ; $00FBD1 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBD3 |/
@loop_start:
    LDA bank16.moon_tilemap_data.l,X                                            ; $00FBD5 |\
    BPL +                                                                       ; $00FBD9 | | Similar to the overworld and underworld routines, if a byte is
    AND #%01111111.b                                                            ; $00FBDB | | $80 or greater, it and the following byte are interpreted as a
    PHA                                                                         ; $00FBDD | | run-length encoded series of tiles with the lower seven bits of
    LDA bank16.moon_tilemap_data.l + 1,X                                        ; $00FBDE | | the first byte being the tile index and the second byte being the
    TAY                                                                         ; $00FBE2 | | count minus one. The major difference is that each row is only 64
    INY                                                                         ; $00FBE3 | | tiles instead of 256.
    PLA                                                                         ; $00FBE4 | |
    LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBE5 | |
-   STA r_tilemap_data.l,X                                                      ; $00FBE7 | |
    INX                                                                         ; $00FBEB | |
    DEY                                                                         ; $00FBEC | |
    BNE -                                                                       ; $00FBED | |
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBEF | |
    TXA                                                                         ; $00FBF1 | |
    CMP #$40.b                                                                  ; $00FBF2 | |
    BEQ ++                                                                      ; $00FBF4 | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBF6 | |
    INX                                                                         ; $00FBF8 | |
    INX                                                                         ; $00FBF9 | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FBFA | |
    JMP @loop_start                                                             ; $00FBFC |/
+   LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FBFF |\
    STA r_tilemap_data.l,X                                                      ; $00FC01 | | Otherwise, the bytes are copied verbatim.
    INX                                                                         ; $00FC05 | |
    STX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FC06 | |
    TXA                                                                         ; $00FC08 | |
    CMP #$40.b                                                                  ; $00FC09 | |
    BEQ ++                                                                      ; $00FC0B | |
    LDX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FC0D | |
    INX                                                                         ; $00FC0F | |
    STX <r_load_outdoor_tilemap_row_arg_index                                   ; $00FC10 | |
    JMP @loop_start                                                             ; $00FC12 | |
++  LDY #$0040.w                                                                ; $00FC15 |/
    LDX <r_load_outdoor_tilemap_row_arg_offset                                  ; $00FC18 |\
-   LDA r_tilemap_data.l - $40,X                                                ; $00FC1A | | Each row is then copied to occupy the remaining 192 bytes, so the
    STA r_tilemap_data.l + $00,X                                                ; $00FC1E | | overall offsets into the data for each row can remain the same.
    STA r_tilemap_data.l + $40,X                                                ; $00FC22 | | The offsets look odd because the X register is the offset for the
    STA r_tilemap_data.l + $80,X                                                ; $00FC26 | | row plus the $40 that was added through the course of the above
    INX                                                                         ; $00FC2A | | code.
    DEY                                                                         ; $00FC2B | |
    BNE -                                                                       ; $00FC2C |/
    RTS                                                                         ; $00FC2E

; outdoor_tilemap_coordinate_mask_data ($00:FC2F)
;
; Indexed by an outdoor map area (overworld, underworld and moon), provides a
; bitmask to mask the coordinates of the map to ensure they stay in range.
outdoor_tilemap_coordinate_mask_data:
    .db %11111111                                                               ; $00FC2F | $00: Overworld (256 tiles)
    .db %11111111                                                               ; $00FC30 | $01: Underworld (256 tiles)
    .db %00111111                                                               ; $00FC31 | $02: Moon (64 tiles)

; _load_dungeon_tilemap ($00:FC32)
;
; Given a tilemap number in the accumulator, loads the designated tilemap to the
; tilemap data area in RAM. Do note that the tilemap number will automatically
; be incremented by $100 if the current map plane is not zero. It will also be
; incremented if the eleventh map property byte has its lowest bit set.
_load_dungeon_tilemap:
    STA <r_load_dungeon_tilemap_index_lo                                        ; $00FC32 |\ Initialize the index to the value passed in the accumulator.
    STZ <r_load_dungeon_tilemap_index_hi                                        ; $00FC34 |/
    LDA #:bank17.dungeon_tilemap_offset_data.b                                  ; $00FC36 |\ Initialize the bank to $17.
    STA <r_load_dungeon_tilemap_bank                                            ; $00FC38 |/
    LDA r_map_properties.bank_flags.w                                           ; $00FC3A |\
    AND #MAP_PROPERTIES_BANK_FLAG_HIGH_TILEMAP.b                                ; $00FC3D | | If the high tilemap flag is set in the map properties, increment
    BNE +                                                                       ; $00FC3F | | the high byte of the index. (Essentially, this is a high bit of
    LDA r_map_plane.w                                                           ; $00FC41 | | the tilemap number, which is otherwise limited to $FF.) Also
    BEQ ++                                                                      ; $00FC44 | | increment the high byte if the map plane is not zero.
+   INC <r_load_dungeon_tilemap_index_hi                                        ; $00FC46 |/
++  ASL <r_load_dungeon_tilemap_index_lo                                        ; $00FC48 |\ Multiply the index by two (as each entry is two bytes).
    ROL <r_load_dungeon_tilemap_index_hi                                        ; $00FC4A |/
    LDX <r_load_dungeon_tilemap_index                                           ; $00FC4C |\
    LDA bank17.dungeon_tilemap_offset_data.l,X                                  ; $00FC4E | | Load the offset from the offset data and use that as the new index
    STA <r_load_dungeon_tilemap_index_lo                                        ; $00FC52 | | value. (X register retains the existing index.)
    LDA bank17.dungeon_tilemap_offset_data.l + 1,X                              ; $00FC54 | |
    STA <r_load_dungeon_tilemap_index_hi                                        ; $00FC58 |/
    BPL +                                                                       ; $00FC5A |\
    INC <r_load_dungeon_tilemap_bank                                            ; $00FC5C | | If the offset is $8000 or greater, increment the bank number and
    AND #%01111111.b                                                            ; $00FC5E | | mask the topmost bit (to subtract $8000).
    STA <r_load_dungeon_tilemap_index_hi                                        ; $00FC60 |/
+   LDA bank17.dungeon_tilemap_offset_data.l + 2,X                              ; $00FC62 |\
    STA <r_load_dungeon_tilemap_index2_lo                                       ; $00FC66 | | Load the offset for the next tilemap as well. Ignore the highest
    LDA bank17.dungeon_tilemap_offset_data.l + 3,X                              ; $00FC68 | | bit, as we need to do some calculations and we're assuming that it
    AND #%01111111.b                                                            ; $00FC6C | | is no more than a few hundred bytes away.
    STA <r_load_dungeon_tilemap_index2_hi                                       ; $00FC6E |/
    LDX <r_load_dungeon_tilemap_index                                           ; $00FC70 |\
    CPX <r_load_dungeon_tilemap_index2                                          ; $00FC72 | | If the second offset is less than the first offset, add $8000 so
    BCC +                                                                       ; $00FC74 | | that it will instead be greater.
    LDA <r_load_dungeon_tilemap_index2_hi                                       ; $00FC76 | |
    CLC                                                                         ; $00FC78 | |
    ADC #$80.b                                                                  ; $00FC79 | |
    STA <r_load_dungeon_tilemap_index2_hi                                       ; $00FC7B |/
+   LDA r_map_properties.bank_flags.w                                           ; $00FC7D |\
    AND #MAP_PROPERTIES_BANK_FLAG_HIGH_TILEMAP.b                                ; $00FC80 | | If the high tilemap bit is set or if the current map plane is not
    BNE +                                                                       ; $00FC82 | | zero, increment the bank number.
    LDA r_map_plane.w                                                           ; $00FC84 | |
    BEQ ++                                                                      ; $00FC87 | |
+   INC <r_load_dungeon_tilemap_bank                                            ; $00FC89 |/
++  LDA <r_load_dungeon_tilemap_index2_lo                                       ; $00FC8B |\
    SEC                                                                         ; $00FC8D | | Calculate the number of bytes to read by subtracting the first
    SBC <r_load_dungeon_tilemap_index_lo                                        ; $00FC8E | | offset from the second offset.
    STA <r_load_dungeon_tilemap_index2_lo                                       ; $00FC90 | |
    LDA <r_load_dungeon_tilemap_index2_hi                                       ; $00FC92 | |
    SBC <r_load_dungeon_tilemap_index_hi                                        ; $00FC94 | |
    STA <r_load_dungeon_tilemap_index2_hi                                       ; $00FC96 |/
    LDY <r_load_dungeon_tilemap_index                                           ; $00FC98 | Set the Y register to the tilemap offset.
    LDX #$0000.w                                                                ; $00FC9A | Zero the X register.
    LDA <r_load_dungeon_tilemap_bank                                            ; $00FC9D |\
    PHA                                                                         ; $00FC9F | | Set the data bank register to the calculated bank number.
    PLB                                                                         ; $00FCA0 |/
-   LDA bank17.dungeon_tilemap_offset_data,Y                                    ; $00FCA1 |\ Load the next byte and copy it to the temporary tilemap data.
    STA r_dungeon_tilemap_tmp_data.l,X                                          ; $00FCA4 |/
    INX                                                                         ; $00FCA8 |\
    CPX <r_load_dungeon_tilemap_index2                                          ; $00FCA9 | | Break out of the loop once the total number of bytes is copied.
    BEQ +                                                                       ; $00FCAB |/
    INY                                                                         ; $00FCAD |\
    CPY #$8000.w                                                                ; $00FCAE | | Loop, incrementing Y each time, until it reaches $8000.
    BNE -                                                                       ; $00FCB1 |/
    LDY #$0000.w                                                                ; $00FCB3 |\
    INC <r_load_dungeon_tilemap_bank                                            ; $00FCB6 | | Since Y reached $8000, reset it back to zero and increment the
    LDA <r_load_dungeon_tilemap_bank                                            ; $00FCB8 | | bank number, setting the data bank register to the new value.
    PHA                                                                         ; $00FCBA | |
    PLB                                                                         ; $00FCBB | |
    JMP -                                                                       ; $00FCBC |/
+   LDA #$00.b                                                                  ; $00FCBF |\
    PHA                                                                         ; $00FCC1 | | Reset the data bank register to $00.
    PLB                                                                         ; $00FCC2 |/
    LDX #$0000.w                                                                ; $00FCC3 |\
    STX <r_load_dungeon_tilemap_index2                                          ; $00FCC6 | | Zero out both indexes.
    STX <r_load_dungeon_tilemap_index                                           ; $00FCC8 |/
--  LDA r_dungeon_tilemap_tmp_data.l,X                                          ; $00FCCA | Load the next byte from the tilemap data.
    BPL ++                                                                      ; $00FCCE | If the value is less than $80, skip to the relevant section.
    AND #%01111111.b                                                            ; $00FCD0 |\ Calculate the tile number by subtracting $80 and push it to the
    PHA                                                                         ; $00FCD2 |/ stack.
    LDA r_dungeon_tilemap_tmp_data.l + 1,X                                      ; $00FCD3 |\
    TAY                                                                         ; $00FCD7 | | Load the next byte, increment it, and put it in the Y register.
    INY                                                                         ; $00FCD8 |/
    PLA                                                                         ; $00FCD9 | Restore the tile number into the accumulator.
    LDX <r_load_dungeon_tilemap_index2                                          ; $00FCDA | Load the decoded offset and put it in the X register.
-   STA r_tilemap_data.l,X                                                      ; $00FCDC | Store the value in the tilemap data.
    INX                                                                         ; $00FCE0 |\ Update the decoded index.
    STX <r_load_dungeon_tilemap_index2                                          ; $00FCE1 |/
    PHA                                                                         ; $00FCE3 |\
    TXA                                                                         ; $00FCE4 | | If the low byte of the X register reaches 32, increment the high
    CMP #$20.b                                                                  ; $00FCE5 | | byte (to move to the next row) and zero out the low byte.
    BNE +                                                                       ; $00FCE7 | |
    INC <r_load_dungeon_tilemap_index2_hi                                       ; $00FCE9 | |
    STZ <r_load_dungeon_tilemap_index2_lo                                       ; $00FCEB | |
    LDX <r_load_dungeon_tilemap_index2                                          ; $00FCED | |
+   PLA                                                                         ; $00FCEF |/
    CPX #$2000.w                                                                ; $00FCF0 |\ Abort the loop once all 32 rows have been decoded.
    BEQ +++                                                                     ; $00FCF3 |/
    DEY                                                                         ; $00FCF5 |\ Decrement Y and continue looping until it reaches zero.
    BNE -                                                                       ; $00FCF6 |/
    LDX <r_load_dungeon_tilemap_index                                           ; $00FCF8 |\
    INX                                                                         ; $00FCFA | | Increment the X register by two (as we just used two bytes) and
    INX                                                                         ; $00FCFB | | return to the very start of the loop (to fetch the next byte).
    STX <r_load_dungeon_tilemap_index                                           ; $00FCFC | |
    JMP --                                                                      ; $00FCFE |/
++  LDX <r_load_dungeon_tilemap_index2                                          ; $00FD01 |\
    STA r_tilemap_data.l,X                                                      ; $00FD03 | | On the other hand, if the byte was less than $80, the byte is
    INX                                                                         ; $00FD07 | | simply copied verbatim. The same checks for the end of the row
    STX <r_load_dungeon_tilemap_index2                                          ; $00FD08 | | and the end of the full tilemap are in place, of course.
    TXA                                                                         ; $00FD0A | |
    CMP #$20.b                                                                  ; $00FD0B | |
    BNE +                                                                       ; $00FD0D | |
    STZ <r_load_dungeon_tilemap_index2_lo                                       ; $00FD0F | |
    INC <r_load_dungeon_tilemap_index2_hi                                       ; $00FD11 | |
+   LDX <r_load_dungeon_tilemap_index2                                          ; $00FD13 | |
    CPX #$2000.w                                                                ; $00FD15 | |
    BEQ +++                                                                     ; $00FD18 | |
    LDX <r_load_dungeon_tilemap_index                                           ; $00FD1A | |
    INX                                                                         ; $00FD1C | |
    STX <r_load_dungeon_tilemap_index                                           ; $00FD1D | |
    JMP --                                                                      ; $00FD1F |/
+++ RTS                                                                         ; $00FD22

; _load_current_dungeon_tilemap ($00:FD23)
;
; Loads the current dungeon tilemap, as specified by the value in $06F9.
_load_current_dungeon_tilemap:
    LDA r_tilemap.w                                                             ; $00FD23 |\ Load the current tilemap.
    JSR _load_dungeon_tilemap                                                   ; $00FD26 |/
    RTS                                                                         ; $00FD29

; _load_background_dungeon_tilemap ($00:FD2A)
;
; Loads the tilemap associated with the current map's background.
_load_background_dungeon_tilemap:
    LDA r_map_properties.background_tilemap.w                                   ; $00FD2A |\ Load the background tilemap.
    JSR _load_dungeon_tilemap                                                   ; $00FD2D |/
    RTS                                                                         ; $00FD30

UNUSED_00FD31:
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE == 1
    .dsb $000B $FF
.else
.if FF4_REVISION == 0
    .dsb $0003 $FF
.else
    .dsb $0001 $FF
.endif
.endif
.else
    .dsb $028B $FF                                                              ; $00FD31.FFAF
.endif

; init_cecil_proxy ($00:FFBC)
;
; This function calls _init_cecil, which sets up Cecil's initial statistics and
; equipment.
init_cecil_proxy:
    JSR init_cecil                                                              ; $00FFBC
    RTL                                                                         ; $00FFBF

.ends

.orga $FFE0                                                                     ; Unused native vector entries
.dw $FFFF                                                                       ; $00FFE0
.dw $FFFF                                                                       ; $00FFE2

.orga $FFF0                                                                     ; Unused emulation vector entries
.dw $FFFF                                                                       ; $00FFF0
.dw $FFFF                                                                       ; $00FFF2
