.include "header.inc"

.define r_init_character_battle_base                  $80 ; 16-bit
.define r_calculate_character_battle_record_ptr       $80 ; 16-bit
.define r_calculate_character_battle_record_ptr_lo    $80 ; 8-bit
.define r_calculate_character_battle_record_ptr_hi    $81 ; 8-bit
.define r_calculate_character_battle_equipment_ptr    $82 ; 16-bit

.define r_update_equipment_data_result_ptr            $84 ; 16-bit
.define r_update_equipment_data_result_ptr_hi         $85 ; 16-bit
.define r_update_equipment_data_base_ptr              $86 ; 16-bit
.define r_update_equipment_data_base_ptr_hi           $87 ; 16-bit

.define r_get_opposite_elements_arg                   $A9 ; 8-bit
.define r_get_timer_status_timer_offset               $A9 ; 8-bit
.define r_init_character_battle_slot                  $A9 ; 8-bit
.define r_update_equipment_data_slot                  $A9 ; 8-bit
.define r_calculate_character_battle_tmp_1            $A9 ; 16-bit
.define r_calculate_character_battle_tmp_1_lo         $A9 ; 8-bit
.define r_calculate_character_battle_tmp_1_hi         $AA ; 8-bit
.define r_get_opposite_elements_tmp                   $AA ; 8-bit

.define r_update_equipment_data_index                 $AB ; 8-bit
.define r_calculate_character_battle_tmp_2            $AB ; 16-bit
.define r_calculate_character_battle_tmp_2_lo         $AB ; 8-bit
.define r_calculate_character_battle_tmp_2_hi         $AC ; 8-bit
.define r_update_equipment_data_tmp_data              $AD ; 7-byte array
.define r_calculate_character_battle_tmp_equipment    $AD ; array

.define r_calculate_character_battle_tmp_3            $AF ; 8-bit

.define r_update_equipment_data_flags_right           $B7 ; 8-bit
.define r_update_equipment_data_flags_left            $B8 ; 8-bit

.define r_calculate_character_battle_tmp_4            $BF ; 8-bit

.define r_math_multiply_8bit_arg_1                    $DF ; 8-bit
.define r_math_multiply_8bit_arg_1_hi                 $E0 ; 8-bit
.define r_math_multiply_8bit_arg_2                    $E1 ; 8-bit
.define r_math_multiply_8bit_arg_2_hi                 $E2 ; 8-bit
.define r_math_multiply_8bit_result                   $E3 ; 16-bit
.define r_math_multiply_8bit_result_lo                $E3 ; 8-bit
.define r_math_multiply_8bit_result_hi                $E4 ; 8-bit

.bank 3 slot 1
.section "Bank" namespace "bank03"

; start_battle ($03:8000)
;
; This proxy function calls the actual function which starts the battle.
start_battle:
    JMP battle_start_battle                                                     ; $038000

; unused_start_battle ($03:8003)
;
; Unused proxy function to call battle_start_battle.
unused_start_battle:
    JMP battle_start_battle                                                     ; $038003

; calculate_character_stats ($03:8006)
;
; This is a proxy function that does nothing but jump directly to the actual
; function. The target function takes the slot number to calculate stats for
; in the accumulator. Note that this function also ultimately ends up
; initializing various areas of memory and should not be used as a general
; purpose function.
calculate_character_stats:
    JMP _calculate_character_stats_proxy                                        ; $038006

; battle_start_battle ($03:8009)
;
; Preserves existing register values and executes the code to start and run the
; battle.
battle_start_battle:
    PHP                                                                         ; $038009 | Preserve the existing state of the processor flags.
    REP #FLAG_P_INDEX | FLAG_P_ACCUMULATOR                                      ; $03800A | Enable both 16-bit accumulator and index mode.
    PHB                                                                         ; $03800C |\
    PHD                                                                         ; $03800D | | Preserve the other registers.
    PHA                                                                         ; $03800E | |
    PHX                                                                         ; $03800F | |
    PHY                                                                         ; $038010 |/
    LDA #0.w                                                                    ; $038011 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038014 | | Start the battle.
    REP #FLAG_P_INDEX                                                           ; $038016 | |
    JSR _battle_start_battle                                                    ; $038018 |/
    LDA #0.b                                                                    ; $03801B |\ Set PPU brightness to zero.
    STA reg_ppu_inidisp.l                                                       ; $03801D |/
    STA reg_cpu_hdmaen.l                                                        ; $038021 |\ Disable DMA and H-DMA.
    STA reg_cpu_mdmaen.l                                                        ; $038025 |/
    STA reg_cpu_nmitimen.l                                                      ; $038029 | Disable NMI and controller reading.
    REP #FLAG_P_INDEX | FLAG_P_ACCUMULATOR                                      ; $03802D |\
    PLY                                                                         ; $03802F | | Restore the original registers.
    PLX                                                                         ; $038030 | |
    PLA                                                                         ; $038031 | |
    PLD                                                                         ; $038032 | |
    PLB                                                                         ; $038033 | |
    PLP                                                                         ; $038034 |/
    RTL                                                                         ; $038035

; _calculate_character_stats_proxy ($03:8036)
;
; This function takes the slot number to calculate stats for in the accumulator.
; Note that this function also ultimately ends up initializing various areas of
; memory and should not be used as a general purpose function.
_calculate_character_stats_proxy:
    STA r_battle_generic_arg_slot.l                                             ; $038036 | Store the parameter in $7E3975.
    PHP                                                                         ; $03803A | Save the P register.
    REP #FLAG_P_INDEX | FLAG_P_ACCUMULATOR                                      ; $03803B | Set 16-bit accumulator and 16-bit index registers.
    PHB                                                                         ; $03803D | Save the data bank register.
    PHD                                                                         ; $03803E | Save the direct register.
    PHA                                                                         ; $03803F | Save the accumulator.
    PHX                                                                         ; $038040 | Save the X register.
    PHY                                                                         ; $038041 | Save the Y register.
    SEI                                                                         ; $038042 | Disable interrupts.
    LDA #$0000                                                                  ; $038043 | Set the accumulator 0.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038046 | Set 8-bit accumulator.
    REP #FLAG_P_INDEX                                                           ; $038048 | Set 16-bit index registers.
    LDX #$0000.w                                                                ; $03804A | Load 0 into X register.
    PHX                                                                         ; $03804D |\ Set the direct register to 0.
    PLD                                                                         ; $03804E |/
    LDA #$7E                                                                    ; $03804F |\
    PHA                                                                         ; $038051 | | Set the data bank register to $7E.
    PLB                                                                         ; $038052 |/
    JSR _calculate_character_stats                                              ; $038053 | Actually calculate the statistics.
    REP #FLAG_P_INDEX | FLAG_P_ACCUMULATOR                                      ; $038056 |\
    PLY                                                                         ; $038058 | | Restore the environment and return from the function.
    PLX                                                                         ; $038059 | |
    PLA                                                                         ; $03805A | |
    PLD                                                                         ; $03805B | |
    PLB                                                                         ; $03805C | |
    PLP                                                                         ; $03805D |/
    RTL                                                                         ; $03805E

; _battle_update_mp ($03:805F)
;
; Every four times this function is called, it calls an update to the MP dialog.
_battle_update_mp:
    LDA r_battle_update_mp_flag.w                                               ; $03805F |\
    EOR #%00000001.b                                                            ; $038062 | | Flip the low bit on the flag variable, and if the result is non-
    STA r_battle_update_mp_flag.w                                               ; $038064 | | zero, skip the rest of the function.
    BNE +++                                                                     ; $038067 |/
    LDA r_battle_update_mp_counter.w                                            ; $038069 |\
    CMP #2.b                                                                    ; $03806C | | If the counter's value is two, reset it back to zero. The result
    BNE +                                                                       ; $03806E | | is that for the following code, the counter always has a value of
    LDA #0.b                                                                    ; $038070 | | zero or one.
    STA r_battle_update_mp_counter.w                                            ; $038072 |/
+   LDA r_battle_update_mp_counter.w                                            ; $038075 |\
    BNE +                                                                       ; $038078 | | If the value of the counter is one, update the character MP
    BRA ++                                                                      ; $03807A | | dialog.
+   LDA #BATTLE_UPDATE_MODE_CHARACTER_MP.b                                      ; $03807C | |
    JSR _battle_update                                                          ; $03807E |/
++  INC r_battle_update_mp_counter.w                                            ; $038081 | Increment the counter.
+++ RTS                                                                         ; $038084

; _battle_update ($03:8085)
;
; Ultimately calls the function that does various battle-related updates
; depending on the value in the accumulator.
_battle_update:
    JSL bank02.battle_update                                                    ; $038085 | Call the battle update function in bank $02.
    RTS                                                                         ; $038089

; _battle_start_battle ($03:808A)
;
; Goes through the process of starting a battle.
_battle_start_battle:
    JSR _init_ppu                                                               ; $03808A | Initialize the PPU with battle-specific settings.
    LDX #bank14._sizeof_prng_data.w - 1                                         ; $03808D |\
-   LDA bank14.prng_data.l,X                                                    ; $038090 | | Reload the PRNG data to RAM.
    STA r_prng_data.w,X                                                         ; $038094 | |
    DEX                                                                         ; $038097 | |
    BPL -                                                                       ; $038098 |/
    JSR _battle_init_memory                                                     ; $03809A | Initialize battle memory.
    LDX #$007F.w                                                                ; $03809D |\
    TDC                                                                         ; $0380A0 | | Set the initial battle RNG index to the sum of various RAM values
    CLC                                                                         ; $0380A1 | | mod 256.
-   ADC $0600,X                                                                 ; $0380A2 | |
    DEX                                                                         ; $0380A5 | |
    BPL -                                                                       ; $0380A6 | |
    STA <r_battle_rng_index                                                     ; $0380A8 |/
    JSR _battle_initialize_action_audiovisual                                   ; $0380AA | Initializes various locations used during action processing.
    LDA r_battle_background.w                                                   ; $0380AD |\
    PHA                                                                         ; $0380B0 | | If the battle background has the magnetic bit set, set the
    PHA                                                                         ; $0380B1 | | magnetic flag for the battle.
    AND #BATTLE_BACKGROUND_MAGNETIC.b                                           ; $0380B2 | |
    STA r_battle_magnetic.w                                                     ; $0380B4 |/
    PLA                                                                         ; $0380B7 |\
    AND #BATTLE_BACKGROUND_WATER.b                                              ; $0380B8 | | Grab the water background flag and store it for later use.
    STA <r_battle_generic_tmp_1_lo                                              ; $0380BA |/
    PLA                                                                         ; $0380BC |\
    AND #(BATTLE_BACKGROUND_ALTERNATE_PALETTE | BATTLE_BACKGROUND_BACKGROUND).b ; $0380BD | | Set the actual background number from the lowest 6 bits.
    STA r_battle_background.w                                                   ; $0380BF |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $0380C2 |\
    BEQ +                                                                       ; $0380C4 | | If the water battle flag is set, explicitly set the water
    LDA #BATTLE_BACKGROUND_WATERWAY_WATER.b                                     ; $0380C6 | | background value.
    STA r_battle_background.w                                                   ; $0380C8 |/
+   LDA r_battle_formation_hi.w                                                 ; $0380CB |\
    AND #BATTLE_FORMATION_USE_ALTERNATE_SCRIPTS.b                               ; $0380CE | | If the high bit of the formation is set, use alternate scripts.
    STA r_battle_alternate_scripts.w                                            ; $0380D0 |/
    LDA r_battle_formation_hi.w                                                 ; $0380D3 |\
    AND #%01111111.b                                                            ; $0380D6 | | Mask out the alternate script bit.
    STA r_battle_formation_hi.w                                                 ; $0380D8 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0380DB |\
    LDA r_battle_formation.w                                                    ; $0380DD | | If the battle formation is $100 or greater, subtract zero from it.
    CMP #$0100.w                                                                ; $0380E0 | | It's possible this is vestigal code from an earlier version where
    BCC +                                                                       ; $0380E3 | | subtracting a value made sense. Or, it was possibly a bug that was
    SEC                                                                         ; $0380E5 | | fixed by merely patching the subtracted value rather than
    SBC #0.w                                                                    ; $0380E6 | | reassembled.
    STA r_battle_formation.w                                                    ; $0380E9 |/
+   LDA r_battle_formation.w                                                    ; $0380EC |\
    STA r_math_multiply_16bit_arg_1.w                                           ; $0380EF | | Multiply the formation number by eight to determine the offset
    LDA #_sizeof_formation_properties.w                                         ; $0380F2 | | into the formation properties data.
    STA r_math_multiply_16bit_arg_2.w                                           ; $0380F5 | |
    JSR _math_multiply_16bit                                                    ; $0380F8 | |
    TDC                                                                         ; $0380FB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0380FC | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $0380FE | |
    TDC                                                                         ; $038101 | |
    TAY                                                                         ; $038102 |/
-   LDA bank0E.formation_property_data.l,X                                      ; $038103 |\
    STA r_formation_properties.w,Y                                              ; $038107 | | Copy the formation properties for the current formation into RAM
    INY                                                                         ; $03810A | | for easy access.
    INX                                                                         ; $03810B | |
    CPY #_sizeof_formation_properties.w                                         ; $03810C | |
    BNE -                                                                       ; $03810F |/
    LDA r_formation_properties.flags1.w                                         ; $038111 |\ Copy the first set of flags to another variable.
    STA r_formation_flags1.w                                                    ; $038114 |/ TODO: Why?
    AND #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $038117 |\ Extract the back attack bit and set the back attack variable.
    STA r_formation_back_attack.w                                               ; $038119 |/
    LDX #3.w                                                                    ; $03811C |\
    TXY                                                                         ; $03811F | | Copy the (up to) three monster IDs in the battle to two separate
    DEY                                                                         ; $038120 | | areas in RAM for later use.
-   LDA r_formation_properties.w,X                                              ; $038121 | |
    STA r_monster_ids,Y                                                         ; $038124 | | Afterward, set the fourth byte of both arrays to $FF, which
    STA r_monster_ids_original,Y                                                ; $038127 | | indicates no monster. TODO: Identify if this fourth byte has some
    DEX                                                                         ; $03812A | | other purpose or if it's merely a remnant of an original plan to
    DEY                                                                         ; $03812B | | support up to four types of monsters per battle.
    BPL -                                                                       ; $03812C | |
    LDA #$FF.b                                                                  ; $03812E | |
    STA r_monster_ids.w + 3                                                     ; $038130 | |
    STA r_monster_ids_original.w + 3                                            ; $038133 |/
    TDC                                                                         ; $038136 |\
    TAX                                                                         ; $038137 | | Set the initial counts of how many monsters of each type are in
    LDA r_formation_properties.monster_counts.w                                 ; $038138 | | the battle. There can be up to three of each type in the battle,
    STA <r_battle_generic_tmp_2_lo                                              ; $03813B | | as each of the three potential types is given two bits in the
-   STZ r_monsters_remaining.w,X                                                ; $03813D | | counts variable. This code shifts out those two bits and then
    ASL <r_battle_generic_tmp_2_lo                                              ; $038140 | | moves on to the next index.
    ROL r_monsters_remaining.w,X                                                ; $038142 | |
    ASL <r_battle_generic_tmp_2_lo                                              ; $038145 | |
    ROL r_monsters_remaining.w,X                                                ; $038147 | |
    INX                                                                         ; $03814A | |
    CPX #3.w                                                                    ; $03814B | |
    BNE -                                                                       ; $03814E |/
    TDC                                                                         ; $038150 |\
    TAX                                                                         ; $038151 | | Since each monster type is limited to only three, but a given type
--  TXY                                                                         ; $038152 | | can appear in the list multiple times, this code consolidates any
    INY                                                                         ; $038153 | | duplicate entries into a single entry and updates the monsters
-   LDA r_monster_ids.w,X                                                       ; $038154 | | remaining count as well. The removed spot is replaced with $FF to
    CMP #$FF.b                                                                  ; $038157 | | indicate no monster.
    BEQ ++                                                                      ; $038159 | |
    CMP r_monster_ids.w,Y                                                       ; $03815B | |
    BNE +                                                                       ; $03815E | |
    CLC                                                                         ; $038160 | |
    LDA r_monsters_remaining.w,X                                                ; $038161 | |
    ADC r_monsters_remaining.w,Y                                                ; $038164 | |
    STA r_monsters_remaining.w,X                                                ; $038167 | |
    TDC                                                                         ; $03816A | |
    STA r_monsters_remaining.w,Y                                                ; $03816B | |
    DEC A                                                                       ; $03816E | |
    STA r_monster_ids.w,Y                                                       ; $03816F | |
+   INY                                                                         ; $038172 | |
    CPY #3.w                                                                    ; $038173 | |
    BNE -                                                                       ; $038176 | |
++  INX                                                                         ; $038178 | |
    CPX #2.w                                                                    ; $038179 | |
    BNE --                                                                      ; $03817C |/
    LDA #$FF.b                                                                  ; $03817E |\
    LDY #7.w                                                                    ; $038180 | | Initialize the monsters lot to ID index maps to $FF, to represent
-   STA r_monster_slot_to_id_index.w,Y                                          ; $038183 | | no monster in that slot.
    STA r_monster_slot_to_id_index_initial.w,Y                                  ; $038186 | |
    DEY                                                                         ; $038189 | |
    BPL -                                                                       ; $03818A |/
    INY                                                                         ; $03818C | Increment the Y register back to zero.
    TYX                                                                         ; $03818D | Also set the X register to zero.
--  LDA r_monsters_remaining.w,X                                                ; $03818E |\
    STA <r_battle_generic_tmp_2_lo                                              ; $038191 | | Properly initialize the slot to ID index maps. The monster slots
    BEQ +                                                                       ; $038193 | | are allocated in order based on the order of the IDs.
-   TXA                                                                         ; $038195 | |
    STA r_monster_slot_to_id_index.w,Y                                          ; $038196 | |
    STA r_monster_slot_to_id_index_initial,Y                                    ; $038199 | |
    INY                                                                         ; $03819C | |
    DEC <r_battle_generic_tmp_2_lo                                              ; $03819D | |
    LDA <r_battle_generic_tmp_2_lo                                              ; $03819F | |
    BNE -                                                                       ; $0381A1 | |
+   INX                                                                         ; $0381A3 | |
    CPX #3.w                                                                    ; $0381A4 | |
    BNE --                                                                      ; $0381A7 |/
    LDA r_formation_properties.arrangement.w                                    ; $0381A9 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $0381AC | | Calculate the index into the arrangement data by multiplying the
    LDA #8.b                                                                    ; $0381AE | | arrangement number by 8.
    STA <r_math_multiply_8bit_arg_2                                             ; $0381B0 | |
    JSR _math_multiply_8bit                                                     ; $0381B2 | |
    LDX <r_math_multiply_8bit_result                                            ; $0381B5 |/
    TDC                                                                         ; $0381B7 |\
    TAY                                                                         ; $0381B8 | | Copy the on-screen coordinates for each monster into RAM.
-   LDA bank0E.monster_arrangement_coordinates_data.l,X                         ; $0381B9 | |
    STA r_monster_coordinates,Y                                                 ; $0381BD | |
    INX                                                                         ; $0381C0 | |
    INY                                                                         ; $0381C1 | |
    CPY #_sizeof_r_monster_coordinates.w                                        ; $0381C2 | |
    BNE -                                                                       ; $0381C5 |/
    CLC                                                                         ; $0381C7 |\
    LDA r_monsters_remaining.1.w                                                ; $0381C8 | | Set the total remaining monsters to the sum of the number of
    ADC r_monsters_remaining.2.w                                                ; $0381CB | | each type of monster.
    ADC r_monsters_remaining.3.w                                                ; $0381CE | |
    STA r_monsters_remaining_total.w                                            ; $0381D1 |/
    LDA r_monsters_remaining.1.w                                                ; $0381D4 |\
    STA r_monster_initial_counts.1.w                                            ; $0381D7 | | Save the initial counts of each type of monster for later use.
    LDA r_monsters_remaining.2.w                                                ; $0381DA | |
    STA r_monster_initial_counts.2.w                                            ; $0381DD | |
    LDA r_monsters_remaining.3.w                                                ; $0381E0 | |
    STA r_monster_initial_counts.3.w                                            ; $0381E3 |/
    LDA r_formation_properties.target_map.w                                     ; $0381E6 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $0381E9 | | Copy the target map information for the formation from ROM to
    LDA #16.b                                                                   ; $0381EB | | memory.
    STA <r_math_multiply_8bit_arg_2                                             ; $0381ED | |
    JSR _math_multiply_8bit                                                     ; $0381EF | |
    LDX <r_math_multiply_8bit_result                                            ; $0381F2 | |
    TDC                                                                         ; $0381F4 | |
    TAY                                                                         ; $0381F5 | |
-   LDA bank0E.battle_formation_target_map_data.l,X                             ; $0381F6 | |
    STA r_battle_menu_target_map.monster,Y                                      ; $0381FA | |
    INX                                                                         ; $0381FD | |
    INY                                                                         ; $0381FE | |
    CPY #_sizeof_r_battle_menu_target_map.monster.w                             ; $0381FF | |
    BNE -                                                                       ; $038202 |/
    JSR _init_battle_data                                                       ; $038204 | Does a bunch of initialization of battle data.
    LDA r_character_battle.6.level.w                                            ; $038207 |\
    CMP #97.b                                                                   ; $03820A | | If the first monster is levels 97 through 99, set the run delay
    BCC +                                                                       ; $03820C | | based on a table in ROM. The default value is $FF, but is set to
    SEC                                                                         ; $03820E | | 3, 7 or 10, depending on the monster level.
    SBC #97.b                                                                   ; $03820F | |
    TAX                                                                         ; $038211 | |
    LDA bank13.battle_run_delay_data.l,X                                        ; $038212 | |
    STA r_battle_run_delay_timer.w                                              ; $038216 |/
+   LDA r_formation_flags2.w                                                    ; $038219 |\
    AND #FORMATION_FLAGS_2_AUDIO_TRACK.b                                        ; $03821C | | If the battle has music specified, play the appropriate audio
    LSR A                                                                       ; $03821E | | track.
    LSR A                                                                       ; $03821F | |
    CMP #BATTLE_AUDIO_TRACK_NONE.b                                              ; $038220 | |
    BEQ +                                                                       ; $038222 | |
    TAX                                                                         ; $038224 | |
    LDA bank13.battle_audio_track_data.l,X                                      ; $038225 | |
    JSL bank13.play_song_and_verify                                             ; $038229 |/
+   LDA #BATTLE_UPDATE_MODE_ANIMATE_BATTLE_START.b                              ; $03822D |\ Initialize the battle graphics and animate the start of battle.
    JSR _battle_update                                                          ; $03822F |/
    JMP _battle_main_loop                                                       ; $038232 | Jump to the main battle loop.

; _battle_init_memory ($03:8235)
;
; Does basic initialization of memory used for battle.
_battle_init_memory:
    LDX #$007F.w                                                                ; $038235 |\
-   STZ $80,X                                                                   ; $038238 | | Zero out RAM from $80 to $FF, used for various temporary
    DEX                                                                         ; $03823A | | variables.
    BPL -                                                                       ; $03823B |/
    LDX #$197D.w                                                                ; $03823D |\
-   STZ $2000.w,X                                                               ; $038240 | | Zero out RAM from $2000 to $397D.
    DEX                                                                         ; $038243 | |
    BPL -                                                                       ; $038244 |/
    LDX #_sizeof_r_battle_drops.w - 1                                           ; $038246 |\
-   STZ r_battle_drops.w,X                                                      ; $038249 | | Zero out the item drops array.
    DEX                                                                         ; $03824C | |
    BPL -                                                                       ; $03824D |/
    LDX #$0710.w                                                                ; $03824F |\
    LDA #$80.b                                                                  ; $038252 | | Write $80 every four bytes to $2C7A to $338A. This does basic
-   STA $2C7A.w,X                                                               ; $038254 | | initialization of the spell lists, battle inventory and battle
    DEX                                                                         ; $038257 | | commands.
    DEX                                                                         ; $038258 | |
    DEX                                                                         ; $038259 | |
    DEX                                                                         ; $03825A | |
    BPL -                                                                       ; $03825B |/
    LDX #$333F.w                                                                ; $03825D |\
    LDA #$FF.b                                                                  ; $038260 | | Write $FF to RAM from $397F to $6CBE. This initializes the arrays
-   STA $397F.w,X                                                               ; $038262 | | used for monster scripts.
    DEX                                                                         ; $038265 | |
    BPL -                                                                       ; $038266 |/
    LDX #_sizeof_r_battle_party_menu_queue.w - 1                                ; $038268 |\
-   STA r_battle_party_menu_queue.w,X                                           ; $03826B | | Write $FF to RAM from $3929 to $392E, which is used as the menu
    DEX                                                                         ; $03826E | | queue.
    BPL -                                                                       ; $03826F |/
    LDX #_sizeof_r_battle_monster_victim_action_index.w - 1                     ; $038271 |\
-   STA r_battle_monster_victim_action_index.w,X                                ; $038274 | | Write $FF to RAM from $35F7 to $35FE, which is the current index
    DEX                                                                         ; $038277 | | in each monster's victim action history.
    BPL -                                                                       ; $038278 |/
    STA <r_battle_active_character_slot                                         ; $03827A |\
    STA r_battle_twin_other_slot.w                                              ; $03827C | | Initialize various variables to $FF.
    STA r_battle_fusoya_bless_counter.w                                         ; $03827F | |
    STA r_battle_minimum_character_level.w                                      ; $038282 | |
    STA r_cecil_paladin_slot.w                                                  ; $038285 | |
    STA r_monster_script_chain_slot_lo.w                                        ; $038288 | |
    STA r_monster_script_chain_slot_hi.w                                        ; $03828B | |
    STA r_battle_run_delay_timer.w                                              ; $03828E |/
    LDA #BATTLE_COMMAND_CHANGE.b                                                ; $038291 |\
    STA r_battle_commands.1.change.id.w                                         ; $038293 | | Set each character's change battle command to the correct ID.
    STA r_battle_commands.2.change.id.w                                         ; $038296 | |
    STA r_battle_commands.3.change.id.w                                         ; $038299 | |
    STA r_battle_commands.4.change.id.w                                         ; $03829C | |
    STA r_battle_commands.5.change.id.w                                         ; $03829F |/
    INC A                                                                       ; $0382A2 |\
    STA r_battle_commands.1.parry.id.w                                          ; $0382A3 | | Repeat with each character's party battle command.
    STA r_battle_commands.2.parry.id.w                                          ; $0382A6 | |
    STA r_battle_commands.3.parry.id.w                                          ; $0382A9 | |
    STA r_battle_commands.4.parry.id.w                                          ; $0382AC | |
    STA r_battle_commands.5.parry.id.w                                          ; $0382AF |/
    LDA r_battle_speed.w                                                        ; $0382B2 |\
    STA r_battle_speed_delay_counter.w                                          ; $0382B5 | | Write the battle speed to two other locations in RAM.
    STA r_battle_speed_counter.w                                                ; $0382B8 |/
    LDX #_sizeof_r_battle_status_count_inner_timer.w - 2                        ; $0382BB |\
    LDA #2.b                                                                    ; $0382BE | | Initialize the inner Count timers for each slot to 2.
-   STA r_battle_status_count_inner_timer.w,X                                   ; $0382C0 | |
    STZ r_battle_status_count_inner_timer.w + 1,X                               ; $0382C3 | |
    DEX                                                                         ; $0382C6 | |
    DEX                                                                         ; $0382C7 | |
    BPL -                                                                       ; $0382C8 |/
    RTS                                                                         ; $0382CA

; _init_ppu ($03:82CB)
;
; Resets various PPU registers to provide a blank slate and sets the locations
; of different types of data in VRAM.
_init_ppu:
    LDA #$00.b                                                                  ; $0382CB |\
    PHA                                                                         ; $0382CD | | Set the data bank register to $00.
    PLB                                                                         ; $0382CE |/
    STA reg_cpu_nmitimen                                                        ; $0382CF | Disable NMI, interrupts and automatic joypad reading.
    LDX #$0000.w                                                                ; $0382D2 |\
    PHX                                                                         ; $0382D5 | | Set the direct register to $0000.
    PLD                                                                         ; $0382D6 |/
    LDA #%10000000.b                                                            ; $0382D7 |\ Enable forced blanking and set brightness to zero.
    STA reg_ppu_inidisp                                                         ; $0382D9 |/
    LDA #%00001001.b                                                            ; $0382DC |\  Set BG mode 1, with high priority BG3.
    STA reg_ppu_bgmode                                                          ; $0382DE |/
    LDX #$0000.w                                                                ; $0382E1 |\ Set the OAM address to $0000.
    STX reg_ppu_oamadd                                                          ; $0382E4 |/
    TXA                                                                         ; $0382E7 |\ Set sprite sizes to 8x8 and 16x16 and the OAM address to $0000.
    STA reg_ppu_objsel                                                          ; $0382E8 |/
    LDA #$22.b                                                                  ; $0382EB |\ Set the BG1 and BG2 tile addresses to $2000.
    STA reg_ppu_bg12nba                                                         ; $0382ED |/
    LDA #$55.b                                                                  ; $0382F0 |\ Set the BG3 and BG4 tile addresses to $5000.
    STA reg_ppu_bg34nba                                                         ; $0382F2 |/
    LDA #$63.b                                                                  ; $0382F5 |\ Set the BG1 tilemap address to $6000 and the size to 64x64.
    STA reg_ppu_bg1sc                                                           ; $0382F7 |/
    LDA #$59.b                                                                  ; $0382FA |\ Set the BG2 tilemap address to $5800 and the size to 64x32.
    STA reg_ppu_bg2sc                                                           ; $0382FC |/
    LDA #$73.b                                                                  ; $0382FF |\ Set the BG3 tilemap address to $7000 and the size to 64x64.
    STA reg_ppu_bg3sc                                                           ; $038301 |/
    STA reg_ppu_bg4sc                                                           ; $038304 | Set the BG4 tilemap address to $7000 and the size to 64x64.
    LDA #%10000000.b                                                            ; $038307 |\ Set the VRAM increment to 1 by 1 on high byte.
    STA reg_ppu_vmainc                                                          ; $038309 |/
    TDC                                                                         ; $03830C |\ Zero out the accumulator and X register.
    TAX                                                                         ; $03830D |/
    STA reg_ppu_mosaic                                                          ; $03830E | Disable mosaic.
    STA reg_ppu_bg1h0fs                                                         ; $038311 |\
    STA reg_ppu_bg1h0fs                                                         ; $038314 | | Set all the BG scroll registers to zero.
    STA reg_ppu_bg1v0fs                                                         ; $038317 | |
    STA reg_ppu_bg1v0fs                                                         ; $03831A | |
    STA reg_ppu_bg2h0fs                                                         ; $03831D | |
    STA reg_ppu_bg2h0fs                                                         ; $038320 | |
    STA reg_ppu_bg2v0fs                                                         ; $038323 | |
    STA reg_ppu_bg2v0fs                                                         ; $038326 | |
    STA reg_ppu_bg3h0fs                                                         ; $038329 | |
    STA reg_ppu_bg3h0fs                                                         ; $03832C | |
    STA reg_ppu_bg3v0fs                                                         ; $03832F | |
    STA reg_ppu_bg3v0fs                                                         ; $038332 | |
    STA reg_ppu_bg4h0fs                                                         ; $038335 | |
    STA reg_ppu_bg4h0fs                                                         ; $038338 | |
    STA reg_ppu_bg4v0fs                                                         ; $03833B | |
    STA reg_ppu_bg4v0fs                                                         ; $03833E |/
    STA reg_ppu_w12sel                                                          ; $038341 |\
    STA reg_ppu_w34sel                                                          ; $038344 | | Disable any windows.
    STA reg_ppu_wobjsel                                                         ; $038347 | |
    STA reg_ppu_wh0                                                             ; $03834A | |
    STA reg_ppu_wh1                                                             ; $03834D | |
    STA reg_ppu_wh2                                                             ; $038350 | |
    STA reg_ppu_wh3                                                             ; $038353 | |
    STX reg_ppu_wbglog                                                          ; $038356 |/
    STA reg_ppu_tm                                                              ; $038359 | Set no screens as main screen.
    STA reg_ppu_ts                                                              ; $03835C | Set no screens as sub screen.
    STA reg_ppu_tmw                                                             ; $03835F | Set no screens as window mask for main screen.
    STA reg_ppu_tsw                                                             ; $038362 | set no screens as window mask for sub screen.
    STA reg_cpu_mdmaen                                                          ; $038365 | Reset DMA.
    STA reg_cpu_hdmaen                                                          ; $038368 | Reset HDMA.
    STA reg_ppu_cgadsub                                                         ; $03836B | Disable any color math.
    STA reg_ppu_setini                                                          ; $03836E | Set normal screen parameters.
    STA reg_ppu_cgswsel                                                         ; $038371 | Disable additional color math settings.
    LDA #$7E.b                                                                  ; $038374 |\
    PHA                                                                         ; $038376 | | Set the data bank register to $7E.
    PLB                                                                         ; $038377 |/
    RTS                                                                         ; $038378

; _get_battle_rng ($03:8379)
;
; Given a minimum value in the X register and a maximum value in the
; accumulator, returns a pseudorandom value in that range.
_get_battle_rng:
    SEP #FLAG_P_INDEX                                                           ; $038379 |\ Set the minimum value to the X register value.
    STX <r_battle_rng_minimum                                                   ; $03837B |/
    CPX #$FF.b                                                                  ; $03837D |\
    BNE +                                                                       ; $03837F | | If the minimum value is $FF, simply return.
    BRA ++                                                                      ; $038381 |/
+   CMP #$00.b                                                                  ; $038383 |\ If the maximum value is set to zero, return.
    BEQ ++                                                                      ; $038385 |/
    CMP <r_battle_rng_minimum                                                   ; $038387 |\ If the maximum value equals the minimum, return.
    BEQ ++                                                                      ; $038389 |/
    LDX <r_battle_rng_index                                                     ; $03838B | Load the current RNG index into the X register.
    SEC                                                                         ; $03838D |\ Subtract the minimum from the maximum to find the range minus one.
    SBC <r_battle_rng_minimum                                                   ; $03838E |/
    CMP #$FF.b                                                                  ; $038390 |\
    BNE +                                                                       ; $038392 | | If the range includes all numbers, simply read the value from the
    LDA r_prng_data.w,X                                                         ; $038394 | | PRNG data and return.
    BRA ++                                                                      ; $038397 |/
+   INC A                                                                       ; $038399 |\
    STA r_math_divide_16bit_arg_2_lo.w                                          ; $03839A | | Divide the read RNG value by the range.
    STZ r_math_divide_16bit_arg_2_hi.w                                          ; $03839D | |
    LDA r_prng_data.w,X                                                         ; $0383A0 | |
    TAX                                                                         ; $0383A3 | |
    STX r_math_divide_16bit_arg_1.w                                             ; $0383A4 | |
    REP #FLAG_P_INDEX                                                           ; $0383A7 | |
    JSR _math_divide_16bit                                                      ; $0383A9 |/
    SEP #FLAG_P_INDEX                                                           ; $0383AC |\
    CLC                                                                         ; $0383AE | | Return the remainder of the division plus the minimum.
    LDA r_math_divide_16bit_remainder.w                                         ; $0383AF | |
    ADC <r_battle_rng_minimum                                                   ; $0383B2 | |
    INC <r_battle_rng_index                                                     ; $0383B4 | |
++  REP #FLAG_P_INDEX                                                           ; $0383B6 |/
    RTS                                                                         ; $0383B8

; _math_multiply_16bit ($03:83B9)
;
; This function multipies the 16-bit value in $393D by the 16-bit value in
; $393F. The 32-bit result is returned in $3941 (low) and $3943 (high).
_math_multiply_16bit:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0383B9 | Switch to 16-bit accumulator.
    LDX #$0010.w                                                                ; $0383BB | Initialize X to loop 16 times.
    STZ r_math_multiply_16bit_result_lo.w                                       ; $0383BE |\ Initialize result to zero.
    STZ r_math_multiply_16bit_result_hi.w                                       ; $0383C1 |/
-   ROR r_math_multiply_16bit_arg_2.w                                           ; $0383C4 |\
    BCC +                                                                       ; $0383C7 | | For each set bit of the first arg, add the second arg to the
    CLC                                                                         ; $0383C9 | | high result word. We then rotate the lowest bit into the
    LDA r_math_multiply_16bit_arg_1.w                                           ; $0383CA | | low result word. This has the effect of effectively doing
    ADC r_math_multiply_16bit_result_hi.w                                       ; $0383CD | | binary multiplication in the same way you might do it on
    STA r_math_multiply_16bit_result_hi.w                                       ; $0383D0 | | paper.
+   ROR r_math_multiply_16bit_result_hi.w                                       ; $0383D3 | |
    ROR r_math_multiply_16bit_result_lo.w                                       ; $0383D6 |/
    DEX                                                                         ; $0383D9 |\ Repeat the loop.
    BNE -                                                                       ; $0383DA |/
    TDC                                                                         ; $0383DC | Set accumulator to zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0383DD | Switch to 8-bit accumulator.
    RTS                                                                         ; $0383DF

; _math_multiply_8bit ($03:83E0)
;
; This function multiplies the 8-bit value in $DF by the 8-bit value in $E1. The
; 16-bit result is returned in $E3. Except for differences in addressing
; (direct page vs absolute) and argument size, it functions identically to
; math_multiply_16bit.
_math_multiply_8bit:
    STZ r_math_multiply_8bit_arg_1_hi                                           ; $0383E0 |\ Zero out the high bytes of the args.
    STZ r_math_multiply_8bit_arg_2_hi                                           ; $0383E2 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0383E4 | Switch to 16-bit accumulator.
    LDX #$0010.w                                                                ; $0383E6 | Initialize X to loop 16 times.
    STZ r_math_multiply_8bit_result                                             ; $0383E9 |\ Initialize result to zero.
    STZ r_math_multiply_8bit_tmp.w                                              ; $0383EB |/
-   ROR r_math_multiply_8bit_arg_2                                              ; $0383EE |\
    BCC +                                                                       ; $0383F0 | | This loop functions identically to math_multiply_16bit
    CLC                                                                         ; $0383F2 | | seen above.
    LDA r_math_multiply_8bit_arg_1                                              ; $0383F3 | |
    ADC r_math_multiply_8bit_tmp.w                                              ; $0383F5 | |
    STA r_math_multiply_8bit_tmp.w                                              ; $0383F8 | |
+   ROR r_math_multiply_8bit_tmp.w                                              ; $0383FB | |
    ROR r_math_multiply_8bit_result                                             ; $0383FE |/
    DEX                                                                         ; $038400 |\ Repeat the loop.
    BNE -                                                                       ; $038401 |/
    TDC                                                                         ; $038403 | Set accumulator to zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038404 | Switch to 8-bit accumulator.
    RTS                                                                         ; $038406

; _math_divide_16bit ($03:8407)
;
; This function divides the 16-bit value in $3945 by the 16-bit value in $3947.
; The 16-bit result is returned in $3949.
_math_divide_16bit:
    REP #FLAG_P_ACCUMULATOR                                                     ; $038407 |\
    STZ r_math_divide_16bit_result.w                                            ; $038409 | | Initialize the result variables to zero.
    STZ r_math_divide_16bit_remainder.w                                         ; $03840C |/
    LDA r_math_divide_16bit_arg_1.w                                             ; $03840F |\
    BEQ ++                                                                      ; $038412 | | If either of the parameters is zero, just jump to the end
    LDA r_math_divide_16bit_arg_2.w                                             ; $038414 | | and return zero.
    BEQ ++                                                                      ; $038417 |/
    CLC                                                                         ; $038419 |\
    LDX #$0010.w                                                                ; $03841A | | This sequence does binary long division, in much the same
-   ROL r_math_divide_16bit_arg_1.w                                             ; $03841D | | way you would do so on paper.
    ROL r_math_divide_16bit_remainder.w                                         ; $038420 | |
    SEC                                                                         ; $038423 | |
    LDA r_math_divide_16bit_remainder.w                                         ; $038424 | |
    SBC r_math_divide_16bit_arg_2.w                                             ; $038427 | |
    STA r_math_divide_16bit_remainder.w                                         ; $03842A | |
    BCS +                                                                       ; $03842D | |
    LDA r_math_divide_16bit_remainder.w                                         ; $03842F | |
    ADC r_math_divide_16bit_arg_2.w                                             ; $038432 | |
    STA r_math_divide_16bit_remainder.w                                         ; $038435 | |
    CLC                                                                         ; $038438 | |
+   ROL r_math_divide_16bit_result.w                                            ; $038439 | |
    DEX                                                                         ; $03843C | |
    BNE -                                                                       ; $03843D |/
++  TDC                                                                         ; $03843F |\ Switch to 8-bit accumulator and return.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038440 |/
    RTS                                                                         ; $038442

; _find_nth_entry ($03:8443)
;
; Given a bank number in the accumulator, a 16-bit address in the Y register,
; and a count in $E5, returns the offset to that entry in the Y register. The
; target array should be an array of records separated by $FF.
_find_nth_entry:
    STA <r_generic_tmp_ptr_bank                                                 ; $038443 | Set the target bank to the value in the accumulator.
    STY <r_generic_tmp_ptr_addr                                                 ; $038445 | Set the target address to the value in the Y register.
    TDC                                                                         ; $038447 |\ Reset the Y register to zero.
    TAY                                                                         ; $038448 |/
    LDA <r_find_nth_entry_arg_n                                                 ; $038449 |\ Load the count and branch to the end if zero.
    BEQ +++                                                                     ; $03844B |/
-   LDA [<r_generic_tmp_ptr],Y                                                  ; $03844D | Load the next value from the target data.
    CMP #$FF.b                                                                  ; $03844F |\
    BNE +                                                                       ; $038451 | | Loop through the target data until finding the requested number
    DEC <r_find_nth_entry_arg_n                                                 ; $038453 | | of $FF entries.
    LDA <r_find_nth_entry_arg_n                                                 ; $038455 | |
    BEQ ++                                                                      ; $038457 | |
+   INY                                                                         ; $038459 | |
    BRA -                                                                       ; $03845A |/
++  INY                                                                         ; $03845C | Increment Y to move to the next byte.
+++ RTS                                                                         ; $03845D

; _copy_from_array ($03:845E)
;
; This function copies a single record from an array of records. It takes three
; parameters: the size of each record in the accumulator, the desired index in
; the array to copy in $E5, and a 24-bit long pointer to the array in $80. The
; resulting bytes are copied into an array starting at $289C.
_copy_from_array:
    STA r_math_multiply_8bit_arg_2                                              ; $03845E |\
    LDA r_copy_from_array_arg_index                                             ; $038460 | | Multiply the index by the given record size and transfer
    STA r_math_multiply_8bit_arg_1                                              ; $038462 | | that result into the Y register. Copy the record size into
    LDA r_math_multiply_8bit_arg_2                                              ; $038464 | | RAM for later use.
    STA r_copy_from_array_arg_index                                             ; $038466 | |
    JSR _math_multiply_8bit                                                     ; $038468 | |
    LDY r_math_multiply_8bit_result                                             ; $03846B |/
    TDC                                                                         ; $03846D |\
    TAX                                                                         ; $03846E | | Copy the entire record from its source location to the
-   LDA [r_generic_tmp_ptr],Y                                                   ; $03846F | | result array.
    STA r_copy_from_array_result.w,X                                            ; $038471 | |
    INY                                                                         ; $038474 | |
    INX                                                                         ; $038475 | |
    CPX r_copy_from_array_arg_index                                             ; $038476 | |
    BNE -                                                                       ; $038478 |/
    RTS                                                                         ; $03847A

; _math_multiply_by_x ($03:847B)
;
; What follows is a series of functions that do simple multiplications using
; left shifts. The caller specifies the exact multiplier by jumping to a
; different location within the sequence of instructions. Only known jump
; targets are labeled.
;
; The value to be multiplied is specified in the accumulator and the result is
; returned in the accumulator.
_math_multiply_by_64:
    ASL A                                                                       ; $03847B
_math_multiply_by_32:
    ASL A                                                                       ; $03847C
_math_multiply_by_16:
    ASL A                                                                       ; $03847D
_math_multiply_by_8:
    ASL A                                                                       ; $03847E
_math_multiply_by_4:
    ASL A                                                                       ; $03847F
    ASL A                                                                       ; $038480
    RTS                                                                         ; $038481

; _math_divide_by_x ($03:8482)
;
; What follows is a series of functions that do simple divisions using right
; shifts. The caller specifies the exact divisor by jumping to a different
; location within the sequence of instructions. Only known jump targets are
; labeled.
;
; The value to be divided is specified in the accumulator and the result is
; returned in the accumulator.
_math_divide_by_64:
    LSR A                                                                       ; $038482
_math_divide_by_32:
    LSR A                                                                       ; $038483
_math_divide_by_16:
    LSR A                                                                       ; $038484
_math_divide_by_8:
    LSR A                                                                       ; $038485
_math_divide_by_4:
    LSR A                                                                       ; $038486
    LSR A                                                                       ; $038487
    RTS                                                                         ; $038488

; _calculate_offsets ($03:8489)
;
; Given a slot number in the accumulator, calculates offsets used for indexing
; into various locations in memory. The offsets calculated are:
;
;     $A6 = A * 128: Used for indexing into in-battle character/monster stats.
;   $3530 = A * 21:  Used for indexing into in-battle timer data.
;   $3532 = A * 55:  Used for indexing into in-battle equipment data.
;   $3534 = A * 28:  Used for indexing into in-battle command lists.
;   $3536 = A * 288: Used for indexing into in-battle spell lists.
_calculate_offsets:
    STA r_calculate_offsets_slot.w                                              ; $038489 | Save the desired slot number.
    STA r_math_multiply_8bit_arg_1                                              ; $03848C |\
    LDA #_sizeof_character_battle                                               ; $03848E | | Multiply the slot number by 128 to determine the offset into the
    STA r_math_multiply_8bit_arg_2                                              ; $038490 | | character battle record.
    JSR _math_multiply_8bit                                                     ; $038492 | |
    LDX r_math_multiply_8bit_result                                             ; $038495 | |
    STX <r_current_slot_offset_character_battle                                 ; $038497 |/
    LDA r_calculate_offsets_slot.w                                              ; $038499 |\
    STA r_math_multiply_8bit_arg_1                                              ; $03849C | | Multiply the slot number by 21 to determine the offset into the
    LDA #_sizeof_character_timers                                               ; $03849E | | character's timer data.
    STA r_math_multiply_8bit_arg_2                                              ; $0384A0 | |
    JSR _math_multiply_8bit                                                     ; $0384A2 | |
    LDX r_math_multiply_8bit_result                                             ; $0384A5 | |
    STX r_current_slot_offset_timer.w                                           ; $0384A7 |/
    LDA r_calculate_offsets_slot.w                                              ; $0384AA |\
    STA r_math_multiply_8bit_arg_1                                              ; $0384AD | | Multiply the slot number by 55.
    LDA #$37                                                                    ; $0384AF | |
    STA r_math_multiply_8bit_arg_2                                              ; $0384B1 | |
    JSR _math_multiply_8bit                                                     ; $0384B3 | |
    LDX r_math_multiply_8bit_result                                             ; $0384B6 | |
    STX r_current_slot_offset_equipment.w                                       ; $0384B8 |/
    LDA r_calculate_offsets_slot.w                                              ; $0384BB |\
    STA r_math_multiply_8bit_arg_1                                              ; $0384BE | | Multiply the slot number by 28 to determine the offset into the
    LDA #_sizeof_command_entry_list                                             ; $0384C0 | | character's command entry list.
    STA r_math_multiply_8bit_arg_2                                              ; $0384C2 | |
    JSR _math_multiply_8bit                                                     ; $0384C4 | |
    LDX r_math_multiply_8bit_result                                             ; $0384C7 | |
    STX r_current_slot_offset_command_list.w                                    ; $0384C9 |/
    LDA r_calculate_offsets_slot.w                                              ; $0384CC |\
    TAX                                                                         ; $0384CF | | Multiply the slot number by 288 to determine the offset into the
    STX r_math_multiply_16bit_arg_1.w                                           ; $0384D0 | | character's spell list.
    LDX #_sizeof_spell_entry.w * 72                                             ; $0384D3 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $0384D6 | |
    JSR _math_multiply_16bit                                                    ; $0384D9 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $0384DC | |
    STX r_current_slot_offset_spell_list.w                                      ; $0384DF |/
    RTS                                                                         ; $0384E2

; _math_add_16bit ($03:84E3)
;
; Given two 16-bit numbers in $3956 and $3958, adds them together and writes the
; 32-bit result in $395A.
_math_add_16bit:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0384E3 |\
    CLC                                                                         ; $0384E5 | | Add the two arguments and store the result in the two result
    LDA r_math_add_16bit_arg_1.w                                                ; $0384E6 | | variables.
    ADC r_math_add_16bit_arg_2.w                                                ; $0384E9 | |
    STA r_math_add_16bit_result_lo.w                                            ; $0384EC | |
    LDA #0.w                                                                    ; $0384EF | |
    ADC #0.w                                                                    ; $0384F2 | |
    STA r_math_add_16bit_result_hi.w                                            ; $0384F5 | |
    TDC                                                                         ; $0384F8 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0384F9 |/
    RTS                                                                         ; $0384FB

; _unused_math_subtract_16bit ($03:84FC)
;
; Given an initial 16-bit number in $395E, subtracts the 16-bit number in $3960
; and stores the 16-bit result in $3962. Appears to be unused.
_unused_math_subtract_16bit:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0384FC |\
    SEC                                                                         ; $0384FE | | Subtract the second argument from the first argument and store the
    LDA r_math_subtract_16bit_arg_1.w                                           ; $0384FF | | result.
    SBC r_math_subtract_16bit_arg_2.w                                           ; $038502 | |
    STA r_math_subtract_16bit_result.w                                          ; $038505 | |
    TDC                                                                         ; $038508 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038509 |/
    RTS                                                                         ; $03850B

; _count_set_bits ($03:850C)
;
; Given a value in the accumulator, returns the number of bits that are set in
; that value in the X register.
_count_set_bits:
    LDX #0.w                                                                    ; $03850C | Initialize the count to zero.
    LDY #8.w                                                                    ; $03850F | Initialize the number of bits to examine to 8.
-   ASL A                                                                       ; $038512 |\
    BCC +                                                                       ; $038513 | | If the next bit is set, increment the count.
    INX                                                                         ; $038515 |/
+   DEY                                                                         ; $038516 |\ Decrement the count and loop until all 8 bits are checked.
    BNE -                                                                       ; $038517 |/
    RTS                                                                         ; $038519

; _battle_command_finalize_actor_target_stats ($03:851A)
;
; Transfers the temporary target stat record at $2700 back to the main location
; in the array at $2000. If $3553 is zero, it does the same thing with the
; temporary actor stat record.
_battle_command_finalize_actor_target_stats:
    LDA r_battle_skip_character_battle_actor.w                                  ; $03851A |\ If the copying of the actor record is being skipped, branch to a
    BNE ++                                                                      ; $03851D |/ later section of the routine.
    LDA <r_battle_command_actor_slot                                            ; $03851F |\
    BPL +                                                                       ; $038521 | | Set the X register to the offset to the actor's actual stat
    AND #%01111111.b                                                            ; $038523 | | record.
    CLC                                                                         ; $038525 | |
    ADC #5.b                                                                    ; $038526 | |
+   JSR _calculate_offsets                                                      ; $038528 | |
    LDX <r_current_slot_offset_character_battle                                 ; $03852B |/
    TDC                                                                         ; $03852D |\
    TAY                                                                         ; $03852E | | Copy the entire temporary actor record back to the main location.
-   LDA r_character_battle_current_actor.w,Y                                    ; $03852F | |
    STA r_character_battle.w,X                                                  ; $038532 | |
    INX                                                                         ; $038535 | |
    INY                                                                         ; $038536 | |
    CPY #_sizeof_character_battle.w                                             ; $038537 | |
    BNE -                                                                       ; $03853A |/
++  LDA <r_battle_command_target_slot                                           ; $03853C |\
    BPL +                                                                       ; $03853E | | Set the X register ot the offset to the target's actual stat
    AND #%01111111.b                                                            ; $038540 | | record.
    CLC                                                                         ; $038542 | |
    ADC #5.b                                                                    ; $038543 | |
+   JSR _calculate_offsets                                                      ; $038545 | |
    LDX <r_current_slot_offset_character_battle                                 ; $038548 |/
    TDC                                                                         ; $03854A |\
    TAY                                                                         ; $03854B | | Copy the entire temporary target record back to the main location.
-   LDA r_character_battle_current_target.w,Y                                   ; $03854C | |
    STA r_character_battle.w,X                                                  ; $03854F | |
    INX                                                                         ; $038552 | |
    INY                                                                         ; $038553 | |
    CPY #_sizeof_character_battle.w                                             ; $038554 | |
    BNE -                                                                       ; $038557 |/
    RTS                                                                         ; $038559

; _unset_bit_x ($03:855A)
;
; Given a value in the accumulator and a bit number (with 0 being the highest
; and 7 being the lowest) in the X register, returns a byte in the accumulator
; with that bit unset and all other bits at their previous value.
_unset_bit_x:
    AND bank13.bit_unset_mask_data.l,X                                          ; $03855A | Unset the target bit.
    RTS                                                                         ; $03855E

; _set_bit_x ($03:855F)
;
; Given a value in the accumulator and a bit number (with 0 being the highest
; and 7 being the lowest) in the X register, returns a byte in the accumulator
; with that bit set (in addition to any bits that were already set).
_set_bit_x:
    ORA bank13.bit_mask_data.l,X                                                ; $03855F | Set the target bit.
    RTS                                                                         ; $038563

; _mask_bit_x ($03:8564)
;
; Given a value in the accumulator and a bit number (with 0 being the highest
; and 7 being the lowest) in the X register, returns a byte in the accumulator
; with only that bit present. The bit is not shifted from its original location.
_mask_bit_x:
    AND bank13.bit_mask_data.l,X                                                ; $038564 | Mask out the target bit.
    RTS                                                                         ; $038568

; _add_timer_offset ($03:8569)
;
; Adds the value in A to the previously computed value of the current
; character's timer offset at $3530. The 16-bit result is returned at $3598.
_add_timer_offset:
    CLC                                                                         ; $038569 | Clear the carry flag.
    ADC r_current_slot_offset_timer_lo.w                                        ; $03856A | Add the low byte of the argument to the accumulator.
    STA r_add_timer_offset_result.w                                             ; $03856D | Store the addition in the low byte of the result.
    LDA r_current_slot_offset_timer_hi.w                                        ; $038570 | Load the high byte of the argument into the accumulator.
    ADC #0.b                                                                    ; $038573 | Add any carry from the previous addition.
    STA r_add_timer_offset_result_hi.w                                          ; $038575 | Store the high byte of the result.
    RTS                                                                         ; $038578

; _get_battle_rng_0_7 ($03:8579)
;
; Returns a random value between 0 and 7, inclusive.
_get_battle_rng_0_7:
    LDX #0.w                                                                    ; $038579 |\
    LDA #7.b                                                                    ; $03857C | | Get a random value from the battle RNG in the range 0 to 7.
    JSR _get_battle_rng                                                         ; $03857E |/
    RTS                                                                         ; $038581

; _get_battle_rng_0_4 ($03:8582)
;
; Returns a random value between 0 and 4, inclusive.
_get_battle_rng_0_4:
    LDX #0.w                                                                    ; $038582 |\
    LDA #4.b                                                                    ; $038585 | | Get a random value from the battle RNG in the range 0 to 4.
    JSR _get_battle_rng                                                         ; $038587 |/
    RTS                                                                         ; $03858A

; _get_battle_rng_0_98 ($03:858B)
;
; Returns a random value between 0 and 98, inclusive.
_get_battle_rng_0_98:
    TDC                                                                         ; $03858B |\
    TAX                                                                         ; $03858C | | Gets a random value from the battle RNG in the range 0 to 98.
    LDA #98.b                                                                   ; $03858D | |
    JSR _get_battle_rng                                                         ; $03858F |/
    RTS                                                                         ; $038592

; _get_battle_rng_0_255 ($03:8593)
;
; Returns a random value between 0 and 255, inclusive.
_get_battle_rng_0_255:
    TDC                                                                         ; $038593 |\
    TAX                                                                         ; $038594 | | Gets a random value from the battle RNG in the range 0 to 255.
    LDA #$FF.b                                                                  ; $038595 | |
    JSR _get_battle_rng                                                         ; $038597 |/
    RTS                                                                         ; $03859A

; _battle_script_audiovisual_set_display_dialog_alert_0 ($03:859B)
;
; Adds commands to the audiovisual battle script at offsets 0 and 1 to display
; any pending battle alerts.
_battle_script_audiovisual_set_display_dialog_alert_0:
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03859B |\
    STA r_battle_script_audiovisual.w + 0                                       ; $03859D | | Set the codes to display the battle alert in bytes 0 and 1.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $0385A0 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $0385A2 |/
    RTS                                                                         ; $0385A5

; _battle_script_audiovisual_set_display_dialog_alert_4 ($03:85A6)
;
; Adds commands to the audiovisual battle script at offsets 4 and 5 to display
; any pending battle alerts.
_battle_script_audiovisual_set_display_dialog_alert_4:
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $0385A6 |\
    STA r_battle_script_audiovisual.w + 4                                       ; $0385A8 | | Set the codes to display the battle alert in bytes 4 and 5.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $0385AB | |
    STA r_battle_script_audiovisual.w + 5                                       ; $0385AD |/
    RTS                                                                         ; $0385B0

; _battle_script_audiovisual_set_display_dialog_alert_6 ($03:85B1)
;
; Adds commands to the audiovisual battle script at offsets 6 and 7 to display
; any pending battle alerts.
_battle_script_audiovisual_set_display_dialog_alert_6:
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $0385B1 |\
    STA r_battle_script_audiovisual.w + 6                                       ; $0385B3 | | Set the codes to display the battle alert in bytes 6 and 7.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $0385B6 | |
    STA r_battle_script_audiovisual.w + 7                                       ; $0385B8 |/
    RTS                                                                         ; $0385BB

; _increment_x_by_128 ($03:85BC)
;
; Increments the X register by 128, destroying the accumulator in the process.
_increment_x_by_128:
    REP #FLAG_P_ACCUMULATOR                                                     ; $0385BC |\
    TXA                                                                         ; $0385BE | | Increment the X register by $80.
    CLC                                                                         ; $0385BF | |
    ADC #$0080.w                                                                ; $0385C0 | |
    TAX                                                                         ; $0385C3 | |
    TDC                                                                         ; $0385C4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0385C5 | |
    RTS                                                                         ; $0385C7 |/

; _set_timer_value ($03:85C8)
;
; Sets a battle timer for the character _calculate_offsets was last used for,
; using the timer offset in the accumulator to the 16-bit value provided in $D4.
; The timer offset is the desired index multiplied by 3.
_set_timer_value:
    JSR _add_timer_offset                                                       ; $0385C8 |\ Get the offset to the desired timer value.
    LDX r_add_timer_offset_result.w                                             ; $0385CB |/
    LDA <r_set_timer_value_arg_lo                                               ; $0385CE |\
    STA r_battle_timers.1.value_lo.w,X                                          ; $0385D0 | | Set the timer value.
    LDA <r_set_timer_value_arg_hi                                               ; $0385D3 | |
    STA r_battle_timers.1.value_hi.w,X                                          ; $0385D5 |/
    RTS                                                                         ; $0385D8

; _battle_main_loop ($03:85D9)
;
; This routine is the main battle loop.
_battle_main_loop:
    LDA r_battle_speed.w                                                        ; $0385D9 |\
    TAX                                                                         ; $0385DC | | Transfer the battle speed delay plus one to the delay counter.
    LDA bank13.battle_speed_delay_data.l,X                                      ; $0385DD | |
    INC A                                                                       ; $0385E1 | |
    STA r_battle_speed_delay_counter.w                                          ; $0385E2 |/
    STZ r_battle_monster_special_transition.w                                   ; $0385E5 | Reset to no special monster transition.
-   LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $0385E8 |\ Wait for the next frame, do a bunch of dialog updates, and close
    JSR _battle_update                                                          ; $0385EA |/ the command menu if the character can't act or monsters are dead.
    LDA r_battle_paused.w                                                       ; $0385ED |\
    ORA r_battle_atb_waiting.w                                                  ; $0385F0 | | If the battle is paused or if the ATB is in wait mode, loop.
    BNE -                                                                       ; $0385F3 |/
    DEC r_battle_speed_delay_counter.w                                          ; $0385F5 |\
    LDA r_battle_speed_delay_counter.w                                          ; $0385F8 | | Wait frames until the delay counter reaches zero.
    BNE -                                                                       ; $0385FB |/
    LDA r_battle_initial_atb_alert.w                                            ; $0385FD |\
    BNE +                                                                       ; $038600 | | If the battle is not a back attack and if there is no ATB alert
    LDA r_formation_back_attack.w                                               ; $038602 | | configured, skip entirely past this next block.
    AND #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $038605 | |
    BEQ +++                                                                     ; $038607 |/
+   LDA r_formation_back_attack.w                                               ; $038609 |\
    AND #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $03860C | | If the back attack flag is set, load the code for the back attack
    BEQ +                                                                       ; $03860E | | alert.
    LDA #BATTLE_ALERT_ATTACKED_FROM_BEHIND.b                                    ; $038610 | |
    BRA ++                                                                      ; $038612 |/
+   LDA r_battle_initial_atb_alert.w                                            ; $038614 |\
    BMI +                                                                       ; $038617 | | Otherwise, load the code for either the strike first or surprised
    LDA #BATTLE_ALERT_STRIKE_FIRST.b                                            ; $038619 | | alert, depending on the ATB alert value.
    BRA ++                                                                      ; $03861B | |
+   LDA #BATTLE_ALERT_SURPRISED.b                                               ; $03861D |/
++  STA r_battle_alert_queue.w                                                  ; $03861F | Store the alert code in the battle alert queue.
    LDA #MONSTER_COMMAND_END.b                                                  ; $038622 |\ Make sure there are no other entries in the queue by writing an $FF
    STA r_battle_alert_queue.w + 1                                              ; $038624 |/ to end the scan.
    STA r_battle_script_audiovisual.w + 2                                       ; $038627 |\ Write an audiovisual script to display the pending battle alerts.
    JSR _battle_script_audiovisual_set_display_dialog_alert_0                   ; $03862A |/
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03862D |\ Animate any pending audiovisual effects.
    JSR _battle_update                                                          ; $03862F |/
    STZ r_battle_initial_atb_alert.w                                            ; $038632 |\ Zero out the ATB alert values so the alert will not be shown again.
    STZ r_formation_back_attack.w                                               ; $038635 |/
+++ LDA r_character_battle.6.level.w                                            ; $038638 |\
    CMP #99                                                                     ; $03863B | | If the monster in slot zero is level 99 and the party isn't
    BNE +                                                                       ; $03863D | | already running, set the run delay timer to 15.
    LDA r_battle_running.w                                                      ; $03863F | |
    BNE +                                                                       ; $038642 | |
    LDA #15.b                                                                   ; $038644 | |
    STA r_battle_run_delay_timer.w                                              ; $038646 |/
+   JSR _battle_decrement_timers                                                ; $038649 | Decrement the timers for each character and monster.
    LDA r_monster_script_chain_slot_lo.w                                        ; $03864C |\
    CMP #$FF                                                                    ; $03864F | | If a chain is active, skip the following two updates.
    BNE +                                                                       ; $038651 |/
    JSR _battle_update_mp                                                       ; $038653 | Updates the MP dialog every four cycles.
    JSR _battle_update_hp                                                       ; $038656 | Updates HP and applies sap and bless.
+   JSR _check_battle_status                                                    ; $038659 |\
    LDA <r_battle_status                                                        ; $03865C | | If the battle is ending, branch to battle end code.
    BNE _battle_end_battle                                                      ; $03865E |/
    LDA r_monster_script_chain_slot_lo.w                                        ; $038660 |\
    CMP #$FF                                                                    ; $038663 | | If no monster chain is active, queue any automatic actions and
    BNE +                                                                       ; $038665 | | process the menu queue.
    JSR _battle_queue_auto_actions                                              ; $038667 | |
    JSR _battle_process_menu_queue                                              ; $03866A |/
+   JSR _battle_find_next_expired_timer                                         ; $03866D | Determine if there is an expired timer.
    LDA <r_battle_timer_expired                                                 ; $038670 |\ If not, skip to the end of this function.
    BEQ +                                                                       ; $038672 |/
    JSR _get_timer_status                                                       ; $038674 | Classifies the current expired timer according to its flags.
    JSR _battle_timer_dispatch                                                  ; $038677 | Handle the expired timer.
    LDA r_get_timer_status_result.w                                             ; $03867A |\
    CMP #TIMER_STATUS_EXPIRED_COMMAND.b                                         ; $03867D | | If the expired timer was command-related, process any monster
    BNE +                                                                       ; $03867F | | counters there may be.
    JSR _battle_process_monster_counters                                        ; $038681 |/
+   JMP _battle_main_loop                                                       ; $038684 | Return to the start of the loop.

; _battle_timer_dispatch ($03:8687)
;
; Based on the timer status index at $352E, jumps to the handler for the timer.
_battle_timer_dispatch:
    LDA r_get_timer_status_result.w                                             ; $038687 |\
    ASL                                                                         ; $03868A | | Load the correct pointer based on the timer status.
    TAX                                                                         ; $03868B | |
    LDA battle_timer_jump_data.l + 0,X                                          ; $03868C | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $038690 | |
    LDA battle_timer_jump_data.l + 1,X                                          ; $038692 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $038696 | |
    LDA #:battle_timer_jump_data.b                                              ; $038698 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03869A |/
    JML [r_generic_tmp_ptr.w]                                                   ; $03869C | Jump to that pointer.

; _battle_end_battle ($03:869F)
;
; Goes through the process necessary to end the battle.
_battle_end_battle:
    JSL bank13.battle_zero_hp_if_swoon                                          ; $03869F | Zero out the HP of any character with the swoon status.
    LDA #AUDIO_MODE_VOLUME_FADE_OUT_SLOW.b                                      ; $0386A3 |\ Initially set the audio mode to fade out the volume slowly.
    STA r_battle_monster_script_flags.w                                         ; $0386A5 |/
    LDA <r_battle_current_action.manual_pending                                 ; $0386A8 |\
    BEQ +                                                                       ; $0386AA | | If there is a manual action pending, close any open menus.
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_CLOSE.b                                ; $0386AC | |
    JSR _battle_update                                                          ; $0386AE |/
+   LDA <r_battle_status                                                        ; $0386B1 |\ Transfer the battle status to another variable.
    STA r_battle_end_status.w                                                   ; $0386B3 |/
    AND #(BATTLE_STATUS_RAN_AWAY | BATTLE_STATUS_VICTORY).b                     ; $0386B6 |\ If a victory or if the party ran away, branch ahead to other code.
    BNE @victory_ran_away                                                       ; $0386B8 |/
    LDA <r_battle_status                                                        ; $0386BA |\
    AND #BATTLE_STATUS_STALEMATE.b                                              ; $0386BC | | If not a stalemate, branch to the perished code.
    BEQ @perished                                                               ; $0386BE |/
    LDA #BATTLE_UPDATE_MODE_FINALIZE_DIALOGS.b                                  ; $0386C0 |\ Update any pending dialogs.
    JSR _battle_update                                                          ; $0386C2 |/
    JSR _battle_end_backup_and_remove_status                                    ; $0386C5 | Remove various statuses from the characters.
    JSR _battle_end_copy_battle_to_field                                        ; $0386C8 | Restore most statuses and copy battle stats and inventory to field.
    JMP @next                                                                   ; $0386CB | Branch to the next segment of code.
@perished:
    LDA r_formation_flags2.w                                                    ; $0386CE |\
    AND #FORMATION_FLAGS_2_AUDIO_TRACK.b                                        ; $0386D1 | | If the battle has an audio track, set the audio mode to instead
    CMP #BATTLE_AUDIO_TRACK_NONE.b << 2                                         ; $0386D3 | | fade out quickly.
    BEQ +                                                                       ; $0386D5 | |
    LDA #AUDIO_MODE_VOLUME_FADE_OUT_FAST.b                                      ; $0386D7 | |
    STA r_battle_monster_script_flags.w                                         ; $0386D9 |/
+   LDA #BATTLE_UPDATE_MODE_CHARACTER_HP.b                                      ; $0386DC |\ Update the character HP dialog data.
    JSR _battle_update                                                          ; $0386DE |/
    LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $0386E1 |\ Wait for the next frame and do multiple updates.
    JSR _battle_update                                                          ; $0386E3 |/
    LDA #BATTLE_UPDATE_MODE_FINALIZE_DIALOGS.b                                  ; $0386E6 |\ Update any pending dialogs.
    JSR _battle_update                                                          ; $0386E8 |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_0                   ; $0386EB | Set an audiovisual script to display battle alerts.
    LDA #BATTLE_ALERT_PERISHED.b                                                ; $0386EE |\
    STA r_battle_alert_queue.w + 0                                              ; $0386F0 | | Set the alert queue to display the Perished alert.
    LDA #$FF                                                                    ; $0386F3 | |
    STA r_battle_alert_queue.w + 1                                              ; $0386F5 |/
    STA r_battle_script_audiovisual.w + 2                                       ; $0386F8 | Make sure the script ends after displaying the alerts.
    STZ r_battle_update_dialog_extra_arg_1_lo.w                                 ; $0386FB | Set the battle alert extra argument to zero.
    LDA #BATTLE_ACTION_DETAILS_ACTOR_FLAG_SILENT.b                              ; $0386FE |\ Set the flag that prevents actors from flashing when acting.
    STA r_battle_current_action_details.actor_flags.w                           ; $038700 |/
    LDA r_battle_auto.w                                                         ; $038703 |\
    BNE +                                                                       ; $038706 | | If this isn't an auto-battle, do the update to display the alerts.
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $038708 | |
    JSR _battle_update                                                          ; $03870A |/
+   BRA @next                                                                   ; $03870D | Branch ahead to the next segment.
@victory_ran_away:
    AND #BATTLE_STATUS_RAN_AWAY.b                                               ; $03870F |\ If the ran away bit isn't set, branch ahead.
    BEQ +                                                                       ; $038711 |/
    LDA #BATTLE_UPDATE_MODE_PARTY_RUN.b                                         ; $038713 |\ Display the party running away.
    JSR _battle_update                                                          ; $038715 |/
    JSR _battle_end_backup_and_remove_status                                    ; $038718 | Remove several statuses and back up the original values.
    JSR _battle_end_copy_battle_to_field                                        ; $03871B | Restore the statuses and copy the battle records to the field.
    LDA r_battle_bypass_run_timer.w                                             ; $03871E |\
    BNE @next                                                                   ; $038721 | | If the party is running away directly (without using a spell),
    JSR _battle_drop_gp                                                         ; $038723 | | run the code to potentially drop GP. Either way, branch ahead.
    BRA @next                                                                   ; $038726 |/
+   JSR _battle_check_formation_plays_fanfare                                   ; $038728 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03872B | | Play the victory fanfare. This is only done if either the battle
    BNE +                                                                       ; $03872D | | changed the music at the start or if the formation is listed in
    LDA r_formation_flags2.w                                                    ; $03872F | | the fanfare formation list.
    AND #FORMATION_FLAGS_2_AUDIO_TRACK.b                                        ; $038732 | |
    CMP #BATTLE_AUDIO_TRACK_NONE.b << 2                                         ; $038734 | |
    BEQ ++                                                                      ; $038736 | |
+   LDA #AUDIO_TRACK_FANFARE.b                                                  ; $038738 | |
    STA r_battle_song_change_track.w                                            ; $03873A | |
    INC r_battle_song_change_pending.w                                          ; $03873D |/
++  JSR _battle_end_backup_and_remove_status                                    ; $038740 | Backup the character statuses and remove most of them.
    LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $038743 |\ Wait for the next frame.
    JSR _battle_update                                                          ; $038745 |/
    JSR _battle_check_formation_skips_victory_animation                         ; $038748 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03874B | | Animate the party victory unless the formation is one that skips
    BNE +                                                                       ; $03874D | | the victory animation.
    LDA #BATTLE_UPDATE_MODE_PARTY_VICTORY.b                                     ; $03874F | |
    JSR _battle_update                                                          ; $038751 |/
+   JSR _battle_end_copy_battle_to_field                                        ; $038754 | Restore the status bytes and copy the battle data to the field.
    LDA <r_battle_status                                                        ; $038757 |\
    AND #BATTLE_STATUS_SPOILS.b                                                 ; $038759 | | If the battle skips spoils, branch past the next code.
    BEQ @next                                                                   ; $03875B |/
    JSR _battle_spoils                                                          ; $03875D | Calculate the spoils for the battle.
    JSR _battle_end_backup_and_remove_status                                    ; $038760 | Remove certain statuses from the characters.
    JSR _battle_end_copy_battle_to_field                                        ; $038763 | Restore the status bytes and copy the battle data to the field.
@next:
    TDC                                                                         ; $038766 |\
    TAX                                                                         ; $038767 | | Loop doing nothing while counting from 65536 to 0.
-   DEX                                                                         ; $038768 | | TODO: Does this serve an actual purpose?
    BNE -                                                                       ; $038769 |/
    STZ <r_battle_generic_tmp_2_lo                                              ; $03876B | Initialize the item drop flag to zero.
    LDX r_battle_formation.w                                                    ; $03876D |\
    CPX #BATTLE_FORMATION_FIRST_TRAPPED_CHEST.w                                 ; $038770 | | If this is a trapped chest formation, increment the item drop
    BCC +                                                                       ; $038773 | | flag.
    INC <r_battle_generic_tmp_2_lo                                              ; $038775 |/
+   LDX #_sizeof_r_battle_drops.w - 1                                           ; $038777 |\
-   LDA r_battle_drops.w,X                                                      ; $03877A | | Loop through the battle drops, adding in the bits of the drop. The
    ORA <r_battle_generic_tmp_2_lo                                              ; $03877D | | result is that if there are any drops, the flag will be non-zero.
    STA <r_battle_generic_tmp_2_lo                                              ; $03877F | |
    DEX                                                                         ; $038781 | |
    BPL -                                                                       ; $038782 |/
    INX                                                                         ; $038784 |\
-   DEX                                                                         ; $038785 | | Loop while counting from 65536 to 0 again.
    BNE -                                                                       ; $038786 |/
    LDA r_formation_flags2.w                                                    ; $038788 |\
    AND #FORMATION_FLAGS_2_AUDIO_TRACK.b                                        ; $03878B | | Skip the next block if this battle does not change the audio.
    CMP #BATTLE_AUDIO_TRACK_NONE.b << 2                                         ; $03878D | |
    BEQ ++                                                                      ; $03878F |/
    LDA <r_battle_generic_tmp_2_lo                                              ; $038791 |\ Skip the next block if there are any item drops.
    BNE ++                                                                      ; $038793 |/
    LDA r_battle_formation_lo.w                                                 ; $038795 |\
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL.b                                      ; $038798 | | Skip the next block if this is the final Zeromus battle.
    BNE +                                                                       ; $03879A | |
    LDA r_battle_formation_hi.w                                                 ; $03879C | |
    BNE ++                                                                      ; $03879F |/
+   LDA r_battle_monster_script_flags.w                                         ; $0387A1 |\
    STA r_play_audio_arg_mode.w                                                 ; $0387A4 | | Fade out the volume with the configured audio mode.
    JSL bank04.play_audio                                                       ; $0387A7 |/
++  LDA #255.b                                                                  ; $0387AB |\ Initialize the mosaic counter to 255 (which will be incremented to
    STA <r_battle_generic_tmp_1_lo                                              ; $0387AD |/ 0 before doing anything).
    LDA #16.b                                                                   ; $0387AF |\ Initialize the brightness value to 16.
    STA <r_battle_generic_tmp_1_hi                                              ; $0387B1 |/
-   INC <r_battle_generic_tmp_1_lo                                              ; $0387B3 | Increment the mosaic value.
    DEC <r_battle_generic_tmp_1_hi                                              ; $0387B5 | Decrement the brightness.
    LDA <r_battle_generic_tmp_1_hi                                              ; $0387B7 |\ If brightness is zero, branch to the end.
    BEQ +                                                                       ; $0387B9 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $0387BB |\ Shift the mosaic value into the correct bits.
    JSR _math_multiply_by_8                                                     ; $0387BD |/ NOTE: This may actually be a bug, and should have been 4 bits.
    ORA #%00000011.b                                                            ; $0387C0 | Enable the mosaic effect on BG1 and BG2.
    STA r_battle_ppu_mosaic.w                                                   ; $0387C2 | Set the mosaic value in the PPU register.
    LDA <r_battle_generic_tmp_1_hi                                              ; $0387C5 |\ Set the PPU brightness.
    STA r_battle_ppu_brightness.w                                               ; $0387C7 |/
    LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $0387CA |\ Wait for the next frame.
    JSR _battle_update                                                          ; $0387CC |/
    BRA -                                                                       ; $0387CF | Branch to the next loop.
+   LDA #$00.b                                                                  ; $0387D1 |\ Disable the mosaic effect.
    STA reg_ppu_mosaic.l                                                        ; $0387D3 |/
    RTS                                                                         ; $0387D7

; _battle_check_formation_plays_fanfare ($03:87D8)
;
; Sets $A9 to 1 if the formation should play the victory fanfare even if it
; doesn't change the music in general.
_battle_check_formation_plays_fanfare:
    LDX #bank13.battle_formation_always_play_fanfare_data.w                     ; $0387D8 |\
    STX <r_battle_end_arg_ptr_addr                                              ; $0387DB | | Load the pointer to the fanfare data.
    LDA #:bank13.battle_formation_always_play_fanfare_data.b                    ; $0387DD | |
    STA <r_battle_end_arg_ptr_bank                                              ; $0387DF |/
    JMP _battle_check_formation_list                                            ; $0387E1 | Check if the current formation is in that list.

; _battle_check_formation_list ($03:87E4)
;
; Given a 24-bit pointer to a list of 16-bit formations in $AB, scans the list
; to see if the current formation is in that list. If so, sets $A9 to 1.
; Otherwise, $A9 is set to 0.
_battle_check_formation_list:
    STZ <r_battle_generic_tmp_1_lo                                              ; $0387E4 | Initialize the result variable to zero.
    TDC                                                                         ; $0387E6 |\ Initialize the Y register to zero.
    TAY                                                                         ; $0387E7 |/
-   LDA [<r_battle_end_arg_ptr],Y                                               ; $0387E8 | Load the next byte.
    CMP #$FF.b                                                                  ; $0387EA |\ If the next byte is $FF, branch to the end, as the end of the list
    BEQ +++                                                                     ; $0387EC |/ has been reached.
    CMP r_battle_formation_lo.w                                                 ; $0387EE |\
    BNE +                                                                       ; $0387F1 | | Compare the current formation number with the next entry in the
    INY                                                                         ; $0387F3 | | list.
    LDA [<r_battle_end_arg_ptr],Y                                               ; $0387F4 | |
    CMP r_battle_formation_hi.w                                                 ; $0387F6 | |
    BNE ++                                                                      ; $0387F9 |/
    INC <r_battle_generic_tmp_1_lo                                              ; $0387FB |\ If it matches, increment the result variable and return.
    RTS                                                                         ; $0387FD |/
+   INY                                                                         ; $0387FE |\
++  INY                                                                         ; $0387FF | | Otherwise, continue to the next entry in the list.
    BRA -                                                                       ; $038800 |/
+++ RTS                                                                         ; $038802

; _battle_check_formation_skips_victory_animation ($03:8803)
;
; Sets $A9 to 1 if the current formation is in the list of formations that skip
; the victory animation.
_battle_check_formation_skips_victory_animation:
    LDX #bank13.battle_formation_skip_victory_animation_data.w                  ; $038803
    STX <r_battle_end_arg_ptr_addr                                              ; $038806
    LDA #:bank13.battle_formation_skip_victory_animation_data.b                 ; $038808
    STA <r_battle_end_arg_ptr_bank                                              ; $03880A
    JMP _battle_check_formation_list                                            ; $03880C

; _battle_end_backup_and_remove_status ($03:880F)
;
; Loops through the five character slots, backing up the first, second and
; fourth status bytes. Unsets all statuses except swoon, stone, toad, small,
; pig and float.
_battle_end_backup_and_remove_status:
    TDC                                                                         ; $03880F |\
    TAX                                                                         ; $038810 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $038811 |/
-   LDA r_character_battle.1.status_1.w,X                                       ; $038812 |\ Back up the character's existing first status byte.
    STA r_battle_status_backup.1.status_1.w,Y                                   ; $038815 |/
    AND #(STATUS_1_MUTE | STATUS_1_DARKNESS | STATUS_1_POISON) ~ %11111111      ; $038818 |\ Remove mute, darkness and poison from the character.
    STA r_character_battle.1.status_1.w,X                                       ; $03881A |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03881D |\ Back up the second status byte.
    STA r_battle_status_backup.1.status_2.w,Y                                   ; $038820 |/
    AND #STATUS_2_FLOAT.b                                                       ; $038823 |\ Remove all second byte statuses except float.
    STA r_character_battle.1.status_2.w,X                                       ; $038825 |/
    STZ r_character_battle.1.status_3.w,X                                       ; $038828 | Remove all statuses in the third byte.
    LDA r_character_battle.1.status_4.w,X                                       ; $03882B |\ Back up the fourth status byte.
    STA r_battle_status_backup.1.status_4.w,Y                                   ; $03882E |/
    STZ r_character_battle.1.status_4.w,X                                       ; $038831 | Remove all statuses in the fourth byte.
    JSR _increment_x_by_128                                                     ; $038834 |\
    INY                                                                         ; $038837 | | Increment the indexes and loop until all five characters have been
    INY                                                                         ; $038838 | | handled.
    INY                                                                         ; $038839 | |
    CPY #_sizeof_r_battle_status_backup.w                                       ; $03883A | |
    BNE -                                                                       ; $03883D |/
    RTS                                                                         ; $03883F

; _battle_drop_gp ($03:8840)
;
; Handles the potential dropping of GP at the end of battle.
_battle_drop_gp:
    JSR _get_battle_rng_0_98                                                    ; $038840 |\
    CMP #50.b                                                                   ; $038843 | | If a random number from 0 to 98 is less than 50, skip this code.
    BCS +                                                                       ; $038845 | |
    JMP @done                                                                   ; $038847 |/
+   LDY #0.w                                                                    ; $03884A |\ Initialize the monster type index to zero.
    STY <r_battle_generic_tmp_2                                                 ; $03884D |/
    STY r_battle_drop_gp_tmp_total_lo.w                                         ; $03884F |\ Initialize the total dropped to zero.
    STY r_battle_drop_gp_tmp_total_hi.w                                         ; $038852 |/
-   LDY <r_battle_generic_tmp_2                                                 ; $038855 |\
    LDA r_monster_ids_initial_gp.w,Y                                            ; $038857 | | Transfer the monster ID of this type to the X register.
    TAX                                                                         ; $03885A |/
    STX <r_battle_generic_tmp_1                                                 ; $03885B |\
    ASL <r_battle_generic_tmp_1_lo                                              ; $03885D | | Multiply that value by two to index the GP array.
    ROL <r_battle_generic_tmp_1_hi                                              ; $03885F | |
    LDX <r_battle_generic_tmp_1                                                 ; $038861 |/
    LDA bank0E.monster_gp_data.l + 0,X                                          ; $038863 |\
    STA r_math_multiply_16bit_arg_1_lo.w                                        ; $038867 | | Load the GP held by this monster type and save it as the first
    LDA bank0E.monster_gp_data.l + 1,X                                          ; $03886A | | multiplication argument.
    STA r_math_multiply_16bit_arg_1_hi.w                                        ; $03886E |/
    LDA r_monster_initial_counts.w,Y                                            ; $038871 |\
    TAX                                                                         ; $038874 | | Multiply that amount by the number of monsters of that type.
    STX r_math_multiply_16bit_arg_2.w                                           ; $038875 | |
    JSR _math_multiply_16bit                                                    ; $038878 |/
    CLC                                                                         ; $03887B |\
    LDA r_math_multiply_16bit_result_lo_lo.w                                    ; $03887C | | Add the result to the current total.
    ADC r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $03887F | |
    STA r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $038882 | |
    LDA r_math_multiply_16bit_result_lo_hi.w                                    ; $038885 | |
    ADC r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $038888 | |
    STA r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $03888B | |
    LDA r_math_multiply_16bit_result_hi_lo.w                                    ; $03888E | |
    ADC r_battle_drop_gp_tmp_total_hi_lo.w                                      ; $038891 | |
    STA r_battle_drop_gp_tmp_total_hi_lo.w                                      ; $038894 |/
    INC <r_battle_generic_tmp_2_lo                                              ; $038897 |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $038899 | | Increment the type index and loop until all monster types have
    CMP #3.b                                                                    ; $03889B | | been included.
    BNE -                                                                       ; $03889D |/
    LSR r_battle_drop_gp_tmp_total_hi_lo.w                                      ; $03889F |\
    ROR r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $0388A2 | | Divide the total amount of GP by four.
    ROR r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388A5 | |
    LSR r_battle_drop_gp_tmp_total_hi_lo.w                                      ; $0388A8 | |
    ROR r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $0388AB | |
    ROR r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388AE |/
    LDA r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388B1 |\
    ORA r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $0388B4 | | If not dropping any GP, skip to the end.
    BEQ @done                                                                   ; $0388B7 |/
    LDA r_party_gp.lo.w                                                         ; $0388B9 |\
    ORA r_party_gp.md.w                                                         ; $0388BC | | If the party has no GP, skip to the end.
    ORA r_party_gp.hi.w                                                         ; $0388BF | |
    BEQ @done                                                                   ; $0388C2 |/
    LDA r_party_gp.lo.w                                                         ; $0388C4 |\
    STA <r_battle_generic_tmp_1_lo                                              ; $0388C7 | | Back up the lower 16 bits of the party's existing GP.
    LDA r_party_gp.md.w                                                         ; $0388C9 | |
    STA <r_battle_generic_tmp_1_hi                                              ; $0388CC |/
    SEC                                                                         ; $0388CE |\
    LDA r_party_gp.lo.w                                                         ; $0388CF | | Subtract the calculated total from the party's existing GP.
    SBC r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388D2 | |
    STA r_party_gp.lo.w                                                         ; $0388D5 | |
    LDA r_party_gp.md.w                                                         ; $0388D8 | |
    SBC r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $0388DB | |
    STA r_party_gp.md.w                                                         ; $0388DE | |
    LDA r_party_gp.hi.w                                                         ; $0388E1 | |
    SBC r_battle_drop_gp_tmp_total_hi_lo.w                                      ; $0388E4 | |
    STA r_party_gp.hi.w                                                         ; $0388E7 |/
    BCS +                                                                       ; $0388EA |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $0388EC | | If the amount went negative, change the amount subtracted to the
    STA r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388EE | | party's initial GP and set the party's GP to zero.
    LDA <r_battle_generic_tmp_1_hi                                              ; $0388F1 | |
    STA r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $0388F3 | |
    STZ r_party_gp.lo.w                                                         ; $0388F6 | |
    STZ r_party_gp.md.w                                                         ; $0388F9 | |
    STZ r_party_gp.hi.w                                                         ; $0388FC |/
+   LDA r_battle_drop_gp_tmp_total_lo_lo.w                                      ; $0388FF |\
    STA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $038902 | | Set the dropped amount as the extra argument for the battle
    LDA r_battle_drop_gp_tmp_total_lo_hi.w                                      ; $038905 | | alerts.
    STA r_battle_update_dialog_extra_arg_1_md.w                                 ; $038908 | |
    STZ r_battle_update_dialog_extra_arg_1_hi.w                                 ; $03890B |/
    LDA #BATTLE_ALERT_DROPPED_GP.b                                              ; $03890E |\ Set the dropped GP message as a battle alert.
    STA r_battle_alert_queue.w                                                  ; $038910 |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_0                   ; $038913 | Set audiovisual code to display the alerts.
    LDA #$FF.b                                                                  ; $038916 |\ Clear the third byte of the battle alert queue.
    STA r_battle_alert_queue.w + 2                                              ; $038918 |/ TODO: Why not the second?
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03891B |\ Animate any audiovisual effects.
    JSR _battle_update                                                          ; $03891D |/
@done:
    RTS                                                                         ; $038920

; battle_timer_jump_data ($03:8921)
;
; Provides pointers to four different functions to handle different sorts of
; timer expiration.
battle_timer_jump_data:
    .addr _battle_party_enqueue                                                 ; $038921.8922 | Adds character to menu queue.
    .addr _monster_script_execute                                               ; $038923.8924 | Processes monster scripts.
    .addr _battle_command_execute                                               ; $038925.8926 | Executes the next command.
    .addr _battle_timer_expire                                                  ; $038927.8928 | Handles expiring status timers.

; _init_battle_data ($03:8929)
;
; This large, comprehensive routine does numerous battle initialization tasks,
; including the following (which is not necessarily exhaustive):
;
; - Calls routine to initialize character battle records.
; - Calls routine to set poison timers.
; - Calls routine to set back row characters.
; - Loads relevant auto-battle data.
; - Loads character spell lists.
; - Copies field inventory into the battle inventory.
; - Sets up the character equipped inventory slots.
; - Loads battle commands.
; - Loads monsters.
; - Determines if the battle is a back attack.
; - Initializes the character/monster initial action timers.
_init_battle_data:
    LDA r_battle_formation_lo.w                                                 ; $038929 |\
    CMP #<BATTLE_FORMATION_GOLBEZ_SHADOW.b                                      ; $03892C | | If the current battle is either the final battle against Zeromus
    BEQ +                                                                       ; $03892E | | or the full battle against Golbez, set the flag that makes
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL.b                                      ; $038930 | | monsters completely invincible.
    BNE ++                                                                      ; $038932 | |
+   LDA r_battle_formation_hi.w                                                 ; $038934 | |
    BEQ ++                                                                      ; $038937 | |
    INC r_monsters_invincible.w                                                 ; $038939 |/
++  JSR _init_character_battle                                                  ; $03893C | Initialize the in-battle character records.
    JSR _set_character_poison_timers                                            ; $03893F | Sets poison timers for any poisoned characters.
    JSR _set_back_row_characters                                                ; $038942 | Set the back row bit on characters in the back row.
    LDA r_formation_properties.flags2.w                                         ; $038945 |\ Save the second formation flags variable to a separate variable.
    STA r_formation_flags2.w                                                    ; $038948 |/
    AND #FORMATION_FLAGS_2_AUTO_BATTLE.b                                        ; $03894B |\ Set the auto-battle flag.
    STA r_battle_auto.w                                                         ; $03894D |/
    BEQ @manual                                                                 ; $038950 | Branch to the manual section if this is not an auto-battle.
    TDC                                                                         ; $038952 |\ Zero out the accumulator and X register.
    TAX                                                                         ; $038953 |/
-   LDA bank13.auto_battle_formation_data.l,X                                   ; $038954 |\
    CMP r_battle_formation_lo.w                                                 ; $038958 | | Loop through the auto-battle formation numbers looking for the
    BEQ +                                                                       ; $03895B | | low byte of the current formation number.
    INX                                                                         ; $03895D | |
    INX                                                                         ; $03895E | |
    CPX #bank13._sizeof_auto_battle_formation_data.w                            ; $03895F | |
    BNE -                                                                       ; $038962 |/
    BRA @manual                                                                 ; $038964 | If none of the low bytes matched, skip to the manual section.
+   STX <r_init_battle_data_auto_battle_index                                   ; $038966 | Save the index to the auto-battle data for later use.
    LDA bank13.auto_battle_formation_data.l + 1,X                               ; $038968 |\
    CMP r_battle_formation_hi.w                                                 ; $03896C | | If the high byte doesn't match, branch to the manual section.
    BNE @manual                                                                 ; $03896F |/
    TXA                                                                         ; $038971 |\
    LDA bank13.auto_battle_pointer_data.l,X                                     ; $038972 | | Set the pointer to the auto-battle data to $13:XXXX where XXXX is
    STA <r_generic_tmp_ptr_addr_lo                                              ; $038976 | | determined by reading from another table in ROM using the auto-
    LDA bank13.auto_battle_pointer_data.l + 1,X                                 ; $038978 | | battle index found earlier.
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03897C | |
    LDA #:bank13.auto_battle_pointer_data.b                                     ; $03897E | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038980 |/
    TDC                                                                         ; $038982 |\
    TAY                                                                         ; $038983 | | Copy the first set of auto-battle data.
    TAX                                                                         ; $038984 | |
-   LDA [<r_generic_tmp_ptr],Y                                                  ; $038985 | | TODO: Identify the purpose of this data more exactly.
    STA r_auto_battle_data_1.w,X                                                ; $038987 | |
    INY                                                                         ; $03898A | |
    INX                                                                         ; $03898B | |
    CMP #$FF.b                                                                  ; $03898C | |
    BNE -                                                                       ; $03898E |/
    LDA <r_init_battle_data_auto_battle_index                                   ; $038990 |\
    CMP #AUTO_BATTLE_INDEX_ZEMUS.b                                              ; $038992 | | Skip the next few lines if the battle is not the Zemus or Zeromus
    BEQ +                                                                       ; $038994 | | battles. These are hard-coded indexes into the auto-battle data.
    CMP #AUTO_BATTLE_INDEX_ZEROMUS.b                                            ; $038996 | |
    BNE @manual                                                                 ; $038998 |/
+   TDC                                                                         ; $03899A |\
    TAX                                                                         ; $03899B | | Copy the second set of auto-battle data.
-   LDA [<r_generic_tmp_ptr],Y                                                  ; $03899C | |
    STA r_auto_battle_data_2.w,X                                                ; $03899E | | TODO: Identify this. Given that these are the two battles with two
    INY                                                                         ; $0389A1 | | characters, it's possible this is a script for the second
    INX                                                                         ; $0389A2 | | character.
    CMP #$FF.b                                                                  ; $0389A3 | |
    BNE -                                                                       ; $0389A5 |/
    LDA #99.b                                                                   ; $0389A7 |\
    STA r_character_battle.4.agility_base.w                                     ; $0389A9 | | Set the agility of slots 4 and 5 to 99.
    STA r_character_battle.5.agility_base.w                                     ; $0389AC |/
@manual:
    JSR _update_equipment_data                                                  ; $0389AF | Update the data about current equipment.
    STZ r_battle_generic_arg_slot.w                                             ; $0389B2 | Initialize the slot to zero.
-   LDA r_battle_generic_arg_slot.w                                             ; $0389B5 |\ Load the slot number and transfer it to the X register.
    TAX                                                                         ; $0389B8 |/
    LDA r_battle_slot_empty.w,X                                                 ; $0389B9 |\
    BNE +                                                                       ; $0389BC | | If the current slot is not empty, calculate the battle stats.
    JSR _calculate_character_battle                                             ; $0389BE |/
+   INC r_battle_generic_arg_slot.w                                             ; $0389C1 |\
    LDA r_battle_generic_arg_slot.w                                             ; $0389C4 | | Increment the slot and loop until all five slots have been
    CMP #5.b                                                                    ; $0389C7 | | examined.
    BNE -                                                                       ; $0389C9 |/
    TDC                                                                         ; $0389CB |\
    TAX                                                                         ; $0389CC | | Initialize the various indexes to zero.
    TAY                                                                         ; $0389CD | |
    STX <r_init_battle_data_tmp_index_1                                         ; $0389CE | |
    STY <r_init_battle_data_tmp_index_2                                         ; $0389D0 |/
@magic_start:
    LDA <r_init_battle_data_tmp_index_1_lo                                      ; $0389D2 |\ Calculate the offsets for the current slot.
    JSR _calculate_offsets                                                      ; $0389D4 |/
    LDX <r_current_slot_offset_character_battle                                 ; $0389D7 |\
    LDA r_character_battle.1.sprite_class.w,X                                   ; $0389D9 | | Calculate the index into the spell list data by multiplying the
    AND #%00001111.b                                                            ; $0389DC | | class number by three.
    STA <r_init_battle_data_spell_list_offset_lo                                ; $0389DE | |
    ASL A                                                                       ; $0389E0 | |
    CLC                                                                         ; $0389E1 | |
    ADC <r_init_battle_data_spell_list_offset_lo                                ; $0389E2 | |
    STA <r_init_battle_data_spell_list_offset_lo                                ; $0389E4 | |
    STZ <r_init_battle_data_spell_list_offset_hi                                ; $0389E6 |/
    STZ <r_init_battle_data_spell_list_index                                    ; $0389E8 | Initialize the spell list index to zero.
@magic_char_start:
    LDX <r_init_battle_data_spell_list_offset                                   ; $0389EA |\
    LDA bank13.class_spell_list_data.l,X                                        ; $0389EC | | Load the first byte from the spell list data. If the value is not
    CMP #$FF.b                                                                  ; $0389F0 | | $FF, skip forward to the processing of that value.
    BNE +                                                                       ; $0389F2 |/
    CLC                                                                         ; $0389F4 |\
    LDA <r_init_battle_data_tmp_index_2_lo                                      ; $0389F5 | | Increment the destination index by $60 to move to the next spell
    ADC #_sizeof_spell_entry.b * 24                                             ; $0389F7 | | list, if the value was $FF (an empty list).
    STA <r_init_battle_data_tmp_index_2_lo                                      ; $0389F9 | |
    LDA <r_init_battle_data_tmp_index_2_hi                                      ; $0389FB | |
    ADC #0.b                                                                    ; $0389FD | |
    STA <r_init_battle_data_tmp_index_2_hi                                      ; $0389FF | |
    BRA ++                                                                      ; $038A01 |/
+   STA r_math_multiply_8bit_arg_1                                              ; $038A03 |\
    LDA #24.b                                                                   ; $038A05 | | Determine the index into the actual spell list by multiplying the
    STA r_math_multiply_8bit_arg_2                                              ; $038A07 | | list number by 24.
    JSR _math_multiply_8bit                                                     ; $038A09 | |
    LDX r_math_multiply_8bit_result                                             ; $038A0C | |
    STZ <r_init_battle_data_tmp_count_1                                         ; $038A0E | |
    LDY <r_init_battle_data_tmp_index_2                                         ; $038A10 |/
-   LDA r_spell_lists.l & $FFFF,X                                               ; $038A12 |\
    STA r_current_spell_lists.1.id,Y                                            ; $038A16 | | For each spell in the list, transfer the spell ID number to the
    INY                                                                         ; $038A19 | | current spell lists in RAM associated with each active
    INY                                                                         ; $038A1A | | character.
    INY                                                                         ; $038A1B | |
    INY                                                                         ; $038A1C | |
    INX                                                                         ; $038A1D | |
    INC <r_init_battle_data_tmp_count_1                                         ; $038A1E | |
    LDA <r_init_battle_data_tmp_count_1                                         ; $038A20 | |
    CMP #24.b                                                                   ; $038A22 | |
    BNE -                                                                       ; $038A24 |/
    STY <r_init_battle_data_tmp_index_2                                         ; $038A26 | Update the value of the spell storage index.
++  INC <r_init_battle_data_spell_list_offset_lo                                ; $038A28 | Increment the index into the spell list data.
    INC <r_init_battle_data_spell_list_index                                    ; $038A2A |\
    LDA <r_init_battle_data_spell_list_index                                    ; $038A2C | | Increment the number of spell lists we have processed and repeat
    CMP #3.b                                                                    ; $038A2E | | the above loop until all three for this character have been
    BEQ +                                                                       ; $038A30 | | handled.
    JMP @magic_char_start                                                       ; $038A32 |/
+   INC <r_init_battle_data_tmp_index_1_lo                                      ; $038A35 |\
    LDA <r_init_battle_data_tmp_index_1_lo                                      ; $038A37 | | Increment the slot number and loop until all five slots have been
    CMP #5.b                                                                    ; $038A39 | | processed.
    BEQ +                                                                       ; $038A3B | |
    JMP @magic_start                                                            ; $038A3D |/
+   TDC                                                                         ; $038A40 |\
    TAX                                                                         ; $038A41 | | Initialize the X register to zero.
    STX <r_init_battle_data_tmp_index_1                                         ; $038A42 |/
-   LDX <r_init_battle_data_tmp_index_1                                         ; $038A44 |\ Load the ID for the current spell. Skip the next code if the ID is
    LDA r_current_spell_lists.1.id.w,X                                          ; $038A46 |/ zero.
    BEQ +                                                                       ; $038A49 |\
    TAX                                                                         ; $038A4B | | Copy the properties for the current spell into RAM.
    STX <r_copy_from_array_arg_index                                            ; $038A4C | |
    LDX #bank0F.spell_property_data.w                                           ; $038A4E | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038A51 | |
    LDA #:bank0F.spell_property_data.b                                          ; $038A53 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038A55 | |
    LDA #6.b                                                                    ; $038A57 | |
    JSR _copy_from_array                                                        ; $038A59 |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038A5C |\
    LDA r_copy_from_array_result.w + spell.time_targeting                       ; $038A5E | | Read the upper three bits of the first byte, and shift right once
    AND #%11100000.b                                                            ; $038A61 | | to set the targeting data for the spell.
    LSR A                                                                       ; $038A63 | |
    STA r_current_spell_lists.1.flags.w,X                                       ; $038A64 |/
    LDA r_copy_from_array_result.w + spell.wall_mp                              ; $038A67 |\
    AND #%01111111.b                                                            ; $038A6A | | Set the cost of the spell.
    STA r_current_spell_lists.1.cost.w,X                                        ; $038A6C |/
+   INX                                                                         ; $038A6F |\
    INX                                                                         ; $038A70 | | Increment the index by four (as each entry has four bytes).
    INX                                                                         ; $038A71 | |
    INX                                                                         ; $038A72 | |
    STX <r_init_battle_data_tmp_index_1                                         ; $038A73 |/
    CPX #_sizeof_r_current_spell_lists.w                                        ; $038A75 |\ Loop until all three lists for all five slots have been processed.
    BNE -                                                                       ; $038A78 |/
    TDC                                                                         ; $038A7A |\
    TAX                                                                         ; $038A7B | | Initialize the two index registers to zero.
    TAY                                                                         ; $038A7C |/
-   LDA r_inventory.1.id.w,X                                                    ; $038A7D |\ Copy the item ID to the battle inventory in the same slot.
    STA r_battle_inventory.1.id.w,Y                                             ; $038A80 |/
    LDA r_inventory.1.count.w,X                                                 ; $038A83 |\
.if FF4_VERSION != "JAPAN"                                                      ;         | | Copy the item count into the battle inventory.
.if FF4_VERSION != "JAPAN_REV_1"                                                ;         | |
.if FF4_VERSION != "USA"                                                        ;         | |
    BNE +                                                                       ; $038A86 | | NOTE: For USA Rev 1 and Easytype, if the item count is zero, reset
    STA r_inventory.1.id.w,X                                                    ; $038A88 | |       the item ID to zero in both the field and battle inventories
    STA r_battle_inventory.1.id.w,Y                                             ; $038A8B | |       and skip copying the item count. Otherwise, the item count
    BRA ++                                                                      ; $038A8E | |       is copied as before. This effectively removes the ability to
.endif                                                                          ;         | |       duplicate consumables.
.endif                                                                          ;         | |
.endif                                                                          ;         | |
+   STA r_battle_inventory.1.count.w,Y                                          ; $038A90 |/
++  INX                                                                         ; $038A93 |\
    INX                                                                         ; $038A94 | | Increment the indexes and loop until the entire inventory has been
    INY                                                                         ; $038A95 | | copied.
    INY                                                                         ; $038A96 | |
    INY                                                                         ; $038A97 | |
    INY                                                                         ; $038A98 | |
    CPX #_sizeof_r_inventory.w                                                  ; $038A99 | |
    BNE -                                                                       ; $038A9C |/
    TDC                                                                         ; $038A9E |\
    TAX                                                                         ; $038A9F | | Initialize the index to zero.
    STX <r_init_battle_data_tmp_index_1                                         ; $038AA0 |/
@item_start:
    STZ <r_init_battle_data_tmp_1_lo                                            ; $038AA2 | Initially set the throwable bit to zero.
    LDX <r_init_battle_data_tmp_index_1                                         ; $038AA4 |\ Load the next item ID to process.
    LDA r_battle_inventory.1.id.w,X                                             ; $038AA6 |/
    BEQ @item_next                                                              ; $038AA9 |\
    CMP #ITEM_FIRST_NON_BATTLE_ITEM.b                                           ; $038AAB | | Dispatch based on the item ID. Non-battle items, armor and an
    BCS @item_next                                                              ; $038AAD | | empty slot need no further processing, and simply jump to the end
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $038AAF | | of the loop. Shields explicitly set the flags byte to zero and
    BCS @battle_items                                                           ; $038AB1 | | jump to the next part of the loop. Battle items jump to a section
    CMP #ITEM_FIRST_HELM.b                                                      ; $038AB3 | | for those, and non-shield equipment continues directly from here.
    BCS @item_next                                                              ; $038AB5 | |
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $038AB7 | |
    BCC +                                                                       ; $038AB9 | |
    LDA #0.b                                                                    ; $038ABB | |
    BEQ @shield                                                                 ; $038ABD |/
+   TAX                                                                         ; $038ABF |\
    STX <r_copy_from_array_arg_index                                            ; $038AC0 | | Load the equipment's property bytes into RAM.
    LDX #bank0F.equipment_property_data.w                                       ; $038AC2 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038AC5 | |
    LDA #:bank0F.equipment_property_data.b                                      ; $038AC7 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038AC9 | |
    LDA #8.b                                                                    ; $038ACB | |
    JSR _copy_from_array                                                        ; $038ACD |/
    LDA r_copy_from_array_result.w                                              ; $038AD0 |\
    JSR _math_divide_by_8                                                       ; $038AD3 | | Extract the throwable bit from the equipment data and store it for
    AND #%00001000.b                                                            ; $038AD6 | | later use.
    STA <r_init_battle_data_tmp_1_lo                                            ; $038AD8 |/
    LDA r_copy_from_array_result.w + equipment.spell_mdef                       ; $038ADA |\
    PHA                                                                         ; $038ADD | | Load the weapon's spell byte and save it on the stack, and then
    TAX                                                                         ; $038ADE | | use it to load the spell properties.
    STX <r_copy_from_array_arg_index                                            ; $038ADF | |
    LDX #bank0F.spell_property_data.w                                           ; $038AE1 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038AE4 | |
    LDA #:bank0F.spell_property_data.b                                          ; $038AE6 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038AE8 | |
    LDA #6.b                                                                    ; $038AEA | |
    JSR _copy_from_array                                                        ; $038AEC |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038AEF |\
    PLA                                                                         ; $038AF1 | | Save the spell number in the battle inventory's effect byte.
    STA r_battle_inventory.1.effect.w,X                                         ; $038AF2 |/
    BRA +                                                                       ; $038AF5 | Skip ahead past the battle item code.
@battle_items:
    SEC                                                                         ; $038AF7 |\
    SBC #ITEM_FIRST_BATTLE_ITEM.b                                               ; $038AF8 | | Subtract the base item number from the item number and use that to
    TAX                                                                         ; $038AFA | | load the battle item properties, which functions identically to
    STX <r_copy_from_array_arg_index                                            ; $038AFB | | spell properties.
    LDX #bank0F.battle_item_property_data.w                                     ; $038AFD | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038B00 | |
    LDA #:bank0F.battle_item_property_data.b                                    ; $038B02 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038B04 | |
    LDA #6.b                                                                    ; $038B06 | |
    JSR _copy_from_array                                                        ; $038B08 |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038B0B |\
    LDA r_copy_from_array_result.w + spell.effect                               ; $038B0D | | Set the effect based on the item's spell effect.
    STA r_battle_inventory.1.effect.w,X                                         ; $038B10 |/  TODO: Why do items set the effect, but weapons set the spell?
+   LDA r_copy_from_array_result.w + spell.time_targeting                       ; $038B13 |\
    AND #%11100000.b                                                            ; $038B16 | | Set bits 4-6 as the targeting data and bit 2 as the throwable bit.
    ORA <r_init_battle_data_tmp_1_lo                                            ; $038B18 | |
    LSR A                                                                       ; $038B1A |/
@shield:
    STA r_battle_inventory.1.flags.w,X                                          ; $038B1B | Set the actual flags: $00 for shields, as above for anything else.
@item_next:
    INX                                                                         ; $038B1E |\
    INX                                                                         ; $038B1F | | Increment the inventory index by four to move to the next item.
    INX                                                                         ; $038B20 | |
    INX                                                                         ; $038B21 | |
    STX <r_init_battle_data_tmp_index_1                                         ; $038B22 |/
    CPX #_sizeof_r_battle_inventory.w                                           ; $038B24 |\
    BEQ +                                                                       ; $038B27 | | Loop until all of the inventory has been processed.
    JMP @item_start                                                             ; $038B29 |/
+   TDC                                                                         ; $038B2C |\
    TAX                                                                         ; $038B2D | | Reset the current slot to zero.
    STX <r_init_battle_data_tmp_index_1                                         ; $038B2E |/
-   STZ <r_init_battle_data_tmp_1_lo                                            ; $038B30 | Set the throwable bit to zero.
    LDX <r_init_battle_data_tmp_index_1                                         ; $038B32 |\ Load the index and then load the next item ID.
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $038B34 |/
    BEQ +                                                                       ; $038B37 | Skip this item if it's empty.
    TAX                                                                         ; $038B39 |\
    STX <r_copy_from_array_arg_index                                            ; $038B3A | | Copy the eight equipment property bytes from ROM for this item.
    LDX #bank0F.equipment_property_data.w                                       ; $038B3C | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038B3F | |
    LDA #:bank0F.equipment_property_data.b                                      ; $038B41 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038B43 | |
    LDA #_sizeof_equipment.b                                                    ; $038B45 | |
    JSR _copy_from_array                                                        ; $038B47 |/
    LDA r_copy_from_array_result.w + equipment.unknown00                        ; $038B4A |\
    JSR _math_divide_by_8                                                       ; $038B4D | | Extract the equipment's throwable bit and save it for later.
    AND #%00001000.b                                                            ; $038B50 | |
    STA <r_init_battle_data_tmp_1_lo                                            ; $038B52 |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038B54 |\
    LDA r_copy_from_array_result.w + equipment.spell_mdef                       ; $038B56 | | Save the equipment's spell value to the effect variable.
    STA r_battle_hand_inventory.1.effect.w,X                                    ; $038B59 |/
    TAX                                                                         ; $038B5C |\
    STX <r_copy_from_array_arg_index                                            ; $038B5D | | Copy the spell property bytes for this piece of equipment's spell.
    LDX #bank0F.spell_property_data.w                                           ; $038B5F | |
    STX <r_generic_tmp_ptr_addr                                                 ; $038B62 | |
    LDA #:bank0F.spell_property_data.b                                          ; $038B64 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $038B66 | |
    LDA #_sizeof_spell.b                                                        ; $038B68 | |
    JSR _copy_from_array                                                        ; $038B6A |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038B6D |\
    LDA r_copy_from_array_result.w + spell.time_targeting                       ; $038B6F | | Set the flags with the targeting information and the throwable
    AND #%11100000.b                                                            ; $038B72 | | bit.
    ORA <r_init_battle_data_tmp_1_lo                                            ; $038B74 | |
    LSR A                                                                       ; $038B76 | |
    STA r_battle_hand_inventory.1.flags.w,X                                     ; $038B77 |/
+   INX                                                                         ; $038B7A |\
    INX                                                                         ; $038B7B | | Increment the X register and loop until the entire hand inventory
    INX                                                                         ; $038B7C | | has been handled.
    INX                                                                         ; $038B7D | |
    STX <r_init_battle_data_tmp_index_1                                         ; $038B7E | |
    CPX #_sizeof_r_battle_hand_inventory.w                                      ; $038B80 | |
    BNE -                                                                       ; $038B83 |/
    TDC                                                                         ; $038B85 |\
    TAY                                                                         ; $038B86 | | Initialize the slot to zero.
    STY <r_init_battle_data_tmp_index_1                                         ; $038B87 |/
@battle_command_start:
    LDX <r_init_battle_data_tmp_index_1                                         ; $038B89 |\
    LDA r_character_battle.1.id.w,X                                             ; $038B8B | | Load the ID for this slot, and then subtract one. Note that an
    AND #%00011111.b                                                            ; $038B8E | | empty slot will also be zero after this step.
    BNE +                                                                       ; $038B90 | |
    INC A                                                                       ; $038B92 | |
+   DEC A                                                                       ; $038B93 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $038B94 |\
    LDA #5.b                                                                    ; $038B96 | | Initialize the index to the character ID times five, the maximum
    STA <r_math_multiply_8bit_arg_2                                             ; $038B98 | | number of commands a character can have. Also set the loop
    JSR _math_multiply_8bit                                                     ; $038B9A | | variable to five.
    LDA #5.b                                                                    ; $038B9D | |
    STA <r_init_battle_data_tmp_index_2_lo                                      ; $038B9F | |
    LDX <r_math_multiply_8bit_result                                            ; $038BA1 |/
-   LDA bank13.character_battle_commands_data.l,X                               ; $038BA3 |\ Load the command ID and store it in the character's command area.
    STA r_battle_commands.1.commands.1.id,Y                                     ; $038BA7 |/
    CMP #$FF.b                                                                  ; $038BAA |\
    BNE +                                                                       ; $038BAC | | If the ID was anything other than $FF, load the associated
    PHX                                                                         ; $038BAE | | flags byte from ROM and store it in RAM.
    BRA ++                                                                      ; $038BAF | |
+   PHX                                                                         ; $038BB1 | |
    TAX                                                                         ; $038BB2 | |
    LDA bank13.battle_command_flags_data.l,X                                    ; $038BB3 | |
++  STA r_battle_commands.1.commands.1.flags,Y                                  ; $038BB7 |/
    PLX                                                                         ; $038BBA |\
    INX                                                                         ; $038BBB | | Increment the index registers and loop until all five potential
    INY                                                                         ; $038BBC | | commands have been processed.
    INY                                                                         ; $038BBD | |
    INY                                                                         ; $038BBE | |
    INY                                                                         ; $038BBF | |
    DEC <r_init_battle_data_tmp_index_2_lo                                      ; $038BC0 | |
    LDA <r_init_battle_data_tmp_index_2_lo                                      ; $038BC2 | |
    BNE -                                                                       ; $038BC4 |/
    LDA #BATTLE_COMMAND_CHANGE.b                                                ; $038BC6 |\
    STA r_battle_commands.1.commands.1.id,Y                                     ; $038BC8 | | Set the character's Change command to the next slot.
    INY                                                                         ; $038BCB | |
    INY                                                                         ; $038BCC | |
    INY                                                                         ; $038BCD | |
    INY                                                                         ; $038BCE |/
    LDA #BATTLE_COMMAND_PARRY.b                                                 ; $038BCF |\
    STA r_battle_commands.1.commands.1.id,Y                                     ; $038BD1 | | Set the character's Parry command to the next slot.
    INY                                                                         ; $038BD4 | |
    INY                                                                         ; $038BD5 | |
    INY                                                                         ; $038BD6 | |
    INY                                                                         ; $038BD7 |/
    PHP                                                                         ; $038BD8 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $038BD9 | | Increment the slot index by the size of a character record and
    CLC                                                                         ; $038BDB | | loop until all five slots have been processed.
    LDA <r_init_battle_data_tmp_index_1_lo                                      ; $038BDC | |
    ADC #_sizeof_character_battle.w                                             ; $038BDE | |
    STA <r_init_battle_data_tmp_index_1_lo                                      ; $038BE1 | |
    TDC                                                                         ; $038BE3 | |
    PLP                                                                         ; $038BE4 | |
    CPY #_sizeof_r_battle_commands.w                                            ; $038BE5 | |
    BNE @battle_command_start                                                   ; $038BE8 |/
    TDC                                                                         ; $038BEA |\
    TAX                                                                         ; $038BEB | | Start with monster slot zero.
    STX <r_battle_load_monster_arg_slot                                         ; $038BEC |/
-   STZ <r_battle_load_monster_arg_egg                                          ; $038BEE | Initially assume the monster is not an egg.
    LDX <r_battle_load_monster_arg_slot                                         ; $038BF0 |\ Load the ID index for the monster in this slot (ranges from 0 to
    LDA r_monster_slot_to_id_index.w,X                                          ; $038BF2 |/ 2).
    CMP #$FF.b                                                                  ; $038BF5 |\
    BNE +                                                                       ; $038BF7 | | If the slot is set to $FF, set the empty flag for this slot. Five
    TXA                                                                         ; $038BF9 | | is added to the index as monsters start in slot 5.
    CLC                                                                         ; $038BFA | |
    ADC #5.b                                                                    ; $038BFB | |
    TAX                                                                         ; $038BFD | |
    INC r_battle_slot_empty.w,X                                                 ; $038BFE | |
    BRA ++                                                                      ; $038C01 |/
+   TAX                                                                         ; $038C03 |\
    LDA r_formation_properties.flags1.w                                         ; $038C04 | | Check the egg bit for this monster type, and if it is an egg, set
    JSR _mask_bit_x                                                             ; $038C07 | | the egg parameter for the monster loading function.
    BEQ +                                                                       ; $038C0A | |
    INC <r_battle_load_monster_arg_egg                                          ; $038C0C |/
+   LDA r_monster_ids.w,X                                                       ; $038C0E |\
    STA <r_battle_load_monster_arg_id_lo                                        ; $038C11 | | Load the monster ID for this monster and call the routine to load
    STZ <r_battle_load_monster_arg_id_hi                                        ; $038C13 | | the monster's stats and scripts.
    JSR _battle_load_monster                                                    ; $038C15 |/
++  INC <r_battle_load_monster_arg_slot                                         ; $038C18 |\
    LDA <r_battle_load_monster_arg_slot                                         ; $038C1A | | Increment the slot number and loop until all eight monster slots
    CMP #8.b                                                                    ; $038C1C | | have been considered.
    BNE -                                                                       ; $038C1E |/
    LDA r_formation_properties.monster_counts.w                                 ; $038C20 |\
    AND #%00000011.b                                                            ; $038C23 | | Skip this next section if no monsters need to start dead.
    BEQ @end_prekilled_monsters                                                 ; $038C25 |/
    CMP #1.b                                                                    ; $038C27 |\
    BNE ++                                                                      ; $038C29 | | If the value is 1, start any monsters of the second type as
    TDC                                                                         ; $038C2B | | swooned.
    TAX                                                                         ; $038C2C | |
-   LDA r_monster_slot_to_id_index.w,X                                          ; $038C2D | |
    CMP #1.b                                                                    ; $038C30 | |
    BEQ +                                                                       ; $038C32 | |
    INX                                                                         ; $038C34 | |
    BRA -                                                                       ; $038C35 | |
+   JSR _set_monster_swooned                                                    ; $038C37 | |
    BRA @end_prekilled_monsters                                                 ; $038C3A |/
++  CMP #2.b                                                                    ; $038C3C |\
    BNE ++                                                                      ; $038C3E | | If the value is 2, start any monsters of the second or third types
    TDC                                                                         ; $038C40 | | as swooned.
    TAX                                                                         ; $038C41 | |
    STX <r_init_battle_data_tmp_1                                               ; $038C42 | |
-   LDX <r_init_battle_data_tmp_1                                               ; $038C44 | |
    LDA r_monster_slot_to_id_index.w,X                                          ; $038C46 | |
    BEQ +                                                                       ; $038C49 | |
    CMP #$FF.b                                                                  ; $038C4B | |
    BEQ @end_prekilled_monsters                                                 ; $038C4D | |
    JSR _set_monster_swooned                                                    ; $038C4F | |
+   INC <r_init_battle_data_tmp_1_lo                                            ; $038C52 | |
    BRA -                                                                       ; $038C54 |/
++  TDC                                                                         ; $038C56 |\
    TAX                                                                         ; $038C57 | | Otherwise, start the battle with monsters of the third type as
    STX <r_init_battle_data_tmp_1                                               ; $038C58 | | swooned.
-   LDX <r_init_battle_data_tmp_1                                               ; $038C5A | |
    LDA r_monster_slot_to_id_index.w,X                                          ; $038C5C | |
    CMP #$FF.b                                                                  ; $038C5F | |
    BEQ @end_prekilled_monsters                                                 ; $038C61 | |
    CMP #2.b                                                                    ; $038C63 | |
    BNE ++                                                                      ; $038C65 | |
    BEQ +                                                                       ; $038C67 | |
+   JSR _set_monster_swooned                                                    ; $038C69 | |
++  INC <r_init_battle_data_tmp_1_lo                                            ; $038C6C | |
    BRA -                                                                       ; $038C6E |/
@end_prekilled_monsters:
    LDA r_formation_back_attack.w                                               ; $038C70 |\
    AND #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $038C73 | | If this is a forced back attack, set the initial ATB calculations
    BEQ +                                                                       ; $038C75 | | for a surprise attack.
    LDA #BATTLE_INITIAL_ATB_TYPE_SURPRISED.b                                    ; $038C77 | |
    STA r_battle_initial_atb_type.w                                             ; $038C79 | |
-   JMP @end_battle_type                                                        ; $038C7C |/
+   LDA r_boss_battle.w                                                         ; $038C7F |\ Otherwise, if this is a battle with at least one enemy with the
    BNE -                                                                       ; $038C82 |/ boss bit, skip to the next section.
    LDA r_formation_flags2.w                                                    ; $038C84 |\
    AND #FORMATION_FLAGS_2_DISABLE_RUNNING.b                                    ; $038C87 | | Skip to the next section if the battle has disabled running.
    BNE -                                                                       ; $038C89 |/
    LDA r_battle_alternate_scripts.w                                            ; $038C8B |\ Finally, also skip to the next section if the battle uses the
    BNE -                                                                       ; $038C8E |/ alternate scripts (moon dungeon maps).
    TDC                                                                         ; $038C90 |\
    TAX                                                                         ; $038C91 | | Initialize various loop variables to zero.
    TAY                                                                         ; $038C92 | |
    STX <r_init_battle_data_tmp_index_1                                         ; $038C93 | |
    STX <r_init_battle_data_tmp_index_2                                         ; $038C95 | |
    STX <r_init_battle_data_tmp_count_1                                         ; $038C97 |/
-   LDA r_battle_slot_empty.w,Y                                                 ; $038C99 |\
    BNE +                                                                       ; $038C9C | | Loop through the five character slots, adding the level of the
    CLC                                                                         ; $038C9E | | character in any non-empty slot.
    LDA r_character_battle.1.level.w,X                                          ; $038C9F | |
    ADC <r_init_battle_data_tmp_index_1_lo                                      ; $038CA2 | |
    STA <r_init_battle_data_tmp_index_1_lo                                      ; $038CA4 | |
    LDA #0.b                                                                    ; $038CA6 | |
    ADC <r_init_battle_data_tmp_index_1_hi                                      ; $038CA8 | |
    STA <r_init_battle_data_tmp_index_1_hi                                      ; $038CAA | |
    INC <r_init_battle_data_tmp_count_1                                         ; $038CAC | |
+   JSR _increment_x_by_128                                                     ; $038CAE | |
    INY                                                                         ; $038CB1 | |
    CPY #5.w                                                                    ; $038CB2 | |
    BNE -                                                                       ; $038CB5 |/
-   LDA r_battle_slot_empty.w,Y                                                 ; $038CB7 |\
    BNE +                                                                       ; $038CBA | | Loop through the eight monster slots, adding the level of the
    CLC                                                                         ; $038CBC | | monster in any non-empty slot.
    LDA r_character_battle.1.level.w,X                                          ; $038CBD | |
    ADC <r_init_battle_data_tmp_index_2_lo                                      ; $038CC0 | | BUG: The end condition for this checks against 8, but since these
    STA <r_init_battle_data_tmp_index_2_lo                                      ; $038CC2 | |      are slot numbers, it should actually be comparing against 13.
    LDA #0.b                                                                    ; $038CC4 | |      The result is that only the first three monster slots are
    ADC <r_init_battle_data_tmp_index_2_hi                                      ; $038CC6 | |      averaged.
    STA <r_init_battle_data_tmp_index_2_hi                                      ; $038CC8 | |
    INC <r_init_battle_data_tmp_count_2                                         ; $038CCA | |
+   JSR _increment_x_by_128                                                     ; $038CCC | |
    INY                                                                         ; $038CCF | |
    CPY #8.w                                                                    ; $038CD0 | |
    BNE -                                                                       ; $038CD3 |/
    LDX <r_init_battle_data_tmp_index_1                                         ; $038CD5 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $038CD7 | | Divide the sum of the party levels by the count to determine the
    LDA <r_init_battle_data_tmp_count_1                                         ; $038CDA | | party's average level.
    TAX                                                                         ; $038CDC | |
    STX r_math_divide_16bit_arg_2.w                                             ; $038CDD | |
    JSR _math_divide_16bit                                                      ; $038CE0 | |
    LDX r_math_divide_16bit_result.w                                            ; $038CE3 | |
    TXA                                                                         ; $038CE6 | |
    STA r_party_average_level.w                                                 ; $038CE7 |/
    TDC                                                                         ; $038CEA |\
    LDX <r_init_battle_data_tmp_index_2                                         ; $038CEB | | Repeat to the determine the average level of the monsters.
    STX r_math_divide_16bit_arg_1.w                                             ; $038CED | |
    LDA <r_init_battle_data_tmp_count_2                                         ; $038CF0 | |
    TAX                                                                         ; $038CF2 | |
    STX r_math_divide_16bit_arg_2.w                                             ; $038CF3 | |
    JSR _math_divide_16bit                                                      ; $038CF6 | |
    LDX r_math_divide_16bit_result.w                                            ; $038CF9 | |
    TXA                                                                         ; $038CFC | |
    STA r_monster_average_level.w                                               ; $038CFD |/
    TDC                                                                         ; $038D00 |\
    TDC                                                                         ; $038D01 | | Initialize various variables.
    TAX                                                                         ; $038D02 | |
    STX <r_init_battle_data_tmp_index_1                                         ; $038D03 | |
    INC <r_init_battle_data_tmp_index_1_lo                                      ; $038D05 | |
    INC <r_init_battle_data_tmp_index_1_hi                                      ; $038D07 |/
    LDA #99.b                                                                   ; $038D09 |\
    JSR _get_battle_rng                                                         ; $038D0B | | Increment one of the test variables if RNG(0, 99) is less than the
    CMP r_party_average_level.w                                                 ; $038D0E | | party's average level.
    BCS +                                                                       ; $038D11 | |
    INC <r_init_battle_data_tmp_index_1_lo                                      ; $038D13 |/
+   JSR _get_battle_rng_0_98                                                    ; $038D15 |\
    CMP r_monster_average_level.w                                               ; $038D18 | | Increment the other test variable if RNG(0. 98) is less than the
    BCS +                                                                       ; $038D1B | | average level of the monsters.
    INC <r_init_battle_data_tmp_index_1_hi                                      ; $038D1D |/
+   LDA <r_init_battle_data_tmp_index_1_lo                                      ; $038D1F |\
    CMP <r_init_battle_data_tmp_index_1_hi                                      ; $038D21 | | If the party test variable is greater than the monster test
    BEQ @end_battle_type                                                        ; $038D23 | | variable, set the initial ATB values to 1 to reflect the strike
    BCC +                                                                       ; $038D25 | | first condition.
    INC r_battle_initial_atb_alert.w                                            ; $038D27 | |
    INC r_battle_initial_atb_type.w                                             ; $038D2A | |
    BRA @end_battle_type                                                        ; $038D2D |/
+   LDA #BATTLE_INITIAL_ATB_TYPE_SURPRISED.b                                    ; $038D2F |\
    STA r_battle_initial_atb_alert.w                                            ; $038D31 | | If the monster test variable is greater than the party test
    STA r_battle_initial_atb_type.w                                             ; $038D34 | | variable, instead set the values to reflect the surprise attack.
    LDA r_monster_average_level.w                                               ; $038D37 | |
    LSR A                                                                       ; $038D3A | | In addition, do another check to see if RNG(0, party level) is
    STA <r_init_battle_data_tmp_index_1_lo                                      ; $038D3B | | less than half the average monster level. If so, flag the
    TDC                                                                         ; $038D3D | | battle as being a back attack.
    TAX                                                                         ; $038D3E | |
    LDA r_party_average_level.w                                                 ; $038D3F | |
    JSR _get_battle_rng                                                         ; $038D42 | |
    CMP <r_init_battle_data_tmp_index_1_lo                                      ; $038D45 | |
    BCS @end_battle_type                                                        ; $038D47 | |
    LDA #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $038D49 | |
    STA r_formation_back_attack.w                                               ; $038D4B |/
@end_battle_type:
    TDC                                                                         ; $038D4E |\
    TAX                                                                         ; $038D4F | | Initialize the loop variables to zero.
    TAY                                                                         ; $038D50 | |
    STX <r_init_battle_data_tmp_1                                               ; $038D51 |/
-   LDA r_battle_slot_empty,Y                                                   ; $038D53 |\ Skip this slot if it's empty.
    BNE +                                                                       ; $038D56 |/
    LDA <r_init_battle_data_tmp_1_lo                                            ; $038D58 |\ Skip to the end if all five slots have been checked and we're
    BNE +++                                                                     ; $038D5A |/ looking at a non-empty slot.
    LDA r_character_battle.1.id.w,X                                             ; $038D5C |\
    AND #%00011111.b                                                            ; $038D5F | | If the character in the current slot is Cecil (either dark knight
    CMP #CHARACTER_CECIL_1.b                                                    ; $038D61 | | or paladin), skip ahead to the next block.
    BEQ +++                                                                     ; $038D63 | |
    CMP #CHARACTER_CECIL_2.b                                                    ; $038D65 | |
    BEQ ++                                                                      ; $038D67 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $038D69 |\
    TXA                                                                         ; $038D6B | | Loop through all five character slots.
    CLC                                                                         ; $038D6C | |
    ADC #_sizeof_character_battle.w                                             ; $038D6D | |
    TAX                                                                         ; $038D70 | |
    TDC                                                                         ; $038D71 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038D72 | |
    INY                                                                         ; $038D74 | |
    CPY #5.w                                                                    ; $038D75 | |
    BNE -                                                                       ; $038D78 |/
    INC <r_init_battle_data_tmp_1_lo                                            ; $038D7A |\
    TDC                                                                         ; $038D7C | | If for some reason we've gone through all five slots and haven't
    TAX                                                                         ; $038D7D | | found Cecil, set the variables to loop through the slots again
    TAY                                                                         ; $038D7E | | looking for the first non-empty slot.
    BRA -                                                                       ; $038D7F |/
++  STY r_cecil_paladin_slot.w                                                  ; $038D81 | If Cecil is a paladin, set the paladin slot.
+++ LDA r_character_battle.1.agility.w,X                                        ; $038D84 |\
    TAX                                                                         ; $038D87 | | Take the current character's agility (Cecil if in the party, the
    STX r_math_multiply_16bit_arg_1.w                                           ; $038D88 | | first non-empty slot otherwise) and multiply by 50.
    LDX #50.w                                                                   ; $038D8B | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $038D8E | |
    JSR _math_multiply_16bit                                                    ; $038D91 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $038D94 |/
    STX <r_init_battle_data_anchor_agility                                      ; $038D97 |\
    TDC                                                                         ; $038D99 | | Initialize variables to loop through the battle records.
    TAX                                                                         ; $038D9A | |
    STX <r_init_battle_data_tmp_1                                               ; $038D9B | |
    STX <r_init_battle_data_slot                                                ; $038D9D |/
-   LDX <r_init_battle_data_slot                                                ; $038D9F |\ Skip this slot if it's empty.
    LDA r_battle_slot_empty.w,X                                                 ; $038DA1 |/
    BNE ++                                                                      ; $038DA4 |\
    LDX <r_init_battle_data_tmp_1                                               ; $038DA6 | | Calculate this slot's agility times 10.
    LDA r_character_battle.1.agility.w,X                                        ; $038DA8 | |
    STA <r_math_multiply_8bit_arg_1                                             ; $038DAB | |
    LDA #10.b                                                                   ; $038DAD | |
    STA <r_math_multiply_8bit_arg_2                                             ; $038DAF | |
    JSR _math_multiply_8bit                                                     ; $038DB1 |/
    LDX <r_init_battle_data_anchor_agility                                      ; $038DB4 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $038DB6 | | Divide the anchor's agility times 50 by this slot's agility times
    LDX <r_math_multiply_8bit_result                                            ; $038DB9 | | ten.
    STX r_math_divide_16bit_arg_2.w                                             ; $038DBB | |
    JSR _math_divide_16bit                                                      ; $038DBE |/
    LDX r_math_divide_16bit_result.w                                            ; $038DC1 |\
    BNE +                                                                       ; $038DC4 | | If the result was zero, set the result to 1.
    INC r_math_divide_16bit_result.w                                            ; $038DC6 |/
+   LDX <r_init_battle_data_tmp_1                                               ; $038DC9 |\
    LDA r_math_divide_16bit_result_lo.w                                         ; $038DCB | | Use this value to set this slot's relative speed.
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $038DCE | |
    LDA r_math_divide_16bit_result_hi.w                                         ; $038DD1 | |
    STA r_character_battle.1.relative_speed_hi.w,X                              ; $038DD4 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $038DD7 |\
    CLC                                                                         ; $038DD9 | | Increment variables and loop until all five character slots and
    LDA <r_init_battle_data_tmp_1                                               ; $038DDA | | eight monster slots have been considered.
    ADC #_sizeof_character_battle.w                                             ; $038DDC | |
    STA <r_init_battle_data_tmp_1                                               ; $038DDF | |
    TDC                                                                         ; $038DE1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038DE2 | |
    INC <r_init_battle_data_slot_lo                                             ; $038DE4 | |
    LDA <r_init_battle_data_slot_lo                                             ; $038DE6 | |
    CMP #(5 + 8).b                                                              ; $038DE8 | |
    BNE -                                                                       ; $038DEA |/
    TDC                                                                         ; $038DEC |\
    TAX                                                                         ; $038DED | | Initialize loop variables to zero.
    STX <r_init_battle_data_tmp_1                                               ; $038DEE |/
@loop_start:
    LDX <r_init_battle_data_tmp_1                                               ; $038DF0 |\
    LDA r_battle_slot_empty.w,X                                                 ; $038DF2 | | Skip this slot if empty.
    BNE @next                                                                   ; $038DF5 |/
    TXA                                                                         ; $038DF7 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $038DF8 | | Calculate the offset for this slot's battle record.
    LDA #_sizeof_character_battle.b                                             ; $038DFA | |
    STA <r_math_multiply_8bit_arg_2                                             ; $038DFC | |
    JSR _math_multiply_8bit                                                     ; $038DFE | |
    LDX <r_math_multiply_8bit_result                                            ; $038E01 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $038E03 |\ Skip this slot if the character/monster is swooned.
    BMI @next                                                                   ; $038E06 |/
    LDA <r_init_battle_data_tmp_1_lo                                            ; $038E08 |\
    CMP #5.b                                                                    ; $038E0A | | If this slot is a monster slot or if the current battle is not a
    BCS +                                                                       ; $038E0C | | back attack, skip to the next block.
    LDA r_formation_back_attack.w                                               ; $038E0E | |
    AND #FORMATION_FLAGS_1_BACK_ATTACK.b                                        ; $038E11 | |
    BEQ +                                                                       ; $038E13 |/
    LDA r_character_battle.1.sprite_class.w,X                                   ; $038E15 |\
    PHA                                                                         ; $038E18 | | For each of the character slots in a back attack, flip the value
    AND #%01111111.b                                                            ; $038E19 | | of the back row bit, to change the row each character is in.
    STA <r_init_battle_data_tmp_index_1_lo                                      ; $038E1B | |
    PLA                                                                         ; $038E1D | |
    AND #%10000000.b                                                            ; $038E1E | |
    EOR #%10000000.b                                                            ; $038E20 | |
    ORA <r_init_battle_data_tmp_index_1_lo                                      ; $038E22 | |
    STA r_character_battle.1.sprite_class.w,X                                   ; $038E24 |/
+   STZ <r_calculate_timer_value_arg_mode                                       ; $038E27 |\
    LDX <r_init_battle_data_tmp_1                                               ; $038E29 | | Get the slot's modified relative speed.
    TXA                                                                         ; $038E2B | |
    JSR _calculate_timer_value                                                  ; $038E2C |/
    LDA r_battle_initial_atb_type.w                                             ; $038E2F |\
    BEQ +++                                                                     ; $038E32 | | If this is a strike first battle, set the initial monster action
    BMI +                                                                       ; $038E34 | | timers to their modified relative speed times two. If this value
    LDA <r_init_battle_data_tmp_1_lo                                            ; $038E36 | | is zero, instead set the action timer to two.
    CMP #5.b                                                                    ; $038E38 | |
    BCC ++                                                                      ; $038E3A | | This same code is executed for character slots if the battle is a
-   ASL <r_set_timer_value_arg_lo                                               ; $038E3C | | back attack or surprise attack.
    ROL <r_set_timer_value_arg_hi                                               ; $038E3E | |
    LDA <r_set_timer_value_arg_lo                                               ; $038E40 | |
    ORA <r_set_timer_value_arg_hi                                               ; $038E42 | |
    BNE +++                                                                     ; $038E44 | |
    INC A                                                                       ; $038E46 | |
    INC A                                                                       ; $038E47 | |
    STA <r_set_timer_value_arg_lo                                               ; $038E48 | |
    BRA +++                                                                     ; $038E4A |/
+   LDA <r_init_battle_data_tmp_1_lo                                            ; $038E4C |\
    CMP #5.b                                                                    ; $038E4E | | If this is a surprise/back attack, execute the previous code for
    BCC -                                                                       ; $038E50 |/  characters.
++  LDA #1.b                                                                    ; $038E52 |\
    STA <r_set_timer_value_arg_lo                                               ; $038E54 | | For the group that's acting first, set all action timers to 1.
    STZ <r_set_timer_value_arg_hi                                               ; $038E56 |/
+++ LDA #TIMER_OFFSET_ACTION.b                                                  ; $038E58 |\ Set the value for the action timer.
    JSR _set_timer_value                                                        ; $038E5A |/
@next:
    INC <r_init_battle_data_tmp_1_lo                                            ; $038E5D |\
    LDA <r_init_battle_data_tmp_1_lo                                            ; $038E5F | | Increment the index and loop until all five characters and eight
    CMP #(5 + 8).b                                                              ; $038E61 | | monsters have been handled.
    BNE @loop_start                                                             ; $038E63 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $038E65 |\
    LDA #$FFFF.w                                                                ; $038E67 | | Loop through all thirteen slots looking for the lowest action
    STA <r_init_battle_data_tmp_index_1                                         ; $038E6A | | timer value.
    LDY #(5 + 8).w                                                              ; $038E6C | |
    TDC                                                                         ; $038E6F | |
    TAX                                                                         ; $038E70 | |
-   LDA r_battle_timers.1.action.value.w,X                                      ; $038E71 | |
    BEQ +                                                                       ; $038E74 | |
    CMP <r_init_battle_data_tmp_index_1                                         ; $038E76 | |
    BCS +                                                                       ; $038E78 | |
    STA <r_init_battle_data_tmp_index_1                                         ; $038E7A | |
+   TXA                                                                         ; $038E7C | |
    CLC                                                                         ; $038E7D | |
    ADC #_sizeof_character_timers.w                                             ; $038E7E | |
    TAX                                                                         ; $038E81 | |
    DEY                                                                         ; $038E82 | |
    BNE -                                                                       ; $038E83 |/
    DEC <r_init_battle_data_tmp_index_1                                         ; $038E85 | Decrease the value by one.
    TYX                                                                         ; $038E87 |\
-   SEC                                                                         ; $038E88 | | Loop through the timers again, subtracting the lowest value minus
    LDA r_battle_timers.1.action.value.w,X                                      ; $038E89 | | one. This has the practical effect of having the first actor
    BEQ +                                                                       ; $038E8C | | always have an initial action timer of 1, while the remaining
    SBC <r_init_battle_data_tmp_index_1                                         ; $038E8E | | actors maintain their original delta values against that actor.
    STA r_battle_timers.1.action.value.w,X                                      ; $038E90 | |
+   TXA                                                                         ; $038E93 | |
    CLC                                                                         ; $038E94 | |
    ADC #_sizeof_character_timers.w                                             ; $038E95 | |
    TAX                                                                         ; $038E98 | |
    INY                                                                         ; $038E99 | |
    CPY #(5 + 8).w                                                              ; $038E9A | |
    BNE -                                                                       ; $038E9D | |
    TDC                                                                         ; $038E9F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038EA0 |/
    RTS                                                                         ; $038EA2

; _set_monster_swooned ($03:8EA3)
;
; Sets the monster in the monster slot passed in the X register as swooned and
; appropriately decrements the monster counts.
_set_monster_swooned:
    TXA                                                                         ; $038EA3 |\
    CLC                                                                         ; $038EA4 | | Calculate the overall slot by adding five to the monster slot
    ADC #5.b                                                                    ; $038EA5 | | passed in the X register.
    STA <r_set_monster_swooned_tmp_slot                                         ; $038EA7 |/
    LDA r_monster_slot_to_id_index.w,X                                          ; $038EA9 |\
    STA <r_set_monster_swooned_tmp_index                                        ; $038EAC | | Determine which of the three monster types this monster slot
    LDA #$FF.b                                                                  ; $038EAE | | refers to, and reset that value to $FF to unassign the monster.
    STA r_monster_slot_to_id_index.w,X                                          ; $038EB0 | |
    LDA <r_set_monster_swooned_tmp_index                                        ; $038EB3 |/
    TAX                                                                         ; $038EB5 |\
    DEC r_monsters_remaining.w,X                                                ; $038EB6 | | Reduce the relevant monster counts by one.
    DEC r_monsters_remaining_total.w                                            ; $038EB9 |/
    LDA <r_set_monster_swooned_tmp_slot                                         ; $038EBC |\
    STA <r_math_multiply_8bit_arg_1                                             ; $038EBE | | Calculate the offset to this monster's battle record.
    LDA #_sizeof_character_battle.b                                             ; $038EC0 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $038EC2 | |
    JSR _math_multiply_8bit                                                     ; $038EC4 | |
    LDX <r_math_multiply_8bit_result                                            ; $038EC7 |/
    LDA #STATUS_1_SWOON.b                                                       ; $038EC9 |\ Set the monster as being swooned.
    STA r_character_battle.1.status_1.w,X                                       ; $038ECB |/
    LDA <r_set_monster_swooned_tmp_slot                                         ; $038ECE |\
    ASL A                                                                       ; $038ED0 | | Disable all of the monster's timers.
    TAX                                                                         ; $038ED1 | |
    STZ r_battle_enabled_timers.1.hi.w,X                                        ; $038ED2 |/
    RTS                                                                         ; $038ED5

; _update_equipment_data ($03:8ED6)
;
; For each character, this function reads that character's currently equipped
; equipment and copies the essential data about this equipment to the result
; array at $2780.
_update_equipment_data:
    LDY #r_character_battle.1.armor_head.w                                      ; $038ED6 |\ Set the equipment base pointer to point to the part of the
    STY r_update_equipment_data_base_ptr                                        ; $038ED9 |/ in-battle character record where equipment begins.
    LDY #r_equipment.w                                                          ; $038EDB |\ Set the destination pointer to the result array.
    STY r_update_equipment_data_result_ptr                                      ; $038EDE |/
    STZ r_update_equipment_data_slot                                            ; $038EE0 | Set the initial slot to zero.
@begin_copy:
    TDC                                                                         ; $038EE2 |\
    TAX                                                                         ; $038EE3 | | Initialize the X and Y index registers to 0 to begin the
    STX r_update_equipment_data_index                                           ; $038EE4 | | loop.
    TXY                                                                         ; $038EE6 |/
-   LDA (r_update_equipment_data_base_ptr),Y                                    ; $038EE7 |\
    BNE +                                                                       ; $038EE9 | | Loads the next equipment byte. If nothing is equipped, set
    LDA #ITEM_NAKED                                                             ; $038EEB | | it to $60, a special equipment value for no equipment.
+   STA r_update_equipment_data_tmp_data,X                                      ; $038EED |/
    INY                                                                         ; $038EEF |\
    INX                                                                         ; $038EF0 | | Increment the index registers, and once the full three
    CPX #$0003.w                                                                ; $038EF1 | | bytes have been copied, continue.
    BNE -                                                                       ; $038EF4 |/
-   LDA (r_update_equipment_data_base_ptr),Y                                    ; $038EF6 |\
    STA r_update_equipment_data_tmp_data,X                                      ; $038EF8 | | This next step continues copying four additional bytes (the
    INY                                                                         ; $038EFA | | right and left hand item IDs and quantities. The primary
    INX                                                                         ; $038EFB | | difference from the previous section is that there is no
    CPX #$0007.w                                                                ; $038EFC | | pseudo-equipment corresponding to nothing being equipped.
    BNE -                                                                       ; $038EFF |/
    LDA r_update_equipment_data_slot                                            ; $038F01 |\
    JSR _math_multiply_by_8                                                     ; $038F03 | | Load the slot number and multiply by 8.
    TAX                                                                         ; $038F06 |/
    LDA r_update_equipment_data_tmp_data + 3                                    ; $038F07 |\
    STA r_battle_hand_inventory.1.id.w,X                                        ; $038F09 | | Store the equipped item information to the array that keeps
    LDA r_update_equipment_data_tmp_data + 4                                    ; $038F0C | | track of the item properties of each character's equipped items
    STA r_battle_hand_inventory.1.count.w,X                                     ; $038F0E | | (in case they use them as items and such).
    LDA r_update_equipment_data_tmp_data + 5                                    ; $038F11 | |
    STA r_battle_hand_inventory.2.id.w,X                                        ; $038F13 | |
    LDA r_update_equipment_data_tmp_data + 6                                    ; $038F16 | |
    STA r_battle_hand_inventory.2.count.w,X                                     ; $038F18 |/
    LDA r_update_equipment_data_tmp_data + 5                                    ; $038F1B |\ Move the left hand equipped information directly next to the
    STA r_update_equipment_data_tmp_data + 4                                    ; $038F1D |/ right hand information, discarding the count information.
    STZ r_update_equipment_data_flags_right                                     ; $038F1F |\ Initialize two variables used shortly.
    STZ r_update_equipment_data_flags_left                                      ; $038F21 |/
    LDA r_update_equipment_data_tmp_data + 3                                    ; $038F23 |\
    BEQ ++                                                                      ; $038F25 | | This code ultimately does one of three things: a) if the
    CMP #ITEM_FIRST_BOW                                                         ; $038F27 | | item in the right hand is a bow, right_flags is set to $80.
    BCC ++                                                                      ; $038F29 | | Alternately, if it's an arrow, it is set to $40. Otherwise,
    CMP #ITEM_FIRST_ARROW                                                       ; $038F2B | | it does nothing. The various comparisons are hard coded IDs
    BCS +                                                                       ; $038F2D | | that determine the bounds of where bows or arrows are in
    LDA #%10000000                                                              ; $038F2F | | the item list.
    STA r_update_equipment_data_flags_right                                     ; $038F31 | |
    BRA ++                                                                      ; $038F33 | |
+   CMP #ITEM_FIRST_SHIELD                                                      ; $038F35 | |
    BCS ++                                                                      ; $038F37 | |
    LDA #%01000000                                                              ; $038F39 | |
    STA r_update_equipment_data_flags_right                                     ; $038F3B |/
++  LDA r_update_equipment_data_tmp_data + 4                                    ; $038F3D |\
    BEQ ++                                                                      ; $038F3F | | This repeats the above, except for the left hand, and it
    CMP #ITEM_FIRST_BOW                                                         ; $038F41 | | stores the result in a different variable.
    BCC ++                                                                      ; $038F43 | |
    CMP #ITEM_FIRST_ARROW                                                       ; $038F45 | |
    BCS +                                                                       ; $038F47 | |
    LDA #%10000000                                                              ; $038F49 | |
    STA r_update_equipment_data_flags_left                                      ; $038F4B | |
    BRA ++                                                                      ; $038F4D | |
+   CMP #ITEM_FIRST_SHIELD                                                      ; $038F4F | |
    BCS ++                                                                      ; $038F51 | |
    LDA #%01000000                                                              ; $038F53 | |
    STA r_update_equipment_data_flags_left                                      ; $038F55 |/
++  LDA r_update_equipment_data_flags_right                                     ; $038F57 |\
    ORA r_update_equipment_data_flags_left                                      ; $038F59 | | This part checks that if a bow or arrow is equipped that
    BEQ @begin_copy_2                                                           ; $038F5B | | both are equipped. If both are not present, the two slots
    EOR #%11000000                                                              ; $038F5D | | are filled with $00, essentially reverting to no
    BEQ @begin_copy_2                                                           ; $038F5F | | equipment.
    STZ r_update_equipment_data_tmp_data + 3                                    ; $038F61 | |
    STZ r_update_equipment_data_tmp_data + 4                                    ; $038F63 |/
@begin_copy_2:                                                                  ;         |
    LDX r_update_equipment_data_index                                           ; $038F65 |\
    LDA r_update_equipment_data_tmp_data,X                                      ; $038F67 | | For each piece of equipment in the modified array (with
    TAX                                                                         ; $038F69 | | partial bow+arrow equips removed), copy the main eight
    STX r_copy_from_array_arg_index                                             ; $038F6A | | equipment data bytes.
    LDX #bank0F.equipment_property_data.w                                       ; $038F6C | |
    STX r_generic_tmp_ptr_addr                                                  ; $038F6F | | After the function returns, copy the result into a location
    LDA #:bank0F.equipment_property_data                                        ; $038F71 | | based on the index of the current piece of equipment so
    STA r_generic_tmp_ptr_bank                                                  ; $038F73 | | data about all potential five pieces of equipment is
    LDA #8.b                                                                    ; $038F75 | | available for later calculations.
    JSR _copy_from_array                                                        ; $038F77 | |
    TDC                                                                         ; $038F7A | |
    TAX                                                                         ; $038F7B | |
    TAY                                                                         ; $038F7C | |
-   LDA r_copy_from_array_result.w,X                                            ; $038F7D | |
    STA (r_update_equipment_data_result_ptr),Y                                  ; $038F80 | |
    INY                                                                         ; $038F82 | |
    INX                                                                         ; $038F83 | |
    CPX #$0008.w                                                                ; $038F84 | |
    BNE -                                                                       ; $038F87 |/
    LDA r_copy_from_array_result.w + 4                                          ; $038F89 |\
    AND #%01111111                                                              ; $038F8C | | Based on the values of one of the equipment bytes, copy
    STA r_math_multiply_8bit_arg_1                                              ; $038F8E | | three additional bytes from another location that determine
    LDA #$03                                                                    ; $038F90 | | the element and status effect properties of the equipment
    STA r_math_multiply_8bit_arg_2                                              ; $038F92 | | in question.
    JSR _math_multiply_8bit                                                     ; $038F94 | |
    LDX r_math_multiply_8bit_result                                             ; $038F97 | |
-   LDA bank0F.equipment_element_status_data.l,X                                ; $038F99 | |
    STA (r_update_equipment_data_result_ptr),Y                                  ; $038F9D | |
    INY                                                                         ; $038F9F | |
    INX                                                                         ; $038FA0 | |
    CPY #$000B.w                                                                ; $038FA1 | |
    BNE -                                                                       ; $038FA4 |/
    CLC                                                                         ; $038FA6 |\
    LDA r_update_equipment_data_result_ptr                                      ; $038FA7 | | Increment the destination address by 11, to get ready to
    ADC #$0B                                                                    ; $038FA9 | | store the bytes for the next piece of equipment.
    STA r_update_equipment_data_result_ptr                                      ; $038FAB | |
    LDA r_update_equipment_data_result_ptr_hi                                   ; $038FAD | |
    ADC #$00                                                                    ; $038FAF | |
    STA r_update_equipment_data_result_ptr_hi                                   ; $038FB1 |/
    INC r_update_equipment_data_index                                           ; $038FB3 |\
    LDA r_update_equipment_data_index                                           ; $038FB5 | | Increment the equipment index and repeat the loop until all
    CMP #$05                                                                    ; $038FB7 | | five potential pieces of equipment have been processed.
    BNE @begin_copy_2                                                           ; $038FB9 |/
    CLC                                                                         ; $038FBB |\
    LDA r_update_equipment_data_base_ptr                                        ; $038FBC | | Increment the equipment base offset by $80 in order to read
    ADC #$80                                                                    ; $038FBE | | equipment for the next character.
    STA r_update_equipment_data_base_ptr                                        ; $038FC0 | |
    LDA r_update_equipment_data_base_ptr_hi                                     ; $038FC2 | |
    ADC #$00                                                                    ; $038FC4 | |
    STA r_update_equipment_data_base_ptr_hi                                     ; $038FC6 |/
    INC r_update_equipment_data_slot                                            ; $038FC8 |\
    LDA r_update_equipment_data_slot                                            ; $038FCA | | Increment the slot and repeat the entire loop until all
    CMP #$05                                                                    ; $038FCC | | five slots are done.
    BEQ +                                                                       ; $038FCE | |
    JMP @begin_copy                                                             ; $038FD0 |/
+   RTS                                                                         ; $038FD3

; _battle_load_monster ($03:8FD4)
;
; Given a monster slot number in $B9, loads that monster's stats and battle
; scripts into RAM.
_battle_load_monster:
    LDA <r_battle_load_monster_arg_slot                                         ; $038FD4 |\ Transfer the monster slot number into a local variable.
    STA r_battle_load_monster_slot.w                                            ; $038FD6 |/
    ASL A                                                                       ; $038FD9 |\
    CLC                                                                         ; $038FDA | | Enable the monster's action timer.
    ADC #(5 * 2).b                                                              ; $038FDB | |
    TAX                                                                         ; $038FDD | |
    LDA #>TIMER_ENABLED_ACTION.b                                                ; $038FDE | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $038FE0 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $038FE3 |\
    LDA <r_battle_load_monster_arg_id                                           ; $038FE5 | | Based on the passed monster ID, load the offset to the monster
    ASL A                                                                       ; $038FE7 | | property data relative to the start of the monster property data
    TAX                                                                         ; $038FE8 | | into the X register.
    SEC                                                                         ; $038FE9 | |
    LDA bank0E.monster_property_offset_data.l,X                                 ; $038FEA | |
    SBC #bank0E.monster_property_data.w                                         ; $038FEE | |
    TAX                                                                         ; $038FF1 | |
    TDC                                                                         ; $038FF2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $038FF3 |/
    TDC                                                                         ; $038FF5 |\
    TAY                                                                         ; $038FF6 | | As the monster property record may be any size from 10 to 20
-   LDA bank0E.monster_property_data.l,X                                        ; $038FF7 | | bytes, simply copy 20 bytes from ROM to RAM.
    STA r_copy_from_array_result.w,Y                                            ; $038FFB | |
    INX                                                                         ; $038FFE | |
    INY                                                                         ; $038FFF | |
    CPY #20.w                                                                   ; $039000 | |
    BNE -                                                                       ; $039003 |/
    CLC                                                                         ; $039005 |\
    LDA r_battle_load_monster_slot.w                                            ; $039006 | | Calculate offsets for the monster slot. We have to add five since
    ADC #5.b                                                                    ; $039009 | | the monster slots really begin after the character slots.
    JSR _calculate_offsets                                                      ; $03900B |/
    LDX <r_current_slot_offset_character_battle                                 ; $03900E |\
    LDA <r_battle_load_monster_arg_egg                                          ; $039010 | | If the monster is supposed to be encapsulated within an egg, set
    BEQ +                                                                       ; $039012 | | egg status on the monster.
    LDA #STATUS_3_EGG.b                                                         ; $039014 | |
    STA r_character_battle.1.status_3.w,X                                       ; $039016 |/
    PHX                                                                         ; $039019 |\
    LDA r_battle_load_monster_slot.w                                            ; $03901A | | Also set the egg flag for this particular monster type in the
    TAX                                                                         ; $03901D | | battle.
    LDA r_monster_slot_to_id_index.w,X                                          ; $03901E | |
    TAX                                                                         ; $039021 | |
    LDA #1.b                                                                    ; $039022 | |
    STA r_monster_type_egg.w,X                                                  ; $039024 | |
    PLX                                                                         ; $039027 |/
+   LDA r_copy_from_array_result.w + monster.level_boss                         ; $039028 |\
    STA r_character_battle.1.monster_level_boss.w,X                             ; $03902B | | If the monster has the boss bit set, set the battle to be a boss
    BPL +                                                                       ; $03902E | | battle.
    INC r_boss_battle.w                                                         ; $039030 |/
+   AND #%01111111.b                                                            ; $039033 |\ Set the monster's level to the lower seven bits of that same byte.
    STA r_character_battle.1.level.w,X                                          ; $039035 |/
    CLC                                                                         ; $039038 |\
    ADC #10.b                                                                   ; $039039 | | TODO: Set an unknown byte to the monster's level plus ten.
    STA r_character_battle.1.unknown2F.w,X                                      ; $03903B |/
    LDA r_copy_from_array_result.w + monster.hp_lo                              ; $03903E |\
    STA r_character_battle.1.hp_lo.w,X                                          ; $039041 | | Set the monster's HP and maximum HP.
    STA r_character_battle.1.hp_max_lo.w,X                                      ; $039044 | |
    LDA r_copy_from_array_result.w + monster.hp_hi                              ; $039047 | |
    STA r_character_battle.1.hp_hi.w,X                                          ; $03904A | |
    STA r_character_battle.1.hp_max_hi.w,X                                      ; $03904D |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $039050 |\
    LDA r_copy_from_array_result.w + monster.hp                                 ; $039052 | | Set the monster's MP and maximum MP to the its HP divided by 16.
    JSR _math_divide_by_16                                                      ; $039055 | |
    STA r_character_battle.1.mp.w,X                                             ; $039058 | |
    STA r_character_battle.1.mp_max.w,X                                         ; $03905B | |
    TDC                                                                         ; $03905E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03905F |/
    PHX                                                                         ; $039061 |\
    LDA r_copy_from_array_result.w + monster.agility_index                      ; $039062 | | Set the monster's agility by reading the agility index and then
    AND #%00111111.b                                                            ; $039065 | | selecting a random number in the range specified by the agility
    ASL A                                                                       ; $039067 | | range data.
    TAX                                                                         ; $039068 | |
    LDA bank0E.monster_agility_range_data.l + 1,X                               ; $039069 | |
    STA <r_battle_load_monster_tmp_index                                        ; $03906D | |
    LDA bank0E.monster_agility_range_data.l,X                                   ; $03906F | |
    TAX                                                                         ; $039073 | |
    LDA <r_battle_load_monster_tmp_index                                        ; $039074 | |
    JSR _get_battle_rng                                                         ; $039076 | |
    PLX                                                                         ; $039079 | |
    STA r_character_battle.1.agility.w,X                                        ; $03907A |/
    LDA r_formation_properties.flags2.w                                         ; $03907D |\
    AND #FORMATION_FLAGS_2_AUTO_BATTLE.b                                        ; $039080 | | If this is an auto-battle, set the monster's default speed
    BEQ +                                                                       ; $039082 | | modifier to 1. Otherwise, set it to the standard default of 16.
    LDA #1.b                                                                    ; $039084 | |
    STA r_character_battle.1.speed_modifier.w,X                                 ; $039086 | |
    BRA ++                                                                      ; $039089 | |
+   LDA #16.b                                                                   ; $03908B | |
    STA r_character_battle.1.speed_modifier.w,X                                 ; $03908D |/
++  LDA r_copy_from_array_result.w + monster.script_index                       ; $039090 |\ Load the monster's script index and save it for later use.
    STA r_battle_load_monster_script_index.w                                    ; $039093 |/
    PHX                                                                         ; $039096 |\
    LDA <r_battle_load_monster_arg_slot                                         ; $039097 | | Set the X register to the index of the monster type in this
    TAX                                                                         ; $039099 | | battle.
    LDA r_monster_slot_to_id_index.w,X                                          ; $03909A | |
    TAX                                                                         ; $03909D |/
    LDA <r_battle_load_monster_arg_id                                           ; $03909E |\
    STA r_monster_ids_initial_exp.w,X                                           ; $0390A0 | | Save the monster IDs for use during spoils calculation.
    STA r_monster_ids_initial_gp.w,X                                            ; $0390A3 |/
    LDA r_copy_from_array_result.w + monster.item_index                         ; $0390A6 |\
    STA r_monster_items.w,X                                                     ; $0390A9 | | Save the item index for monsters of this type in the battle and
    PLX                                                                         ; $0390AC | | also save it in the monster's battle record.
    STA r_character_battle.1.monster_item_index.w,X                             ; $0390AD |/
    LDA r_copy_from_array_result.w + monster.physical_attack_index              ; $0390B0 |\
    JSR _load_monster_derived_stats                                             ; $0390B3 | | Set the monster's physical attack stats.
    LDA r_copy_from_array_result.w + 128                                        ; $0390B6 | |
    STA r_character_battle.1.physical_attack_multiplier.w,X                     ; $0390B9 | |
    LDA r_copy_from_array_result.w + 129                                        ; $0390BC | |
    STA r_character_battle.1.physical_attack_accuracy.w,X                       ; $0390BF | |
    LDA r_copy_from_array_result.w + 130                                        ; $0390C2 | |
    STA r_character_battle.1.physical_attack_base.w,X                           ; $0390C5 |/
    LDA r_copy_from_array_result.w + monster.physical_defense_index             ; $0390C8 |\
    JSR _load_monster_derived_stats                                             ; $0390CB | | Set the monster's physical defense stats.
    LDA r_copy_from_array_result.w + 128                                        ; $0390CE | |
    STA r_character_battle.1.physical_defense_multiplier.w,X                    ; $0390D1 | | BUG: The evade percentage is written to the base value instead of
    LDA r_copy_from_array_result.w + 129                                        ; $0390D4 | |      to the actual evade location. This is quickly overwritten by
    STA r_character_battle.1.physical_defense_base.w,X                          ; $0390D7 | |      the actual base value. As a result, monsters have no evade.
    LDA r_copy_from_array_result.w + 130                                        ; $0390DA | |      This may be a quick "fix" after monsters proved too elusive.
    STA r_character_battle.1.physical_defense_base.w,X                          ; $0390DD |/
    LDA r_copy_from_array_result.w + monster.magic_defense_index                ; $0390E0 |\
    JSR _load_monster_derived_stats                                             ; $0390E3 | | Set the monster's magic defense stats.
    LDA r_copy_from_array_result.w + 128                                        ; $0390E6 | |
    STA r_character_battle.1.magic_defense_multiplier.w,X                       ; $0390E9 | | BUG: The same bug as above also applies here, except with magic
    LDA r_copy_from_array_result.w + 129                                        ; $0390EC | |      evade.
    STA r_character_battle.1.magic_defense_base.w,X                             ; $0390EF | |
    LDA r_copy_from_array_result.w + 130                                        ; $0390F2 | |
    STA r_character_battle.1.magic_defense_base.w,X                             ; $0390F5 |/
    LDA r_copy_from_array_result.w + monster.flags                              ; $0390F8 |\
    BNE +                                                                       ; $0390FB | | If the monster has no extra data, skip ahead past this section.
    JMP @extra_done                                                             ; $0390FD |/
+   TDC                                                                         ; $039100 |\
    TAY                                                                         ; $039101 | | If the monster data has elemental and status attack data, set the
    LDA r_copy_from_array_result.w + monster.flags                              ; $039102 | | monster's attack element and status bytes.
    AND #MONSTER_FLAGS_ELEMENTAL_STATUS_ATTACK.b                                ; $039105 | |
    BEQ +                                                                       ; $039107 | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039109 | |
    STA r_character_battle.1.physical_attack_element.w,X                        ; $03910C | |
    INY                                                                         ; $03910F | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039110 | |
    STA r_character_battle.1.physical_attack_status_1.w,X                       ; $039113 | |
    INY                                                                         ; $039116 | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039117 | |
    STA r_character_battle.1.physical_attack_status_2.w,X                       ; $03911A | |
    INY                                                                         ; $03911D |/
+   LDA r_copy_from_array_result.w + monster.flags                              ; $03911E |\
    AND #MONSTER_FLAGS_ELEMENTAL_STATUS_DEFENSE.b                               ; $039121 | | If the monster has elemental and status defense data, set the
    BEQ +++                                                                     ; $039123 | | monster's element and status defense bytes. If the top bit of the
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039125 | | elemental defense byte is set, it will be interpreted as immunity,
    BPL +                                                                       ; $039128 | | but otherwise as resistance.
    STA r_character_battle.1.element_immunity.w,X                               ; $03912A | |
    BRA ++                                                                      ; $03912D | |
+   STA r_character_battle.1.element_resistance.w,X                             ; $03912F | |
++  INY                                                                         ; $039132 | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039133 | |
    STA r_character_battle.1.status_1_immunity.w,X                              ; $039136 | |
    INY                                                                         ; $039139 | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $03913A | |
    STA r_character_battle.1.status_2_immunity.w,X                              ; $03913D | |
    INY                                                                         ; $039140 |/
+++ LDA r_copy_from_array_result.w + monster.flags                              ; $039141 |\
    AND #MONSTER_FLAGS_ELEMENTAL_WEAKNESS.b                                     ; $039144 | | If the monster has elemental weakness data, set the related bytes
    BEQ ++                                                                      ; $039146 | | in its battle record. If the high bit is set, it is interpreted as
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039148 | | a strong weakness. Otherwise, it's a normal weakness.
    BPL +                                                                       ; $03914B | |
    STA r_character_battle.1.element_weakness_strong.w,X                        ; $03914D | |
+   STA r_character_battle.1.element_weakness.w,X                               ; $039150 |/
    INY                                                                         ; $039153 |\
    AND #ELEMENT_AIR.b                                                          ; $039154 | | In addition, if the monster is weak to the air element, give them
    BEQ ++                                                                      ; $039156 | | the float status.
    LDA #STATUS_2_FLOAT.b                                                       ; $039158 | |
    STA r_character_battle.1.status_2.w,X                                       ; $03915A |/
++  LDA r_copy_from_array_result.w + monster.flags                              ; $03915D |\
    AND #MONSTER_FLAGS_MAGIC_POWER.b                                            ; $039160 | | If the monster has a configured magic power, set both their wisdom
    BEQ +                                                                       ; $039162 | | and will to this value.
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039164 | |
    STA r_character_battle.1.wisdom_base.w,X                                    ; $039167 | |
    STA r_character_battle.1.will_base.w,X                                      ; $03916A | |
    STA r_character_battle.1.wisdom.w,X                                         ; $03916D | |
    STA r_character_battle.1.will.w,X                                           ; $039170 | |
    INY                                                                         ; $039173 |/
+   LDA r_copy_from_array_result.w + monster.flags                              ; $039174 |\
    AND #MONSTER_FLAGS_RACE.b                                                   ; $039177 | | Set the monster's race if it configured as having one.
    BEQ +                                                                       ; $039179 | |
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $03917B | |
    STA r_character_battle.1.monster_race.w,X                                   ; $03917E | |
    INY                                                                         ; $039181 |/
+   LDA r_copy_from_array_result.w + monster.flags                              ; $039182 |\
    AND #MONSTER_FLAGS_COUNTER.b                                                ; $039185 | | If the monster has no counter data, skip directly to the next
    BNE +                                                                       ; $039187 | | section.
    JMP @extra_done                                                             ; $039189 |/
+   LDA r_battle_load_monster_slot.w                                            ; $03918C |\
    TAX                                                                         ; $03918F | | Flag this monster as having counters.
    INC r_monster_has_counters.w,X                                              ; $039190 |/
    LDA r_copy_from_array_result.w + monster.extra_data,Y                       ; $039193 |\ Load the index of the monster's counter script data.
    STA r_battle_load_monster_counter_script_index.w                            ; $039196 |/
    LDA r_battle_load_monster_slot.w                                            ; $039199 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03919C | | Calculate the index into this monster's script data by multiplying
    LDA #_sizeof_battle_script.b                                                ; $03919E | | the slot number by the size of the script in RAM.
    STA <r_math_multiply_8bit_arg_2                                             ; $0391A0 | |
    JSR _math_multiply_8bit                                                     ; $0391A2 |/
    LDA r_battle_load_monster_counter_script_index.w                            ; $0391A5 |\
    STA <r_find_nth_entry_arg_n                                                 ; $0391A8 | | Find the location of the monster's script data in ROM and transfer
    LDY #bank0E.battle_script_data.w                                            ; $0391AA | | it to the X register.
    LDA #:bank0E.battle_script_data.b                                           ; $0391AD | |
    JSR _find_nth_entry                                                         ; $0391AF | |
    TYX                                                                         ; $0391B2 |/
    LDY <r_math_multiply_8bit_result                                            ; $0391B3 |\
    STY <r_battle_load_monster_tmp_script_index_1                               ; $0391B5 | | Save the calculated RAM index for later use.
    STY <r_battle_load_monster_tmp_script_index_2                               ; $0391B7 |/
-   LDA bank0E.battle_script_data.l,X                                           ; $0391B9 |\
    STA r_monster_counter_scripts.w,Y                                           ; $0391BD | | Transfer data from ROM until the terminating $FF is encountered.
    INX                                                                         ; $0391C0 | |
    INY                                                                         ; $0391C1 | |
    CMP #$FF.b                                                                  ; $0391C2 | |
    BNE -                                                                       ; $0391C4 |/
    LDA r_battle_load_monster_slot.w                                            ; $0391C6 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $0391C9 | | Calculate the index for the monster's condition sets by
    LDA #_sizeof_condition_sets.b                                               ; $0391CB | | multiplying the monster slot by the size of each monster's
    STA <r_math_multiply_8bit_arg_2                                             ; $0391CD | | condition sets.
    JSR _math_multiply_8bit                                                     ; $0391CF | |
    LDY <r_math_multiply_8bit_result                                            ; $0391D2 | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $0391D4 | |
    STY <r_battle_load_monster_tmp_set_index_2                                  ; $0391D6 |/
--  LDX <r_battle_load_monster_tmp_script_index_1                               ; $0391D8 |\
    LDA r_monster_counter_scripts.w,X                                           ; $0391DA | | If there are no more entries in the monster's script, skip past
    CMP #$FF.b                                                                  ; $0391DD | | this function.
    BEQ ++                                                                      ; $0391DF |/
    STA <r_find_nth_entry_arg_n                                                 ; $0391E1 |\
    LDY #bank0E.battle_condition_sets_data.w                                    ; $0391E3 | | Look up the offset to the particular condition set being
    LDA #:bank0E.battle_condition_sets_data.b                                   ; $0391E6 | | referenced in this script.
    JSR _find_nth_entry                                                         ; $0391E8 | |
    TYX                                                                         ; $0391EB |/
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $0391EC | Load the index to the monster's condition sets.
    LDA #4.b                                                                    ; $0391EE |\ Set the counter index to four, as we need to read up to four bytes.
    STA <r_battle_load_monster_tmp_index                                        ; $0391F0 |/
-   LDA bank0E.battle_condition_sets_data.l,X                                   ; $0391F2 |\ Read the next byte and store it in the monster's data.
    STA r_monster_counter_condition_sets.w,Y                                    ; $0391F6 |/
    CMP #$FF.b                                                                  ; $0391F9 |\
    BEQ +                                                                       ; $0391FB | | If the value is $FF, don't increment the source index anymore.
    INX                                                                         ; $0391FD |/
+   INY                                                                         ; $0391FE |\
    DEC <r_battle_load_monster_tmp_index                                        ; $0391FF | | Repeat the read/store loop until all four bytes have been copied.
    LDA <r_battle_load_monster_tmp_index                                        ; $039201 | |
    BNE -                                                                       ; $039203 |/
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $039205 | Update the index into the monster's condition sets.
    CLC                                                                         ; $039207 |\
    LDA <r_battle_load_monster_tmp_script_index_1_lo                            ; $039208 | | Increment the index into the script by 2 (in order to remain on
    ADC #2.b                                                                    ; $03920A | | the condition byte) and return back to the start of the loop.
    STA <r_battle_load_monster_tmp_script_index_1_lo                            ; $03920C | |
    LDA <r_battle_load_monster_tmp_script_index_1_hi                            ; $03920E | |
    ADC #0.b                                                                    ; $039210 | |
    STA <r_battle_load_monster_tmp_script_index_1_hi                            ; $039212 | |
    BRA --                                                                      ; $039214 |/
++  LDA r_battle_load_monster_slot.w                                            ; $039216 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $039219 | | Calculate the index into the monster's actual condition data by
    LDA #_sizeof_condition_sets_expanded.b                                      ; $03921B | | multiplying the slot number by the size of the conditions array.
    STA <r_math_multiply_8bit_arg_2                                             ; $03921D | |
    JSR _math_multiply_8bit                                                     ; $03921F | |
    LDY <r_math_multiply_8bit_result                                            ; $039222 | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $039224 |/
    LDA #10.b                                                                   ; $039226 |\ Initialize the secondary loop variable to loop through all ten
    STA <r_battle_load_monster_tmp_count_2                                      ; $039228 |/ possible sets of conditions.
--- LDA #4.b                                                                    ; $03922A |\ Initialize this loop variable to loop through each of the four
    STA <r_battle_load_monster_tmp_index                                        ; $03922C |/ possible conditions per set.
--  LDX <r_battle_load_monster_tmp_set_index_2                                  ; $03922E |\ Load the next condition index.
    LDA r_monster_counter_condition_sets.w,X                                    ; $039230 |/
    CMP #$FF.b                                                                  ; $039233 |\ If it's $FF, skip ahead to the next part of the loop, as there are
    BEQ +                                                                       ; $039235 |/ no more conditions in this set.
    STA <r_math_multiply_8bit_arg_1                                             ; $039237 |\
    LDA #4.b                                                                    ; $039239 | | Calculate the index into the condition data by taking the
    STA <r_math_multiply_8bit_arg_2                                             ; $03923B | | condition byte and multiplying by four.
    JSR _math_multiply_8bit                                                     ; $03923D | |
    LDX <r_math_multiply_8bit_result                                            ; $039240 |/
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $039242 | Load the index into the condition data into the Y register.
    LDA #4.b                                                                    ; $039244 |\
    STA <r_battle_load_monster_tmp_count_1                                      ; $039246 | | Copy the four bytes for this particular condition from ROM to the
-   LDA bank0E.battle_condition_data.l,X                                        ; $039248 | | monster's condition data in RAM.
    STA r_monster_counter_conditions.w,Y                                        ; $03924C | |
    INX                                                                         ; $03924F | |
    INY                                                                         ; $039250 | |
    DEC <r_battle_load_monster_tmp_count_1                                      ; $039251 | |
    LDA <r_battle_load_monster_tmp_count_1                                      ; $039253 | |
    BNE -                                                                       ; $039255 |/
+   CLC                                                                         ; $039257 |\
    LDA <r_battle_load_monster_tmp_set_index_1_lo                               ; $039258 | | Add four to the index into the monster's condition data to move to
    ADC #4.b                                                                    ; $03925A | | the next condition.
    STA <r_battle_load_monster_tmp_set_index_1_lo                               ; $03925C | |
    LDA <r_battle_load_monster_tmp_set_index_1_hi                               ; $03925E | |
    ADC #0.b                                                                    ; $039260 | |
    STA <r_battle_load_monster_tmp_set_index_1_hi                               ; $039262 |/
    CLC                                                                         ; $039264 |\
    LDA <r_battle_load_monster_tmp_set_index_2_lo                               ; $039265 | | Add one to the index into the condition set to move to the next
    ADC #1.b                                                                    ; $039267 | | condition byte.
    STA <r_battle_load_monster_tmp_set_index_2_lo                               ; $039269 | |
    LDA <r_battle_load_monster_tmp_set_index_2_hi                               ; $03926B | |
    ADC #0.b                                                                    ; $03926D | |
    STA <r_battle_load_monster_tmp_set_index_2_hi                               ; $03926F |/
    DEC <r_battle_load_monster_tmp_index                                        ; $039271 |\
    LDA <r_battle_load_monster_tmp_index                                        ; $039273 | | Loop until all four potential conditions are handled.
    BNE --                                                                      ; $039275 |/
    DEC <r_battle_load_monster_tmp_count_2                                      ; $039277 |\
    LDA <r_battle_load_monster_tmp_count_2                                      ; $039279 | | Loop until all 10 entries have been handled.
    BNE ---                                                                     ; $03927B |/
    LDA r_battle_load_monster_slot.w                                            ; $03927D |\
    TAX                                                                         ; $039280 | | Calculate the index into the monster's action data by multiplying
    STX r_math_multiply_16bit_arg_1.w                                           ; $039281 | | the slot number by the size of each monster's data.
    LDX #_sizeof_action_sets.w                                                  ; $039284 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $039287 | |
    JSR _math_multiply_16bit                                                    ; $03928A | |
    LDY r_math_multiply_16bit_result_lo.w                                       ; $03928D | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $039290 |/
--  LDX <r_battle_load_monster_tmp_script_index_2                               ; $039292 |\
    LDA r_monster_counter_scripts.w,X                                           ; $039294 | | Read the next action index and if it's $FF, skip to the end of the
    CMP #$FF.b                                                                  ; $039297 | | extra segment.
    BEQ @extra_done                                                             ; $039299 |/
    INX                                                                         ; $03929B |\
    LDA r_monster_counter_scripts.w,X                                           ; $03929C | | For the read action index, find the actual offset for that data,
    STA <r_find_nth_entry_arg_n                                                 ; $03929F | | automatically switching to the alternate data if the flag to use
    LDY #bank0E.battle_action_standard_data.w                                   ; $0392A1 | | the alternate scripts is set.
    LDA r_battle_alternate_scripts.w                                            ; $0392A4 | |
    BEQ +                                                                       ; $0392A7 | |
    LDY #bank0E.battle_action_alternate_data.w                                  ; $0392A9 | |
+   LDA #:bank0E.battle_action_standard_data.b                                  ; $0392AC | |
    JSR _find_nth_entry                                                         ; $0392AE |/
    LDA r_battle_alternate_scripts.w                                            ; $0392B1 |\
    BNE +                                                                       ; $0392B4 | | If the alternate battle scripts flag is not set, copy the actions
    TYX                                                                         ; $0392B6 | | from ROM to RAM from the standard location.
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $0392B7 | |
-   LDA bank0E.battle_action_standard_data.l,X                                  ; $0392B9 | |
    STA r_monster_counter_actions,Y                                             ; $0392BD | |
    INX                                                                         ; $0392C0 | |
    INY                                                                         ; $0392C1 | |
    CMP #$FF.b                                                                  ; $0392C2 | |
    BNE -                                                                       ; $0392C4 | |
    BRA ++                                                                      ; $0392C6 |/
+   TYX                                                                         ; $0392C8 |\
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $0392C9 | | Otherwise, copy it from the alternate location.
-   LDA bank0E.battle_action_alternate_data.l,X                                 ; $0392CB | |
    STA r_monster_counter_actions,Y                                             ; $0392CF | |
    INX                                                                         ; $0392D2 | |
    INY                                                                         ; $0392D3 | |
    CMP #$FF.b                                                                  ; $0392D4 | |
    BNE -                                                                       ; $0392D6 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $0392D8 |\
    CLC                                                                         ; $0392DA | | Increment the indexes to move to the next set of actions and
    LDA <r_battle_load_monster_tmp_set_index_1                                  ; $0392DB | | return to the start of the loop.
    ADC #_sizeof_action_set.w                                                   ; $0392DD | |
    STA <r_battle_load_monster_tmp_set_index_1                                  ; $0392E0 | |
    CLC                                                                         ; $0392E2 | |
    LDA <r_battle_load_monster_tmp_script_index_2                               ; $0392E3 | |
    ADC #_sizeof_battle_script_entry.w                                          ; $0392E5 | |
    STA <r_battle_load_monster_tmp_script_index_2                               ; $0392E8 | |
    TDC                                                                         ; $0392EA | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0392EB | |
    BRA --                                                                      ; $0392ED |/
@extra_done:
    LDA r_battle_load_monster_slot.w                                            ; $0392EF |\
    STA <r_math_multiply_8bit_arg_1                                             ; $0392F2 | | Calculate the index into the monster's primary battle scripts by
    LDA #_sizeof_battle_script.b                                                ; $0392F4 | | multiplying the monster slot number by the size of each monster's
    STA <r_math_multiply_8bit_arg_2                                             ; $0392F6 | | battle scripts.
    JSR _math_multiply_8bit                                                     ; $0392F8 |/
    LDA r_battle_load_monster_script_index.w                                    ; $0392FB |\
    STA <r_find_nth_entry_arg_n                                                 ; $0392FE | | Based on the monster's script index, determine the offset to the
    LDY #bank0E.battle_script_data.w                                            ; $039300 | | actual data and move it to the X register.
    LDA #:bank0E.battle_script_data.b                                           ; $039303 | |
    JSR _find_nth_entry                                                         ; $039305 | |
    TYX                                                                         ; $039308 |/
    LDY <r_math_multiply_8bit_result                                            ; $039309 | Load the previously calculated index and put it in the Y register.
    STY <r_battle_load_monster_tmp_script_index_1                               ; $03930B |\ Save it to two index variables for later use.
    STY <r_battle_load_monster_tmp_script_index_2                               ; $03930D |/
-   LDA bank0E.battle_script_data.l,X                                           ; $03930F |\
    STA r_monster_scripts.w,Y                                                   ; $039313 | | Copy the monster's script data from ROM to RAM.
    INX                                                                         ; $039316 | |
    INY                                                                         ; $039317 | |
    CMP #$FF.b                                                                  ; $039318 | |
    BNE -                                                                       ; $03931A |/
    LDA r_battle_load_monster_slot.w                                            ; $03931C |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03931F | | Calculate the index for the monster's condition sets by
    LDA #_sizeof_condition_sets.b                                               ; $039321 | | multiplying the monster slot by the size of each monster's
    STA <r_math_multiply_8bit_arg_2                                             ; $039323 | | condition sets.
    JSR _math_multiply_8bit                                                     ; $039325 | |
    LDY <r_math_multiply_8bit_result                                            ; $039328 | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $03932A | |
    STY <r_battle_load_monster_tmp_set_index_2                                  ; $03932C |/
--  LDX <r_battle_load_monster_tmp_script_index_1                               ; $03932E |\
    LDA r_monster_scripts.w,X                                                   ; $039330 | | If there are no more entries in the monster's script, skip past
    CMP #$FF.b                                                                  ; $039333 | | this function.
    BEQ ++                                                                      ; $039335 |/
    STA <r_find_nth_entry_arg_n                                                 ; $039337 |\
    LDY #bank0E.battle_condition_sets_data.w                                    ; $039339 | | Look up the offset to the particular condition set being
    LDA #:bank0E.battle_condition_sets_data.b                                   ; $03933C | | referenced in this script.
    JSR _find_nth_entry                                                         ; $03933E | |
    TYX                                                                         ; $039341 |/
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $039342 | Load the index to the monster's condition sets.
    LDA #4.b                                                                    ; $039344 |\ Set the counter index to four, as we need to read up to four bytes.
    STA <r_battle_load_monster_tmp_index                                        ; $039346 |/
-   LDA bank0E.battle_condition_sets_data.l,X                                   ; $039348 |\ Read the next byte and store it in the monster's data.
    STA r_monster_condition_sets.w,Y                                            ; $03934C |/
    CMP #$FF.b                                                                  ; $03934F |\
    BEQ +                                                                       ; $039351 | | If the value is $FF, don't increment the source index anymore.
    INX                                                                         ; $039353 |/
+   INY                                                                         ; $039354 |\
    DEC <r_battle_load_monster_tmp_index                                        ; $039355 | | Repeat the read/store loop until all four bytes have been copied.
    LDA <r_battle_load_monster_tmp_index                                        ; $039357 | |
    BNE -                                                                       ; $039359 |/
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $03935B | Update the index into the monster's condition sets.
    CLC                                                                         ; $03935D |\
    LDA <r_battle_load_monster_tmp_script_index_1_lo                            ; $03935E | | Increment the index into the script by 2 (in order to remain on
    ADC #2.b                                                                    ; $039360 | | the condition byte) and return back to the start of the loop.
    STA <r_battle_load_monster_tmp_script_index_1_lo                            ; $039362 | |
    LDA <r_battle_load_monster_tmp_script_index_1_hi                            ; $039364 | |
    ADC #0.b                                                                    ; $039366 | |
    STA <r_battle_load_monster_tmp_script_index_1_hi                            ; $039368 | |
    BRA --                                                                      ; $03936A |/
++  LDA r_battle_load_monster_slot.w                                            ; $03936C |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03936F | | Calculate the index into the monster's actual condition data by
    LDA #_sizeof_condition_sets_expanded.b                                      ; $039371 | | multiplying the slot number by the size of the conditions array.
    STA <r_math_multiply_8bit_arg_2                                             ; $039373 | |
    JSR _math_multiply_8bit                                                     ; $039375 | |
    LDY <r_math_multiply_8bit_result                                            ; $039378 | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $03937A |/
    LDA #10.b                                                                   ; $03937C |\ Initialize the secondary loop variable to loop through all then
    STA <r_battle_load_monster_tmp_count_2                                      ; $03937E |/ possible sets of conditions.
--- LDA #4.b                                                                    ; $039380 |\ Initialize this loop variable to loop through each of the four
    STA <r_battle_load_monster_tmp_index                                        ; $039382 |/ possible conditions per set.
--  LDX <r_battle_load_monster_tmp_set_index_2                                  ; $039384 |\ Load the next condition index.
    LDA r_monster_condition_sets.w,X                                            ; $039386 |/
    CMP #$FF.b                                                                  ; $039389 |\ If it's $FF, skip ahead to the next part of the loop, as there are
    BEQ +                                                                       ; $03938B |/ no more conditions in this set.
    STA <r_math_multiply_8bit_arg_1                                             ; $03938D |\
    LDA #4.b                                                                    ; $03938F | | Calculate the index into the condition data by taking the
    STA <r_math_multiply_8bit_arg_2                                             ; $039391 | | condition byte and multiplying by four.
    JSR _math_multiply_8bit                                                     ; $039393 | |
    LDX <r_math_multiply_8bit_result                                            ; $039396 |/
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $039398 | Load the index into the condition data into the Y register.
    LDA #$04.b                                                                  ; $03939A |\
    STA <r_battle_load_monster_tmp_count_1                                      ; $03939C | | Copy the four bytes for this particular condition from ROM to the
-   LDA bank0E.battle_condition_data.l,X                                        ; $03939E | | monster's condition data in RAM.
    STA r_monster_conditions.w,Y                                                ; $0393A2 | |
    INX                                                                         ; $0393A5 | |
    INY                                                                         ; $0393A6 | |
    DEC <r_battle_load_monster_tmp_count_1                                      ; $0393A7 | |
    LDA <r_battle_load_monster_tmp_count_1                                      ; $0393A9 | |
    BNE -                                                                       ; $0393AB |/
+   CLC                                                                         ; $0393AD |\
    LDA <r_battle_load_monster_tmp_set_index_1_lo                               ; $0393AE | | Add four to the index into the monster's condition data to move to
    ADC #4.b                                                                    ; $0393B0 | | the next condition.
    STA <r_battle_load_monster_tmp_set_index_1_lo                               ; $0393B2 | |
    LDA <r_battle_load_monster_tmp_set_index_1_hi                               ; $0393B4 | |
    ADC #$00.b                                                                  ; $0393B6 | |
    STA <r_battle_load_monster_tmp_set_index_1_hi                               ; $0393B8 |/
    CLC                                                                         ; $0393BA |\
    LDA <r_battle_load_monster_tmp_set_index_2_lo                               ; $0393BB | | Add one to the index into the condition set to move to the next
    ADC #1.b                                                                    ; $0393BD | | condition byte.
    STA <r_battle_load_monster_tmp_set_index_2_lo                               ; $0393BF | |
    LDA <r_battle_load_monster_tmp_set_index_2_hi                               ; $0393C1 | |
    ADC #0.b                                                                    ; $0393C3 | |
    STA <r_battle_load_monster_tmp_set_index_2_hi                               ; $0393C5 |/
    DEC <r_battle_load_monster_tmp_index                                        ; $0393C7 |\
    LDA <r_battle_load_monster_tmp_index                                        ; $0393C9 | | Loop until all four potential conditions are handled.
    BNE --                                                                      ; $0393CB |/
    DEC <r_battle_load_monster_tmp_count_2                                      ; $0393CD |\
    LDA <r_battle_load_monster_tmp_count_2                                      ; $0393CF | | Loop until all 10 entries have been handled.
    BNE ---                                                                     ; $0393D1 |/
    LDA r_battle_load_monster_slot.w                                            ; $0393D3 |\
    TAX                                                                         ; $0393D6 | | Calculate the index into the monster's action data by multiplying
    STX r_math_multiply_16bit_arg_1.w                                           ; $0393D7 | | the slot number by the size of each monster's data.
    LDX #_sizeof_action_sets.w                                                  ; $0393DA | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $0393DD | |
    JSR _math_multiply_16bit                                                    ; $0393E0 | |
    LDY r_math_multiply_16bit_result_lo.w                                       ; $0393E3 | |
    STY <r_battle_load_monster_tmp_set_index_1                                  ; $0393E6 |/
    STY r_battle_load_monster_tmp_action_index.w                                ; $0393E8 | Save the index into the monster's action data for later.
--- LDX <r_battle_load_monster_tmp_script_index_2                               ; $0393EB |\
    LDA r_monster_scripts.w,X                                                   ; $0393ED | | Read the next action index and if it's $FF, skip to the end of the
    CMP #$FF.b                                                                  ; $0393F0 | | extra segment.
    BEQ @scripts_done                                                           ; $0393F2 |/
    INX                                                                         ; $0393F4 |\
    LDA r_monster_scripts.w,X                                                   ; $0393F5 | | For the read action index, find the actual offset for that data,
    STA <r_find_nth_entry_arg_n                                                 ; $0393F8 | | automatically switching to the alternate data if the flag to use
    LDY #bank0E.battle_action_standard_data.w                                   ; $0393FA | | the alternate scripts is set.
    LDA r_battle_alternate_scripts.w                                            ; $0393FD | |
    BEQ +                                                                       ; $039400 | |
    LDY #bank0E.battle_action_alternate_data.w                                  ; $039402 | |
+   LDA #:bank0E.battle_action_standard_data.b                                  ; $039405 | |
    JSR _find_nth_entry                                                         ; $039407 |/
    LDA r_battle_alternate_scripts.w                                            ; $03940A |\
    BNE +                                                                       ; $03940D | | If the alternate battle scripts flag is not set, copy the actions
    TYX                                                                         ; $03940F | | from ROM to RAM from the standard location.
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $039410 | |
-   LDA bank0E.battle_action_standard_data.l,X                                  ; $039412 | |
    STA r_monster_actions.w,Y                                                   ; $039416 | |
    INX                                                                         ; $039419 | |
    INY                                                                         ; $03941A | |
    CMP #$FF.b                                                                  ; $03941B | |
    BNE -                                                                       ; $03941D | |
    BRA ++                                                                      ; $03941F |/
+   TYX                                                                         ; $039421 |\
    LDY <r_battle_load_monster_tmp_set_index_1                                  ; $039422 | | Otherwise, copy it from the alternate location.
-   LDA bank0E.battle_action_alternate_data.l,X                                 ; $039424 | |
    STA r_monster_actions.w,Y                                                   ; $039428 | |
    INX                                                                         ; $03942B | |
    INY                                                                         ; $03942C | |
    CMP #$FF.b                                                                  ; $03942D | |
    BNE -                                                                       ; $03942F |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $039431 |\
    CLC                                                                         ; $039433 | |
    LDA <r_battle_load_monster_tmp_set_index_1                                  ; $039434 | |
    ADC #_sizeof_action_set.w                                                   ; $039436 | |
    STA <r_battle_load_monster_tmp_set_index_1                                  ; $039439 | |
    CLC                                                                         ; $03943B | |
    LDA <r_battle_load_monster_tmp_script_index_2                               ; $03943C | |
    ADC #_sizeof_battle_script_entry.w                                          ; $03943E | |
    STA <r_battle_load_monster_tmp_script_index_2                               ; $039441 | |
    TDC                                                                         ; $039443 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $039444 | |
    BRA ---                                                                     ; $039446 |/
@scripts_done:
    LDA r_battle_load_monster_slot.w                                            ; $039448 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03944B | | Calculate the index into the monster's script data by multiplying
    LDA #_sizeof_battle_script.b                                                ; $03944D | | the slot number by the size of each monster's script.
    STA <r_math_multiply_8bit_arg_2                                             ; $03944F | |
    JSR _math_multiply_8bit                                                     ; $039451 | |
    LDX <r_math_multiply_8bit_result                                            ; $039454 |/
    TDC                                                                         ; $039456 |\
    TAY                                                                         ; $039457 | | Initialize the index to zero.
    STY <r_battle_load_monster_tmp_index                                        ; $039458 |/
-   LDA r_monster_scripts.w,X                                                   ; $03945A |\
    BEQ +                                                                       ; $03945D | | Find which of the monster's scripts corresponds to a condition set
    INX                                                                         ; $03945F | | of $00 (which is no condition).
    INX                                                                         ; $039460 | |
    INC <r_battle_load_monster_tmp_index                                        ; $039461 | |
    INC <r_battle_load_monster_tmp_index                                        ; $039463 | |
    BRA -                                                                       ; $039465 |/
+   LDA <r_battle_load_monster_tmp_index                                        ; $039467 |\
    LSR A                                                                       ; $039469 | | Divide that value by two (as each entry in the script has two
    PHA                                                                         ; $03946A | | bytes) and store it in RAM as the current active action index.
    LDA r_battle_load_monster_slot.w                                            ; $03946B | |
    TAX                                                                         ; $03946E | |
    PLA                                                                         ; $03946F | |
    STA r_monster_current_script_index.w,X                                      ; $039470 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $039473 |\
    LDA #_sizeof_action_set.b                                                   ; $039475 | | Calculate the equivalent offset into the monster's action data.
    STA <r_math_multiply_8bit_arg_2                                             ; $039477 | |
    JSR _math_multiply_8bit                                                     ; $039479 |/
    LDA r_battle_load_monster_slot.w                                            ; $03947C |\
    ASL A                                                                       ; $03947F | | Finally, save the actual offset to the default action data by
    TAX                                                                         ; $039480 | | taking the index into this monster's action data and adding the
    CLC                                                                         ; $039481 | | offset to this monster's action data as a whole.
    LDA r_battle_load_monster_tmp_action_index.w                                ; $039482 | |
    ADC <r_math_multiply_8bit_result_lo                                         ; $039485 | |
    STA r_monster_current_action_set_offset.w,X                                 ; $039487 | |
    LDA r_battle_load_monster_tmp_action_index.w + 1                            ; $03948A | |
    ADC <r_math_multiply_8bit_result_hi                                         ; $03948D | |
    STA r_monster_current_action_set_offset.w + 1,X                             ; $03948F |/
    RTS                                                                         ; $039492

; _load_monster_derived_stats ($03:9493)
;
; Given an index value in the accumulator, loads the associated derived monster
; stats into $291C, $291D, and $291E.
_load_monster_derived_stats:
    PHX                                                                         ; $039493 | Save the value of the X register.
    STA <r_math_multiply_8bit_arg_1                                             ; $039494 |\
    LDA #3.b                                                                    ; $039496 | | Multiply the index value by three to determine the actual index.
    STA <r_math_multiply_8bit_arg_2                                             ; $039498 | |
    JSR _math_multiply_8bit                                                     ; $03949A | |
    LDX <r_math_multiply_8bit_result                                            ; $03949D |/
    LDY #128.w                                                                  ; $03949F | Set the base offset to 128.
-   LDA bank0E.monster_derived_stats_data.l,X                                   ; $0394A2 |\ Load the next byte and store it to the result array.
    STA r_copy_from_array_result.w,Y                                            ; $0394A6 |/
    INX                                                                         ; $0394A9 |\
    INY                                                                         ; $0394AA | | Increment the two indexes and loop until all three bytes have been
    CPY #131.w                                                                  ; $0394AB | | copied.
    BNE -                                                                       ; $0394AE |/
    PLX                                                                         ; $0394B0 | Restore the value of the X register.
    RTS                                                                         ; $0394B1

; _init_character_battle ($03:94B2)
;
; Preconditions:
;   Direct Register: $0000
;   Data Bank Register: $7E
;
; This function initializes the in-battle character records.
_init_character_battle:
    LDX #r_character_battle.w                                                   ; $0394B2 |\
    STX r_init_character_battle_base                                            ; $0394B5 | | Load the base address for in-battle character records to
    TDC                                                                         ; $0394B7 | | RAM, set the X register to zero, and set the slot number to
    TAX                                                                         ; $0394B8 | | zero.
    STZ r_init_character_battle_slot                                            ; $0394B9 |/
@copy_stats_start:                                                              ;         |\
    TDC                                                                         ; $0394BB | | Zero out the Y register to begin the loop.
    TAY                                                                         ; $0394BC |/
-   LDA r_character_field.w,X                                                   ; $0394BD |\
    STA (r_init_character_battle_base),Y                                        ; $0394C0 | | Copy the entire record for the character slot indicated by
    INX                                                                         ; $0394C2 | | the X register from the character_field location to the
    INY                                                                         ; $0394C3 | | character_battle location.
    CPY #_sizeof_character_field.w                                              ; $0394C4 | |
    BNE -                                                                       ; $0394C7 |/
    PHX                                                                         ; $0394C9 |\
    TDC                                                                         ; $0394CA | | Save the X register and reset the Y register.
    TAY                                                                         ; $0394CB |/
    LDA (r_init_character_battle_base),Y                                        ; $0394CC |\
    AND #%00011111                                                              ; $0394CE | | If the character slot is empty, zero out the four status bytes
    BNE +                                                                       ; $0394D0 | | entirely and set the flag that indicates this slot is empty.
    LDA r_init_character_battle_slot                                            ; $0394D2 | |
    TAX                                                                         ; $0394D4 | | Once all this is done, jump to a later point in the function, as
    INC r_battle_slot_empty.w,X                                                 ; $0394D5 | | the next few steps only apply to slots that actually have a
    LDY #character_battle.status_1.w                                            ; $0394D8 | | character in them.
    TDC                                                                         ; $0394DB | |
    STA (r_init_character_battle_base),Y                                        ; $0394DC | |
    INY                                                                         ; $0394DE | |
    STA (r_init_character_battle_base),Y                                        ; $0394DF | |
    INY                                                                         ; $0394E1 | |
    STA (r_init_character_battle_base),Y                                        ; $0394E2 | |
    INY                                                                         ; $0394E4 | |
    STA (r_init_character_battle_base),Y                                        ; $0394E5 | |
    JMP @copy_stats_end                                                         ; $0394E7 |/
+   LDY #character_battle.status_1.w                                            ; $0394EA |\
    LDA (r_init_character_battle_base),Y                                        ; $0394ED | | Check to see if the character in the slot is dead or
    AND #%11000000                                                              ; $0394EF | | stoned. If they are, jump to a later part of the function.
    BNE @copy_stats_end                                                         ; $0394F1 |/
    LDA r_init_character_battle_slot                                            ; $0394F3 |\
    ASL A                                                                       ; $0394F5 | | Set this slot's action timer as active.
    TAX                                                                         ; $0394F6 | |
    LDA #>TIMER_ENABLED_ACTION                                                  ; $0394F7 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $0394F9 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $0394FC |\
    LDY #character_battle.hp_max.w                                              ; $0394FE | | This sequence check's the character's current HP. If their
    LDA (r_init_character_battle_base),Y                                        ; $039501 | | current HP is greater than or equal to their maximum HP
    JSR _math_divide_by_4                                                       ; $039503 | | divided by four, their HP critical status bit is set.
    LDY #character_battle.hp.w                                                  ; $039506 | | Otherwise, it is cleared. The actual branch condition can
    CMP (r_init_character_battle_base),Y                                        ; $039509 | | be summarized as follows:
    BCC @is_not_hp_critical                                                     ; $03950B | |
    LDY #character_battle.status_3.w                                            ; $03950D | |   (MaxHP // 4) < CurrentHP
    LDA (r_init_character_battle_base),Y                                        ; $039510 | |
    ORA #%0000000100000000                                                      ; $039512 | |
    STA (r_init_character_battle_base),Y                                        ; $039515 | |
    BRA @end_hp_critical_check                                                  ; $039517 | |
@is_not_hp_critical:                                                            ;         | |
    LDY #character_battle.status_3.w                                            ; $039519 | |
    LDA (r_init_character_battle_base),Y                                        ; $03951C | |
    AND #%1111111011111111                                                      ; $03951E | |
    STA (r_init_character_battle_base),Y                                        ; $039521 | |
@end_hp_critical_check:                                                         ;         | |
    TDC                                                                         ; $039523 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $039524 |/
    LDY #character_battle.speed_modifier.w                                      ; $039526 |\
    LDA #$10                                                                    ; $039529 | | Initializes the character's speed modifier. In general, it
    STA (r_init_character_battle_base),Y                                        ; $03952B | | is set to 16. However, if this is an auto-battle, set it instead
    LDA r_formation_properties.flags2.w                                         ; $03952D | | to 1.
    AND #FORMATION_FLAGS_2_AUTO_BATTLE                                          ; $039530 | |
    BEQ +                                                                       ; $039532 | |
    LDA #1.b                                                                    ; $039534 | |
    STA (r_init_character_battle_base),Y                                        ; $039536 |/
+   LDY #character_battle.critical_rate.w                                       ; $039538 |\
    LDA (r_init_character_battle_base),Y                                        ; $03953B | | Copy the base critical rate and bonus to the base locations for
    LDY #character_battle.base_critical_rate.w                                  ; $03953D | | the in-battle record, so the primary locations can eventually be
    STA (r_init_character_battle_base),Y                                        ; $039540 | | overwritten by the derived values.
    LDY #character_battle.critical_bonus.w                                      ; $039542 | |
    LDA (r_init_character_battle_base),Y                                        ; $039545 | |
    LDY #character_battle.base_critical_bonus.w                                 ; $039547 | |
    STA (r_init_character_battle_base),Y                                        ; $03954A |/
    LDY #character_battle.status_2.w                                            ; $03954C |\
    LDA (r_init_character_battle_base),Y                                        ; $03954F | | Initializes the last three status bytes to some extent.
    AND #STATUS_2_FLOAT                                                         ; $039551 | | The first byte is ignored as it has already been copied,
    STA (r_init_character_battle_base),Y                                        ; $039553 | | and all of those statuses should pass through unchanged.
    INY                                                                         ; $039555 | |
    LDA (r_init_character_battle_base),Y                                        ; $039556 | | For the second byte, only float status is allowed to pass
    AND #%10000010                                                              ; $039558 | | through. The rest are cleared.
    STA (r_init_character_battle_base),Y                                        ; $03955A | |
    INY                                                                         ; $03955C | | TODO: Identify the statuses in the third byte.
    LDA (r_init_character_battle_base),Y                                        ; $03955D | |
    AND #STATUS_4_CRITICAL                                                      ; $03955F | | For the last byte, everything except HP critical is cleared.
    STA (r_init_character_battle_base),Y                                        ; $039561 |/
    LDY #character_battle.level.w                                               ; $039563 |\
    LDA (r_init_character_battle_base),Y                                        ; $039566 | | Update the minimum character level if this slot has a lower level
    CMP r_battle_minimum_character_level.w                                      ; $039568 | | than previously seen.
    BCS @copy_stats_end                                                         ; $03956B | |
    STA r_battle_minimum_character_level.w                                      ; $03956D |/
@copy_stats_end:
    PLX                                                                         ; $039570 | Restore the previous value of the X register.
    LDY #character_battle.hp.w                                                  ; $039571 |\
    LDA (r_init_character_battle_base),Y                                        ; $039574 | | If the character's HP is zero, set the swoon status bit.
    LDY #character_battle.hp + 1.w                                              ; $039576 | |
    ORA (r_init_character_battle_base),Y                                        ; $039579 | |
    BNE +                                                                       ; $03957B | |
    LDY #character_battle.status_1.w                                            ; $03957D | |
    LDA (r_init_character_battle_base),Y                                        ; $039580 | |
    ORA #STATUS_1_SWOON                                                         ; $039582 | |
    STA (r_init_character_battle_base),Y                                        ; $039584 |/
+   CLC                                                                         ; $039586 |\
    LDA r_init_character_battle_base                                            ; $039587 | | Increment the base address for the next iteration of the
    ADC #_sizeof_character_battle                                               ; $039589 | | loop. For some reason, they did this as two separate 8-bit
    STA r_init_character_battle_base                                            ; $03958B | | additions instead of a single 16-bit one.
    LDA r_init_character_battle_base + 1                                        ; $03958D | |
    ADC #$00                                                                    ; $03958F | |
    STA r_init_character_battle_base + 1                                        ; $039591 |/
    INC r_init_character_battle_slot                                            ; $039593 |\
    LDA r_init_character_battle_slot                                            ; $039595 | | Repeat the preceding loop until all five character slots
    CMP #$05                                                                    ; $039597 | | have been copied and initialized.
    BEQ +                                                                       ; $039599 | |
    JMP @copy_stats_start                                                       ; $03959B |/
+   LDX #r_character_battle.w                                                   ; $03959E |\
    STX r_init_character_battle_base                                            ; $0395A1 | | Set up for the next loop by resetting the base address to
    TDC                                                                         ; $0395A3 | | the start, zeroing out the index registers, and setting the
    TAY                                                                         ; $0395A4 | | slot to zero.
    TAX                                                                         ; $0395A5 | |
    STY <r_init_character_battle_slot                                           ; $0395A6 |/
@find_twin_casters:
    LDA (r_init_character_battle_base),Y                                        ; $0395A8 |\
    AND #%00011111                                                              ; $0395AA | | This second loop goes through the five character slots,
    CMP #CHARACTER_PALOM                                                        ; $0395AC | | looking specifically for Palom, Porom, FuSoYa and Golbez.
    BEQ +                                                                       ; $0395AE | | The slot numbers matching these characters are put into an
    CMP #CHARACTER_POROM                                                        ; $0395B0 | | array starting at $3539, which determines the twin slots.
    BEQ +                                                                       ; $0395B2 | |
    CMP #CHARACTER_FUSOYA                                                       ; $0395B4 | |
    BEQ +                                                                       ; $0395B6 | |
    CMP #CHARACTER_GOLBEZ                                                       ; $0395B8 | |
    BNE ++                                                                      ; $0395BA | |
+   LDA <r_init_character_battle_slot                                           ; $0395BC | |
    STA r_battle_twin_slots.w,X                                                 ; $0395BE | |
    INX                                                                         ; $0395C1 | |
++  REP #FLAG_P_ACCUMULATOR                                                     ; $0395C2 | |
    CLC                                                                         ; $0395C4 | |
    LDA r_init_character_battle_base                                            ; $0395C5 | |
    ADC #_sizeof_character_battle                                               ; $0395C7 | |
    STA r_init_character_battle_base                                            ; $0395CA | |
    TDC                                                                         ; $0395CC | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0395CD | |
    INC <r_init_character_battle_slot                                           ; $0395CF | |
    LDA <r_init_character_battle_slot                                           ; $0395D1 | |
    CMP #5.b                                                                    ; $0395D3 | |
    BNE @find_twin_casters                                                      ; $0395D5 |/
    RTS                                                                         ; $0395D7

; _set_back_row_characters ($03:95D8)
;
; Using the configured party formation type in $16A8, sets the back row bits on
; the characters who are in the back row.
_set_back_row_characters:
    LDA r_party_formation_two_front.w                                           ; $0395D8 |\
    BNE +                                                                       ; $0395DB | | If the party is currently set to have three characters in front,
    LDA r_character_battle.1.sprite_class.w                                     ; $0395DD | | set the characters in the first three slots to be in the front row
    AND #%01111111.b                                                            ; $0395E0 | | and the other two in the back row.
    STA r_character_battle.1.sprite_class.w                                     ; $0395E2 | |
    LDA r_character_battle.2.sprite_class.w                                     ; $0395E5 | |
    AND #%01111111.b                                                            ; $0395E8 | |
    STA r_character_battle.2.sprite_class.w                                     ; $0395EA | |
    LDA r_character_battle.3.sprite_class.w                                     ; $0395ED | |
    AND #%01111111.b                                                            ; $0395F0 | |
    STA r_character_battle.3.sprite_class.w                                     ; $0395F2 | |
    LDA r_character_battle.4.sprite_class.w                                     ; $0395F5 | |
    ORA #%10000000.b                                                            ; $0395F8 | |
    STA r_character_battle.4.sprite_class.w                                     ; $0395FA | |
    LDA r_character_battle.5.sprite_class.w                                     ; $0395FD | |
    ORA #%10000000.b                                                            ; $039600 | |
    STA r_character_battle.5.sprite_class.w                                     ; $039602 |/
    RTS                                                                         ; $039605 |\
+   LDA r_character_battle.1.sprite_class.w                                     ; $039606 | | Otherwise, set the first three slots in the back row and the other
    ORA #%10000000.b                                                            ; $039609 | | two slots as being in the front row.
    STA r_character_battle.1.sprite_class.w                                     ; $03960B | |
    LDA r_character_battle.2.sprite_class.w                                     ; $03960E | |
    ORA #%10000000.b                                                            ; $039611 | |
    STA r_character_battle.2.sprite_class.w                                     ; $039613 | |
    LDA r_character_battle.3.sprite_class.w                                     ; $039616 | |
    ORA #%10000000.b                                                            ; $039619 | |
    STA r_character_battle.3.sprite_class.w                                     ; $03961B | |
    LDA r_character_battle.4.sprite_class.w                                     ; $03961E | |
    AND #%01111111.b                                                            ; $039621 | |
    STA r_character_battle.4.sprite_class.w                                     ; $039623 | |
    LDA r_character_battle.5.sprite_class.w                                     ; $039626 | |
    AND #%01111111.b                                                            ; $039629 | |
    STA r_character_battle.5.sprite_class.w                                     ; $03962B |/
    RTS                                                                         ; $03962E

; _set_character_poison_timers ($03:962F)
;
; Loops through the five character slots, setting poison timers for any of the
; characters who are poisoned.
_set_character_poison_timers:
    TDC                                                                         ; $03962F |\
    TAX                                                                         ; $039630 | | Initialize the loop variable and set the X register to the initial
    STX <r_set_character_poison_timers_slot                                     ; $039631 | | value of zero.
-   LDX <r_set_character_poison_timers_slot                                     ; $039633 |/
    LDA r_battle_slot_empty.w,X                                                 ; $039635 |\ Skip this slot if the slot is empty.
    BNE +                                                                       ; $039638 |/
    LDX <r_set_character_poison_timers_slot                                     ; $03963A |\
    STX <r_math_multiply_8bit_arg_1                                             ; $03963C | | Determine the index by multiplying the slot number by the size of
    LDX #_sizeof_character_battle.w                                             ; $03963E | | the in-battle character record.
    STX <r_math_multiply_8bit_arg_2                                             ; $039641 | |
    JSR _math_multiply_8bit                                                     ; $039643 | |
    LDX <r_math_multiply_8bit_result                                            ; $039646 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $039648 |\
    AND #STATUS_1_POISON.b                                                      ; $03964B | | Skip this slot if the character isn't poisoned.
    BEQ +                                                                       ; $03964D |/
    LDA #6.b                                                                    ; $03964F |\
    STA <r_calculate_timer_value_arg_mode                                       ; $039651 | | TODO: Returns the slot's vitality (or $2F) plus 20 times the speed
    LDA <r_set_character_poison_timers_slot                                     ; $039653 | |       modifier divided by 16.
    JSR _calculate_timer_value                                                  ; $039655 |/
    LDA #TIMER_OFFSET_POISON.b                                                  ; $039658 |\ Set the calculated value in the poison timer.
    JSR _set_timer_value                                                        ; $03965A |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03965D |\ Flag this timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03965F |/
    LDA <r_set_character_poison_timers_slot                                     ; $039662 |\
    ASL A                                                                       ; $039664 | | Calculate the index by multiplying the slot by two.
    TAX                                                                         ; $039665 |/
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $039666 |\
    ORA #>TIMER_ENABLED_POISON                                                  ; $039669 | | Enable the poison timer for this slot.
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03966B |/
    LDA <r_set_timer_value_arg_lo                                               ; $03966E |\
    STA r_battle_poison_interval.w + 0,X                                        ; $039670 | | Store the calculated timer value in the slot's poison interval
    LDA <r_set_timer_value_arg_hi                                               ; $039673 | | data.
    STA r_battle_poison_interval.w + 1,X                                        ; $039675 |/
+   INC <r_set_character_poison_timers_slot                                     ; $039678
    LDA <r_set_character_poison_timers_slot                                     ; $03967A
    CMP #5.b                                                                    ; $03967C
    BNE -                                                                       ; $03967E
    RTS                                                                         ; $039680

; _battle_decrement_timers ($03:9681)
;
; This function loops through all the character and monster slots, updating
; timer values. The major special processing is that Stop being active precludes
; the update of any other timers, and that Count has an inner timer that causes
; it to run half as fast as the other timers.
_battle_decrement_timers:
    STZ r_battle_speed_counter.w                                                ; $039681 |\
    LDA r_battle_speed_counter.w                                                ; $039684 | | This seemingly disabled code would only allow this function to
    BEQ +                                                                       ; $039687 | | execute at an interval determined by the battle speed.
    DEC r_battle_speed_counter.w                                                ; $039689 | |
    JMP @done                                                                   ; $03968C |/
+   LDA r_battle_speed.w                                                        ; $03968F |\ Update the battle speed counter to the current battle speed.
    STA r_battle_speed_counter.w                                                ; $039692 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $039695 |\
    TDC                                                                         ; $039697 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $039698 | |
    TAY                                                                         ; $039699 |/
@start:
    LDA r_monster_script_chain_slot.w                                           ; $03969A |\
    CMP #$FFFF                                                                  ; $03969D | | If a monster chain is active, branch ahead to skip this slot
    BEQ +                                                                       ; $0396A0 | | unless currently looking at the slot with the chain attack.
    STA <r_generic_tmp_ptr_addr                                                 ; $0396A2 | |
    TYA                                                                         ; $0396A4 | |
    LSR                                                                         ; $0396A5 | |
    CMP <r_generic_tmp_ptr_addr                                                 ; $0396A6 | |
    BEQ +                                                                       ; $0396A8 | |
    BRA ++                                                                      ; $0396AA |/
+   LDA r_battle_enabled_timers.w,Y                                             ; $0396AC |\ Transfer this slot's enabled timers to a temporary variable.
    STA r_battle_decrement_timers_tmp_enabled.w                                 ; $0396AF |/
    ASL r_battle_decrement_timers_tmp_enabled.w                                 ; $0396B2 |\ If the stop timer is not enabled, branch ahead to processing.
    BCC +                                                                       ; $0396B5 |/
    TDC                                                                         ; $0396B7 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0396B8 | | If the stop timer is currently expired, branch ahead to
    LDA r_battle_timers.1.flags.w,X                                             ; $0396BA | | processing.
    AND #TIMER_FLAG_EXPIRED.b                                                   ; $0396BD | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $0396BF | |
    BNE +                                                                       ; $0396C1 |/
    DEC r_battle_timers.1.value.w,X                                             ; $0396C3 |\ Decrement the timer value by one.
    LDA r_battle_timers.1.value.w,X                                             ; $0396C6 |/
    BNE ++                                                                      ; $0396C9 |\
    TDC                                                                         ; $0396CB | | If the timer value reaches zero, flag it as expired.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0396CC | |
    LDA r_battle_timers.1.flags.w,X                                             ; $0396CE | |
    ORA #TIMER_FLAG_EXPIRED.b                                                   ; $0396D1 | |
    STA r_battle_timers.1.flags.w,X                                             ; $0396D3 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $0396D6 |/
++  TXA                                                                         ; $0396D8 |\
    CLC                                                                         ; $0396D9 | | Increment the X register to move to the next character and branch
    ADC #_sizeof_character_timers                                               ; $0396DA | | to the next loop.
    TAX                                                                         ; $0396DD | |
    BRA @next                                                                   ; $0396DE |/
+   INX                                                                         ; $0396E0 |\
    INX                                                                         ; $0396E1 | | Increment the X register to move to the next timer.
    INX                                                                         ; $0396E2 |/
    LDA #6.w                                                                    ; $0396E3 |\ Initialize the count to 6, as there are 6 remaining timers.
    STA r_battle_decrement_timers_tmp_count.w                                   ; $0396E6 |/
@inner_start:
    ASL r_battle_decrement_timers_tmp_enabled.w                                 ; $0396E9 |\ If the current timer is not enabled, skip this timer.
    BCC @inner_next                                                             ; $0396EC |/
    TDC                                                                         ; $0396EE |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $0396EF | | TODO: If the timer is either expired or has another unknown bit,
    LDA r_battle_timers.1.flags.w,X                                             ; $0396F1 | |       skip any further processing.
    AND #(TIMER_FLAG_UNKNOWN7 | TIMER_FLAG_EXPIRED).b                           ; $0396F4 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $0396F6 | |
    BNE @inner_next                                                             ; $0396F8 |/
    LDA r_battle_decrement_timers_tmp_count.w                                   ; $0396FA |\
    CMP #1.w                                                                    ; $0396FD | | If the current timer is not Count, skip this block.
    BNE ++                                                                      ; $039700 |/
    PHX                                                                         ; $039702 |\
    TYA                                                                         ; $039703 | | Decrement the Count timer's inner timer. If it reaches zero, reset
    ASL                                                                         ; $039704 | | its value to 2, and continue forward to the next code. Otherwise,
    TAX                                                                         ; $039705 | | after the decrement, branch to move to the next iteration.
    DEC r_battle_status_count_inner_timer.w,X                                   ; $039706 | |
    LDA r_battle_status_count_inner_timer.w,X                                   ; $039709 | | BUG: The value of the Y register should not be doubled here, as the
    BEQ +                                                                       ; $03970C | |      Y register is already indexing a data structure that uses two
    PLX                                                                         ; $03970E | |      bytes per entry. The result is that count only works on lower
    BRA @inner_next                                                             ; $03970F | |      slots.
+   LDA #2.w                                                                    ; $039711 | |
    STA r_battle_status_count_inner_timer.w,X                                   ; $039714 | |
    PLX                                                                         ; $039717 |/
++  LDA r_battle_timers.1.value.w,X                                             ; $039718 |\ If the timer has reached zero, branch ahead.
    BEQ +                                                                       ; $03971B |/
    DEC r_battle_timers.1.value.w,X                                             ; $03971D |\
    LDA r_battle_timers.1.value.w,X                                             ; $039720 | | Decrement the timer and branch to the next iteration.
    BNE @inner_next                                                             ; $039723 |/
+   TDC                                                                         ; $039725 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $039726 | | TODO: Set the expired bit and another bit on the timer's status.
    LDA r_battle_timers.1.flags.w,X                                             ; $039728 | |
    ORA #(TIMER_FLAG_UNKNOWN7 | TIMER_FLAG_EXPIRED).b                           ; $03972B | |
    STA r_battle_timers.1.flags.w,X                                             ; $03972D | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $039730 |/
@inner_next:
    INX                                                                         ; $039732 |\
    INX                                                                         ; $039733 | | Increment the X register by three to move to next timer.
    INX                                                                         ; $039734 |/
    DEC r_battle_decrement_timers_tmp_count.w                                   ; $039735 |\
    LDA r_battle_decrement_timers_tmp_count.w                                   ; $039738 | | Decrement the timer counter and loop until all of them are done.
    BNE @inner_start                                                            ; $03973B |/
@next:
    INY                                                                         ; $03973D |\
    INY                                                                         ; $03973E | | Increment the Y register and loop until all 13 slots have been
    CPY #_sizeof_r_battle_enabled_timers.w                                      ; $03973F | | checked.
    BEQ +                                                                       ; $039742 | |
    JMP @start                                                                  ; $039744 |/
+   TDC                                                                         ; $039747
    SEP #FLAG_P_ACCUMULATOR                                                     ; $039748
@done:
    RTS                                                                         ; $03974A

; _battle_find_next_expired_timer ($03:974B)
;
; Scans through the 13 slots and the 7 timers for each slot, looking for the
; first one that is expired. Note that the search does not begin at slot zero,
; but rather at the current value in $38F6.
_battle_find_next_expired_timer:
    STZ <r_battle_timer_expired                                                 ; $03974B | Unset the timer expired flag.
    STZ <r_battle_generic_tmp_index                                             ; $03974D | Initialize the slot counter to zero.
    LDA r_get_timer_status_slot.w                                               ; $03974F |\ Set the first slot to scan to the current value of the timer slot
    STA <r_battle_generic_tmp_1_lo                                              ; $039752 |/ variable.
@start:
    LDA r_monster_script_chain_slot.w                                           ; $039754 |\
    CMP #$FF                                                                    ; $039757 | | If a monster chain is active, skip the current slot unless it
    BEQ +                                                                       ; $039759 | | matches the current chain slot.
    CMP <r_battle_generic_tmp_1_lo                                              ; $03975B | |
    BNE ++                                                                      ; $03975D |/
+   STZ <r_battle_generic_tmp_3_lo                                              ; $03975F | Initialize the timer index to zero.
    STZ <r_battle_generic_tmp_3_hi                                              ; $039761 | Initialize a variable that isn't used to zero.
    LDA <r_battle_generic_tmp_1_lo                                              ; $039763 |\
    ASL                                                                         ; $039765 | | Load the enabled timers byte and save it to a temporary variable.
    TAX                                                                         ; $039766 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $039767 | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03976A |/
-   ASL <r_battle_generic_tmp_2_lo                                              ; $03976C |\
    BCC +                                                                       ; $03976E | | Shift out the bit for the next timer, and if it's enabled, check
    JSR _battle_check_timer_expired                                             ; $039770 | | if the timer is expired. If so, branch to done as we've found an
    LDA <r_battle_timer_expired                                                 ; $039773 | | expired timer.
    BNE @done                                                                   ; $039775 |/
+   INC <r_battle_generic_tmp_3_lo                                              ; $039777 |\
    LDA <r_battle_generic_tmp_3_lo                                              ; $039779 | | Increment the timer index and loop until all seven timers have
    CMP #7.b                                                                    ; $03977B | | been checked.
    BNE -                                                                       ; $03977D |/
++  INC <r_battle_generic_tmp_1_lo                                              ; $03977F |\ Increment the slot number being checked.
    LDA <r_battle_generic_tmp_1_lo                                              ; $039781 |/
    CMP #(5 + 8).b                                                              ; $039783 |\
    BNE +                                                                       ; $039785 | | If the slot number reaches 13, reset it to zero to wrap around.
    STZ <r_battle_generic_tmp_1_lo                                              ; $039787 |/
+   INC <r_battle_generic_tmp_index                                             ; $039789 |\
    LDA <r_battle_generic_tmp_index                                             ; $03978B | | Loop until all 13 slots have been checked.
    CMP #(5 + 8).b                                                              ; $03978D | |
    BNE @start                                                                  ; $03978F |/
@done:
    RTS                                                                         ; $039791

; _battle_check_timer_expired ($03:9792)
;
; Given an 8-bit slot number in $A9 and an 8-bit timer index in $AD, determines
; if that timer is expired, and if so, sets the result flag in $D1. Regardless
; of whether it was expired or not, the slot number is transferred to $D2 and
; the timer index is stored in $D3.
_battle_check_timer_expired:
    LDA <r_battle_generic_tmp_1_lo                                              ; $039792 |\ Set the timer slot.
    STA <r_battle_timer_slot                                                    ; $039794 |/
    JSR _calculate_offsets                                                      ; $039796 | Calculate the offsets for the slot.
    LDA <r_battle_generic_tmp_3_lo                                              ; $039799 |\ Save the index to the current timer.
    STA <r_battle_timer_index                                                   ; $03979B |/
    ASL A                                                                       ; $03979D |\
    CLC                                                                         ; $03979E | | Calculate the offset for this timer by multiplying by 3.
    ADC <r_battle_generic_tmp_3_lo                                              ; $03979F | |
    STA <r_battle_generic_tmp_4_lo                                              ; $0397A1 |/
    LDA <r_battle_generic_tmp_4_lo                                              ; $0397A3 |\
    JSR _add_timer_offset                                                       ; $0397A5 | | Load the value for this timer.
    LDX r_add_timer_offset_result.w                                             ; $0397A8 | |
    LDA r_battle_timers.1.value_lo.w,X                                          ; $0397AB | |
    ORA r_battle_timers.1.value_hi.w,X                                          ; $0397AE |/
    BNE +                                                                       ; $0397B1 |\
    LDA r_battle_timers.1.flags.w,X                                             ; $0397B3 | | If the value is zero and timer is expired, increment the timer
    AND #TIMER_FLAG_EXPIRED.b                                                   ; $0397B6 | | expired flag.
    BEQ +                                                                       ; $0397B8 | |
    INC <r_battle_timer_expired                                                 ; $0397BA |/
+   RTS                                                                         ; $0397BC

; _get_timer_status ($03:97BD)
;
; This function takes a slot in $D2 and a timer index in $D3. It examines that
; timer and depending on the type of timer, returns a value from 0-3 in $352E.
_get_timer_status:
    LDA <r_battle_timer_slot                                                    ; $0397BD |\ Copy the slot to an internal variable.
    STA r_get_timer_status_slot.w                                               ; $0397BF |/
    JSR _calculate_offsets                                                      ; $0397C2 | Calculate the offsets for this slot.
    INC r_get_timer_status_slot.w                                               ; $0397C5 |\
    LDA r_get_timer_status_slot.w                                               ; $0397C8 | | If this is the last slot, set the slot variable to zero.
    CMP #(5 + 8).b                                                              ; $0397CB | | Otherwise, simply increment it.
    BNE +                                                                       ; $0397CD | |
    STZ r_get_timer_status_slot.w                                               ; $0397CF |/
+   LDA <r_battle_timer_index                                                   ; $0397D2 |\
    ASL                                                                         ; $0397D4 | | Calculate the timer index * 3.
    CLC                                                                         ; $0397D5 | |
    ADC <r_battle_timer_index                                                   ; $0397D6 | |
    STA <r_get_timer_status_timer_offset                                        ; $0397D8 | |
    LDA <r_get_timer_status_timer_offset                                        ; $0397DA |/
    JSR _add_timer_offset                                                       ; $0397DC |\ Add the timer offset to this slot's timer offset and put it in the
    LDX r_add_timer_offset_result.w                                             ; $0397DF |/ X register.
    LDA r_battle_timers.1.flags.w,X                                             ; $0397E2 | Loads the flags for the given timer.
    AND #(TIMER_FLAG_UNKNOWN7 | TIMER_FLAG_EXPIRED).b ~ $FF                     ; $0397E5 |\
    BNE ++                                                                      ; $0397E7 | | Sets the accumulator according to the following:
    LDA <r_battle_timer_slot                                                    ; $0397E9 | |
    CMP #5.b                                                                    ; $0397EB | | 0: Status & 0x7E == 0, slot is for character (<5)
    BCC +                                                                       ; $0397ED | | 1: Status & 0x7E == 0, slot is for monster (>=5)
    LDA #TIMER_STATUS_QUEUE_MONSTER.b                                           ; $0397EF | | 2: Status & 0x7E > 0, Status & 0x08 > 0
    BRA @end                                                                    ; $0397F1 | | 3: Status & 0x7E > 0, Status & 0x08 == 0
+   LDA #TIMER_STATUS_QUEUE_CHARACTER.b                                         ; $0397F3 | |
    BRA @end                                                                    ; $0397F5 | |
++  AND #TIMER_FLAG_COMMAND.b                                                   ; $0397F7 | |
    BEQ +                                                                       ; $0397F9 | |
    LDA #TIMER_STATUS_EXPIRED_COMMAND.b                                         ; $0397FB | |
    BRA @end                                                                    ; $0397FD | |
+   LDA #TIMER_STATUS_EXPIRED_STATUS.b                                          ; $0397FF |/
@end:
    STA r_get_timer_status_result.w                                             ; $039801 | Store the result in the result variable.
    STZ <r_battle_timer_expired                                                 ; $039804 | Unset the timer expired flag.
    RTS                                                                         ; $039806

; _calculate_character_stats ($03:9807)
;
; This function initializes all of the in-battle character records at $2000 and
; calculates the derived stats for the character in the slot passed as a
; parameter in $3975. Note that it clobbers the derived stats of all other
; characters. The only stats that may be affected is the critical rate and bonus
; as they are given different values in the field and in-battle records, while
; other stats should be copies.
_calculate_character_stats:
    LDA r_battle_generic_arg_slot.w                                             ; $039807 |\
    PHA                                                                         ; $03980A | | Preserve the value of $3975, while calling the specified
    JSR _battle_init_memory                                                     ; $03980B | | function, which initializes various locations in RAM.
    PLA                                                                         ; $03980E | |
    STA r_battle_generic_arg_slot.w                                             ; $03980F |/
    JSR _init_character_battle                                                  ; $039812 | Initialize the in-battle character records.
    JSR _update_equipment_data                                                  ; $039815 | Update data about equipped equipment.
    JSR _calculate_character_battle                                             ; $039818 | Calculate the derived stats in the in-battle character record.
    LSR <r_current_slot_offset_character_battle_hi                              ; $03981B |\  Divide the main character offset by 2, to index field character
    ROR <r_current_slot_offset_character_battle_lo                              ; $03981D | | records instead. _calculate_offsets was called by the previous
    LDX <r_current_slot_offset_character_battle                                 ; $03981F |/  function.
    TDC                                                                         ; $039821 |\
    TAY                                                                         ; $039822 | | Copies the first 64 bytes of the in-battle character record back
-   LDA (r_calculate_character_battle_record_ptr),Y                             ; $039823 | | to the field character record, to update the derived values.
    STA r_character_field.w,X                                                   ; $039825 | |
    INX                                                                         ; $039828 | |
    INY                                                                         ; $039829 | |
    CPY #_sizeof_character_field.w                                              ; $03982A | |
    BNE -                                                                       ; $03982D |/
    LDY #character_battle.base_critical_rate.w                                  ; $03982F |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039832 | | Restore the critical rate and bonus values in the field character
    LDX <r_current_slot_offset_character_battle                                 ; $039834 | | record to the base values that were just overwritten by the
    STA r_character_field.1.critical_rate.w,X                                   ; $039836 | | derived values.
    INY                                                                         ; $039839 | |
    INX                                                                         ; $03983A | |
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $03983B | |
    STA r_character_field.1.critical_rate.w,X                                   ; $03983D |/
    RTS                                                                         ; $039840

; _calculate_character_battle ($03:9841)
;
; This function calculates numerous stats used for battles. It takes as a
; parameter the slot number of the character in $3975. The in-battle character
; records at $2000 should already be initialized. It modifies these records by
; calculating the derived stats (e.g. physical attack accuracy) from the base
; stats and equipment.
;
; This function also calls _calculate_offsets and does not alter the values so
; they can be reused by any calling code.
_calculate_character_battle:
    LDA r_battle_generic_arg_slot.w                                             ; $039841 |\ Load the desired slot number and calculate several offsets
    JSR _calculate_offsets                                                      ; $039844 |/ for that slot.
    CLC                                                                         ; $039847 |\
    LDA <r_current_slot_offset_character_battle                                 ; $039848 | | Load the character record offset and store a pointer to the
    ADC #<r_character_battle                                                    ; $03984A | | in-battle record.
    STA r_calculate_character_battle_record_ptr_lo                              ; $03984C | |
    LDA <r_current_slot_offset_character_battle_hi                              ; $03984E | |
    ADC #>r_character_battle                                                    ; $039850 | |
    STA r_calculate_character_battle_record_ptr_hi                              ; $039852 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $039854 |\
    CLC                                                                         ; $039856 | | Store a pointer to the equipment data.
    LDA r_current_slot_offset_equipment.w                                       ; $039857 | |
    ADC #r_equipment.w                                                          ; $03985A | |
    STA r_calculate_character_battle_equipment_ptr                              ; $03985D | |
    TDC                                                                         ; $03985F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $039860 |/
    LDA r_battle_magnetic.w                                                     ; $039862 |\ If the current battle is not magnetic, skip to the non-magnetic
    BEQ @non_magnetic                                                           ; $039865 |/ part of the code.
    TDC                                                                         ; $039867 |\
    TAY                                                                         ; $039868 | | Check each piece of equipment for the metallic property. If
    STY r_calculate_character_battle_tmp_1                                      ; $039869 | | one is found, set the magnetized status on the character.
    STY r_calculate_character_battle_tmp_2                                      ; $03986B | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $03986D | |
    BPL +                                                                       ; $03986F | |
    INC r_calculate_character_battle_tmp_1_lo                                   ; $039871 | |
    BRA ++                                                                      ; $039873 | |
+   TYA                                                                         ; $039875 | |
    CLC                                                                         ; $039876 | |
    ADC #_sizeof_equipment_full                                                 ; $039877 | |
    TAY                                                                         ; $039879 | |
    INC r_calculate_character_battle_tmp_2_lo                                   ; $03987A | |
    LDA r_calculate_character_battle_tmp_2_lo                                   ; $03987C | |
    CMP #$05                                                                    ; $03987E | |
    BNE -                                                                       ; $039880 | |
++  LDA r_calculate_character_battle_tmp_1_lo                                   ; $039882 | |
    BEQ @non_magnetic                                                           ; $039884 | |
    LDY #character_battle.status_3.w                                            ; $039886 | |
    LDA #STATUS_3_MAGNETIZED                                                    ; $039889 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $03988B |/
@non_magnetic:
    LDY #character_battle.strength.w                                            ; $03988D |\
    TDC                                                                         ; $039890 | | Zero out the character's modified statistics.
-   STA (r_calculate_character_battle_record_ptr),Y                             ; $039891 | |
    INY                                                                         ; $039893 | |
    CPY #character_battle.physical_attack_element.w                             ; $039894 | |
    BNE -                                                                       ; $039897 |/
    STZ r_calculate_character_battle_tmp_3                                      ; $039899 |\
    LDY #equipment.stat_bonus.w                                                 ; $03989B | | Here, a loop begins to look through each piece of equipment
@add_equipment_stat_bonuses:                                                    ;         | | a character has equipped. First, the stat bonus byte from
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $03989E | | the equipment data is loaded, and split into its two
    PHA                                                                         ; $0398A0 | | components. The lower three bits are an index into the
    AND #%11111000                                                              ; $0398A1 | | equipment_stat_modifier_data array, which selects a pair of
    STA r_calculate_character_battle_tmp_1_lo                                   ; $0398A3 | | signed integers. The upper five bits then choose which of
    PLA                                                                         ; $0398A5 | | the two numbers applies to each of the five stats.
    AND #%00000111                                                              ; $0398A6 | |
    ASL A                                                                       ; $0398A8 | | This section reads the two possible numbers and stores them
    TAX                                                                         ; $0398A9 | | into two temporary variables.
    LDA bank13.equipment_stat_modifier_data.l,X                                 ; $0398AA | |
    STA r_calculate_character_battle_tmp_2_lo                                   ; $0398AE | |
    INX                                                                         ; $0398B0 | |
    LDA bank13.equipment_stat_modifier_data.l,X                                 ; $0398B1 | |
    STA r_calculate_character_battle_tmp_2_hi                                   ; $0398B5 | |
    PHY                                                                         ; $0398B7 |/
    LDY #character_battle.strength.w                                            ; $0398B8 |\
-   ASL r_calculate_character_battle_tmp_1_lo                                   ; $0398BB | | This code adds the appropriate equipment bonuses to the
    BCC +                                                                       ; $0398BD | | character's modified stats for this piece of equipment. The
    CLC                                                                         ; $0398BF | | upper 5 bits of the equipment byte read earlier determine
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $0398C0 | | which of the two possible bonuses the character will get
    ADC r_calculate_character_battle_tmp_2_lo                                   ; $0398C2 | | for each stat. After processing all five equipment slots,
    BRA ++                                                                      ; $0398C4 | | we move on.
+   CLC                                                                         ; $0398C6 | |
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $0398C7 | |
    ADC r_calculate_character_battle_tmp_2_hi                                   ; $0398C9 | |
++  STA (r_calculate_character_battle_record_ptr),Y                             ; $0398CB | |
    INY                                                                         ; $0398CD | |
    CPY #(character_battle.strength + 5).w                                      ; $0398CE | |
    BNE -                                                                       ; $0398D1 |/
    PLY                                                                         ; $0398D3 |\
    TYA                                                                         ; $0398D4 | | Add 11 bytes to the Y index to go to the next piece of
    CLC                                                                         ; $0398D5 | | equipment. Repeat the loop until all five pieces have been
    ADC #_sizeof_equipment_full                                                 ; $0398D6 | | processed.
    TAY                                                                         ; $0398D8 | |
    INC r_calculate_character_battle_tmp_3                                      ; $0398D9 | |
    LDA r_calculate_character_battle_tmp_3                                      ; $0398DB | |
    CMP #$05                                                                    ; $0398DD | |
    BNE @add_equipment_stat_bonuses                                             ; $0398DF |/
    LDY #character_battle.strength_base.w                                       ; $0398E1 |\
    STY r_calculate_character_battle_tmp_1                                      ; $0398E4 | | This loop here loops through the five stats for the
    LDY #character_battle.strength.w                                            ; $0398E6 | | character, adding the base stat into the modified stat
    STY r_calculate_character_battle_tmp_2                                      ; $0398E9 | | location. (The equipment bonuses were previously loaded
@add_base_stats:                                                                ;         | | into the modified stat locations.)
    LDY r_calculate_character_battle_tmp_1                                      ; $0398EB | |
    CLC                                                                         ; $0398ED | | There is some range-checking of the final value: if it is
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $0398EE | | greater than or equal to $B6 (which basically checks if it
    LDY r_calculate_character_battle_tmp_2                                      ; $0398F0 | | is negative, as $B6 (-74) is the lowest a stat could get
    ADC (r_calculate_character_battle_record_ptr),Y                             ; $0398F2 | | with the availble stat bonuses) it is set to 1. Second, if
    CMP #$B6                                                                    ; $0398F4 | | it is greater than 99, it is set to 99.
    BCS +                                                                       ; $0398F6 | |
    CMP #$63                                                                    ; $0398F8 | | This does result in an interesting effect where if a
    BCC ++                                                                      ; $0398FA | | character gets a stat of exactly zero, it is kept, but any
    LDA #$63                                                                    ; $0398FC | | lower value is increased to 1.
    BRA ++                                                                      ; $0398FE | |
+   LDA #$01                                                                    ; $039900 | |
++  STA (r_calculate_character_battle_record_ptr),Y                             ; $039902 | |
    INC r_calculate_character_battle_tmp_1_lo                                   ; $039904 | |
    INC r_calculate_character_battle_tmp_2_lo                                   ; $039906 | |
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039908 | |
    CMP #character_battle.strength                                              ; $03990A | |
    BNE @add_base_stats                                                         ; $03990C |/
    LDY #character_battle.level.w                                               ; $03990E |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039911 | | Copy the character's level and five modified stats to
    STA r_add_shield_stats_result.level.w                                       ; $039913 | | another location in memory.
    TDC                                                                         ; $039916 | |
    TAX                                                                         ; $039917 | | TODO: Determine if this other location is used outside
    LDY #character_battle.strength.w                                            ; $039918 | | this function. It appears to be reused for all characters
-   LDA (r_calculate_character_battle_record_ptr),Y                             ; $03991B | | so likely candidates would be any functions that follow
    STA r_add_shield_stats_result.strength.w,X                                  ; $03991D | | this one.
    INY                                                                         ; $039920 | |
    INX                                                                         ; $039921 | |
    CPX #$0005.w                                                                ; $039922 | |
    BNE -                                                                       ; $039925 |/
    STZ r_add_shield_stats_result.shield_count.w                                ; $039927 |\
    STZ r_add_shield_stats_result.shield_physical_evade.w                       ; $03992A | | Zero out the portion of the array covering shield stats,
    STZ r_add_shield_stats_result.shield_1_element.w                            ; $03992D | | which will be added to by a function called in the next
    STZ r_add_shield_stats_result.shield_2_element.w                            ; $039930 | | block of code. This allows us to accumulate the results for
    STZ r_add_shield_stats_result.shield_physical_defense.w                     ; $039933 | | multiple potential shields in one data block.
    STZ r_add_shield_stats_result.shield_status_1.w                             ; $039936 | |
    STZ r_add_shield_stats_result.shield_status_2.w                             ; $039939 | |
    STZ r_add_shield_stats_result.shield_magic_evade.w                          ; $03993C | |
    STZ r_add_shield_stats_result.shield_magic_defense.w                        ; $03993F | |
    STZ r_add_shield_stats_result.shield_race.w                                 ; $039942 |/
    LDY #character_equipment.right_hand.data.element_status_ptr.w               ; $039945 |\
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039948 | | If the equipment in the right hand has the shield bit set,
    BPL +                                                                       ; $03994A | | add the stats for it to the array for later calculations,
    LDY #character_equipment.right_hand.data.w                                  ; $03994C | | taking care to back up the shield element into the second
    JSR _add_shield_stats                                                       ; $03994F | | byte, because _add_shield_stats overwrites it.
    LDA r_add_shield_stats_result.shield_1_element.w                            ; $039952 | |
    STA r_add_shield_stats_result.shield_2_element.w                            ; $039955 |/
+   LDY #character_equipment.left_hand.data.element_status_ptr.w                ; $039958 |\
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $03995B | | Repeat the process with the left hand, if it has a shield
    BPL +                                                                       ; $03995D | | equipped.
    LDY #character_equipment.left_hand.data.w                                   ; $03995F | |
    JSR _add_shield_stats                                                       ; $039962 |/
+   TDC                                                                         ; $039965 |\
    TAX                                                                         ; $039966 | | Copy the element byte for each piece of non-hand equipment
    STX r_calculate_character_battle_tmp_1                                      ; $039967 | | to another temporary array.
    LDY #equipment_full.element_status.element.w                                ; $039969 | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $03996C | |
    STA r_calculate_character_battle_tmp_equipment,X                            ; $03996E | |
    TYA                                                                         ; $039970 | |
    CLC                                                                         ; $039971 | |
    ADC #_sizeof_equipment_full                                                 ; $039972 | |
    TAY                                                                         ; $039974 | |
    INX                                                                         ; $039975 | |
    CPX #0003.w                                                                 ; $039976 | |
    BNE -                                                                       ; $039979 |/
    LDA r_add_shield_stats_result.shield_1_element.w                            ; $03997B |\
    STA r_calculate_character_battle_tmp_equipment + 3                          ; $03997E | | Also transfer the element bytes for the two shields, if
    LDA r_add_shield_stats_result.shield_2_element.w                            ; $039980 | | equipped, which leaves all five pieces in this array.
    STA r_calculate_character_battle_tmp_equipment + 4                          ; $039983 |/
    TDC                                                                         ; $039985 |\
    TAX                                                                         ; $039986 | | For each piece of equipment, take the element byte, and
-   LDA r_calculate_character_battle_tmp_equipment,X                            ; $039987 | | depending on whether or not the immune bit is set, send
    BMI +                                                                       ; $039989 | | them to separate bytes, to individually track immunities
    ORA r_calculate_character_battle_tmp_1_lo                                   ; $03998B | | and resistances.
    STA r_calculate_character_battle_tmp_1_lo                                   ; $03998D | |
    BRA ++                                                                      ; $03998F | |
+   ORA r_calculate_character_battle_tmp_1_hi                                   ; $039991 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039993 | |
++  INX                                                                         ; $039995 | |
    CPX #$0005.w                                                                ; $039996 | |
    BNE -                                                                       ; $039999 |/
    LDY #character_battle.element_resistance.w                                  ; $03999B |\
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $03999E | | Transfer the elemental resistances and immunities to the
    STA (r_calculate_character_battle_record_ptr),Y                             ; $0399A0 | | in-battle character record.
    INY                                                                         ; $0399A2 | |
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $0399A3 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $0399A5 |/
    LDY #$0005.w                                                                ; $0399A7 |\
    TDC                                                                         ; $0399AA | | For each of the three non-hand equipment items, load the
    TAX                                                                         ; $0399AB | | race defense byte and ORA it into a temporary variable.
    STZ r_calculate_character_battle_tmp_1_lo                                   ; $0399AC | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $0399AE | |
    ORA r_calculate_character_battle_tmp_1_lo                                   ; $0399B0 | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $0399B2 | |
    TYA                                                                         ; $0399B4 | |
    CLC                                                                         ; $0399B5 | |
    ADC #_sizeof_equipment_full                                                 ; $0399B6 | |
    TAY                                                                         ; $0399B8 | |
    INX                                                                         ; $0399B9 | |
    CPX #$0003.w                                                                ; $0399BA | |
    BNE -                                                                       ; $0399BD |/
    LDY #character_battle.physical_defense_race.w                               ; $0399BF |\
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $0399C2 | | Additionally add the combined racial defense from the
    ORA r_add_shield_stats_result.shield_race.w                                 ; $0399C4 | | shields and then store it in the character record.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $0399C7 |/
    LDY #character_battle.physical_defense_multiplier.w                         ; $0399C9 |\
    LDA r_add_shield_stats_result.level.w                                       ; $0399CC | | Set the character's physical defense multiplier based on
    JSR _math_divide_by_16                                                      ; $0399CF | | the follow formula:
    STA r_math_multiply_8bit_arg_1                                              ; $0399D2 | |
    LDA r_add_shield_stats_result.shield_count.w                                ; $0399D4 | |   (level // 16 * shield_count) + agility // 8
    STA r_math_multiply_8bit_arg_2                                              ; $0399D7 | |
    JSR _math_multiply_8bit                                                     ; $0399D9 | |
    LDA r_add_shield_stats_result.agility.w                                     ; $0399DC | |
    JSR _math_divide_by_8                                                       ; $0399DF | |
    CLC                                                                         ; $0399E2 | |
    ADC r_math_multiply_8bit_result                                             ; $0399E3 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $0399E5 |/
    LDY #equipment_full.data.accuracy.w                                         ; $0399E7 |\
    TDC                                                                         ; $0399EA | | Set the total physical evade percentage to the sum of the
    TAX                                                                         ; $0399EB | | evade parameters for all five potential pieces of armor,
-   CLC                                                                         ; $0399EC | | and store this in the character record. Additionally, this
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $0399ED | | value is capped at 99.
    AND #%01111111                                                              ; $0399EF | |
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $0399F1 | | An empty armor slot is considered to have an evade of 10.
    STA r_calculate_character_battle_tmp_1_hi                                   ; $0399F3 | | This does not apply to an empty shield slot.
    TYA                                                                         ; $0399F5 | |
    CLC                                                                         ; $0399F6 | |
    ADC #_sizeof_equipment_full                                                 ; $0399F7 | |
    TAY                                                                         ; $0399F9 | |
    INX                                                                         ; $0399FA | |
    CPX #$0003.w                                                                ; $0399FB | |
    BNE -                                                                       ; $0399FE | |
    LDY #character_battle.physical_defense_evade.w                              ; $039A00 | |
    CLC                                                                         ; $039A03 | |
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $039A04 | |
    ADC r_add_shield_stats_result.shield_physical_evade.w                       ; $039A06 | |
    JSR _set_upper_bound_99                                                     ; $039A09 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A0C |/
    LDA r_add_shield_stats_result.vitality.w                                    ; $039A0E |\
    LSR A                                                                       ; $039A11 | | Set the character's physical defense base stat to the sum
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039A12 | | of the physical defense from each piece of armor and add
    TDC                                                                         ; $039A14 | | half their vitality as well. If, for whatever reason, this
    TAX                                                                         ; $039A15 | | total exceeds a single byte and the carry flag is set, it
    TAY                                                                         ; $039A16 | | will be reset to $FF.
    INY                                                                         ; $039A17 | |
-   CLC                                                                         ; $039A18 | |
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039A19 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039A1B | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039A1D | |
    TYA                                                                         ; $039A1F | |
    CLC                                                                         ; $039A20 | |
    ADC #_sizeof_equipment_full                                                 ; $039A21 | |
    TAY                                                                         ; $039A23 | |
    INX                                                                         ; $039A24 | |
    CPX #$0003.w                                                                ; $039A25 | |
    BNE -                                                                       ; $039A28 | |
    LDY #character_battle.physical_defense_base.w                               ; $039A2A | |
    CLC                                                                         ; $039A2D | |
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039A2E | |
    ADC r_add_shield_stats_result.shield_physical_defense.w                     ; $039A30 | |
    JSR _set_max_if_carry                                                       ; $039A33 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A36 |/
    TDC                                                                         ; $039A38 |\
    TAX                                                                         ; $039A39 | | Set the character's status immunities to the union of the
    STX r_calculate_character_battle_tmp_1                                      ; $039A3A | | immunities offered by each piece of equipment.
    LDY #equipment_full.element_status.status_1.w                               ; $039A3C | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039A3F | |
    ORA r_calculate_character_battle_tmp_1_lo                                   ; $039A41 | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039A43 | |
    INY                                                                         ; $039A45 | |
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039A46 | |
    ORA r_calculate_character_battle_tmp_1_hi                                   ; $039A48 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039A4A | |
    TYA                                                                         ; $039A4C | |
    CLC                                                                         ; $039A4D | |
    ADC #_sizeof_equipment_full - 1                                             ; $039A4E | |
    TAY                                                                         ; $039A50 | |
    INX                                                                         ; $039A51 | |
    CPX #$0003.w                                                                ; $039A52 | |
    BNE -                                                                       ; $039A55 | |
    LDY #character_battle.status_1_immunity.w                                   ; $039A57 | |
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039A5A | |
    ORA r_add_shield_stats_result.shield_status_1.w                             ; $039A5C | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A5F | |
    INY                                                                         ; $039A61 | |
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $039A62 | |
    ORA r_add_shield_stats_result.shield_status_2.w                             ; $039A64 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A67 |/
    LDY #character_battle.element_resistance.w                                  ; $039A69 |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039A6C | | Read the character's elemental resistances and set
    STA r_get_opposite_elements_arg                                             ; $039A6E | | weaknesses to the opposite elements. Fire/ice and
    JSR _get_opposite_elements                                                  ; $039A70 | | holy/darkness are the only opposing pairs. Lightning and
    LDY #character_battle.element_weakness.w                                    ; $039A73 | | and the pseudo-elements have no opposites.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A76 |/
    LDY #character_battle.element_immunity.w                                    ; $039A78 | Load $2026 (elemental immune)
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039A7B |\
    STA r_get_opposite_elements_arg                                             ; $039A7D | | Repeat the process, except set strong weaknesses for the
    JSR _get_opposite_elements                                                  ; $039A7F | | opposite of any elemental immunities.
    BEQ +                                                                       ; $039A82 | | BUG: The game fails to store any value at all if there are
    LDY #character_battle.element_weakness_strong.w                             ; $039A84 | |      no immunities. If a character loses an immunity, they
    ORA #%10000000                                                              ; $039A87 | |      will retain any associated strong weaknesses forever.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039A89 |/  TODO: The immune bit is set. Does it do anything?
+   LDY #character_battle.magic_defense_multiplier.w                            ; $039A8B |\
    CLC                                                                         ; $039A8E | | Set the character's magic defense multiplier according to
    LDA r_add_shield_stats_result.wisdom.w                                      ; $039A8F | | the following formula:
    ADC r_add_shield_stats_result.will.w                                        ; $039A92 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039A95 | |   (wisdom + will) // 32 + (agility // 32)
    JSR _math_divide_by_32                                                      ; $039A97 | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039A9A | |
    LDA r_add_shield_stats_result.agility.w                                     ; $039A9C | |
    JSR _math_divide_by_32                                                      ; $039A9F | |
    CLC                                                                         ; $039AA2 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039AA3 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039AA5 |/
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $039AA7 |\
    JSR _math_divide_by_8                                                       ; $039AA9 | | Sets the character's magic evasion according to the
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039AAC | | following formula:
    TDC                                                                         ; $039AAE | |
    TAY                                                                         ; $039AAF | |   (wisdom + will) // 8 + sum(equipment magic evasion)
    TAX                                                                         ; $039AB0 | |
-   CLC                                                                         ; $039AB1 | | Equipment magic evasion is determined by the low seven bits
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039AB2 | | of the first equipment byte.
    AND #%01111111                                                              ; $039AB4 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039AB6 | | The result is capped at 99.
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039AB8 | |
    TYA                                                                         ; $039ABA | |
    CLC                                                                         ; $039ABB | |
    ADC #_sizeof_equipment_full                                                 ; $039ABC | |
    TAY                                                                         ; $039ABE | |
    INX                                                                         ; $039ABF | |
    CPX #$0003.w                                                                ; $039AC0 | |
    BNE -                                                                       ; $039AC3 | |
    LDY #character_battle.magic_defense_evade.w                                 ; $039AC5 | |
    CLC                                                                         ; $039AC8 | |
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039AC9 | |
    ADC r_add_shield_stats_result.shield_magic_evade.w                          ; $039ACB | |
    JSR _set_upper_bound_99                                                     ; $039ACE | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039AD1 |/
    LDY #equipment_full.data.spell_mdef.w                                       ; $039AD3 |\
    TDC                                                                         ; $039AD6 | | Set the character's base magic defense by summing the
    TAX                                                                         ; $039AD7 | | magic defense values from all their equipment.
    STX r_calculate_character_battle_tmp_1                                      ; $039AD8 | |
-   CLC                                                                         ; $039ADA | | Like physical defense, this is capped at 255.
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039ADB | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039ADD | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039ADF | |
    TYA                                                                         ; $039AE1 | |
    CLC                                                                         ; $039AE2 | |
    ADC #_sizeof_equipment_full                                                 ; $039AE3 | |
    TAY                                                                         ; $039AE5 | |
    INX                                                                         ; $039AE6 | |
    CPX #$0003.w                                                                ; $039AE7 | |
    BNE -                                                                       ; $039AEA | |
    LDY #character_battle.magic_defense_base.w                                  ; $039AEC | |
    CLC                                                                         ; $039AEF | |
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039AF0 | |
    ADC r_add_shield_stats_result.shield_magic_defense.w                        ; $039AF2 | |
    JSR _set_max_if_carry                                                       ; $039AF5 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039AF8 |/
    LDX #$0015.w                                                                ; $039AFA |\
-   STZ r_weapons.w,X                                                           ; $039AFD | | Zero out a 22-byte array.
    DEX                                                                         ; $039B00 | |
    BPL -                                                                       ; $039B01 |/
    STZ r_calculate_character_battle_weapon_flags_1.w                           ; $039B03 |\
    LDY #character_battle.sprite_class.w                                        ; $039B06 | | Determine if the current character is of the Karate class
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039B09 | | (in other words, Yang) and if so, set the lowest bit in
    AND #%00001111                                                              ; $039B0B | | the weapon flags variable.
    CMP #CLASS_KARATE                                                           ; $039B0D | |
    BNE +                                                                       ; $039B0F | |
    INC r_calculate_character_battle_weapon_flags_1.w                           ; $039B11 |/
+   LDY #character_battle.right_hand_item.w                                     ; $039B14 |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039B17 | | Check to see if the character has a weapon in their right
    BEQ +                                                                       ; $039B19 | | hand. If not, skip the next section of code.
    LDY #character_equipment.right_hand.data.element_status_ptr.w               ; $039B1B | |
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039B1E | |
    BMI +                                                                       ; $039B20 |/
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039B22 |\
    ORA #%10000000                                                              ; $039B25 | | If a weapon is equipped in the right hand, set a flag in
    STA r_calculate_character_battle_weapon_flags_1.w                           ; $039B27 | | the weapon flags variable, and then copy all of the
    LDY #character_equipment.right_hand.data.unknown00.w                        ; $039B2A | | equipment bytes to the array we just initialized.
    TDC                                                                         ; $039B2D | |
    TAX                                                                         ; $039B2E | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039B2F | |
    STA r_weapons.w,X                                                           ; $039B31 | |
    INY                                                                         ; $039B34 | |
    INX                                                                         ; $039B35 | |
    CPX #_sizeof_equipment_full                                                 ; $039B36 | |
    BNE -                                                                       ; $039B39 |/
+   LDY #character_battle.left_hand_item.w                                      ; $039B3B |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039B3E | | Repeat the above process, except with the left hand instead
    BEQ +                                                                       ; $039B40 | | of the right hand. The second highest bit is set in the
    LDY #character_equipment.left_hand.data.element_status_ptr.w                ; $039B42 | | weapon flags variable instead of the highest
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039B45 | | bit. The equipment bytes are copied to the second set of 11
    BMI +                                                                       ; $039B47 | | bytes in the 22-byte array.
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039B49 | |
    ORA #%01000000                                                              ; $039B4C | |
    STA r_calculate_character_battle_weapon_flags_1.w                           ; $039B4E | |
    LDY #character_equipment.left_hand.data.unknown00.w                         ; $039B51 | |
    LDX #_sizeof_equipment_full                                                 ; $039B54 | |
-   LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039B57 | |
    STA r_weapons.w,X                                                           ; $039B59 | |
    INY                                                                         ; $039B5C | |
    INX                                                                         ; $039B5D | |
    CPX #_sizeof_equipment_full * 2.w                                           ; $039B5E | |
    BNE -                                                                       ; $039B61 |/
+   LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039B63 |\
    AND #%11000000                                                              ; $039B66 | | This sequence of code looks at what's equipped in the
    BEQ +                                                                       ; $039B68 | | character's right hand, and branches to an appropriate
    EOR #%11000000                                                              ; $039B6A | | label depending on exactly what is equipped. Once again,
    BNE @one_weapon_equipped                                                    ; $039B6C | | bows and arrows are completely ignored if both aren't
    LDA r_weapons.1.data.flags.w                                                ; $039B6E | | equipped.
    AND #%11000000                                                              ; $039B71 | |
+   BEQ @not_bow_or_arrow                                                       ; $039B73 | | In any case, a second flags variable is set to $80 if a bow
    LDA #%10000000                                                              ; $039B75 | | is equipped and $40 if an arrow is equipped.
    STA r_calculate_character_battle_weapon_flags_2.w                           ; $039B77 | |
    LDA r_weapons.1.data.flags.w                                                ; $039B7A | |
    AND #%10000000                                                              ; $039B7D | |
    BNE @bow_equipped                                                           ; $039B7F | |
    LDA #%01000000                                                              ; $039B81 | |
    STA r_calculate_character_battle_weapon_flags_2.w                           ; $039B83 |/
    TDC                                                                         ; $039B86 |\
    TAX                                                                         ; $039B87 | | If the item equipped in the right hand is an arrow, the
    LDY #_sizeof_equipment_full * 2.w                                           ; $039B88 | | weapon data array is reversed so that any bow will be the
-   LDA r_weapons.w,X                                                           ; $039B8B | | first entry, and the arrow will be the second. Note that we
    STA r_weapons.w,Y                                                           ; $039B8E | | only reach this point if two weapons are equipped, so we
    INX                                                                         ; $039B91 | | know that there is something to swap with.
    INY                                                                         ; $039B92 | |
    CPX #_sizeof_equipment_full.w                                               ; $039B93 | |
    BNE -                                                                       ; $039B96 | |
    TDC                                                                         ; $039B98 | |
    TAY                                                                         ; $039B99 | |
-   LDA r_weapons.w,X                                                           ; $039B9A | |
    STA r_weapons.w,Y                                                           ; $039B9D | |
    INX                                                                         ; $039BA0 | |
    INY                                                                         ; $039BA1 | |
    CPX #_sizeof_equipment_full * 2.w                                           ; $039BA2 | |
    BNE -                                                                       ; $039BA5 | |
    LDY #_sizeof_equipment_full.w                                               ; $039BA7 | |
-   LDA r_weapons.w,X                                                           ; $039BAA | |
    STA r_weapons.w,Y                                                           ; $039BAD | |
    INX                                                                         ; $039BB0 | |
    INY                                                                         ; $039BB1 | |
    CPY #_sizeof_equipment_full * 2.w                                           ; $039BB2 | |
    BNE -                                                                       ; $039BB5 |/
@bow_equipped:                                                                  ;         |\
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039BB7 | | If a bow and arrow is equipped, change the weapon flags to
    AND #%00111111                                                              ; $039BBA | | set bits 5 and 7 instead of bits 6 and 7, to distinguish
    ORA #%10100000                                                              ; $039BBC | | from the regular two weapons case.
    STA r_calculate_character_battle_weapon_flags_1.w                           ; $039BBE |/
@not_bow_or_arrow:
    BRA +                                                                       ; $039BC1 | Move on the next section.
@one_weapon_equipped:
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039BC3 |\
    BMI +                                                                       ; $039BC6 | | If the character has only single weapon equiped in the left
    LDX #_sizeof_equipment_full.w                                               ; $039BC8 | | hand, move the data to the first 11 bytes in the array and
    TDC                                                                         ; $039BCB | | set the weapon flags to set the highest bit instead of the
    TAY                                                                         ; $039BCC | | second-highest.
-   LDA r_weapons.w,X                                                           ; $039BCD | |
    STA r_weapons.w,Y                                                           ; $039BD0 | | Ultimately, after this recent sequence, weapon_flags
    INX                                                                         ; $039BD3 | | will contain the following: $C0 if two weapons are equipped,
    INY                                                                         ; $039BD4 | | $A0 if a bow and arrow is equipped and $80 if a single
    CPY #_sizeof_equipment_full.w                                               ; $039BD5 | | weapon is equipped. In addition, bit 0 will be set if the
    BNE -                                                                       ; $039BD8 | | character's class is Karate (Yang).
    TYX                                                                         ; $039BDA | |
-   STZ r_weapons.w,X                                                           ; $039BDB | |
    INX                                                                         ; $039BDE | |
    CPX #_sizeof_equipment_full * 2.w                                           ; $039BDF | |
    BNE -                                                                       ; $039BE2 | |
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039BE4 | |
    AND #%00111111                                                              ; $039BE7 | |
    ORA #%10000000                                                              ; $039BE9 | |
    STA r_calculate_character_battle_weapon_flags_1.w                           ; $039BEB |/
+   TDC                                                                         ; $039BEE |\
    TAX                                                                         ; $039BEF | | Load the elements associated with each weapon and store
    STX r_calculate_character_battle_tmp_1                                      ; $039BF0 | | the union of attack elements in the character's physical
    LDA r_weapons.1.data.element_status_ptr.w                                   ; $039BF2 | | attack element field.
    BMI +                                                                       ; $039BF5 | |
    LDA r_weapons.1.element_status.element.w                                    ; $039BF7 | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039BFA | |
+   LDA r_weapons.2.data.element_status_ptr.w                                   ; $039BFC | |
    BMI +                                                                       ; $039BFF | |
    LDA r_weapons.2.element_status.element.w                                    ; $039C01 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039C04 | |
+   LDA r_calculate_character_battle_tmp_1_lo                                   ; $039C06 | |
    ORA r_calculate_character_battle_tmp_1_hi                                   ; $039C08 | |
    LDY #character_battle.physical_attack_element.w                             ; $039C0A | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039C0D |/
    TDC                                                                         ; $039C0F |\
    TAX                                                                         ; $039C10 | | Load the races the weapons are strong against and store the
    STX r_calculate_character_battle_tmp_1                                      ; $039C11 | | union in the character's physical attack race field.
    LDA r_weapons.1.data.element_status_ptr.w                                   ; $039C13 | |
    BMI +                                                                       ; $039C16 | |
    LDA r_weapons.1.data.race.w                                                 ; $039C18 | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039C1B | |
+   LDA r_weapons.2.data.element_status_ptr.w                                   ; $039C1D | |
    BMI +                                                                       ; $039C20 | |
    LDA r_weapons.2.data.race.w                                                 ; $039C22 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039C25 | |
+   LDA r_calculate_character_battle_tmp_1_lo                                   ; $039C27 | |
    ORA r_calculate_character_battle_tmp_1_hi                                   ; $039C29 | |
    LDY #character_battle.physical_attack_race.w                                ; $039C2B | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039C2E |/
    LDA r_add_shield_stats_result.strength.w                                    ; $039C30 |\
    JSR _math_divide_by_8                                                       ; $039C33 | | Set the character's physical attack multiplier according to
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039C36 | | the following formula:
    LDA r_add_shield_stats_result.agility.w                                     ; $039C38 | |
    JSR _math_divide_by_16                                                      ; $039C3B | |   strength // 8 + agility // 16 + 1
    CLC                                                                         ; $039C3E | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039C3F | |
    INC A                                                                       ; $039C41 | |
    LDY #character_battle.physical_attack_multiplier.w                          ; $039C42 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039C45 |/
    LDA r_add_shield_stats_result.level.w                                       ; $039C47 |\
    JSR _math_divide_by_4                                                       ; $039C4A | | Calculate level // 4 and save it for later.
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039C4D |/
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039C4F |\
    AND #%11000000                                                              ; $039C52 | | Determine how many weapons are equipped and dispatch
    BEQ @no_weapons                                                             ; $039C54 | | accordingly.
    EOR #%11000000                                                              ; $039C56 | |
    BNE @one_weapon                                                             ; $039C58 |/
    CLC                                                                         ; $039C5A |\
    LDA r_weapons.1.data.accuracy.w                                             ; $039C5B | | If the character has two weapons equipped, calculate their
    AND #%01111111                                                              ; $039C5E | | physical attack accuracy as follows:
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039C60 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039C62 | |   (level // 4 + level // 4 + sum(weapon accuracies)) // 2
    CLC                                                                         ; $039C64 | |
    LDA r_weapons.2.data.accuracy.w                                             ; $039C65 | | The value has an enforced upper bound of 99.
    AND #%01111111                                                              ; $039C68 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039C6A | | This does not include bows and arrows, which are treated as
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039C6C | | a single weapon, with the arrows ignored.
    LSR A                                                                       ; $039C6E | |
    CMP #$63                                                                    ; $039C6F | |
    BCC ++                                                                      ; $039C71 | |
    LDA #$63                                                                    ; $039C73 | |
    BRA ++                                                                      ; $039C75 |/
@no_weapons:
    CLC                                                                         ; $039C77 |\
    LDA (bank0F.equipment_property_data + equipment.accuracy).l                 ; $039C78 | | If the character has no weapons equipped, accuracy is set
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039C7C | | explicitly to the accuracy of item $00 plus level // 4. If
    BRA +                                                                       ; $039C7E | | they have one weapon equipped, the accuracy is set to the
@one_weapon:                                                                    ;         | | accuracy of that weapon plus level // 4. In either case,
    CLC                                                                         ; $039C80 | | the value is capped at 99.
    LDA r_weapons.1.data.accuracy.w                                             ; $039C81 | |
    AND #%01111111                                                              ; $039C84 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039C86 | |
+   JSR _set_upper_bound_99                                                     ; $039C88 |/
++  LDY #character_battle.physical_attack_accuracy.w                            ; $039C8B |\ Store the calculated accuracy in the character record.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039C8E |/
    LDA r_add_shield_stats_result.strength.w                                    ; $039C90 |\
    JSR _math_divide_by_4                                                       ; $039C93 | | Calculate strength // 4 and save it for later use.
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039C96 |/
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039C98 |\
    AND #%00000001                                                              ; $039C9B | | If the character's class is Karate (Yang), calculate
    BEQ +                                                                       ; $039C9D | | the physical attack base using this formula:
    LDA r_add_shield_stats_result.level.w                                       ; $039C9F | |
    ASL A                                                                       ; $039CA2 | |   level * 2 + strength // 4 + 2
    CLC                                                                         ; $039CA3 | |
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039CA4 | |
    ADC #$02                                                                    ; $039CA6 | |
    BRA @physical_attack_base_done                                              ; $039CA8 |/
+   LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039CAA |\
    AND #%11000000                                                              ; $039CAD | | For non-Karate characters, branch based on the number of
    BEQ @physical_attack_base_no_weapons                                        ; $039CAF | | equipped weapons.
    EOR #%11000000                                                              ; $039CB1 | |
    BNE @physical_attack_base_one_weapon                                        ; $039CB3 |/
    CLC                                                                         ; $039CB5 |\
    LDA r_weapons.1.data.power.w                                                ; $039CB6 | | If the character has two weapons equipped (not including
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039CB9 | | bows), set their physical attack base according to the
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039CBB | | following formula:
    STA r_calculate_character_battle_tmp_2_lo                                   ; $039CBD | |
    CLC                                                                         ; $039CBF | |   (level // 4 + strength // 4) * 2 + sum(weapon powers)
    LDA r_weapons.2.data.power.w                                                ; $039CC0 | |
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039CC3 | | BUG: If the weapon power goes above 205 or so, the overflow
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039CC5 | | can be missed.
    CLC                                                                         ; $039CC7 | |
    ADC r_calculate_character_battle_tmp_2_lo                                   ; $039CC8 | |
    BRA @physical_attack_base_done                                              ; $039CCA |/
@physical_attack_base_one_weapon:                                               ;         |\
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039CCC | | If the character has a bow and arrow equipped, set the
    AND #%00100000                                                              ; $039CCF | | physical attack base based on the following formula:
    BEQ @physical_attack_base_no_weapons                                        ; $039CD1 | |
    LDA r_weapons.1.data.power.w                                                ; $039CD3 | |   bow_power // 2 + arrow_power + strength // 4
    LSR A                                                                       ; $039CD6 | |
    CLC                                                                         ; $039CD7 | | This value is saved to a temporary variable.
    ADC r_weapons.2.data.power.w                                                ; $039CD8 | | BUG: Probably an overflow issue here too.
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039CDB | |
    STA r_calculate_character_battle_tmp_4                                      ; $039CDD |/
    LDY #character_battle.id.w                                                  ; $039CDF |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039CE2 | | This checks if the bow is in the off hand or not. If so
    AND #%11000000                                                              ; $039CE4 | | it branches to the next section. Otherwise, it executes the
    AND r_calculate_character_battle_weapon_flags_2.w                           ; $039CE6 | | next bit.
    BEQ +                                                                       ; $039CE9 |/
    LDA r_calculate_character_battle_tmp_4                                      ; $039CEB |\
    TAX                                                                         ; $039CED | | The bow and arrow are expected to be on the correct hands.
    STX r_math_divide_16bit_arg_1.w                                             ; $039CEE | | The arrow should be in the dominant hand, and the bow
    LDX #$0005.w                                                                ; $039CF1 | | should be in the off hand. If they are in the wrong hands,
    STX r_math_divide_16bit_arg_2.w                                             ; $039CF4 | | this section of code reduces the calculated physical attack
    JSR _math_divide_16bit                                                      ; $039CF7 | | base by reducing it to 4/5th of its value.
    SEC                                                                         ; $039CFA | |
    LDA r_calculate_character_battle_tmp_4                                      ; $039CFB | |
    SBC r_math_divide_16bit_result.w                                            ; $039CFD | |
    STA r_calculate_character_battle_tmp_4                                      ; $039D00 | |
    BRA ++                                                                      ; $039D02 | |
+   LDA r_calculate_character_battle_tmp_4                                      ; $039D04 | |
    BRA ++                                                                      ; $039D06 |/
@physical_attack_base_no_weapons:                                               ;         |\
    CLC                                                                         ; $039D08 | | Finally, if the character has zero or one weapon equipped,
    LDA r_weapons.1.data.power.w                                                ; $039D09 | | the following formula is used:
    ADC r_calculate_character_battle_tmp_1_lo                                   ; $039D0C | |   level // 4 + strength // 4 + weapon_power (0 if none)
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039D0E |/  BUG: If it overflows after the first add, it'll glitch out.
@physical_attack_base_done:
    JSR _set_max_if_carry                                                       ; $039D10 |\
++  LDY #character_battle.physical_attack_base.w                                ; $039D13 | | Cap the attack base at 255 and store it in the record.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039D16 |/
    LDA r_weapons.1.element_status.status_1.w                                   ; $039D18 |\
    ORA r_weapons.2.element_status.status_1.w                                   ; $039D1B | | Set the character's physical attack status to the union of
    LDY #character_battle.physical_attack_status_1.w                            ; $039D1E | | the statuses of their weapons.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039D21 | |
    LDA r_weapons.1.element_status.status_2.w                                   ; $039D23 | |
    ORA r_weapons.2.element_status.status_2.w                                   ; $039D26 | |
    INY                                                                         ; $039D29 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039D2A |/
    LDY #character_battle.base_critical_rate.w                                  ; $039D2C |\
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039D2F | | Load the character's base critical rate and bonus and then
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039D31 | | depending on the equipped weapon, branch to the correct
    INY                                                                         ; $039D33 | | section of the code.
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039D34 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039D36 | |
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039D38 | |
    AND #%11000000                                                              ; $039D3B | |
    BEQ @critical_no_bonus                                                      ; $039D3D | |
    EOR #$C0                                                                    ; $039D3F | |
    BEQ @critical_no_bonus                                                      ; $039D41 | |
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039D43 | |
    AND #%00100000                                                              ; $039D46 | |
    BEQ ++                                                                      ; $039D48 |/
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039D4A |\
    CMP #$21                                                                    ; $039D4C | | For bows and arrows, the character's base critical rate is
    BCC +                                                                       ; $039D4E | | multiplied by 3 to determine their actual critical rate.
    LDA #$21                                                                    ; $039D50 | | The critical bonus is increased by the power of the arrow
+   STA r_math_multiply_8bit_arg_1                                              ; $039D52 | | they have equipped.
    LDA #$03                                                                    ; $039D54 | |
    STA r_math_multiply_8bit_arg_2                                              ; $039D56 | | The calculated critical rate is capped at 99, and the
    JSR _math_multiply_8bit                                                     ; $039D58 | | critical bonus is capped at 255.
    LDA r_math_multiply_8bit_result                                             ; $039D5B | |
    STA r_calculate_character_battle_tmp_1_lo                                   ; $039D5D | |
    CLC                                                                         ; $039D5F | |
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $039D60 | |
    ADC r_weapons.2.data.power.w                                                ; $039D62 | |
    JSR _set_max_if_carry                                                       ; $039D65 | |
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039D68 | |
    BRA @critical_store_data                                                    ; $039D6A |/
++  ASL r_calculate_character_battle_tmp_1_lo                                   ; $039D6C |\
    BCC +                                                                       ; $039D6E | | If the character has a single weapon equipped, the critical
    LDA #$63                                                                    ; $039D70 | | rate is instead set to double their base critical rate.
    BRA ++                                                                      ; $039D72 | | Their critical bonus is increased by half the power of
+   LDA r_calculate_character_battle_tmp_1_lo                                   ; $039D74 | | their weapon.
++  STA r_calculate_character_battle_tmp_1_lo                                   ; $039D76 | |
    LDA r_weapons.1.data.power.w                                                ; $039D78 | | The critical rate is capped at 99, though it actually only
    LSR A                                                                       ; $039D7B | | applies this cap if the pre-doubling value was greater than
    CLC                                                                         ; $039D7C | | or equal to 128. TODO: Determine if this even matters. It
    ADC r_calculate_character_battle_tmp_1_hi                                   ; $039D7D | | probably doesn't, since the typical value is more like 2.
    JSR _set_max_if_carry                                                       ; $039D7F | | The critical bonus is capped at 255.
    STA r_calculate_character_battle_tmp_1_hi                                   ; $039D82 |/
@critical_store_data:
    LDY #character_battle.critical_rate.w                                       ; $039D84 |\
    LDA r_calculate_character_battle_tmp_1_lo                                   ; $039D87 | | Store the new calculated critical rate and bonus into the
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039D89 | | character record. As an interesting note, if the character
    INY                                                                         ; $039D8B | | has two weapons equipped, they get no bonus to either their
    LDA r_calculate_character_battle_tmp_1_hi                                   ; $039D8C | | critical rate or bonus.
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039D8E |/
@critical_no_bonus:
    LDA r_calculate_character_battle_weapon_flags_1.w                           ; $039D90 |\
    AND #%00100000                                                              ; $039D93 | | If the character has either a bow and arrow or a weapon
    BNE +                                                                       ; $039D95 | | with the long range bit set, their long range bit is set.
    LDA r_weapons.1.data.unknown00.w                                            ; $039D97 | |
    AND #%00100000                                                              ; $039D9A | | BUG: This bit is never unset, so the character gains the
    BEQ ++                                                                      ; $039D9C | |      permanent ability to have full accuracy from the back
+   LDY #character_battle.sprite_class.w                                        ; $039D9E | |      row.
    LDA (r_calculate_character_battle_record_ptr),Y                             ; $039DA1 | |
    ORA #%00100000                                                              ; $039DA3 | |
    STA (r_calculate_character_battle_record_ptr),Y                             ; $039DA5 |/
++  RTS                                                                         ; $039DA7

; _get_opposite_elements ($03:9DA8)
;
; Given a byte in the accumulator and in $A9, with bits corresponding to
; elemental strengths or weaknesses, returns a value in the accumulator that has
; bits set according to the opposite of any elements that have opposites. In
; particular, fire/ice and holy/darkness. Any set elements that do not have
; opposites are completely unset.
_get_opposite_elements:
    AND #%00010010                                                              ; $039DA8 |\
    LSR A                                                                       ; $039DAA | | Mask holy and ice, and set darkness or fire if set.
    STA r_get_opposite_elements_tmp                                             ; $039DAB |/
    LDA r_get_opposite_elements_arg                                             ; $039DAD |\
    AND #%00001001                                                              ; $039DAF | | Mask darkness and fire, and set holy or ice if set.
    ASL A                                                                       ; $039DB1 | |
    ORA r_get_opposite_elements_tmp                                             ; $039DB2 |/
    RTS                                                                         ; $039DB4

; _add_shield_stats ($03:9DB5)
;
; This function ultimately takes two parameters: A pointer to a character's
; 55 byte equipment data array in $80, and an index to the piece of equipment
; to process in Y. (This index should be in bytes, so should be divisible by
; 11.) Results are added directly in an appropriate fashion to an array at
; $3965 (though this function does not modify anything lower than $396B). The
; caller is expected to initialize this array as desired.
_add_shield_stats:
    INC r_add_shield_stats_result.shield_count.w                                ; $039DB5 | Increment the shield count.
    CLC                                                                         ; $039DB8 |\
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DB9 | | Read the shield's magic evade attribute (the lower seven
    AND #%01111111                                                              ; $039DBB | | bits of the first byte) and store it in the result array.
    ADC r_add_shield_stats_result.shield_magic_evade.w                          ; $039DBD | |
    STA r_add_shield_stats_result.shield_magic_evade.w                          ; $039DC0 |/
    INY                                                                         ; $039DC3 |\
    CLC                                                                         ; $039DC4 | | Next, load the shield's physical defense base and add it to
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DC5 | | the result array.
    ADC r_add_shield_stats_result.shield_physical_defense.w                     ; $039DC7 | |
    STA r_add_shield_stats_result.shield_physical_defense.w                     ; $039DCA |/
    INY                                                                         ; $039DCD |\
    CLC                                                                         ; $039DCE | | Load the shield's physical evade percentage and add it to
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DCF | | the result array.
    AND #%01111111                                                              ; $039DD1 | |
    ADC r_add_shield_stats_result.shield_physical_evade.w                       ; $039DD3 | |
    STA r_add_shield_stats_result.shield_physical_evade.w                       ; $039DD6 |/
    INY                                                                         ; $039DD9 |\
    CLC                                                                         ; $039DDA | | Add the shield's magical defense into the result.
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DDB | |
    ADC r_add_shield_stats_result.shield_magic_defense.w                        ; $039DDD | |
    STA r_add_shield_stats_result.shield_magic_defense.w                        ; $039DE0 |/
    INY                                                                         ; $039DE3 |\
    INY                                                                         ; $039DE4 | | Add the shield's racial defense property to the result.
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DE5 | | This is done as an ORA instead of ADC as the byte is a
    ORA r_add_shield_stats_result.shield_race.w                                 ; $039DE7 | | bitmask.
    STA r_add_shield_stats_result.shield_race.w                                 ; $039DEA |/
    INY                                                                         ; $039DED |\
    INY                                                                         ; $039DEE | | Store the shield's elemental defense in the array.
    INY                                                                         ; $039DEF | | Notably, this is the only byte in this function which is
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DF0 | | blatantly overwritten.
    STA r_add_shield_stats_result.shield_1_element.w                            ; $039DF2 |/
    INY                                                                         ; $039DF5 |\
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DF6 | | Store the shield's status defense properties in the result
    ORA r_add_shield_stats_result.shield_status_1.w                             ; $039DF8 | | array. These are both done with ORA, to combine the bits
    STA r_add_shield_stats_result.shield_status_1.w                             ; $039DFB | | with any that are already present.
    INY                                                                         ; $039DFE | |
    LDA (r_calculate_character_battle_equipment_ptr),Y                          ; $039DFF | |
    ORA r_add_shield_stats_result.shield_status_2.w                             ; $039E01 | |
    STA r_add_shield_stats_result.shield_status_2.w                             ; $039E04 |/
    RTS                                                                         ; $039E07

; _copy_equipment_from_hand_inventory ($03:9E08)
;
; Given a slot number in $3975, copies that character's equipment from their
; hand inventory at $32DA to their stat record at $2000.
_copy_equipment_from_hand_inventory:
    LDA r_battle_generic_arg_slot.w                                             ; $039E08 |\
    JSR _math_multiply_by_8                                                     ; $039E0B | | Set the Y register to the slot number times eight.
    TAY                                                                         ; $039E0E |/
    LDX <r_current_slot_offset_character_battle                                 ; $039E0F |\
    LDA r_battle_hand_inventory.1.id.w,Y                                        ; $039E11 | | Copy the right hand item and count from the battle inventory to
    STA r_character_battle.1.right_hand_item.w,X                                ; $039E14 | | the character stat record.
    LDA r_battle_hand_inventory.1.count.w,Y                                     ; $039E17 | |
    STA r_character_battle.1.right_hand_count.w,X                               ; $039E1A |/
    LDA r_battle_hand_inventory.2.id.w,Y                                        ; $039E1D |\
    STA r_character_battle.1.left_hand_item.w,X                                 ; $039E20 | | Copy the left hand item and count from the battle inventory to
    LDA r_battle_hand_inventory.2.count.w,Y                                     ; $039E23 | | the character stat record.
    STA r_character_battle.1.left_hand_count.w,X                                ; $039E26 |/
    RTS                                                                         ; $039E29

; _set_upper_bound_99 ($03:9E2A)
;
; This simple function takes a single parameter in the accumulator. If this
; value is greater than or equal to 99, the accumulator is set to 99.
; Otherwise, it is left untouched.
_set_upper_bound_99:
    CMP #$63                                                                    ; $039E2A
    BCC +                                                                       ; $039E2C
    LDA #$63                                                                    ; $039E2E
+   RTS                                                                         ; $039E30

; _set_max_if_carry ($03:9E31)
;
; This simple function sets the accumulator to the maximum value of 255 if the
; carry bit is set. It is useful, for example, after an addition. If that
; sum exceeded the 8-bit limit, the carry flag would be set, and this function
; would simply reset your value to the maximum. This allows values to be given
; an upper bound.
_set_max_if_carry:
    BCC +                                                                       ; $039E31
    LDA #$FF                                                                    ; $039E33
+   RTS

; _calculate_timer_value ($03:9E36)
;
; Given a slot number in the accumulator and a mode in $D6, calculates a timer
; value for the slot modified by the slot's speed modifier. The 16-bit result is
; returned in $D4, which is also the location of the argument to
; _set_timer_value, for easy chaining.
;
; TODO: Determine the modes and make sure they are all relevant to timers.
_calculate_timer_value:
    STZ r_calculate_timer_value_is_monster.w                                    ; $039E36 |\
    CMP #5.b                                                                    ; $039E39 | | Set a flag to indicate if this is a monster slot.
    BCC +                                                                       ; $039E3B | |
    INC r_calculate_timer_value_is_monster.w                                    ; $039E3D |/
+   JSR _calculate_offsets                                                      ; $039E40 | Calculate the offsets for the current slot.
    LDX <r_current_slot_offset_character_battle                                 ; $039E43 |\
    LDA r_character_battle.1.relative_speed_lo.w,X                              ; $039E45 | | Initially set the value to modify to be the slot's relative speed.
    STA <r_get_modified_timer_value_arg_value_lo                                ; $039E48 | |
    LDA r_character_battle.1.relative_speed_hi.w,X                              ; $039E4A | |
    STA <r_get_modified_timer_value_arg_value_hi                                ; $039E4D |/
    LDA r_character_battle.1.speed_modifier.w,X                                 ; $039E4F |\
    TAY                                                                         ; $039E52 | | Set the slot's speed modifier as the second parameter.
    STY r_current_slot_speed_modifier.w                                         ; $039E53 |/
    PHX                                                                         ; $039E56 |\
    LDA r_calculate_timer_value_arg_mode                                        ; $039E57 | | Using the passed mode parameter, jump to the correct handler for
    ASL A                                                                       ; $039E59 | | the given mode.
    TAX                                                                         ; $039E5A | |
    LDA calculate_timer_value_mode_ptr_data.l,X                                 ; $039E5B | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $039E5F | |
    LDA calculate_timer_value_mode_ptr_data.l + 1,X                             ; $039E61 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $039E65 | |
    LDA #:calculate_timer_value_mode_ptr_data.b                                 ; $039E67 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $039E69 | |
    PLX                                                                         ; $039E6B | |
    JML [r_generic_tmp_ptr.w]                                                   ; $039E6C |/

; __calculate_timer_value_mode_relative_speed ($03:9E6F)
;
; Mode for calculate_timer_value that calculates the slot's modified relative
; speed. The resulting value will never be lower than one.
__calculate_timer_value_mode_relative_speed:
    JSR _get_modified_timer_value                                               ; $039E6F |\
    LDY <r_get_modified_timer_value_result                                      ; $039E72 | | Calculate the modified relative speed, ensure the value is set to
    BNE +                                                                       ; $039E74 | | one if zero, and then return.
    INC <r_get_modified_timer_value_result                                      ; $039E76 | |
+   JMP __calculate_timer_value_done                                            ; $039E78 |/

; __calculate_timer_value_mode_fixed ($03:9E7B)
;
; Mode for calculate_timer_value that simply returns 0 if this is a character
; slot and 1 if this is a monster slot.
__calculate_timer_value_mode_fixed:
    LDA r_calculate_timer_value_is_monster.w                                    ; $039E7B |\
    BNE +                                                                       ; $039E7E | | If this is a character slot, set the base value to zero.
    TDC                                                                         ; $039E80 | |
    TAX                                                                         ; $039E81 | |
    BRA ++                                                                      ; $039E82 |/
+   LDX #1.w                                                                    ; $039E84 |\ Otherwise, set it to 1.
++  STX <r_get_modified_timer_value_arg_value                                   ; $039E87 |/
    JSR _get_modified_timer_value                                               ; $039E89 | Modify the value by the speed modifier.
    JMP __calculate_timer_value_done                                            ; $039E8C

; __calculate_timer_value_mode_item ($03:9E8F)
;
; Mode for calculate_timer_value that loads the appropriate delay from item data
; in ROM and then jumps to a common item_spell handler.
__calculate_timer_value_mode_item:
    LDA r_calculate_timer_value_arg_index.w                                     ; $039E8F |\
    STA <r_math_multiply_8bit_arg_1                                             ; $039E92 | | Calculate the index by multiplying the index by the size of
    LDA #6.b                                                                    ; $039E94 | | the record.
    STA <r_math_multiply_8bit_arg_2                                             ; $039E96 | |
    JSR _math_multiply_8bit                                                     ; $039E98 | | BUG: The table assumes a base index of $B0 instead of $00.
    LDX <r_math_multiply_8bit_result                                            ; $039E9B |/
    LDA bank0F.battle_item_property_data.l,X                                    ; $039E9D | Load the byte into the accumulator.
    BRA __calculate_timer_value_mode_item_spell                                 ; $039EA1 | Branch to the common code.

; __calculate_timer_value_mode_spell ($03:9EA3)
;
; Mode for calculate_timer_value that loads the appropriate delay from spell
; data in ROM and then falls through to a common item_spell handler.
__calculate_timer_value_mode_spell:
    LDA r_calculate_timer_value_arg_index.w                                     ; $039EA3 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $039EA6 | | Calculate the index by multiplying the index by the size of the
    LDA #_sizeof_spell.b                                                        ; $039EA8 | | spell record.
    STA <r_math_multiply_8bit_arg_2                                             ; $039EAA | |
    JSR _math_multiply_8bit                                                     ; $039EAC | |
    LDX <r_math_multiply_8bit_result                                            ; $039EAF |/
    LDA bank0F.spell_property_data.l + spell.time_targeting,X                   ; $039EB1 | Load the time and targeting byte into the accumulator.

; __calculate_timer_value_mode_item_spell ($03:9EB5)
;
; Common routine for both item and spell timer calculation modes. Extracts the
; time portion of the loaded byte and then modifies it by the speed modifier.
__calculate_timer_value_mode_item_spell:
    AND #%00011111.b                                                            ; $039EB5 |\
    TAX                                                                         ; $039EB7 | | Mask out the time bits and then store it in memory.
    STX <r_get_modified_timer_value_arg_value                                   ; $039EB8 |/
    ASL <r_get_modified_timer_value_arg_value_lo                                ; $039EBA |\ Multiply the value by two.
    ROL <r_get_modified_timer_value_arg_value_hi                                ; $039EBC |/
    LDA r_battle_auto.w                                                         ; $039EBE |\
    BEQ +                                                                       ; $039EC1 | | If this is an auto-battle, replace the value with 0.
    TDC                                                                         ; $039EC3 | |
    TAX                                                                         ; $039EC4 | |
    STX <r_get_modified_timer_value_arg_value                                   ; $039EC5 |/
+   JSR _get_modified_timer_value                                               ; $039EC7 | Adjust the value by the speed modifier.
    JMP __calculate_timer_value_done                                            ; $039ECA

; __calculate_timer_value_mode_will ($03:9ECD)
;
; Mode for calculate_timer_value that starts with either the slot's will (if
; a character) or the value at $2F in the stat record if a monster. This value
; times four is subtracted from 300, and the final result is modified by the
; speed modifier and then divided by six.
__calculate_timer_value_mode_will:
    LDA r_calculate_timer_value_is_monster.w                                    ; $039ECD |\
    BEQ +                                                                       ; $039ED0 | | If the slot is a character, initially load the will stat.
    LDA r_character_battle.1.unknown2F.w,X                                      ; $039ED2 | | Otherwise, use the monster specific stat at $2F.
    BRA ++                                                                      ; $039ED5 | |
+   LDA r_character_battle.1.will.w,X                                           ; $039ED7 |/
++  STA <r_battle_generic_tmp_3_lo                                              ; $039EDA |\
    ASL <r_battle_generic_tmp_3_lo                                              ; $039EDC | | Subtract the given stat times four from 300.
    ASL <r_battle_generic_tmp_3_lo                                              ; $039EDE | |
    SEC                                                                         ; $039EE0 | | BUG: If the stat value (will or $2F) has a value of 64 or greater,
    LDA #(300 & %11111111).b                                                    ; $039EE1 | |      it will overflow during the multiplication process, and the
    SBC <r_battle_generic_tmp_3_lo                                              ; $039EE3 | |      upper bits will be lost, leading to unintuitive results.
    STA <r_get_modified_timer_value_arg_value_lo                                ; $039EE5 | |
    LDA #((300 & (%11111111 << 8)) >> 8).b                                      ; $039EE7 | |
    SBC #0.b                                                                    ; $039EE9 | |
    STA <r_get_modified_timer_value_arg_value_hi                                ; $039EEB |/
    BCS +                                                                       ; $039EED |\
    LDX #1.w                                                                    ; $039EEF | | If the result was negative, set it to 1.
    STX <r_get_modified_timer_value_arg_value                                   ; $039EF2 |/
+   JSR _get_modified_timer_value                                               ; $039EF4 | Modify the value by the speed modifier.
    LDX <r_get_modified_timer_value_result                                      ; $039EF7 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $039EF9 | | Divide the result by six.
    LDX #6.w                                                                    ; $039EFC | |
    STX r_math_divide_16bit_arg_2.w                                             ; $039EFF | |
    JSR _math_divide_16bit                                                      ; $039F02 | |
    LDX r_math_divide_16bit_result.w                                            ; $039F05 | |
    STX <r_get_modified_timer_value_result                                      ; $039F08 |/
    JMP __calculate_timer_value_done                                            ; $039F0A

; __calculate_timer_value_mode_vitality ($03:9F0D)
;
; Mode for calculate_timer_value that starts with either the slot's vitality (if
; a character) or the value at $2F in the stat record if a monster. 20 is added
; to that value. Finally, the result is modified by the speed modifier.
__calculate_timer_value_mode_vitality:
    LDA r_calculate_timer_value_is_monster.w                                    ; $039F0D |\
    BEQ +                                                                       ; $039F10 | | If the timer is being calculated for a monster, load the value of
    LDA r_character_battle.1.unknown2F.w,X                                      ; $039F12 | | $2F into the accumulator. Otherwise, load the slot's vitality.
    BRA ++                                                                      ; $039F15 | |
+   LDA r_character_battle.1.vitality.w,X                                       ; $039F17 |/
++  CLC                                                                         ; $039F1A |\
    ADC #20.b                                                                   ; $039F1B | | Add 20 to the value.
    TAX                                                                         ; $039F1D |/
    STX <r_get_modified_timer_value_arg_value                                   ; $039F1E |\ Adjust the result by the speed modifier.
    JSR _get_modified_timer_value                                               ; $039F20 |/
    JMP __calculate_timer_value_done                                            ; $039F23

; __calculate_timer_value_mode_parameter_formula ($03:9F26)
;
; Mode for calculate_timer_value that sets the timer value to the value passed
; in the parameter at $397B times two, plus 30. The final value is modified by
; the speed modifier (so slower characters will have a higher value).
__calculate_timer_value_mode_parameter_formula:
    LDA r_calculate_timer_value_arg_index.w                                     ; $039F26 |\
    STA <r_battle_generic_tmp_3_lo                                              ; $039F29 | | Save the argument to a temporary variable.
    STZ <r_battle_generic_tmp_3_hi                                              ; $039F2B |/
    ASL <r_battle_generic_tmp_3_lo                                              ; $039F2D |\ Multiply the value by two.
    ROL <r_battle_generic_tmp_3_hi                                              ; $039F2F |/
    CLC                                                                         ; $039F31 |\
    LDA <r_battle_generic_tmp_3_lo                                              ; $039F32 | | Add 30 to the value.
    ADC #30.b                                                                   ; $039F34 | |
    STA <r_get_modified_timer_value_arg_value_lo                                ; $039F36 | |
    LDA <r_battle_generic_tmp_3_hi                                              ; $039F38 | |
    ADC #0.b                                                                    ; $039F3A | |
    STA <r_get_modified_timer_value_arg_value_hi                                ; $039F3C |/
    JSR _get_modified_timer_value                                               ; $039F3E | Adjust the value by the speed modifier.
    JMP __calculate_timer_value_done                                            ; $039F41

; __calculate_timer_value_mode_wisdom_will ($03:9F44)
;
; Mode for calculate_timer_value that will either set the value to 30 or a
; random value, both adjusted by the speed modifier of the target.
;
; BUG: The code looks like it was supposed to set either 4 * $2F + 30 for
;      monsters or 2 * (wisdom + will) + 30 for characters. Unfortunately, it
;      writes one of these parameters to the wrong byte, so it will always
;      return either 30 or a random value (depending on if the correct parameter
;      byte has a previous value or zero in it).
;
; TODO: Determine if $E1 is initialized anytime before this is is called.
__calculate_timer_value_mode_wisdom_will:
    LDA r_calculate_timer_value_is_monster.w                                    ; $039F44 |\
    BEQ +                                                                       ; $039F47 | | If the target is a monster, set the two parameters to the value of
    LDA r_character_battle.1.unknown2F.w,X                                      ; $039F49 | | the stat at $2F in the battle record and four.
    STA <r_battle_generic_tmp_3_lo                                              ; $039F4C | |
    LDA #4.b                                                                    ; $039F4E | |
    STA <r_battle_generic_tmp_3_hi                                              ; $039F50 | |
    BRA ++                                                                      ; $039F52 |/
+   CLC                                                                         ; $039F54 |\
    LDA r_character_battle.1.wisdom.w,X                                         ; $039F55 | | Otherwise, set the two values to the sum of the character's wisdom
    ADC r_character_battle.1.will.w,X                                           ; $039F58 | | and will and two.
    STA <r_battle_generic_tmp_3_lo                                              ; $039F5B | |
    LDA #2.b                                                                    ; $039F5D | |
    STA <r_battle_generic_tmp_3_hi                                              ; $039F5F |/
++  LDA <r_battle_generic_tmp_3_lo                                              ; $039F61 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $039F63 | | Multiply the first value by the second value times 256.
    LDA <r_battle_generic_tmp_3_hi                                              ; $039F65 | |
    STA <r_math_multiply_8bit_arg_2_hi                                          ; $039F67 | | BUG: This actually ends up multiplying by zero or a random value.
    JSR _math_multiply_8bit                                                     ; $039F69 |/
    CLC                                                                         ; $039F6C |\
    LDA <r_math_multiply_8bit_result_lo                                         ; $039F6D | | Add 30 to the calculated value.
    ADC #30.b                                                                   ; $039F6F | |
    STA <r_get_modified_timer_value_arg_value_lo                                ; $039F71 | |
    LDA <r_math_multiply_8bit_result_hi                                         ; $039F73 | |
    ADC #0.b                                                                    ; $039F75 | |
    STA <r_get_modified_timer_value_arg_value_hi                                ; $039F77 |/
    JSR _get_modified_timer_value                                               ; $039F79 | Modify the result by the speed modifier.
    JMP __calculate_timer_value_done                                            ; $039F7C

; __calculate_timer_value_mode_parameter_times_three ($03:9F7F)
;
; Mode for calculate_timer_value that will set the value to three times the
; argument and then adjusting for the speed modifier.
__calculate_timer_value_mode_parameter_times_three:
    LDA r_calculate_timer_value_arg_index.w                                     ; $039F7F |\
    STA <r_math_multiply_8bit_arg_1                                             ; $039F82 | | Multiply the parameter by 3.
    LDA #3.b                                                                    ; $039F84 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $039F86 | |
    JSR _math_multiply_8bit                                                     ; $039F88 |/
    LDX <r_math_multiply_8bit_result                                            ; $039F8B |\
    STX <r_get_modified_timer_value_arg_value                                   ; $039F8D | | Modify the result by the speed modifier.
    JSR _get_modified_timer_value                                               ; $039F8F |/
    JMP __calculate_timer_value_done                                            ; $039F92

; __calculate_timer_value_mode_command ($03:9F95)
;
; Mode for calculate_timer_value that loads a byte associated with a given
; command and either multiplies or divides the relative speed by that value,
; depending on the value. The result is then modified by the speed modifier to
; produce the final result.
__calculate_timer_value_mode_command:
    LDA r_calculate_timer_value_arg_index.w                                     ; $039F95 |\
    CMP #BATTLE_COMMAND_JUMP.b                                                  ; $039F98 | | If the command was specifically jump, set the X register to four
    BNE +                                                                       ; $039F9A | | and branch ahead to near the end of the function.
    LDX #4.w                                                                    ; $039F9C | |
    BRA ++                                                                      ; $039F9F |/
+   TAX                                                                         ; $039FA1 |\ Otherwise, load a value from ROM associated with this command.
    LDA bank13.battle_command_timer_data.l,X                                    ; $039FA2 |/
    BNE +                                                                       ; $039FA6 |\ If the value was zero, switch to using the fixed timer mode.
    JMP __calculate_timer_value_mode_fixed                                      ; $039FA8 |/
+   BPL +                                                                       ; $039FAB |\
    AND #%01111111.b                                                            ; $039FAD | | If the value has the high bit set, mask out the high bit and
    TAX                                                                         ; $039FAF | | then set the ultimate value to the relative speed times the
    STX r_math_multiply_16bit_arg_2.w                                           ; $039FB0 | | value.
    LDX <r_get_modified_timer_value_arg_value                                   ; $039FB3 | |
    STX r_math_multiply_16bit_arg_1.w                                           ; $039FB5 | |
    JSR _math_multiply_16bit                                                    ; $039FB8 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $039FBB | |
    STX <r_get_modified_timer_value_arg_value                                   ; $039FBE | |
    BRA +++                                                                     ; $039FC0 |/
+   TAX                                                                         ; $039FC2 |\
    STX r_math_divide_16bit_arg_2.w                                             ; $039FC3 | | Otherwise, divide the relative speed by the read value. If the
    LDX <r_get_modified_timer_value_arg_value                                   ; $039FC6 | | result is equal to zero, increment it to one.
    STX r_math_divide_16bit_arg_1.w                                             ; $039FC8 | |
    JSR _math_divide_16bit                                                      ; $039FCB | |
    LDX r_math_divide_16bit_result.w                                            ; $039FCE | |
    BNE ++                                                                      ; $039FD1 | |
    INX                                                                         ; $039FD3 |/
++  STX <r_get_modified_timer_value_arg_value                                   ; $039FD4 |\ Modify the calculated value by the speed modifier.
+++ JSR _get_modified_timer_value                                               ; $039FD6 |/

; __calculate_timer_value_done ($03:9FD9)
;
; Finalizes the result of _calculate_timer_value and returns the result in $D4.
; This function should not be called directly.
__calculate_timer_value_done:
    LDY <r_get_modified_timer_value_result                                      ; $039FD9 |\
    BPL +                                                                       ; $039FDB | | Set the result to zero if the high bit is set, and then return.
    TDC                                                                         ; $039FDD | |
    TAY                                                                         ; $039FDE | |
+   STY <r_set_timer_value_arg                                                  ; $039FDF |/
    RTS                                                                         ; $039FE1

; _get_modified_timer_value ($03:9FE2)
;
; Given a 16-bit timer value of a character in $A9 and the 16-bit speed modifier
; of that character in $3979, returns the 16-bit modified timer value of that
; character in $AB. Note that if the product of the two parameters is greater
; than $FFFF, the result will be incorrect.
_get_modified_timer_value:
    LDX <r_get_modified_timer_value_arg_value                                   ; $039FE2 |\
    STX r_math_multiply_16bit_arg_1.w                                           ; $039FE4 | | Multiply the timer value by the speed modifier.
    LDX r_current_slot_speed_modifier.w                                         ; $039FE7 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $039FEA | |
    JSR _math_multiply_16bit                                                    ; $039FED |/
    LDX r_math_multiply_16bit_result_lo.w                                       ; $039FF0 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $039FF3 | | Divide the result by 16.
    LDX #16.w                                                                   ; $039FF6 | |
    STX r_math_divide_16bit_arg_2.w                                             ; $039FF9 | |
    JSR _math_divide_16bit                                                      ; $039FFC |/
    LDX r_math_divide_16bit_result.w                                            ; $039FFF |\ Store the result in the result variable.
    STX <r_get_modified_timer_value_result                                      ; $03A002 |/
    RTS                                                                         ; $03A004

; calculate_timer_value_mode_ptr_data ($03:A005)
;
; For each of the 12 calculate_timer_value modes, contains a pointer to the
; handler for that mode.
calculate_timer_value_mode_ptr_data:
    .addr __calculate_timer_value_mode_relative_speed                           ; $03A005.A006 | $00
    .addr __calculate_timer_value_mode_fixed                                    ; $03A007.A008 | $01
    .addr __calculate_timer_value_mode_fixed                                    ; $03A009.A00A | $02
    .addr __calculate_timer_value_mode_spell                                    ; $03A00B.A00C | $03
    .addr __calculate_timer_value_mode_will                                     ; $03A00D.A00E | $04
    .addr __calculate_timer_value_mode_will                                     ; $03A00F.A010 | $05
    .addr __calculate_timer_value_mode_vitality                                 ; $03A011.A012 | $06
    .addr __calculate_timer_value_mode_vitality                                 ; $03A013.A014 | $07
    .addr __calculate_timer_value_mode_parameter_formula                        ; $03A015.A016 | $08
    .addr __calculate_timer_value_mode_wisdom_will                              ; $03A017.A018 | $09
    .addr __calculate_timer_value_mode_parameter_times_three                    ; $03A019.A01A | $0A
    .addr __calculate_timer_value_mode_item                                     ; $03A01B.A01C | $0B
    .addr __calculate_timer_value_mode_command                                  ; $03A01D.A01E | $0C

; _check_battle_status ($03:A01F)
;
; Determines the current battle status and stores the result in $A8. If the
; running variable at $352D is set and running is disabled for the formation, it
; will be zeroed out.
;
; TODO: $00 ostensibly means the battle continues, but there may be some cases
;       where the battle can end with $A8 still having a value of $00.
_check_battle_status:
    LDA r_battle_status.w                                                       ; $03A01F |\ If the current status is already non-zero, simply return. The
    BNE @done1                                                                  ; $03A022 |/ battle is over.
    LDX #4.w                                                                    ; $03A024 |\ Initialize the character slot to 4.
    STX <r_check_battle_status_slot                                             ; $03A027 |/
-   LDX <r_check_battle_status_slot                                             ; $03A029 | Set the X register to the current character slot.
    LDA r_battle_slot_empty.w,X                                                 ; $03A02B |\ Skip this slot if it's empty.
    BNE +                                                                       ; $03A02E |/
    LDA <r_check_battle_status_slot_lo                                          ; $03A030 |\ Calculate the offsets for this slot.
    JSR _calculate_offsets                                                      ; $03A032 |/
    LDX r_current_slot_offset_character_battle                                  ; $03A035 | Load the offset for this slot's stat record into the X register.
    LDA r_character_battle.1.status_1.w,X                                       ; $03A037 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03A03A | | Skip this slot if the character is swoon or stone.
    BNE +                                                                       ; $03A03C |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03A03E |\ If this character is not magnetized, skip ahead to the next
    BPL +++                                                                     ; $03A041 |/ segment.
+   DEC <r_check_battle_status_slot_lo                                          ; $03A043 |\
    LDA <r_check_battle_status_slot_lo                                          ; $03A045 | | Decrement and loop until all five have been checked.
    BPL -                                                                       ; $03A047 |/
    LDA r_formation_flags2.w                                                    ; $03A049 |\
    AND #FORMATION_FLAGS_2_SCRIPTED                                             ; $03A04C | | If we reach this code, all characters are either dead, stoned or
    BEQ +                                                                       ; $03A04E | | magnetized. Depending on if this is a scripted battle or not,
    LDA #BATTLE_STATUS_PERISHED_SCRIPTED                                        ; $03A050 | | return either the regular perished value or the scripted perished
    BRA ++                                                                      ; $03A052 | | value.
+   LDA #BATTLE_STATUS_PERISHED                                                 ; $03A054 | |
++  STA <r_battle_status                                                        ; $03A056 | | TODO: Research if $00 can sometimes be perished as well.
    JMP @done2                                                                  ; $03A058 |/
+++ LDA r_monsters_remaining_total.w                                            ; $03A05B |\ If someone is alive and not magnetized, we reach this point. If
    BNE ++                                                                      ; $03A05E |/ there are still monsters alive, skip ahead to another point.
    LDA #(BATTLE_STATUS_VICTORY | BATTLE_STATUS_SPOILS).b                       ; $03A060 |\ Otherwise, set the battle status to victory with spoils.
    STA <r_battle_status                                                        ; $03A062 |/
    TDC                                                                         ; $03A064 |\ Initialize the X register to zero.
    TAX                                                                         ; $03A065 |/
-   LDA bank13.battle_formations_without_spoils_data.l + 0,X                    ; $03A066 |\
    CMP #$FF                                                                    ; $03A06A | | Check the next formation in the list to see if it matches the
    BEQ @done1                                                                  ; $03A06C | | current formation. If the end of the list has been reached without
    CMP r_battle_formation_lo.w                                                 ; $03A06E | | finding a matching formation, return the victory with spoils value.
    BNE +                                                                       ; $03A071 | |
    LDA bank13.battle_formations_without_spoils_data.l + 1,X                    ; $03A073 | |
    CMP r_battle_formation_hi.w                                                 ; $03A077 | |
    BNE +                                                                       ; $03A07A |/
    LDA <r_battle_status                                                        ; $03A07C |\
    AND #(BATTLE_STATUS_SPOILS ~ $FF)                                           ; $03A07E | | If a matching formation is found, remove the spoils bit and
    STA <r_battle_status                                                        ; $03A080 | | return.
    RTS                                                                         ; $03A082 |/
+   INX                                                                         ; $03A083 |\
    INX                                                                         ; $03A084 | | Otherwise, loop through the remaining formations.
    BRA -                                                                       ; $03A085 |/
@done1:
    RTS                                                                         ; $03A087 | Return the set value.
++  LDA r_battle_auto.w                                                         ; $03A088 |\ If we reach here, there are still living monsters. If this is an
    BNE @done2                                                                  ; $03A08B |/ auto battle, simply return.
    LDA r_battle_running_with_spell.w                                           ; $03A08D |\
    BNE +                                                                       ; $03A090 | | If the player isn't currently running, return.
    LDA r_battle_running.w                                                      ; $03A092 | |
    BEQ @done2                                                                  ; $03A095 |/
+   LDA r_battle_run_delay_timer.w                                              ; $03A097 |\
    CMP #$FF                                                                    ; $03A09A | | Return if the run delay timer is currently set to $FF.
    BEQ @done2                                                                  ; $03A09C |/
    LDA r_battle_run_delay_timer.w                                              ; $03A09E |\
    BEQ +                                                                       ; $03A0A1 | | If the run delay timer is non-zero and the run timer bypass is not
    LDA r_battle_bypass_run_timer.w                                             ; $03A0A3 | | set, decrement the run delay timer and return.
    BNE +                                                                       ; $03A0A6 | |
    DEC r_battle_run_delay_timer.w                                              ; $03A0A8 | |
    BRA @done2                                                                  ; $03A0AB |/
+   LDA r_formation_flags2.w                                                    ; $03A0AD |\
    AND #FORMATION_FLAGS_2_DISABLE_RUNNING.b                                    ; $03A0B0 | | Skip the next section if running is disabled for this formation.
    BNE ++                                                                      ; $03A0B2 |/
    TDC                                                                         ; $03A0B4 |\ Initialize the X register to zero.
    TAX                                                                         ; $03A0B5 |/
    STX <r_check_battle_status_slot                                             ; $03A0B6 | Set the slot to zero.
-   LDX <r_check_battle_status_slot                                             ; $03A0B8 |\
    LDA r_battle_slot_empty.w,X                                                 ; $03A0BA | | Skip this slot if it's empty.
    BNE +                                                                       ; $03A0BD |/
    LDA <r_check_battle_status_slot                                             ; $03A0BF |\ Calculate the offsets for this slot.
    JSR _calculate_offsets                                                      ; $03A0C1 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A0C4 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A0C6 | | Skip this slot if the character has any of the following statuses:
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03A0C9 | | Swoon, stone, paralyze, sleep, magnetized, stop, or jumping.
    BNE +                                                                       ; $03A0CB | |
    LDA r_character_battle.1.status_2.w,X                                       ; $03A0CD | |
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03A0D0 | |
    BNE +                                                                       ; $03A0D2 | |
    LDA r_character_battle.1.status_3.w,X                                       ; $03A0D4 | |
    AND #(STATUS_3_MAGNETIZED | STATUS_3_STOP | STATUS_3_JUMPING).b             ; $03A0D7 | |
    BNE +                                                                       ; $03A0D9 |/
    LDA #BATTLE_STATUS_RAN_AWAY                                                 ; $03A0DB |\
    STA <r_battle_status                                                        ; $03A0DD | | Otherwise, set the battle status to ran away.
    RTS                                                                         ; $03A0DF |/
+   INC <r_check_battle_status_slot_lo                                          ; $03A0E0 |\
    LDA <r_check_battle_status_slot_lo                                          ; $03A0E2 | | Increment the slot and loop until all five slots have been checked.
    CMP #5.b                                                                    ; $03A0E4 | |
    BNE -                                                                       ; $03A0E6 |/
++  STZ r_battle_running.w                                                      ; $03A0E8 | If running is disabled, zero out the running variable.
    JSR _battle_script_audiovisual_set_display_dialog_alert_0                   ; $03A0EB | Add code to display battle alerts.
    LDA #MONSTER_COMMAND_END                                                    ; $03A0EE |\ Write the end command to the audiovisual script.
    STA r_battle_script_audiovisual.w + 2                                       ; $03A0F0 |/
    LDA #BATTLE_ALERT_CANT_RUN                                                  ; $03A0F3 |\ Add the "Can't run" alert to the alert queue.
    STA r_battle_alert_queue.w                                                  ; $03A0F5 |/
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03A0F8 |\ Animate any audiovisual effects.
    JSR _battle_update                                                          ; $03A0FA |/
    JSR _battle_initialize_action_audiovisual                                   ; $03A0FD | Initializes various locations used during action processing.
@done2:
    RTS                                                                         ; $03A100

; _battle_update_inventory_enabled ($03:A101)
;
; Updates the battle inventory disabled flags to reflect the currently active
; character slot. Items they can equip and items usable in battle are enabled.
; Everything else is disabled.
_battle_update_inventory_enabled:
    STZ <r_battle_check_item_disabled_arg_character_lo                          ; $03A101 |\ Initialize the character variable to zero.
    STZ <r_battle_check_item_disabled_arg_character_hi                          ; $03A103 |/
    LDA r_battle_last_active_character_slot.w                                   ; $03A105 | Load the currently active character slot.
    JSR _calculate_offsets                                                      ; $03A108 | Calculate the offsets for that slot.
    LDX <r_current_slot_offset_character_battle                                 ; $03A10B |\
    LDA r_character_battle.1.sprite_class.w,X                                   ; $03A10D | | Load the class for this character and transfer it to the Y
    AND #%00001111.b                                                            ; $03A110 | | register.
    TAY                                                                         ; $03A112 |/
    INY                                                                         ; $03A113 | Increment the value so it represents the total number of rotates.
    SEC                                                                         ; $03A114 |\
-   ROL <r_battle_check_item_disabled_arg_character_lo                          ; $03A115 | | Rotate a single bit a number of times corresponding to the number
    ROL <r_battle_check_item_disabled_arg_character_hi                          ; $03A117 | | the character's class, so the corresponding bit is set in the
    DEY                                                                         ; $03A119 | | argument.
    BNE -                                                                       ; $03A11A |/
    TDC                                                                         ; $03A11C |\
    TAX                                                                         ; $03A11D | | Initialize the inventory offset to zero.
    STX <r_battle_update_inventory_enabled_tmp_offset                           ; $03A11E |/
-   LDX <r_battle_update_inventory_enabled_tmp_offset                           ; $03A120 | Load the inventory offset into the X register.
    LDA r_battle_inventory.1.id.w,X                                             ; $03A122 |\ If this slot is empty, skip to the next iteration.
    BEQ @next                                                                   ; $03A125 |/
    CMP #ITEM_CRYSTAL.b                                                         ; $03A127 |\
    BNE +                                                                       ; $03A129 | | If the item in question is the crystal, determine if the current
    LDX <r_current_slot_offset_character_battle                                 ; $03A12B | | character is Paladin Cecil. If so, branch to the code that enables
    LDA r_character_battle.1.id.w,X                                             ; $03A12D | | the item. Otherwise, branch to the code that disables it.
    AND #%00011111.b                                                            ; $03A130 | |
    CMP #CHARACTER_CECIL_2.b                                                    ; $03A132 | |
    BNE ++                                                                      ; $03A134 | |
    BEQ +++                                                                     ; $03A136 |/
+   JSR _battle_check_item_disabled                                             ; $03A138 |\
    LDA r_battle_check_item_disabled_result.w                                   ; $03A13B | | For all other items, call a function to determine enabled status.
    BEQ +++                                                                     ; $03A13E |/
++  LDX <r_battle_update_inventory_enabled_tmp_offset                           ; $03A140 |\
    LDA r_battle_inventory.1.flags.w,X                                          ; $03A142 | | If disabled, set the disabled flag in the inventory.
    ORA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $03A145 | |
    STA r_battle_inventory.1.flags.w,X                                          ; $03A147 | |
    BRA @next                                                                   ; $03A14A |/
+++ LDX <r_battle_update_inventory_enabled_tmp_offset                           ; $03A14C |\
    LDA r_battle_inventory.1.flags.w,X                                          ; $03A14E | | Otherwise, mask out the disabled flag to enable the item.
    AND #(BATTLE_INVENTORY_FLAG_DISABLED ~ $FF).b                               ; $03A151 | |
    STA r_battle_inventory.1.flags.w,X                                          ; $03A153 |/
@next:
    CLC                                                                         ; $03A156 |\
    LDA <r_battle_update_inventory_enabled_tmp_offset_lo                        ; $03A157 | | Increment the offset by the size of an inventory entry to move to
    ADC #_sizeof_battle_inventory_entry                                         ; $03A159 | | the next entry.
    STA <r_battle_update_inventory_enabled_tmp_offset_lo                        ; $03A15B |/
    CMP #_sizeof_r_battle_inventory.b                                           ; $03A15D |\ Loop until the entire inventory has been processed.
    BNE -                                                                       ; $03A15F |/
    RTS                                                                         ; $03A161

; _battle_check_item_disabled ($03:A162)
;
; Given a bitmask of the desired character (with each bit corresponding to the
; class of the character, with bit 0 corresponding to class 0) in $A9 and an
; item ID in the accumulator, determines whether that item should be enabled or
; disabled in the inventory. In particular, items are enabled if that item can
; be equipped by the passed character or if it is an item usable in battle.
; The result (a 0 if enabled or a 1 if disabled) is returned in $353D.
_battle_check_item_disabled:
    STZ r_battle_check_item_disabled_result.w                                   ; $03A162 | Initialize the result to zero.
    CMP #ITEM_FIRST_HELM.b                                                      ; $03A165 |\
    BCC +                                                                       ; $03A167 | | Depending on the range the item is in, branch to the appropriate
    CMP #ITEM_FIRST_NON_BATTLE_ITEM.b                                           ; $03A169 | | section of code.
    BCS ++                                                                      ; $03A16B | |
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03A16D | |
    BCC ++                                                                      ; $03A16F | |
    BCS +++                                                                     ; $03A171 |/
+   TAX                                                                         ; $03A173 |\
    STX <r_copy_from_array_arg_index                                            ; $03A174 | | If the item in question was a weapon or shield, load the equipment
    LDX #bank0F.equipment_property_data.w                                       ; $03A176 | | data from ROM.
    STX <r_generic_tmp_ptr_addr                                                 ; $03A179 | |
    LDA #:bank0F.equipment_property_data.b                                      ; $03A17B | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03A17D | |
    LDA #_sizeof_equipment.b                                                    ; $03A17F | |
    JSR _copy_from_array                                                        ; $03A181 |/
    LDA r_copy_from_array_result.w + equipment.flags                            ; $03A184 |\
    AND #EQUIPMENT_FLAG_CHARACTER_INDEX.b                                       ; $03A187 | | Load the equipment's index into the character equipment data.
    ASL A                                                                       ; $03A189 | |
    TAX                                                                         ; $03A18A |/
    LDA bank0F.equipment_character_equip_data.l + 0,X                           ; $03A18B |\
    STA <r_battle_check_item_disabled_tmp_mask_lo                               ; $03A18F | | Load the actual mask of characters that can use this equipment.
    LDA bank0F.equipment_character_equip_data.l + 1,X                           ; $03A191 | |
    STA <r_battle_check_item_disabled_tmp_mask_hi                               ; $03A195 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03A197 |\
    LDA <r_battle_check_item_disabled_tmp_mask                                  ; $03A199 | | If the passed character is one of the characters that can use this
    AND <r_battle_check_item_disabled_arg_character                             ; $03A19B | | equipment, branch forward.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03A19D | |
    BNE +++                                                                     ; $03A19F |/
++  INC r_battle_check_item_disabled_result.w                                   ; $03A1A1 |\
+++ REP #FLAG_P_ACCUMULATOR                                                     ; $03A1A4 | | For non-battle items or for non-equipable weapons and armor,
    TDC                                                                         ; $03A1A6 | | increment the result. Otherwise, leave it at zero.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03A1A7 |/
    RTS                                                                         ; $03A1A9

; _battle_update_commands_spells_enabled ($03:A1AA)
;
; Loops through the current character's commands and spells, updating each of
; their flags to enable/disable them as required.
_battle_update_commands_spells_enabled:
    STZ <r_battle_update_commands_spells_enabled_tmp_flags_1                    ; $03A1AA |\
    STZ <r_battle_update_command_enabled_result                                 ; $03A1AC | | Initialize various variables to zero.
    STZ <r_battle_update_commands_spells_enabled_tmp_flags_2                    ; $03A1AE | |
    STZ <r_battle_update_commands_spells_enabled_tmp_flags_3                    ; $03A1B0 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A1B2 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A1B4 | | If the character has the mute status, set the disabled bit in the
    AND #STATUS_1_MUTE.b                                                        ; $03A1B7 | | first flags variable.
    BEQ +                                                                       ; $03A1B9 | |
    LDA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A1BB | |
    STA <r_battle_update_commands_spells_enabled_tmp_flags_1                    ; $03A1BD |/
+   LDA r_character_battle.1.status_1.w,X                                       ; $03A1BF |\
    AND #STATUS_1_TOAD.b                                                        ; $03A1C2 | | If the character has the toad status, set the disabled bit in the
    BEQ +                                                                       ; $03A1C4 | | second flags variable.
    LDA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A1C6 | |
    STA <r_battle_update_commands_spells_enabled_tmp_flags_2                    ; $03A1C8 |/
+   LDA r_character_battle.1.status_1.w,X                                       ; $03A1CA |\
    AND #STATUS_1_PIG.b                                                         ; $03A1CD | | If the character has the pig status, set the disabled bit in the
    BEQ +                                                                       ; $03A1CF | | third flags variable.
    LDA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A1D1 | |
    STA <r_battle_update_commands_spells_enabled_tmp_flags_3                    ; $03A1D3 |/
+   LDA r_character_battle.1.mp_lo.w,X                                          ; $03A1D5 |\
    STA <r_battle_update_commands_spells_enabled_tmp_mp                         ; $03A1D8 | | Copy the character's current MP to a temporary variable. If they
    LDA r_character_battle.1.mp_hi.w,X                                          ; $03A1DA | | have more than 255 MP, simply assume 255 MP since a spell can't
    BEQ +                                                                       ; $03A1DD | | require more than that anyway.
    LDA #255.b                                                                  ; $03A1DF | |
    STA <r_battle_update_commands_spells_enabled_tmp_mp                         ; $03A1E1 |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03A1E3 |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03A1E5 | | Skip this next block if the character is hiding.
    BMI ++                                                                      ; $03A1E8 |/
    LDY #5.w                                                                    ; $03A1EA | Initialize the Y register to five.
    LDX r_current_slot_offset_command_list.w                                    ; $03A1ED | Set the X register to the offset to the character's command list.
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03A1F0 |\
    CMP #$FF.b                                                                  ; $03A1F3 | | Loop through the character's commands, updating their enabled
    BEQ +                                                                       ; $03A1F5 | | status in turn.
    JSR _battle_update_command_enabled                                          ; $03A1F7 | |
+   INX                                                                         ; $03A1FA | |
    INX                                                                         ; $03A1FB | |
    INX                                                                         ; $03A1FC | |
    INX                                                                         ; $03A1FD | |
    DEY                                                                         ; $03A1FE | |
    BNE -                                                                       ; $03A1FF |/
++  LDA <r_battle_update_command_enabled_result                                 ; $03A201 |\
    BEQ +                                                                       ; $03A203 | | If any of the commands' statuses changed, update the command menu
    LDA r_battle_last_active_character_slot.w                                   ; $03A205 | | entries for this slot.
    STA <r_battle_update_arg_slot                                               ; $03A208 | |
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_ENTRIES.b                              ; $03A20A | |
    JSR _battle_update                                                          ; $03A20C |/
+   LDX r_current_slot_offset_spell_list.w                                      ; $03A20F |\ Set the offset to the offset to the character's spell list.
    STX <r_battle_update_commands_spells_enabled_tmp_offset                     ; $03A212 |/
    TDC                                                                         ; $03A214 |\
    TAX                                                                         ; $03A215 | | Initialize the spell index to zero.
    STX <r_battle_update_commands_spells_enabled_tmp_index                      ; $03A216 |/
@start:
    LDX <r_battle_update_commands_spells_enabled_tmp_offset                     ; $03A218 | Load the current offset into the X register.
    LDA r_current_spell_lists.1.id.w,X                                          ; $03A21A |\ Skip this entry if it's empty.
    BEQ @next                                                                   ; $03A21D |/
    LDA r_current_spell_lists.1.flags.w,X                                       ; $03A21F |\
    AND #(BATTLE_COMMAND_FLAG_DISABLED ~ $FF).b                                 ; $03A222 | | Update the flags by masking out any existing disabled bit and
    ORA <r_battle_update_commands_spells_enabled_tmp_flags_1                    ; $03A224 | | combining the previously calculated disabled bits.
    ORA <r_battle_update_commands_spells_enabled_tmp_flags_2                    ; $03A226 | |
    ORA <r_battle_update_commands_spells_enabled_tmp_flags_3                    ; $03A228 | |
    STA r_current_spell_lists.1.flags.w,X                                       ; $03A22A |/
    LDA <r_battle_update_commands_spells_enabled_tmp_flags_1                    ; $03A22D |\ If the flags from the mute status were non-zero, skip this next
    BNE ++                                                                      ; $03A22F |/ block, as there are no exceptions to the mute status.
    LDA <r_battle_update_commands_spells_enabled_tmp_flags_2                    ; $03A231 |\
    BPL +                                                                       ; $03A233 | | If the spell being examined is Toad and the toad flags bits were
    LDA r_current_spell_lists.1.id.w,X                                          ; $03A235 | | non-zero, mask out the disabled bit to allow the user to cast it.
    CMP #SPELL_TOAD.b                                                           ; $03A238 | |
    BNE ++                                                                      ; $03A23A | |
    LDA r_current_spell_lists.1.flags.w,X                                       ; $03A23C | |
    AND #(BATTLE_COMMAND_FLAG_DISABLED ~ $FF).b                                 ; $03A23F | |
    STA r_current_spell_lists.1.flags.w,X                                       ; $03A241 | |
    BRA ++                                                                      ; $03A244 |/
+   LDA <r_battle_update_commands_spells_enabled_tmp_flags_3                    ; $03A246 |\
    BPL ++                                                                      ; $03A248 | | If the spell is Piggy and the pig disabled bit is set, mask out
    LDA r_current_spell_lists.1.id.w,X                                          ; $03A24A | | that bit so the character can still cast Piggy.
    CMP #SPELL_PIGGY.b                                                          ; $03A24D | |
    BNE ++                                                                      ; $03A24F | |
    LDA r_current_spell_lists.1.flags.w,X                                       ; $03A251 | |
    AND #(BATTLE_COMMAND_FLAG_DISABLED ~$FF).b                                  ; $03A254 | |
    STA r_current_spell_lists.1.flags.w,X                                       ; $03A256 |/
++  LDA r_current_spell_lists.1.cost.w,X                                        ; $03A259 |\
    CMP <r_battle_update_commands_spells_enabled_tmp_mp                         ; $03A25C | | If the cost of the spell is greater than the available MP, set
    BEQ @next                                                                   ; $03A25E | | the disabled bit to disallow casting of the spell.
    BCC @next                                                                   ; $03A260 | |
    LDA r_current_spell_lists.1.flags.w,X                                       ; $03A262 | |
    ORA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A265 | |
    STA r_current_spell_lists.1.flags.w,X                                       ; $03A267 |/
@next:
    LDX <r_battle_update_commands_spells_enabled_tmp_offset                     ; $03A26A |\
    INX                                                                         ; $03A26C | | Increment the offset by four to move to the next spell entry.
    INX                                                                         ; $03A26D | |
    INX                                                                         ; $03A26E | |
    INX                                                                         ; $03A26F | |
    STX <r_battle_update_commands_spells_enabled_tmp_offset                     ; $03A270 |/
    INC <r_battle_update_commands_spells_enabled_tmp_index                      ; $03A272 |\
    LDA <r_battle_update_commands_spells_enabled_tmp_index                      ; $03A274 | | Increment the spell index and loop until all potential 72 spells
    CMP #72.b                                                                   ; $03A276 | | for this character have been updated.
    BEQ +                                                                       ; $03A278 | |
    JMP @start                                                                  ; $03A27A |/
+   LDA r_battle_last_active_character_slot.w                                   ; $03A27D |\
    STA <r_battle_update_arg_slot                                               ; $03A280 | | Update the palettes for the spell list entries for this slot, to
    LDA #BATTLE_UPDATE_MODE_SPELL_LIST_PALETTES.b                               ; $03A282 | | actually visualize the new enabled/disabled data.
    JSR _battle_update                                                          ; $03A284 |/
    RTS                                                                         ; $03A287

; _battle_update_command_enabled ($03:A288)
;
; Given the offset to a command in the battle commands list in the X register,
; determines if that command should be enabled or disabled, and sets the
; appropriate bit in its flags. This function expects the _calculate_offsets
; data to be current. If the flags byte of the given command changes, $01 will
; be written to $AA. If the caller cares about the result, it's the caller's
; responsibility to initialize it to another known value beforehand.
_battle_update_command_enabled:
    STZ <r_battle_update_command_enabled_tmp_flags                              ; $03A288 | Initialize the flags variable to zero.
    PHX                                                                         ; $03A28A | Preserve the offset to the current command.
    LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03A28B |\
    CMP #BATTLE_COMMAND_DARK_WAVE.b                                             ; $03A28E | | If the command is dark wave, sing, aim or twin, call a separate
    BEQ +                                                                       ; $03A290 | | function to determine if it should be disabled. If so, branch
    CMP #BATTLE_COMMAND_SING.b                                                  ; $03A292 | | directly to the code that handles disabling the command.
    BEQ +                                                                       ; $03A294 | |
    CMP #BATTLE_COMMAND_AIM.b                                                   ; $03A296 | |
    BEQ +                                                                       ; $03A298 | |
    CMP #BATTLE_COMMAND_TWIN.b                                                  ; $03A29A | |
    BNE ++                                                                      ; $03A29C | |
+   JSR _battle_check_sing_aim_twin_dark_wave_disabled                          ; $03A29E | |
    LDA <r_battle_check_sing_aim_twin_dark_wave_disabled_result                 ; $03A2A1 | |
    BNE +                                                                       ; $03A2A3 |/
++  PLX                                                                         ; $03A2A5 |\ Restore the offset to the command and preserve it again.
    PHX                                                                         ; $03A2A6 |/
    LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03A2A7 |\
    ASL A                                                                       ; $03A2AA | | Look up the status masks for this command.
    TAX                                                                         ; $03A2AB | |
    LDA bank13.battle_command_status_restriction_data.l + 0,X                   ; $03A2AC | |
    STA <r_battle_update_command_enabled_tmp_status_1_mask                      ; $03A2B0 | |
    LDA bank13.battle_command_status_restriction_data.l + 1,X                   ; $03A2B2 | |
    STA <r_battle_update_command_enabled_tmp_status_2_mask                      ; $03A2B6 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A2B8 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A2BA | | Disable the command if the character has any of the statuses
    AND <r_battle_update_command_enabled_tmp_status_1_mask                      ; $03A2BD | | disallowed in the first status byte.
    BNE +                                                                       ; $03A2BF |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03A2C1 |\
    AND <r_battle_update_command_enabled_tmp_status_2_mask                      ; $03A2C4 | | Repeat the check for the second status byte.
    BEQ ++                                                                      ; $03A2C6 |/
+   LDA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A2C8 |\ If the command should be disabled, set the disabled bit in the
    STA <r_battle_update_command_enabled_tmp_flags                              ; $03A2CA |/ flags variable.
++  PLX                                                                         ; $03A2CC | Restore the X register to the command offset.
    LDA r_battle_commands.1.commands.1.flags.w,X                                ; $03A2CD |\
    PHA                                                                         ; $03A2D0 | | Update the flags byte for the command by masking out the existing
    AND #(BATTLE_COMMAND_FLAG_DISABLED ~ $FF).b                                 ; $03A2D1 | | disabled bit and replacing it with the one set above.
    ORA <r_battle_update_command_enabled_tmp_flags                              ; $03A2D3 | |
    STA r_battle_commands.1.commands.1.flags.w,X                                ; $03A2D5 |/
    PLA                                                                         ; $03A2D8 |\
    CMP r_battle_commands.1.commands.1.flags.w,X                                ; $03A2D9 | | If the value of the flags byte changed, set the result variable to
    BEQ +                                                                       ; $03A2DC | | $01.
    LDA #1.b                                                                    ; $03A2DE | |
    STA <r_battle_update_command_enabled_result                                 ; $03A2E0 |/
+   RTS                                                                         ; $03A2E2

; _battle_check_sing_aim_twin_dark_wave_disabled ($03:A2E3)
;
; For the currently being processed character (with their offset in $A6),
; determines if the command passed in the accumulator should be disabled. The
; 8-bit result is returned in $B3. Specifically, a zero is returned if the
; command shouldn't be disabled, and 1 otherwise.
_battle_check_sing_aim_twin_dark_wave_disabled:
    LDX <r_current_slot_offset_character_battle                                 ; $03A2E3 | Set the X register to the offset to the character's record.
    STZ <r_battle_check_sing_aim_twin_dark_wave_disabled_result                 ; $03A2E5 | Zero out the result variable.
    CMP #BATTLE_COMMAND_SING.b                                                  ; $03A2E7 |\
    BEQ @sing                                                                   ; $03A2E9 | | Depending on the command value passed in the accumulator, branch
    CMP #BATTLE_COMMAND_AIM.b                                                   ; $03A2EB | | to the right code. Any values other than sing, aim and twin simply
    BEQ @aim                                                                    ; $03A2ED | | fall through to the next section.
    CMP #BATTLE_COMMAND_TWIN.b                                                  ; $03A2EF | |
    BEQ @twin                                                                   ; $03A2F1 |/
    LDA r_character_battle.1.right_hand_item.w,X                                ; $03A2F3 |\
    BEQ +                                                                       ; $03A2F6 | | For commands other than sing, aim, and twin, follow the enabled
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03A2F8 | | branch if the character has at least one weapon equipped. Based on
    BCS +                                                                       ; $03A2FA | | the caller, this branch is almost certainly intended for Cecil's
    JMP @enabled                                                                ; $03A2FC | | dark wave attack.
+   LDA r_character_battle.1.left_hand_item.w,X                                 ; $03A2FF | |
    BEQ @disabled                                                               ; $03A302 | |
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03A304 | |
    BCS @disabled                                                               ; $03A306 | |
    RTS                                                                         ; $03A308 |/
@sing:
    LDA r_character_battle.1.right_hand_item.w,X                                ; $03A309 |\
    BEQ +                                                                       ; $03A30C | | For sing, check that the character has a weapon in at least one
    CMP #ITEM_FIRST_HARP.b                                                      ; $03A30E | | hand that falls in the range from $44 to $4C, which includes both
    BCC @disabled                                                               ; $03A310 | | harps, as well as some other miscellaneous weapons that Edward
    CMP #ITEM_FIRST_BOW.b                                                       ; $03A312 | | cannot equip.
    BCS @disabled                                                               ; $03A314 | |
    RTS                                                                         ; $03A316 | |
+   LDA r_character_battle.1.left_hand_item.w,X                                 ; $03A317 | |
    BEQ @disabled                                                               ; $03A31A | |
    CMP #ITEM_FIRST_HARP.b                                                      ; $03A31C | |
    BCC @disabled                                                               ; $03A31E | |
    CMP #ITEM_FIRST_BOW.b                                                       ; $03A320 | |
    BCS @disabled                                                               ; $03A322 | |
    RTS                                                                         ; $03A324 |/
@aim:
    LDA r_character_battle.1.right_hand_item.w,X                                ; $03A325 |\
    BEQ @disabled                                                               ; $03A328 | | For Aim, check if there is a bow in the right hand and that the
    CMP #ITEM_FIRST_BOW.b                                                       ; $03A32A | | left hand is not empty.
    BCC @disabled                                                               ; $03A32C | |
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03A32E | | NOTE: This clearly makes assumptions about the handedness of the
    BCS @disabled                                                               ; $03A330 | |       user. By default, this is always Rosa.
    LDA r_character_battle.1.left_hand_item.w,X                                 ; $03A332 | |
    BEQ @disabled                                                               ; $03A335 | |
    BNE @enabled                                                                ; $03A337 |/
@twin:
    PHX                                                                         ; $03A339 | Preserve the character's battle record offset.
    LDX r_current_slot_offset_spell_list.w                                      ; $03A33A |\ Preserve the offset for this character's spell lists.
    PHX                                                                         ; $03A33D |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A33E |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A340 | | Return disabled if the character has any of these statuses: toad,
    AND #(STATUS_1_TOAD | STATUS_1_SMALL | STATUS_1_PIG | STATUS_1_MUTE).b      ; $03A343 | | small, pig or mute.
    BNE ++                                                                      ; $03A345 |/
    LDX #1.w                                                                    ; $03A347 |\
    LDA <r_battle_active_character_slot                                         ; $03A34A | | Determine the slot number of the other twin. Assume the second
    CMP r_battle_twin_slots.w                                                   ; $03A34C | | twin slot has the other twin first. Compare the first twin slot
    BEQ +                                                                       ; $03A34F | | with the current slot. If they don't match, then switch to
    DEX                                                                         ; $03A351 | | reading the slot number from the first twin slot.
+   LDA r_battle_twin_slots.w,X                                                 ; $03A352 |/
    JSR _calculate_offsets                                                      ; $03A355 | Calculate the offsets for the second twin.
    LDX <r_current_slot_offset_character_battle                                 ; $03A358 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A35A | | Ensure that the second twin is not swoon, stone, toad, mini, pig
    AND #$FC.b                                                                  ; $03A35D | | or muted.
    BNE ++                                                                      ; $03A35F |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03A361 |\
    AND #$3C.b                                                                  ; $03A364 | | Also ensure they're not paralyzed, sleeping, charmed or berserked.
    BNE ++                                                                      ; $03A366 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03A368 |\
    AND #STATUS_3_STOP.b                                                        ; $03A36B | | Finally, ensure they're not stopped.
    BNE ++                                                                      ; $03A36D |/
    DEC <r_battle_check_sing_aim_twin_dark_wave_disabled_result                 ; $03A36F | Decrement the result, so that when it's incremented it'll be valid.
++  PLX                                                                         ; $03A371 |\
    STX r_current_slot_offset_spell_list.w                                      ; $03A372 | | Restore the offsets for the actual character being processed.
    PLX                                                                         ; $03A375 | |
    STX <r_current_slot_offset_character_battle                                 ; $03A376 |/
@disabled:
    INC <r_battle_check_sing_aim_twin_dark_wave_disabled_result                 ; $03A378 | Increment the result if the command should be disabled.
@enabled:
    RTS                                                                         ; $03A37A

; _battle_party_enqueue ($03:A37B)
;
; Handles the expiration of a party member's action timer. If that slot is
; capable of acting, it is added to the menu queue.
_battle_party_enqueue:
    LDA r_battle_formation_lo.w                                                 ; $03A37B |\
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL                                        ; $03A37E | | If this is the final Zeromus battle and party ATB is currently
    BNE +                                                                       ; $03A380 | | disabled, skip the processing of this function.
    LDA r_battle_formation_hi.w                                                 ; $03A382 | |
    BEQ +                                                                       ; $03A385 | |
    LDA r_battle_zeromus_enable_party_atb.w                                     ; $03A387 | |
    BEQ @done                                                                   ; $03A38A |/
+   LDA r_battle_bypass_run_timer.w                                             ; $03A38C |\
    BNE +                                                                       ; $03A38F | | If the run delay bypass flag is set or the monster in slot zero is
    LDA r_character_battle.6.level.w                                            ; $03A391 | | level 96 or lower, set the run delay timer to zero.
    CMP #99.b                                                                   ; $03A394 | |
    BEQ ++                                                                      ; $03A396 | |
    CMP #98.b                                                                   ; $03A398 | |
    BEQ ++                                                                      ; $03A39A | |
    CMP #97.b                                                                   ; $03A39C | |
    BEQ ++                                                                      ; $03A39E | |
+   STZ r_battle_run_delay_timer.w                                              ; $03A3A0 |/
++  TDC                                                                         ; $03A3A3 |\ Initialize the X register to zero.
    TAX                                                                         ; $03A3A4 |/
-   LDA r_battle_party_menu_queue.w,X                                           ; $03A3A5 |\
    CMP <r_battle_timer_slot                                                    ; $03A3A8 | | If this slot is already in the menu queue, abort processing this
    BEQ @done                                                                   ; $03A3AA | | function.
    INX                                                                         ; $03A3AC | |
    CPX #5.w                                                                    ; $03A3AD | |
    BNE -                                                                       ; $03A3B0 |/
    LDA <r_battle_active_character_slot                                         ; $03A3B2 |\ Load the active character slot and store it in a temporary
    STA <r_battle_party_enqueue_tmp                                             ; $03A3B4 |/ variable.
    LDA <r_battle_timer_slot                                                    ; $03A3B6 |\ Load the timer slot and calculate offsets for it.
    JSR _calculate_offsets                                                      ; $03A3B8 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03A3BB |\
    JSR _add_timer_offset                                                       ; $03A3BD | | Get the offset to that slot's action timer.
    LDX r_add_timer_offset_result.w                                             ; $03A3C0 |/
    LDA r_battle_timers.1.flags.w,X                                             ; $03A3C3 |\
    AND #TIMER_FLAG_EXPIRED.b ~ $FF                                             ; $03A3C6 | | Unset the expired bit in this timer's flags.
    STA r_battle_timers.1.flags.w,X                                             ; $03A3C8 |/
    LDA <r_battle_timer_slot                                                    ; $03A3CB |\
    STA <r_battle_active_character_slot                                         ; $03A3CD | | Determine if the timer slot is capable of acting.
    JSR _check_slot_active                                                      ; $03A3CF | |
    LDA <r_battle_active_character_slot                                         ; $03A3D2 | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03A3D4 | |
    LDA <r_battle_party_enqueue_tmp                                             ; $03A3D6 | |
    STA <r_battle_active_character_slot                                         ; $03A3D8 |/
    LDA <r_battle_generic_tmp_1_hi                                              ; $03A3DA |\
    CMP #$FF.b                                                                  ; $03A3DC | | If not, branch to the end.
    BEQ @done                                                                   ; $03A3DE |/
    LDA r_battle_party_menu_queue_count.w                                       ; $03A3E0 |\
    TAX                                                                         ; $03A3E3 | | Add this slot to the menu queue.
    LDA <r_battle_timer_slot                                                    ; $03A3E4 | |
    STA r_battle_party_menu_queue.w,X                                           ; $03A3E6 | |
    INC r_battle_party_menu_queue_count.w                                       ; $03A3E9 |/
@done:
    RTS                                                                         ; $03A3EC

; _battle_process_menu_queue ($03:A3ED)
;
; If a command menu is already open, handle a few situations that would cause it
; to be automatically closed. Otherwise, handle any appropriate auto-battle
; instructions or do processing necessary to open a command menu for the next
; active character in the queue.
_battle_process_menu_queue:
    LDA <r_battle_current_action.manual_pending                                 ; $03A3ED |\ If there is no manual action pending, branch ahead to the no menu
    BEQ @no_menu                                                                ; $03A3EF |/ code.
    LDA <r_battle_active_character_slot                                         ; $03A3F1 |\
    CMP #$FF                                                                    ; $03A3F3 | | If there is no active character slot, simply return.
    BEQ +++                                                                     ; $03A3F5 |/
    JSR _check_slot_active                                                      ; $03A3F7 | Check if this slot is currently capable of acting.
    LDA <r_battle_active_character_slot                                         ; $03A3FA |\
    CMP #$FF                                                                    ; $03A3FC | | If not, branch to code that makes sure the menu is closed.
    BEQ ++                                                                      ; $03A3FE |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A400 |\
    LDA r_character_battle.1.id.w,X                                             ; $03A402 | | If the character is not Edward, branch forward.
    AND #%00011111                                                              ; $03A405 | |
    CMP #CHARACTER_EDWARD.b                                                     ; $03A407 | |
    BNE +                                                                       ; $03A409 |/
    LDA r_boss_battle.w                                                         ; $03A40B |\ Branch forward if this is a boss battle.
    BNE +                                                                       ; $03A40E |/
    LDA r_battle_count_living_characters_result.w                               ; $03A410 |\
    DEC A                                                                       ; $03A413 | | Branch forward if there is only one living character.
    BEQ +                                                                       ; $03A414 |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03A416 |\ Branch forward if the character is currently hiding.
    BMI +                                                                       ; $03A419 |/
    AND #STATUS_4_CRITICAL.b                                                    ; $03A41B |\ If in HP critical, branch to the code that ensures the menu is
    BNE ++                                                                      ; $03A41D |/ closed.
+   JSR _battle_update_commands_spells_enabled                                  ; $03A41F | Update the enabled commands and spells.
    LDA <r_battle_active_character_slot                                         ; $03A422 |\
    JSR _math_multiply_by_8                                                     ; $03A424 | | If the character has Avenger equipped, call the function to
    TAX                                                                         ; $03A427 | | activate its effects, and then fall through to close the menu.
    LDA r_battle_hand_inventory.1.id.w,X                                        ; $03A428 | | Otherwise, return without closing the menu.
    CMP #ITEM_AVENGER.b                                                         ; $03A42B | |
    BEQ +                                                                       ; $03A42D | |
    LDA r_battle_hand_inventory.2.id.w,X                                        ; $03A42F | |
    CMP #ITEM_AVENGER.b                                                         ; $03A432 | |
    BNE +++                                                                     ; $03A434 | |
+   JSR _battle_activate_avenger                                                ; $03A436 |/
++  LDA #$FF                                                                    ; $03A439 |\ Clear the current active character slot.
    STA <r_battle_active_character_slot                                         ; $03A43B |/
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_CLOSE.b                                ; $03A43D |\ Close the menu.
    JSR _battle_update                                                          ; $03A43F |/
+++ RTS                                                                         ; $03A442
@no_menu:
    LDA <r_battle_active_character_slot                                         ; $03A443 |\
    CMP #$FF                                                                    ; $03A445 | | If there is no active character slot, skip the next code.
    BEQ +++                                                                     ; $03A447 |/
    JSR _check_slot_active                                                      ; $03A449 | Check if the character in this slot can currently act.
    LDA <r_battle_active_character_slot                                         ; $03A44C |\
    CMP #$FF                                                                    ; $03A44E | | If not, return without doing anything.
    BEQ ++                                                                      ; $03A450 |/
    LDA r_battle_auto.w                                                         ; $03A452 |\
    BEQ +                                                                       ; $03A455 | | If this is an auto-battle, execute the auto-battle code.
    JSR _battle_execute_auto_battle                                             ; $03A457 |/
+   LDX #_sizeof_action.w - 1                                                   ; $03A45A |\
-   LDA <r_battle_current_action,X                                              ; $03A45D | | Copy the action bytes from the first location to the second
    STA r_battle_current_action_2.w,X                                           ; $03A45F | | location.
    DEX                                                                         ; $03A462 | |
    BPL -                                                                       ; $03A463 |/
    JSR _battle_queue_current_action                                            ; $03A465 | Process and queue the current action.
    LDA #$FF                                                                    ; $03A468 |\ Clear out the active character slot.
    STA <r_battle_active_character_slot                                         ; $03A46A |/
++  RTS                                                                         ; $03A46C | Return from this function.
+++ LDA r_battle_running.w                                                      ; $03A46D |\ If there was no active character, and the player is running, skip
    BNE @done                                                                   ; $03A470 |/ to the end.
    LDA r_battle_party_menu_queue.w                                             ; $03A472 |\
    CMP #$FF                                                                    ; $03A475 | | If there is no one in the menu queue, branch to the end.
    BEQ @done                                                                   ; $03A477 |/
    PHA                                                                         ; $03A479 | Preserve the slot number at the top of the queue.
    TDC                                                                         ; $03A47A |\
    TAX                                                                         ; $03A47B | | Shift all the entries in the queue up one slot, now that we've
-   LDA r_battle_party_menu_queue.w + 1,X                                       ; $03A47C | | taken the top entry off.
    STA r_battle_party_menu_queue.w + 0,X                                       ; $03A47F | |
    INX                                                                         ; $03A482 | |
    CPX #_sizeof_r_battle_party_menu_queue.w - 1                                ; $03A483 | |
    BNE -                                                                       ; $03A486 | |
    DEC r_battle_party_menu_queue_count.w                                       ; $03A488 |/
    PLA                                                                         ; $03A48B | Restore the popped slot number to the accumulator.
    STA r_battle_last_active_character_slot.w                                   ; $03A48C |\ Set the active character slot variables.
    STA <r_battle_active_character_slot                                         ; $03A48F |/
    JSR _battle_remove_pending_arrow                                            ; $03A491 | Remove any pending last arrows from this slow.
    JSR _check_slot_active                                                      ; $03A494 | Check if this slot can act.
    LDA <r_battle_active_character_slot                                         ; $03A497 |\
    CMP #$FF                                                                    ; $03A499 | | If not, branch to the end.
    BEQ @done                                                                   ; $03A49B |/
    JSR _battle_update_inventory_enabled                                        ; $03A49D | Update the disabled inventory entries.
    JSR _battle_update_commands_spells_enabled                                  ; $03A4A0 | Update the disabled commands and spells.
    LDX <r_current_slot_offset_character_battle                                 ; $03A4A3 |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03A4A5 | | Remove the character's defending status, if set.
    AND #STATUS_3_DEFENDING.b ~ $FF                                             ; $03A4A8 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03A4AA |/
    LDA r_battle_twin_other_slot.w                                              ; $03A4AD |\
    CMP <r_battle_active_character_slot                                         ; $03A4B0 | | For USA Rev 1, if this slot matches the slot of the "other" twin,
.if FF4_VERSION == "USA_REV_1"                                                  ;         | | clear the active slot variable. For either version, branch ahead
    BNE +                                                                       ; $03A4B2 | | to skip the opening of the command menu.
    LDA #$FF                                                                    ; $03A4B4 | |
    STA <r_battle_active_character_slot                                         ; $03A4B6 | |
    BRA @done                                                                   ; $03A4B8 | |
.else                                                                           ;         | |
    BEQ @done                                                                   ; $03A4B2 | |
.endif                                                                          ;         |/
+   LDA r_character_battle.1.right_hand_item.w,X                                ; $03A4BA |\
    CMP #ITEM_AVENGER.b                                                         ; $03A4BD | | If the character has the Avenger equipped, activate its effects.
    BEQ +                                                                       ; $03A4BF | |
    LDA r_character_battle.1.left_hand_item.w,X                                 ; $03A4C1 | |
    CMP #ITEM_AVENGER.b                                                         ; $03A4C4 | |
    BNE ++                                                                      ; $03A4C6 | |
+   JMP _battle_activate_avenger                                                ; $03A4C8 |/
++  LDA r_battle_auto.w                                                         ; $03A4CB |\
    BEQ +                                                                       ; $03A4CE | | If this is an auto-battle, reset the pending manual byte, and
    STZ <r_battle_current_action.manual_pending                                 ; $03A4D0 | | return.
    RTS                                                                         ; $03A4D2 |/
+   TDC                                                                         ; $03A4D3 |\ Otherwise, signal that a command menu should be opened.
    JSR _battle_update                                                          ; $03A4D4 |/
@done:
    RTS                                                                         ; $03A4D7

; _battle_activate_avenger ($03:A4D8)
;
; Gives the current character the berserk status and resets their auto-action
; queued flag.
_battle_activate_avenger:
    LDX <r_current_slot_offset_character_battle                                 ; $03A4D8 |\
    LDA r_character_battle.1.status_2.w,X                                       ; $03A4DA | | Give the character the berserk status.
    ORA #STATUS_2_BERSERK.b                                                     ; $03A4DD | |
    STA r_character_battle.1.status_2.w,X                                       ; $03A4DF |/
    LDA <r_battle_active_character_slot                                         ; $03A4E2 |\
    TAX                                                                         ; $03A4E4 | | Unset the slot's auto-action queued flag.
    STZ r_battle_slot_auto_action_queued.w,X                                    ; $03A4E5 |/
    RTS                                                                         ; $03A4E8

; _battle_execute_auto_battle ($03:A4E9)
;
; For the currently active character slot, loads the next auto-battle
; instruction and sets the appropriate variables as if the command had been
; chosen manually.
_battle_execute_auto_battle:
-   LDA r_battle_action_pose_pending.w                                          ; $03A4E9 |\ Keep looping until any pending action pose changes are complete.
    BNE -                                                                       ; $03A4EC |/
    STZ <r_battle_current_action.targets.party                                  ; $03A4EE | Zero out the party target value.
    STZ <r_battle_current_action.command_index                                  ; $03A4F0 | Set the command index to zero (Fight).
    LDA <r_battle_active_character_slot                                         ; $03A4F2 |\ Store the character slot in the pending action pose slot variable.
    STA r_battle_action_pose_slot.w                                             ; $03A4F4 |/
    JSR _calculate_offsets                                                      ; $03A4F7 | Calculate the offsets for this slot.
    LDX <r_current_slot_offset_character_battle                                 ; $03A4FA |\
    LDA r_character_battle.1.id.w,X                                             ; $03A4FC | | If the character is not Golbez, branch forward to use the first
    AND #%00011111.b                                                            ; $03A4FF | | set of auto-battle data. Otherwise, continue and use the second
    CMP #CHARACTER_GOLBEZ.b                                                     ; $03A501 | | set.
    BNE @auto1                                                                  ; $03A503 |/
-   LDA r_auto_battle_index_2.w                                                 ; $03A505 |\
    ASL A                                                                       ; $03A508 | | Load the next byte from the auto battle data. If the value is $FF,
    TAX                                                                         ; $03A509 | | branch ahead to the code that will reset the sequence.
    LDA r_auto_battle_data_2.w,X                                                ; $03A50A | |
    CMP #$FF.b                                                                  ; $03A50D | |
    BEQ +                                                                       ; $03A50F |/
    STA <r_battle_execute_auto_battle_data_1                                    ; $03A511 | Otherwise, store the byte in a local variable.
    LDA r_auto_battle_data_2.w + 1,X                                            ; $03A513 |\ Load the second byte and store it in another variable.
    STA <r_battle_execute_auto_battle_data_2                                    ; $03A516 |/
    INC r_auto_battle_index_2.w                                                 ; $03A518 | Increment the index.
    BRA ++                                                                      ; $03A51B | Branch ahead to the processing code.
+   STZ r_auto_battle_index_2.w                                                 ; $03A51D |\ If the value was $FF, set the index to zero to reset the sequence
    BRA -                                                                       ; $03A520 |/ and then branch back to the beginning of the loop.
@auto1:
    LDA r_auto_battle_index_1.w                                                 ; $03A522 |\
    ASL A                                                                       ; $03A525 | | This code is identical to above, except it uses the first set of
    TAX                                                                         ; $03A526 | | auto-battle data (for non-Golbez characters) instead of the
    LDA r_auto_battle_data_1.w,X                                                ; $03A527 | | second set.
    CMP #$FF.b                                                                  ; $03A52A | |
    BEQ +                                                                       ; $03A52C | |
    STA <r_battle_execute_auto_battle_data_1                                    ; $03A52E | |
    LDA r_auto_battle_data_1.w + 1,X                                            ; $03A530 | |
    STA <r_battle_execute_auto_battle_data_2                                    ; $03A533 | |
    INC r_auto_battle_index_1.w                                                 ; $03A535 | |
    BRA ++                                                                      ; $03A538 | |
+   STZ r_auto_battle_index_1.w                                                 ; $03A53A | |
    BRA @auto1                                                                  ; $03A53D |/
++  LDA <r_battle_execute_auto_battle_data_1                                    ; $03A53F |\
    CMP #BATTLE_AUTO_COMMAND_BASE.b                                             ; $03A541 | | If the first data byte is less than $C0, branch ahead.
    BCC ++                                                                      ; $03A543 |/
    SEC                                                                         ; $03A545 |\
    SBC #BATTLE_AUTO_COMMAND_BASE.b                                             ; $03A546 | | Otherwise, set the command and pose command by subtracting $C0.
    STA <r_battle_current_action.command                                        ; $03A548 | |
    STA r_battle_action_pose_command.w                                          ; $03A54A |/
    LDA <r_battle_execute_auto_battle_data_1                                    ; $03A54D |\
    CMP #BATTLE_AUTO_COMMAND_BASE.b + BATTLE_COMMAND_KICK                       ; $03A54F | | If the command is specifically the kick command, set the monster
    BNE @start                                                                  ; $03A551 | | target to all monsters.
    LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03A553 | |
    STA <r_battle_current_action.targets.monster                                ; $03A555 | |
    BRA +                                                                       ; $03A557 |/
@start:
    JSR _get_battle_rng_0_7                                                     ; $03A559 |\
    STA <r_battle_execute_auto_battle_data_1                                    ; $03A55C | | Otherwise, keep trying random monster slots until one is found
    CLC                                                                         ; $03A55E | | that is not empty.
    ADC #5.b                                                                    ; $03A55F | |
    TAX                                                                         ; $03A561 | |
    LDA r_battle_slot_empty.w,X                                                 ; $03A562 | |
    BNE @start                                                                  ; $03A565 |/
    LDA <r_battle_execute_auto_battle_data_1                                    ; $03A567 |\
    TAX                                                                         ; $03A569 | | Convert the randomly-generated target into a bit mask and save it
    TDC                                                                         ; $03A56A | | into the target variable.
    JSR _set_bit_x                                                              ; $03A56B | |
    STA <r_battle_current_action.targets.monster                                ; $03A56E |/
+   LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $03A570 |\ Flag the action type as a command.
    STA <r_battle_current_action.flags                                          ; $03A572 |/
    BRA +++                                                                     ; $03A574 | Branch to the end.
++  CMP #BATTLE_AUTO_ITEM.b                                                     ; $03A576 |\
    BEQ +                                                                       ; $03A578 | | If the first byte doesn't match the value used for items, set the
    LDA #BATTLE_COMMAND_WHITE.b                                                 ; $03A57A | | pose command to white magic (to do the casting animation), and set
    STA r_battle_action_pose_command.w                                          ; $03A57C | | the actual spell value by using the second byte. Set the action
    LDA <r_battle_execute_auto_battle_data_2                                    ; $03A57F | | flags to magic. Finally, set the target to all monsters, before
    STA <r_battle_current_action.command                                        ; $03A581 | | branching to the end.
    LDA #BATTLE_ACTION_FLAG_MAGIC.b                                             ; $03A583 | |
    STA <r_battle_current_action.flags                                          ; $03A585 | |
    LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03A587 | |
    STA <r_battle_current_action.targets.monster                                ; $03A589 | |
    BRA +++                                                                     ; $03A58B |/
+   LDA <r_battle_execute_auto_battle_data_2                                    ; $03A58D |\
    STA <r_battle_current_action.command                                        ; $03A58F | | Otherwise, set the item value based on the second byte and set the
    LDA #BATTLE_ACTION_FLAG_ITEM.b                                              ; $03A591 | | action flags to item. Set the target to all monsters.
    STA <r_battle_current_action.flags                                          ; $03A593 | |
    LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03A595 | |
    STA <r_battle_current_action.targets.monster                                ; $03A597 |/
+++ INC r_battle_action_pose_pending.w                                          ; $03A599 | Flag that an action pose change is pending.
    RTS                                                                         ; $03A59C

; _check_slot_active ($03:A59D)
;
; Checks to see if the slot provided in $D0 is currently able to act in battle.
; Specifically, it will change $D0 to $FF if the slot currently has any of the
; following statuses: Swoon, Stone, Paralyze, Sleep, Charm, Berserk, Stop,
; Magnetized, Twin Casting, or Jumping.
_check_slot_active:
    LDA r_battle_active_character_slot                                          ; $03A59D |\  If the given slot number is $FF, there's
    CMP #$FF                                                                    ; $03A59F | | nothing to do, so skip to the end.
    BEQ @slot_inactive                                                          ; $03A5A1 |/
    JSR _calculate_offsets                                                      ; $03A5A3 | Otherwise, calculate the indexing offsets.
    LDX <r_current_slot_offset_character_battle                                 ; $03A5A6 | Load the offset for in-battle stats.
    LDA r_character_battle.1.status_1.w,X                                       ; $03A5A8 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE)                                      ; $03A5AB | | Check for Swoon and Stone statuses.
    BNE @slot_inactive                                                          ; $03A5AD |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03A5AF |\
    AND #%00111100                                                              ; $03A5B2 | | Check for Paralyze, Sleep, Charm, or Berserk.
    BNE @slot_inactive                                                          ; $03A5B4 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03A5B6 |\
    AND #%11000110                                                              ; $03A5B9 | | Check for Magnetized, Twin Casting, or Jumping.
    BEQ +                                                                       ; $03A5BB |/
@slot_inactive:
    LDA #$FF                                                                    ; $03A5BD |\ The slot is inactive, so store $FF in the
    STA r_battle_active_character_slot                                          ; $03A5BF |/ slot variable.
+   RTS                                                                         ; $03A5C1

; _battle_queue_current_action ($03:A5C2)
;
; Given updated data in the current action arrays at $D7 and $3937, processes
; the intended command sets the relevant values in the character's battle
; record. Additionally calculates the delay for that command to execute and sets
; the character's action timer.
_battle_queue_current_action:
    LDA <r_battle_active_character_slot                                         ; $03A5C2 |\ Transfer the current slot into a variable used by a number of
    STA r_battle_generic_arg_slot.w                                             ; $03A5C4 |/ calculation functions for the slot.
    JSR _calculate_offsets                                                      ; $03A5C7 | Calculate offsets for this slot.
    LDA r_battle_stats_recalculation_pending.w                                  ; $03A5CA |\
    BEQ +                                                                       ; $03A5CD | | If there is a stats recalculation pending from changed inventory,
    JSR _copy_equipment_from_hand_inventory                                     ; $03A5CF | | update the character's equipment data and recalculate the stats.
    JSR _update_equipment_data                                                  ; $03A5D2 | |
    JSR _calculate_character_battle                                             ; $03A5D5 | |
    STZ r_battle_stats_recalculation_pending.w                                  ; $03A5D8 |/
+   LDA r_battle_current_action_2.targets.monster.w                             ; $03A5DB |\
    ORA r_battle_current_action_2.targets.party.w                               ; $03A5DE | | If there are no pre-existing targets set, reset the target to the
    BNE +                                                                       ; $03A5E1 | | acting character slot.
    LDA <r_battle_active_character_slot                                         ; $03A5E3 | |
    TAX                                                                         ; $03A5E5 | |
    TDC                                                                         ; $03A5E6 | |
    JSR _set_bit_x                                                              ; $03A5E7 | |
    STA r_battle_current_action_2.targets.party.w                               ; $03A5EA |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03A5ED | Transfer the character's record offset into the X register.
    STZ r_character_battle.1.subcommand.w,X                                     ; $03A5EF | Zero out the subcommand value.
    LDA r_battle_current_action_2.flags.w                                       ; $03A5F2 |\ Copy the flags for the action to the character record.
    STA r_character_battle.1.action_flags.w,X                                   ; $03A5F5 |/
    BPL @non_command                                                            ; $03A5F8 | If the command flag isn't set, branch forward.
    LDX #_sizeof_command_entry_list.w                                           ; $03A5FA |\
    STX <r_calculate_battle_command_address_arg_record_size                     ; $03A5FD | | Calculate the address to the battle command index specified in the
    LDX #r_battle_commands.w                                                    ; $03A5FF | | current action data, in this slot's battle command data. The
    STX <r_calculate_battle_command_address_arg_base_address                    ; $03A602 | | result is put in $80.
    JSR _calculate_battle_command_address                                       ; $03A604 |/
    LDA r_battle_auto.w                                                         ; $03A607 |\
    BEQ +                                                                       ; $03A60A | | If this is an auto-battle, load the command value directly from
    LDA <r_battle_current_action.command                                        ; $03A60C | | the current action data. Otherwise, load it from the previously
    BRA ++                                                                      ; $03A60E | | calculated address.
+   LDY #command_entry.id.w                                                     ; $03A610 | |
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A613 |/
++  STA r_calculate_timer_value_arg_index.w                                     ; $03A615 | Store the command value in the timer index argument.
    PHA                                                                         ; $03A618 | Push the command value to the stack.
    CMP #BATTLE_COMMAND_TWIN.b                                                  ; $03A619 |\
    BNE ++                                                                      ; $03A61B | | If the command is twin, get the slot number for the other twin
    LDX #1.w                                                                    ; $03A61D | | and save the value to memory.
    LDA <r_battle_active_character_slot                                         ; $03A620 | |
    CMP r_battle_twin_slots.w                                                   ; $03A622 | |
    BEQ +                                                                       ; $03A625 | |
    DEX                                                                         ; $03A627 | |
+   LDA r_battle_twin_slots.w,X                                                 ; $03A628 | |
    STA r_battle_twin_other_slot.w                                              ; $03A62B | |
    BRA +                                                                       ; $03A62E |/
++  CMP #BATTLE_COMMAND_HEAL.b                                                  ; $03A630 |\
    BNE +                                                                       ; $03A632 | | If the command is heal, check for the proper Cure1 item.
    JSR _battle_heal_check_inventory                                            ; $03A634 |/
+   LDA #TIMER_MODE_COMMAND.b                                                   ; $03A637 |\ Set the timer calculation mode to command.
    STA r_calculate_timer_value_arg_mode                                        ; $03A639 |/
    PLA                                                                         ; $03A63B | Set the accumulator to the pushed command value.
    BRA @done_proxy                                                             ; $03A63C | Branch ahead to later code.
@non_command:
    AND #BATTLE_ACTION_FLAG_ITEM.b                                              ; $03A63E |\ If the item action flag is not set, branch ahead to the non-item,
    BEQ @non_item                                                               ; $03A640 |/ non-command code.
    TDC                                                                         ; $03A642 |\
    TAX                                                                         ; $03A643 | | Calculate the address for the inventory item listed in the action
    STX <r_calculate_battle_command_address_arg_record_size                     ; $03A644 | | data command variable.
    LDX #r_battle_inventory.w                                                   ; $03A646 | |
    STX <r_calculate_battle_command_address_arg_base_address                    ; $03A649 | |
    JSR _calculate_battle_command_address                                       ; $03A64B |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A64E | Set the X register to the offset to this slot's battle record.
    LDA r_character_battle.1.action_flags.w,X                                   ; $03A650 |\
    AND #BATTLE_ACTION_FLAG_DART.b                                              ; $03A653 | | If this is not a dart action, branch ahead.
    BEQ +                                                                       ; $03A655 |/
    LDA #TIMER_MODE_FIXED_2.b                                                   ; $03A657 |\ Set the timer calculate mode to fixed.
    STA <r_calculate_timer_value_arg_mode                                       ; $03A659 |/
    LDY #battle_inventory_entry.id.w                                            ; $03A65B |\
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A65E | | Set the subcommand to the ID of this inventory slot.
    STA r_character_battle.1.subcommand.w,X                                     ; $03A660 |/
    INY                                                                         ; $03A663 |\
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A664 | | Decrement the item count for the used item.
    DEC A                                                                       ; $03A666 | |
    STA (<r_generic_tmp_ptr),Y                                                  ; $03A667 |/
    JSR _battle_update_inventory_entry                                          ; $03A669 | Update the inventory entry for this item.
    LDA #BATTLE_COMMAND_DART.b                                                  ; $03A66C |\ Set the command to dart and branch to the end of the function.
    JMP @done                                                                   ; $03A66E |/
+   LDA r_battle_auto.w                                                         ; $03A671 |\
    BEQ +                                                                       ; $03A674 | | If the dart flag wasn't set, load the item ID from the inventory
    LDA <r_battle_current_action.command.b                                      ; $03A676 | | if this is not an auto-battle, and from the current action data
    BRA ++                                                                      ; $03A678 | | if this is an auto-battle.
+   LDY #battle_inventory_entry.id.w                                            ; $03A67A | |
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A67D |/
++  CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03A67F |\
    BCS +                                                                       ; $03A681 | | If the item ID is less than the first battle item, set the timer
    STA r_character_battle.1.subcommand.w,X                                     ; $03A683 | | calculation mode to fixed, set the subcommand to the item ID, and
    LDA #TIMER_MODE_FIXED_2.b                                                   ; $03A686 | | branch forward.
    STA <r_calculate_timer_value_arg_mode                                       ; $03A688 | |
    BRA ++                                                                      ; $03A68A |/
+   STA r_character_battle.1.subcommand.w,X                                     ; $03A68C | Set the subcommand to the item ID.
    STA r_calculate_timer_value_arg_index.w                                     ; $03A68F | Store the item ID in the timer calculation argument.
    LDA #TIMER_MODE_ITEM.b                                                      ; $03A692 |\ Set the timer calculation mode for items.
    STA <r_calculate_timer_value_arg_mode                                       ; $03A694 |/
    LDA r_battle_auto.w                                                         ; $03A696 |\ If this is an auto-battle, skip the next block of code.
    BNE ++                                                                      ; $03A699 |/
    LDA r_calculate_timer_value_arg_index.w                                     ; $03A69B |\
    CMP #ITEM_CRYSTAL.b                                                         ; $03A69E | | If the item is anything other than the crystal, decrement the
    BEQ ++                                                                      ; $03A6A0 | | count and update the inventory entry.
    LDY #battle_inventory_entry.count.w                                         ; $03A6A2 | |
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A6A5 | |
    DEC A                                                                       ; $03A6A7 | |
    STA (<r_generic_tmp_ptr),Y                                                  ; $03A6A8 | |
    JSR _battle_update_inventory_entry                                          ; $03A6AA |/
++  LDA #BATTLE_COMMAND_ITEM.b                                                  ; $03A6AD | Load the item command value into the accumulator.
@done_proxy:
    BRA @done                                                                   ; $03A6AF | Branch to the end.
@non_item:
    LDA r_battle_current_action_2.flags.w                                       ; $03A6B1 |\
    AND #BATTLE_ACTION_FLAG_MAGIC.b                                             ; $03A6B4 | | If the magic flag is not set, branch ahead to the next section.
    BEQ +++                                                                     ; $03A6B6 |/
    LDA #TIMER_MODE_SPELL.b                                                     ; $03A6B8 |\ Set the timer calculation mode to magic.
    STA <r_calculate_timer_value_arg_mode                                       ; $03A6BA |/
    LDX #_sizeof_command_entry.w * 72                                           ; $03A6BC |\
    STX <r_calculate_battle_command_address_arg_record_size                     ; $03A6BF | | Calculate the address for the particular spell entry referenced in
    LDX #r_current_spell_lists.w                                                ; $03A6C1 | | this slot's spell lists.
    STX <r_calculate_battle_command_address_arg_base_address                    ; $03A6C4 | |
    JSR _calculate_battle_command_address                                       ; $03A6C6 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A6C9 | Set the X register to the slot's battle record offset.
    LDA r_battle_auto.w                                                         ; $03A6CB |\
    BEQ +                                                                       ; $03A6CE | | If this is an auto-battle, load the spell ID from the current
    LDA <r_battle_current_action.command                                        ; $03A6D0 | | action data. Otherwise, load it from the character's spell list.
    BRA ++                                                                      ; $03A6D2 | |
+   LDY #spell_entry.id.w                                                       ; $03A6D4 | |
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A6D7 |/
++  STA r_calculate_timer_value_arg_index.w                                     ; $03A6D9 |\ Set the spell ID in the timer calculation argument and the
    STA r_character_battle.1.subcommand.w,X                                     ; $03A6DC |/ character's subcommand.
    LDA #BATTLE_COMMAND_WHITE.b                                                 ; $03A6DF |\ Load the command value for white into the accumulator and branch to
    BRA @done                                                                   ; $03A6E1 |/ the end.
+++ LDA #TIMER_MODE_FIXED_2.b                                                   ; $03A6E3 |\ If none of the command, item or magic flags is set, we reach this
    STA <r_calculate_timer_value_arg_mode                                       ; $03A6E5 |/ point. Set the timer calculation mode to fixed.
    LDX #_sizeof_battle_inventory_entry.w * 2                                   ; $03A6E7 |\
    STX <r_calculate_battle_command_address_arg_record_size                     ; $03A6EA | | Calculate the address of the entry in the character's hand
    LDX #r_battle_hand_inventory.w                                              ; $03A6EC | | inventory.
    STX <r_calculate_battle_command_address_arg_base_address                    ; $03A6EF | |
    JSR _calculate_battle_command_address                                       ; $03A6F1 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A6F4 |\
    LDY #battle_inventory_entry.id.w                                            ; $03A6F6 | | Load the ID of the item in that slot.
    LDA (<r_generic_tmp_ptr),Y                                                  ; $03A6F9 |/
    STA r_character_battle.1.subcommand.w,X                                     ; $03A6FB | Set the subcommand.
    LDA #BATTLE_COMMAND_ITEM.b                                                  ; $03A6FE | Load the item command value into the accumulator.
@done:
    LDX <r_current_slot_offset_character_battle                                 ; $03A700 |\ Set the character's command to the value in the accumulator.
    STA r_character_battle.1.command.w,X                                        ; $03A702 |/
    JSR _battle_unset_dead_targets_wrapper                                      ; $03A705 | Unset any dead targets in the targeting values.
    LDA r_battle_current_action_2.targets.monster.w                             ; $03A708 |\ Set the character's monster target value.
    STA r_character_battle.1.targets.monster.w,X                                ; $03A70B |/
    LDA r_battle_current_action_2.targets.party.w                               ; $03A70E |\ Set the character's party target value.
    STA r_character_battle.1.targets.party.w,X                                  ; $03A711 |/
    LDA <r_battle_active_character_slot                                         ; $03A714 |\ Calculate the timer value for this action.
    JSR _calculate_timer_value                                                  ; $03A716 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03A719 |\ Set the character's action timer to the calculated value.
    JSR _set_timer_value                                                        ; $03A71B |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03A71E |\ Flag the timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03A720 |/
    RTS                                                                         ; $03A723

; _battle_unset_dead_targets_wrapper ($03:A724)
;
; If more than one party member or monster is being targeted, updates the values
; in $393A and $393B to unset any targets that have either the swoon or stone
; status.
_battle_unset_dead_targets_wrapper:
    PHX                                                                         ; $03A724 | Preserve the value of the X register.
    LDA r_battle_current_action_2.targets.party.w                               ; $03A725 |\
    ORA r_battle_current_action_2.targets.monster.w                             ; $03A728 | | If the total number of set targets is equal to one, skip to the
    JSR _count_set_bits                                                         ; $03A72B | | end of the function.
    DEX                                                                         ; $03A72E | |
    BEQ +                                                                       ; $03A72F |/
    TDC                                                                         ; $03A731 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03A732 |/
    LDA r_battle_current_action_2.targets.party.w                               ; $03A733 |\
    STA <r_battle_unset_dead_targets_arg_targets                                ; $03A736 | | Remove any swooned or stoned targets from the party target value.
    STA <r_battle_unset_dead_targets_result                                     ; $03A738 | |
    LDX #5.w                                                                    ; $03A73A | |
    STX <r_battle_unset_dead_targets_arg_count                                  ; $03A73D | |
    JSR _battle_unset_dead_targets                                              ; $03A73F | |
    LDA <r_battle_unset_dead_targets_result                                     ; $03A742 | |
    STA r_battle_current_action_2.targets.party.w                               ; $03A744 |/
    LDA r_battle_current_action_2.targets.monster.w                             ; $03A747 |\
    STA <r_battle_unset_dead_targets_arg_targets                                ; $03A74A | | Remove any swooned or stoned targets from the monster target
    STA <r_battle_unset_dead_targets_result                                     ; $03A74C | | value.
    LDX #(5 + 8).w                                                              ; $03A74E | |
    STX <r_battle_unset_dead_targets_arg_count                                  ; $03A751 | | NOTE: The use of 13 here instead of 8 is actually a bug, but since
    JSR _battle_unset_dead_targets                                              ; $03A753 | |       it doesn't actually result in any impact, it doesn't matter.
    LDA <r_battle_unset_dead_targets_result                                     ; $03A756 | |
    STA r_battle_current_action_2.targets.monster.w                             ; $03A758 |/
+   PLX                                                                         ; $03A75B | Restore the value of the X register.
    RTS                                                                         ; $03A75C

; _battle_unset_dead_targets ($03:A75D)
;
; Given a targeting value in both $A9 and $AD, a count in $AB, and the offset
; within the battle records at $2000 to the desired starting slot in the Y
; registers, removes any targets from the targeting value that are swooned or
; stoned and returns the result in $AD.
_battle_unset_dead_targets:
    STZ <r_battle_unset_dead_targets_tmp_index                                  ; $03A75D | Initialize the index to zero.
-   ASL <r_battle_unset_dead_targets_arg_targets                                ; $03A75F |\ Read the next targeting bit, and branch forward to the next
    BCC +                                                                       ; $03A761 |/ iteration if it's not set.
    LDA r_character_battle.1.status_1.w,Y                                       ; $03A763 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03A766 | | Branch forward if the slot is neither dead nor stoned.
    BEQ +                                                                       ; $03A768 |/
    LDA <r_battle_unset_dead_targets_tmp_index                                  ; $03A76A |\
    TAX                                                                         ; $03A76C | | Otherwise, unset this bit in the target.
    LDA <r_battle_unset_dead_targets_result                                     ; $03A76D | |
    JSR _unset_bit_x                                                            ; $03A76F | |
    STA <r_battle_unset_dead_targets_result                                     ; $03A772 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03A774 |\
    TYA                                                                         ; $03A776 | | Add 128 to the index to move to the next slot.
    CLC                                                                         ; $03A777 | |
    ADC #_sizeof_character_battle.w                                             ; $03A778 | |
    TAY                                                                         ; $03A77B | |
    TDC                                                                         ; $03A77C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03A77D |/
    INC <r_battle_unset_dead_targets_tmp_index                                  ; $03A77F |\
    LDA <r_battle_unset_dead_targets_tmp_index                                  ; $03A781 | | Increment the index and loop until the requested number of slots
    CMP <r_battle_unset_dead_targets_arg_count                                  ; $03A783 | | has been checked.
    BNE -                                                                       ; $03A785 |/
    RTS                                                                         ; $03A787

; _calculate_battle_command_address ($03:A788)
;
; Given an 8-bit slot number in $D0, a 16-bit record size in $AB, a 16-bit base
; address in $AD and an 8-bit index value in $3939, calculates the address for
; that entry within that slot's data. Each individual entry is assumed to be
; four bytes, with the record size being the total size of the record for each
; slot. The result is stored both in the slot's character record at $2055 as
; well as at $80.
_calculate_battle_command_address:
    LDA <r_battle_active_character_slot                                         ; $03A788 |\
    TAX                                                                         ; $03A78A | | Multiply the slot number by the record size to determine the
    STX r_math_multiply_16bit_arg_1.w                                           ; $03A78B | | offset to the slot's data within the data structure.
    LDX <r_calculate_battle_command_address_arg_record_size                     ; $03A78E | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03A790 | |
    JSR _math_multiply_16bit                                                    ; $03A793 |/
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03A796 |\
    STX r_math_add_16bit_arg_1.w                                                ; $03A799 | | Add that result to the base address to determine the address of
    LDX <r_calculate_battle_command_address_arg_base_address                    ; $03A79C | | this slot's data.
    STX r_math_add_16bit_arg_2.w                                                ; $03A79E | |
    JSR _math_add_16bit                                                         ; $03A7A1 |/
    LDA r_battle_current_action_2.command_index.w                               ; $03A7A4 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03A7A7 | | Multiply the index by the size of an entry to determine the offset
    LDA #_sizeof_command_entry                                                  ; $03A7A9 | | within this slot's data.
    STA <r_math_multiply_8bit_arg_2                                             ; $03A7AB | |
    JSR _math_multiply_8bit                                                     ; $03A7AD |/
    LDX <r_math_multiply_8bit_result                                            ; $03A7B0 |\
    STX r_math_add_16bit_arg_1.w                                                ; $03A7B2 | | Add that offset to the previously calculated address to determine
    LDX r_math_add_16bit_result_lo.w                                            ; $03A7B5 | | the final address.
    STX r_math_add_16bit_arg_2.w                                                ; $03A7B8 | |
    JSR _math_add_16bit                                                         ; $03A7BB |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A7BE |\
    LDA r_math_add_16bit_result_lo_lo.w                                         ; $03A7C0 | | Store the result in the appropriate place in the character's
    STA r_character_battle.1.command_offset_lo.w,X                              ; $03A7C3 | | battle record, as well as in a generic result variable.
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03A7C6 | |
    LDA r_math_add_16bit_result_lo_hi.w                                         ; $03A7C8 | |
    STA r_character_battle.1.command_offset_hi.w,X                              ; $03A7CB | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03A7CE |/
    RTS                                                                         ; $03A7D0

; _battle_update_inventory_entry ($03:A7D1)
;
; Given a count in the accumulator and a pointer to the count byte of the
; inventory entry in the Y register, determines if the entry should be disabled
; and then updates the actual inventory entry and dialogs. Intended to be called
; from within the function at $03:A5C2.
_battle_update_inventory_entry:
    BNE +                                                                       ; $03A7D1 | If the count isn't zero, branch ahead.
    DEY                                                                         ; $03A7D3 |\
    TDC                                                                         ; $03A7D4 | | If it was zero, set the ID to zero and set the disabled flag.
    STA (<r_generic_tmp_ptr),Y                                                  ; $03A7D5 | |
    DEY                                                                         ; $03A7D7 | |
    LDA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $03A7D8 | |
    STA (<r_generic_tmp_ptr),Y                                                  ; $03A7DA |/
+   LDA r_battle_current_action_2.command_index.w                               ; $03A7DC |\
    STA <r_battle_update_arg_index                                              ; $03A7DF | | Update the inventory entry to reflect the new count and flags.
    LDA #BATTLE_UPDATE_MODE_INVENTORY_ENTRY.b                                   ; $03A7E1 | |
    JMP _battle_update                                                          ; $03A7E3 |/

; _battle_heal_check_inventory ($03:A7E6)
;
; For the heal command, checks that the inventory contains at least one Cure1
; and subsequently subtracts one from the count and updates the inventory
; entry.
;
; TODO: For some reason, after all this is complete, it restores the original
;       count, but does not restore the original flags, etc.
_battle_heal_check_inventory:
    TDC                                                                         ; $03A7E6 |\
    TAX                                                                         ; $03A7E7 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03A7E8 |/
-   LDA r_battle_inventory.1.id.w,X                                             ; $03A7E9 |\
    CMP #ITEM_CURE1.b                                                           ; $03A7EC | | Scan the inventory for at least one Cure1 item. If none is found,
    BEQ +                                                                       ; $03A7EE | | return from the function. Otherwise, continue, with the index of
    INY                                                                         ; $03A7F0 | | the item in the Y register and the offset in the X register.
    INX                                                                         ; $03A7F1 | |
    INX                                                                         ; $03A7F2 | |
    INX                                                                         ; $03A7F3 | |
    INX                                                                         ; $03A7F4 | |
    CPX #_sizeof_r_battle_inventory.w                                           ; $03A7F5 | |
    BNE -                                                                       ; $03A7F8 | |
    RTS                                                                         ; $03A7FA |/
+   LDA r_battle_inventory.1.count.w,X                                          ; $03A7FB |\
    CMP #1.b                                                                    ; $03A7FE | | If the count is less than 1, return.
    BCC ++                                                                      ; $03A800 |/
    SEC                                                                         ; $03A802 |\
    LDA r_battle_inventory.1.count.w,X                                          ; $03A803 | | Load the current count, and then save both the count and the
    PHA                                                                         ; $03A806 | | index.
    PHX                                                                         ; $03A807 |/
    SBC #1.b                                                                    ; $03A808 |\ Subtract one and update the count.
    STA r_battle_inventory.1.count.w,X                                          ; $03A80A |/
    BNE +                                                                       ; $03A80D |\
    STZ r_battle_inventory.1.count.w,X                                          ; $03A80F | | If the count after subtraction reached zero, set the count and ID
    STZ r_battle_inventory.1.id.w,X                                             ; $03A812 | | to zero, and set the disabled flag on the entry.
    LDA r_battle_inventory.1.flags.w,X                                          ; $03A815 | |
    ORA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03A818 | |
    STA r_battle_inventory.1.flags.w,X                                          ; $03A81A |/
+   TYA                                                                         ; $03A81D |\
    STA <r_battle_update_arg_index                                              ; $03A81E | | Update the inventory entry.
    LDA #BATTLE_UPDATE_MODE_INVENTORY_ENTRY.b                                   ; $03A820 | |
    JSR _battle_update                                                          ; $03A822 |/
    PLX                                                                         ; $03A825 |\ Restore the previously saved offset and count.
    PLA                                                                         ; $03A826 |/
    STA r_battle_inventory.1.count.w,X                                          ; $03A827 | TODO: Restore the old count for some reason.
++  RTS                                                                         ; $03A82A

; _battle_remove_pending_arrow ($03:A82B)
;
; If arrow removal was pending for the current character slot, removes the
; arrow from that slot's hand inventory and recalculates statistics.
_battle_remove_pending_arrow:
    LDA r_battle_last_active_character_slot.w                                   ; $03A82B |\ Load the character slot into the Y register.
    TAY                                                                         ; $03A82E |/
    LDA r_battle_remove_arrow_pending.w,Y                                       ; $03A82F |\ If this slot doesn't have a pending arrow removal, skip to the end
    BEQ ++                                                                      ; $03A832 |/ of the function.
    LDA r_battle_last_active_character_slot.w                                   ; $03A834 |\ Set the slot number argument to the current slot.
    STA r_battle_generic_arg_slot.w                                             ; $03A837 |/
    JSR _math_multiply_by_8                                                     ; $03A83A |\ Multiply the slot number by 8 and transfer it into the X register
    TAX                                                                         ; $03A83D |/ to index the hand inventory.
    LDA r_battle_remove_arrow_pending.w,Y                                       ; $03A83E |\
    BPL +                                                                       ; $03A841 | | If the high bit of the value is set, increment the X register by
    INX                                                                         ; $03A843 | | four to switch to the left hand. Otherwise, it will default to the
    INX                                                                         ; $03A844 | | right hand.
    INX                                                                         ; $03A845 | |
    INX                                                                         ; $03A846 |/
+   TDC                                                                         ; $03A847 |\ Zero out the pending value, since we're handling it now.
    STA r_battle_remove_arrow_pending.w,Y                                       ; $03A848 |/
    STZ r_battle_hand_inventory.1.id.w,X                                        ; $03A84B |\ Set the hand inventory's ID and count to zero to remove the item in
    STZ r_battle_hand_inventory.1.count.w,X                                     ; $03A84E |/ question.
    LDA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $03A851 |\ Set the flags to disable the item.
    STA r_battle_hand_inventory.1.flags.w,X                                     ; $03A853 |/
    LDA r_battle_generic_arg_slot.w                                             ; $03A856 |\ Calculate the offsets for the slot.
    JSR _calculate_offsets                                                      ; $03A859 |/
    JSR _copy_equipment_from_hand_inventory                                     ; $03A85C |\
    JSR _update_equipment_data                                                  ; $03A85F | | Recalculate the stats taking into account the new equipment.
    JSR _calculate_character_battle                                             ; $03A862 |/
++  RTS                                                                         ; $03A865

; _battle_timer_expire ($03:A866)
;
; Given an 8-bit slot in $D2 and an 8-bit timer index in $D3, jumps to the
; function that handles the expiration of that timer.
;
; TODO: The handlers all appear to be status related. Is there another handler
;       that handles non-status timers? Clearly at least some of the timers are
;       dual purposed.
_battle_timer_expire:
    JSR _battle_initialize_action_audiovisual                                   ; $03A866 | Initializes various locations used during action processing.
    LDA <r_battle_timer_slot                                                    ; $03A869 | Load the currently active slot.
    JSR _calculate_offsets                                                      ; $03A86B | Calculate the offsets for this slot.
    LDA <r_battle_timer_index                                                   ; $03A86E |\
    STA <r_battle_timer_expire_tmp                                              ; $03A870 | | Determine the offset to the current timer by taking its index and
    ASL A                                                                       ; $03A872 | | multiplying by 3.
    CLC                                                                         ; $03A873 | |
    ADC <r_battle_timer_expire_tmp                                              ; $03A874 |/
    JSR _add_timer_offset                                                       ; $03A876 |\
    LDX r_add_timer_offset_result.w                                             ; $03A879 | | Add the offset to the base for this slot to determine the offset.
    STX r_battle_timer_offset.w                                                 ; $03A87C |/
    LDA <r_battle_timer_index                                                   ; $03A87F |\
    ASL A                                                                       ; $03A881 | | Load the pointer to the handler for this timer and jump to it.
    TAX                                                                         ; $03A882 | |
    LDA battle_timer_expire_offset_data.l + 0,X                                 ; $03A883 | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03A887 | |
    LDA battle_timer_expire_offset_data.l + 1,X                                 ; $03A889 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03A88D | |
    LDA #:battle_timer_expire_offset_data                                       ; $03A88F | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03A891 | |
    JML [r_generic_tmp_ptr.w]                                                   ; $03A893 |/
    RTS                                                                         ; $03A896

; _battle_timer_expire_stop ($03:A897)
;
; Handles the expiration of the stop timer. Removes the stop status from the
; character, disables the timer, and does some TODO stuff.
_battle_timer_expire_stop:
    LDX <r_current_slot_offset_character_battle                                 ; $03A897 |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03A899 | | Remove the stop status from this character slot.
    AND #STATUS_3_STOP.b ~ $FF                                                  ; $03A89C | |
    STA r_character_battle.1.status_3.w,X                                       ; $03A89E |/
    LDX r_current_slot_offset_timer.w                                           ; $03A8A1 |\ Unset any flags in the stop timer.
    STZ r_battle_timers.1.stop.flags.w,X                                        ; $03A8A4 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03A8A7 |\
    JSR _add_timer_offset.w                                                     ; $03A8A9 | | Calculate the offset to this slot's action timer.
    LDX r_add_timer_offset_result.w                                             ; $03A8AC |/
    LDA r_battle_timers.1.flags.w,X                                             ; $03A8AF |\
    BPL +                                                                       ; $03A8B2 | | TODO: If the action timer has an unknown flag set, unset any
    STZ r_battle_timers.1.flags.w,X                                             ; $03A8B4 | |       flag bits and set the timer's value to 1.
    LDA #1.b                                                                    ; $03A8B7 | |
    STA r_battle_timers.1.value_lo.w,X                                          ; $03A8B9 | |
    STZ r_battle_timers.1.value_hi.w,X                                          ; $03A8BC |/
+   LDA <r_battle_timer_slot                                                    ; $03A8BF |\
    ASL A                                                                       ; $03A8C1 | | Disable the stop timer for this slot.
    TAX                                                                         ; $03A8C2 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03A8C3 | |
    AND #>TIMER_ENABLED_STOP ~ $FF                                              ; $03A8C6 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03A8C8 |/
    RTS                                                                         ; $03A8CB

; _battle_timer_expire_action ($03:A8CC)
;
; Handles the expiration of the action timer, which appears to be used for the
; sleep and paralysis statuses. Removes those statuses and resets the action
; timer to the slot's relative speed.
_battle_timer_expire_action:
    LDX <r_current_slot_offset_character_battle                                 ; $03A8CC |\
    LDA r_character_battle.1.status_2.w,X                                       ; $03A8CE | | Remove the sleep and paralysis statuses from the slot.
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b ~ $FF                           ; $03A8D1 | |
    STA r_character_battle.1.status_2.w,X                                       ; $03A8D3 |/
    STZ <r_calculate_timer_value_arg_mode                                       ; $03A8D6 |\
    LDA <r_battle_timer_slot                                                    ; $03A8D8 | | Reset the action timer to the slot's relative speed and unset any
    JSR _calculate_timer_value                                                  ; $03A8DA | | flags in the timer.
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03A8DD | |
    JSR _set_timer_value                                                        ; $03A8DF | |
    STZ r_battle_timers.1.flags.w,X                                             ; $03A8E2 |/
    RTS                                                                         ; $03A8E5

; _battle_timer_expire_sap ($03:A8E6)
;
; Handles the expiration of the sap timer. Removes the sap status and disables
; the timer.
_battle_timer_expire_sap:
    LDX <r_current_slot_offset_character_battle                                 ; $03A8E6 |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03A8E8 | | Remove the sap status from this slot.
    AND #STATUS_4_SAP.b ~ $FF                                                   ; $03A8EB | |
    STA r_character_battle.1.status_4.w,X                                       ; $03A8ED |/
    LDA <r_battle_timer_slot                                                    ; $03A8F0 |\
    ASL A                                                                       ; $03A8F2 | | Disable the sap timer for this slot.
    TAX                                                                         ; $03A8F3 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03A8F4 | |
    AND #>TIMER_ENABLED_SAP ~ $FF                                               ; $03A8F7 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03A8F9 |/
    RTS                                                                         ; $03A8FC

; _battle_timer_expire_poison ($03:A8FD)
;
; Handles the expiration of the poison timer. Resets the timer to the previously
; calculated poison interval. Also updates the character's HP and animates the
; damage effect.
_battle_timer_expire_poison:
    LDX <r_current_slot_offset_character_battle                                 ; $03A8FD |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03A8FF | | If the character is currently jumping or hiding, skip this routine
    AND #STATUS_3_JUMPING.b                                                     ; $03A902 | | entirely.
    BNE @done                                                                   ; $03A904 | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03A906 | |
    BMI @done                                                                   ; $03A909 |/
    LDA <r_battle_timer_slot                                                    ; $03A90B |\
    ASL A                                                                       ; $03A90D | | Reset the slot's poison timer to the value for the slot's
    TAX                                                                         ; $03A90E | | calculated poison interval.
    LDA r_battle_poison_interval.w + 0,X                                        ; $03A90F | |
    STA <r_battle_timer_expire_poison_tmp_lo                                    ; $03A912 | |
    LDA r_battle_poison_interval.w + 1,X                                        ; $03A914 | |
    STA <r_battle_timer_expire_poison_tmp_hi                                    ; $03A917 | |
    LDX r_battle_timer_offset.w                                                 ; $03A919 | |
    LDA <r_battle_timer_expire_poison_tmp_lo                                    ; $03A91C | |
    STA r_battle_timers.1.value_lo.w,X                                          ; $03A91E | |
    LDA <r_battle_timer_expire_poison_tmp_hi                                    ; $03A921 | |
    STA r_battle_timers.1.value_hi.w,X                                          ; $03A923 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03A926 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03A928 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03A92B |\
    LDX <r_current_slot_offset_character_battle                                 ; $03A92D | | Calculate the poison damage by taking the maximum HP and dividing
    LDA r_character_battle.1.hp_max.w,X                                         ; $03A92F | | by eight. If the result is zero, increment it to one.
    JSR _math_divide_by_8                                                       ; $03A932 | |
    STA <r_battle_timer_expire_poison_tmp                                       ; $03A935 | |
    LDA <r_battle_timer_expire_poison_tmp                                       ; $03A937 | |
    BNE +                                                                       ; $03A939 | |
    INC <r_battle_timer_expire_poison_tmp                                       ; $03A93B | |
+   TDC                                                                         ; $03A93D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03A93E |/
    LDA <r_battle_timer_slot                                                    ; $03A940 |\
    ASL A                                                                       ; $03A942 | | Set the damage for this slot to the calculated value.
    TAX                                                                         ; $03A943 | |
    LDA <r_battle_timer_expire_poison_tmp_lo                                    ; $03A944 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03A946 | |
    LDA <r_battle_timer_expire_poison_tmp_hi                                    ; $03A949 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03A94B |/
    JSR _battle_apply_pending_damage                                            ; $03A94E | Apply the pending damage.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03A951 |\
    STA r_battle_script_audiovisual.w + 0                                       ; $03A953 | | Set the audiovisual code to display the "Damaged by poison" alert.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $03A956 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03A958 |/
    LDA #BATTLE_ALERT_DAMAGED_BY_POISON.b                                       ; $03A95B |\ Add the damaged by poison alert to the queue.
    STA r_battle_alert_queue.w                                                  ; $03A95D |/
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03A960 |\ Animate any audiovisual effects.
    JSR _battle_update                                                          ; $03A962 |/
    JSR _battle_apply_pending_status                                            ; $03A965 | Apply any pending status changes.
    LDA #BATTLE_UPDATE_MODE_DAMAGE.b                                            ; $03A968 |\ Animate the damage effect.
    JSR _battle_update                                                          ; $03A96A |/
    LDA #BATTLE_UPDATE_MODE_CHARACTER_HP.b                                      ; $03A96D |\ Update character HP.
    JSR _battle_update                                                          ; $03A96F |/
    LDA #BATTLE_UPDATE_MODE_MONSTER_DEATH.b                                     ; $03A972 |\ Animate any dead monsters.
    JSR _battle_update                                                          ; $03A974 |/
@done:
    RTS                                                                         ; $03A977

; _battle_timer_expire_stone ($03:A978)
;
; Handles the expiration of the stone (or gradual petrification) timer. Resets
; the timer value to the precalculated stone timer interval for that slot. This
; suffers from a bug that causes it to disable the slot 0 stone timer if any
; slot reaches full petrification.
_battle_timer_expire_stone:
    LDX <r_current_slot_offset_character_battle                                 ; $03A978 |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03A97A | | Skip this function if the slot is currently jumping or hiding.
    AND #STATUS_3_JUMPING.b                                                     ; $03A97D | |
    BNE @done                                                                   ; $03A97F | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03A981 | |
    BMI @done                                                                   ; $03A984 |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03A986 |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $03A989 | | Fetch the slot's current stone status, and increment it, storing
    INC A                                                                       ; $03A98B | | it to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03A98C |/
    CMP #STONE_STATUS_FULL.b + 1                                                ; $03A98E |\ If the new status hasn't exceeded the full level, branch ahead to
    BNE +                                                                       ; $03A990 |/ the next section.
    LDA r_character_battle.1.status_2.w,X                                       ; $03A992 |\
    AND #STATUS_2_STONE_STATUS.b ~ $FF                                          ; $03A995 | | Unset any gradual stone status bits.
    STA r_character_battle.1.status_2.w,X                                       ; $03A997 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03A99A |\
    ORA #STATUS_1_STONE.b                                                       ; $03A99D | | Set the actual stone status.
    STA r_character_battle.1.status_1.w,X                                       ; $03A99F |/
    LDA <r_battle_timer_slot                                                    ; $03A9A2 |\
    ASL A                                                                       ; $03A9A4 | | Disable the stone timer and return.
    TAX                                                                         ; $03A9A5 | |
    LDA r_battle_enabled_timers.1.hi.w                                          ; $03A9A6 | | BUG: While the index is properly calculated, it isn't actually
    AND #>TIMER_ENABLED_STONE ~ $FF                                             ; $03A9A9 | |      used, meaning this always disables the timer on slot 0.
    STA r_battle_enabled_timers.1.hi.w                                          ; $03A9AB | |
    RTS                                                                         ; $03A9AE |/
+   LDA r_character_battle.1.status_2.w,X                                       ; $03A9AF |\
    ORA <r_battle_generic_tmp_1_lo                                              ; $03A9B2 | | Set the new stone status level.
    STA r_character_battle.1.status_2.w,X                                       ; $03A9B4 |/
    LDA <r_battle_timer_slot                                                    ; $03A9B7 |\
    ASL A                                                                       ; $03A9B9 | | Set the timer's value to the previously calculated stone interval.
    TAX                                                                         ; $03A9BA | |
    LDA r_battle_stone_interval.w + 0,X                                         ; $03A9BB | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03A9BE | |
    LDA r_battle_stone_interval.w + 1,X                                         ; $03A9C0 | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03A9C3 | |
    LDX r_battle_timer_offset.w                                                 ; $03A9C5 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03A9C8 | |
    STA r_battle_timers.1.value_lo.w,X                                          ; $03A9CA | |
    LDA <r_battle_generic_tmp_1_hi                                              ; $03A9CD | |
    STA r_battle_timers.1.value_hi.w,X                                          ; $03A9CF |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03A9D2 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03A9D4 |/
@done:
    RTS                                                                         ; $03A9D7

; _battle_timer_expire_wall ($03:A9D8)
;
; Handles the expiration of the wall timer. Unsets the wall status from the
; slot and disables the timer.
_battle_timer_expire_wall:
    LDX <r_current_slot_offset_character_battle                                 ; $03A9D8 |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03A9DA | | Unset the wall status from the slot.
    AND #STATUS_4_WALL.b ~ $FF                                                  ; $03A9DD | |
    STA r_character_battle.1.status_4.w,X                                       ; $03A9DF |/
    LDA <r_battle_timer_slot                                                    ; $03A9E2 |\
    ASL A                                                                       ; $03A9E4 | | Disable the wall timer.
    TAX                                                                         ; $03A9E5 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03A9E6 | |
    AND #>TIMER_ENABLED_WALL ~ $FF                                              ; $03A9E9 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03A9EB |/
    RTS                                                                         ; $03A9EE

; _battle_timer_expire_count ($03:A9EF)
;
; Handles the expiration of the count timer. Gives the slot the swoon status and
; disables all timers for the slot. Slots that are currently jumping or hiding
; are not processed.
_battle_timer_expire_count:
    LDX <r_current_slot_offset_character_battle                                 ; $03A9EF |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03A9F1 | | Don't process this timer if the slot is currently jumping or
    AND #STATUS_3_JUMPING.b                                                     ; $03A9F4 | | hiding.
    BNE +                                                                       ; $03A9F6 | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03A9F8 | |
    BMI +                                                                       ; $03A9FB |/
    LDX <r_current_slot_offset_character_battle                                 ; $03A9FD |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03A9FF | | Set the swoon status on this slot.
    ORA #STATUS_1_SWOON.b                                                       ; $03AA02 | |
    STA r_character_battle.1.status_1.w,X                                       ; $03AA04 |/
    LDA <r_battle_timer_slot                                                    ; $03AA07 |\
    ASL A                                                                       ; $03AA09 | | Disable all timers for this slot.
    TAX                                                                         ; $03AA0A | |
    STZ r_battle_enabled_timers.1.hi.w,X                                        ; $03AA0B |/
+   RTS                                                                         ; $03AA0E

; _battle_update_hp ($03:AA0F)
;
; Executes a number of operations to update the HP values in battle. First, if
; $3557 is zero, it will apply sap effects to any afflicted characters. It will
; then handle the increasing HP as a result of FuSoYa's (dummied out) bless
; skill. Note that this is affected by a bug that will prevent it from working
; if the middle slot is empty. FuSoYa, however, is never in anything other than
; a full party, so it doesn't take effect in the vanilla game.
_battle_update_hp:
    INC r_battle_prevent_sap_timer.w                                            ; $03AA0F |\
    LDA r_battle_prevent_sap_timer.w                                            ; $03AA12 | | Only execute the first part of this function if $3557 was exactly
    CMP #1.b                                                                    ; $03AA15 | | zero at the start. Otherwise, it will count up by one once per
    BNE @bless                                                                  ; $03AA17 | | execution. NOTE: This seems completely useless unless something sets it.
    STZ r_battle_prevent_sap_timer.w                                            ; $03AA19 |/
    JSR _battle_initialize_action_audiovisual                                   ; $03AA1C | Initializes various locations used during action processing.
    LDA #0.b                                                                    ; $03AA1F |\ Initialize the slot to zero.
    STA <r_battle_update_hp_slot                                                ; $03AA21 |/
-   LDA <r_battle_update_hp_slot                                                ; $03AA23 |\
    TAX                                                                         ; $03AA25 | | Skip this slot if it's empty.
    LDA r_battle_slot_empty.w,X                                                 ; $03AA26 | |
    BNE +                                                                       ; $03AA29 |/
    LDA <r_battle_update_hp_slot                                                ; $03AA2B |\
    ASL A                                                                       ; $03AA2D | | Check to see if the sap timer is enabled. If not, skip the next
    TAX                                                                         ; $03AA2E | | section of code.
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03AA2F | |
    AND #>TIMER_ENABLED_SAP                                                     ; $03AA32 | | TODO: Is this timer really sap exclusive?
    BEQ +                                                                       ; $03AA34 |/
    LDA <r_battle_update_hp_slot                                                ; $03AA36 |\ Calculate the offsets for the current slot.
    JSR _calculate_offsets                                                      ; $03AA38 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AA3B |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03AA3D | | Ensure that this slot is not swoon, not stone, not stopped, not
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03AA40 | | jumping and not hiding. If any of those statuses is set, skip
    BNE +                                                                       ; $03AA42 | | the next block of code.
    LDA r_character_battle.1.status_3.w,X                                       ; $03AA44 | |
    AND #(STATUS_3_STOP | STATUS_3_JUMPING).b                                   ; $03AA47 | |
    BNE +                                                                       ; $03AA49 | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03AA4B | |
    BMI +                                                                       ; $03AA4E |/
    LDA <r_battle_update_hp_slot                                                ; $03AA50 |\
    ASL A                                                                       ; $03AA52 | | Set this slot's pending damage to 2 HP.
    TAX                                                                         ; $03AA53 | |
    LDA #2.b                                                                    ; $03AA54 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03AA56 | |
    STZ r_battle_slot_damage.w + 1,X                                            ; $03AA59 |/
+   INC <r_battle_update_hp_slot                                                ; $03AA5C |\
    LDA <r_battle_update_hp_slot                                                ; $03AA5E | | Increment the slot and loop until all of them have been processed.
    CMP #(5 + 8).b                                                              ; $03AA60 | |
    BNE -                                                                       ; $03AA62 |/
    STZ r_battle_apply_pending_damage_result_deaths.w                           ; $03AA64 | Zero out the death counter.
    JSR _battle_apply_pending_damage                                            ; $03AA67 | Apply any currently pending damage and count any deaths.
    LDA #MONSTER_COMMAND_END.b                                                  ; $03AA6A |\ Set the audiovisual script to do nothing.
    STA r_battle_script_audiovisual.w                                           ; $03AA6C |/
    LDA r_battle_apply_pending_damage_result_deaths.w                           ; $03AA6F |\
    BEQ @bless                                                                  ; $03AA72 | | If there was one more deaths, set the audiovisual commands to
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03AA74 | | display the "HP ran out" alert.
    STA r_battle_script_audiovisual.w + 0                                       ; $03AA76 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $03AA79 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03AA7B | |
    LDA #BATTLE_ALERT_HP_RAN_OUT.b                                              ; $03AA7E | |
    STA r_battle_alert_queue.w                                                  ; $03AA80 |/
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03AA83 |\ Animate audiovisual effects.
    JSR _battle_update                                                          ; $03AA85 |/
    JSR _battle_apply_pending_status                                            ; $03AA88 | Apply any currently pending status changes.
    LDA #BATTLE_UPDATE_MODE_MONSTER_DEATH.b                                     ; $03AA8B |\ Animate any monster deaths.
    JSR _battle_update                                                          ; $03AA8D |/
    LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $03AA90 |\ Waits for the next frame, does various dialog updates, and closes
    JSR _battle_update                                                          ; $03AA92 |/ the command menu in certain instances.
@bless:
    JSR _battle_initialize_action_audiovisual                                   ; $03AA95 | Initializes various locations used during action processing.
    JSL bank13.battle_check_fusoya_bless_status                                 ; $03AA98 | Disable the FuSoYa bless timer depending on his status.
    LDA r_battle_fusoya_bless_counter.w                                         ; $03AA9C |\
    CMP #$FF.b                                                                  ; $03AA9F | | Skip to the end if the Bless counter is disabled.
    BEQ @done                                                                   ; $03AAA1 |/
    INC r_battle_fusoya_bless_counter.w                                         ; $03AAA3 | Increment the Bless counter.
    CMP #5.b                                                                    ; $03AAA6 |\ If the counter hasn't reached 5, skip past the next code.
    BNE @done                                                                   ; $03AAA8 |/
    STZ r_battle_fusoya_bless_counter.w                                         ; $03AAAA | Zero out the Bless counter.
    JSR _battle_initialize_action_audiovisual                                   ; $03AAAD | Initializes audiovisual data for the current action.
    TDC                                                                         ; $03AAB0 |\
    TAX                                                                         ; $03AAB1 | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03AAB2 |/
-   LDA r_battle_slot_empty.w                                                   ; $03AAB3 |\ BUG: This should skip this slot if it's empty, but they forget to
    BNE +                                                                       ; $03AAB6 |/      index, so it always checks slot 0.
    LDA r_character_battle.1.status_1.w,X                                       ; $03AAB8 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03AABB | | Skip the slot if the character has either the swoon or stone
    BNE +                                                                       ; $03AABD |/  status.
    PHX                                                                         ; $03AABF |\ Preserve the values of X and Y.
    PHY                                                                         ; $03AAC0 |/
    TYA                                                                         ; $03AAC1 |\
    ASL A                                                                       ; $03AAC2 | | Set the pending damage for this slot to the value Bless will
    TAX                                                                         ; $03AAC3 | | restore, making sure to set the high bit so it will be treated
    LDA r_battle_fusoya_bless_value.w                                           ; $03AAC4 | | as a cure instead of damage.
    STA r_battle_slot_damage.w + 0,X                                            ; $03AAC7 | |
    LDA #$80.b                                                                  ; $03AACA | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03AACC |/
    PLY                                                                         ; $03AACF |\ Restore the original X and Y registers.
    PLX                                                                         ; $03AAD0 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03AAD1 |\
    TXA                                                                         ; $03AAD3 | | Increase the slot offset to move to the next slot.
    CLC                                                                         ; $03AAD4 | |
    ADC #_sizeof_character_battle                                               ; $03AAD5 | |
    TAX                                                                         ; $03AAD8 | |
    TDC                                                                         ; $03AAD9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03AADA |/
    INY                                                                         ; $03AADC | Increment the Y register.
    CPY #5.w                                                                    ; $03AADD |\ Loop until all five slots have been considered.
    BNE -                                                                       ; $03AAE0 |/
    JSR _battle_apply_pending_damage                                            ; $03AAE2 | Apply any pending damage.
    JSR _battle_apply_pending_status                                            ; $03AAE5 | Apply any pending status changes.
@done:
    LDA #BATTLE_UPDATE_MODE_DAMAGE.b                                            ; $03AAE8 |\ Animate any pending damage.
    JSR _battle_update                                                          ; $03AAEA |/
    LDA #BATTLE_UPDATE_MODE_CHARACTER_HP.b                                      ; $03AAED |\ Update the character HP dialog.
    JMP _battle_update                                                          ; $03AAEF |/

; _battle_queue_auto_actions ($03:AAF2)
;
; Loops through the five character slots, queueing any automatic actions of the
; following types: charm, berserk, auto-hide and auto-show.
_battle_queue_auto_actions:
    TDC                                                                         ; $03AAF2 |\
    TAX                                                                         ; $03AAF3 | | Initialize the slot to zero.
    STX <r_battle_queue_auto_actions_slot                                       ; $03AAF4 |/
@start:
    LDX <r_battle_queue_auto_actions_slot                                       ; $03AAF6 | Load the current slot into the X register.
    LDA r_battle_slot_empty.w,X                                                 ; $03AAF8 |\
    BNE +                                                                       ; $03AAFB | | Skip this slot if empty or if an auto action has already been
    LDA r_battle_slot_auto_action_queued.w,X                                    ; $03AAFD | | queued.
    BEQ ++                                                                      ; $03AB00 | |
+   JMP @next                                                                   ; $03AB02 |/
++  TXA                                                                         ; $03AB05 |\ Calculate the offsets for the current slot.
    JSR _calculate_offsets                                                      ; $03AB06 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AB09 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03AB0B | | Skip this slot if the character has any of the following statuses:
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03AB0E | | swoon, stone, paralyze, sleep, stop, or jumping.
    BNE +                                                                       ; $03AB10 | |
    LDA r_character_battle.1.status_2.w,X                                       ; $03AB12 | | NOTE: The jumping status is only checked in USA Rev 1 and
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03AB15 | |       Easytype.
+   BNE +                                                                       ; $03AB17 | |
    LDA r_character_battle.1.status_3.w,X                                       ; $03AB19 | |
.if FF4_EASYTYPE == 1                                                           ;         | |
.if FF4_VERSION == "USA"                                                        ;         | |
    AND #STATUS_3_STOP.b                                                        ; $03AB1C | |
.else                                                                           ;         | |
    AND #(STATUS_3_STOP | STATUS_3_JUMPING).b                                   ; $03AB1C | |
.endif                                                                          ;         | |
.else                                                                           ;         | |
    AND #STATUS_3_STOP.b                                                        ; $03AB1C | |
.endif                                                                          ;         | |
    BEQ ++                                                                      ; $03AB1E | |
+   JMP @next                                                                   ; $03AB20 |/
++  LDA r_character_battle.1.status_2.w,X                                       ; $03AB23 |\
    AND #(STATUS_2_CHARM | STATUS_2_BERSERK).b                                  ; $03AB26 | | Skip the next block if the character isn't charmed or berserked.
    BEQ ++                                                                      ; $03AB28 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03AB2A |\
    AND #STATUS_3_TWIN_CASTING.b ~ %11111111                                    ; $03AB2D | | Remove the twin casting status from the character.
    STA r_character_battle.1.status_3.w,X                                       ; $03AB2F |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03AB32 |\
    AND #STATUS_2_BERSERK.b                                                     ; $03AB35 | | If the character is berserked, call a function to select the
    BEQ +                                                                       ; $03AB37 | | berserk target. Branch to the queue section.
    JSR _battle_select_berserk_target                                           ; $03AB39 | |
    BRA @queue                                                                  ; $03AB3C |/
+   LDA r_character_battle.1.status_2.w,X                                       ; $03AB3E |\
    AND #STATUS_2_CHARM.b                                                       ; $03AB41 | | If the character is charmed, call a function to select the action
    BEQ ++                                                                      ; $03AB43 | | and target. NOTE: Actually checking the status seems pointless,
    JSR _battle_select_charm_action                                             ; $03AB45 | | since it should be guaranteed from previous checks. Branch to the
    BRA @queue                                                                  ; $03AB48 |/  queue section.
++  LDA r_character_battle.1.status_4.w,X                                       ; $03AB4A |\
    AND #STATUS_4_CRITICAL.b                                                    ; $03AB4D | | Skip the rest of the iteration if the character isn't HP critical.
    BEQ @next                                                                   ; $03AB4F |/
    LDA r_character_battle.1.id.w,X                                             ; $03AB51 |\
    AND #%00011111.b                                                            ; $03AB54 | | Skip the rest of the iteration if the character isn't Edward.
    CMP #CHARACTER_EDWARD.b                                                     ; $03AB56 | |
    BNE @next                                                                   ; $03AB58 |/
    LDA r_boss_battle.w                                                         ; $03AB5A |\ Skip the rest of the iteration if this is a boss battle.
    BNE @next                                                                   ; $03AB5D |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03AB5F |\ Calculate the timer offset for the character's action timer.
    JSR _add_timer_offset                                                       ; $03AB61 |/
    LDX r_add_timer_offset_result.w                                             ; $03AB64 |\
    LDA r_battle_timers.1.flags.w,X                                             ; $03AB67 | | Skip this slot if the action timer already indicates a command is
    AND #TIMER_FLAG_COMMAND.b                                                   ; $03AB6A | | set up.
    BNE @next                                                                   ; $03AB6C |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AB6E |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03AB70 | | If the character is not hiding, branch ahead.
    BPL +                                                                       ; $03AB73 |/
    JSR _battle_count_living_characters                                         ; $03AB75 |\
    DEC A                                                                       ; $03AB78 | | If the character is hiding and there is only one living character,
    BNE @next                                                                   ; $03AB79 | | queue the auto-show and branch ahead.
    JSR _battle_queue_auto_show                                                 ; $03AB7B | |
    BRA ++                                                                      ; $03AB7E |/
+   JSR _battle_count_living_characters                                         ; $03AB80 |\
    DEC A                                                                       ; $03AB83 | | If the character is not hiding and the character in question is
    BEQ @next                                                                   ; $03AB84 | | not the only remaining living character, queue the auto-hide.
    JSR _battle_queue_auto_hide                                                 ; $03AB86 | |
    BRA ++                                                                      ; $03AB89 |/
@queue:
    STZ <r_calculate_timer_value_arg_mode                                       ; $03AB8B | Set the timer value calculation mode to modified relative speed.
    LDA <r_battle_queue_auto_actions_slot                                       ; $03AB8D |\ Calculate the timer value for this slot.
    JSR _calculate_timer_value                                                  ; $03AB8F |/
++  LDA #TIMER_OFFSET_ACTION.b                                                  ; $03AB92 |\ Set the character's action timer to the calculated value.
    JSR _set_timer_value                                                        ; $03AB94 |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03AB97 |\ Flag the timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03AB99 |/
    LDX <r_battle_queue_auto_actions_slot                                       ; $03AB9C |\ Flag that the slot has a queued auto action.
    INC r_battle_slot_auto_action_queued.w,X                                    ; $03AB9E |/
@next:
    INC <r_battle_queue_auto_actions_slot                                       ; $03ABA1 |\
    LDA <r_battle_queue_auto_actions_slot                                       ; $03ABA3 | | Increment the slot number and loop until all five character slots
    CMP #5.b                                                                    ; $03ABA5 | | have been checked.
    BEQ +                                                                       ; $03ABA7 | |
    JMP @start                                                                  ; $03ABA9 |/
+   RTS                                                                         ; $03ABAC

; _battle_select_charm_action ($03:ABAD)
;
; Selects an action for the character whose offset is currently stored in $A6.
; If a random number from 0 to 98 (inclusive) is greater than or equal to 70, a
; physical attack will be performed against a random party member. Otherwise, it
; will attempt to select a white or black magic spell. If this fails for
; whatever reason, it will instead fall back on a physical attack.
_battle_select_charm_action:
    LDX <r_current_slot_offset_character_battle                                 ; $03ABAD | Set the X register to the offset to the character record.
    STZ r_character_battle.1.targets.monster.w,X                                ; $03ABAF |\ Initially set no targets.
    STZ r_character_battle.1.targets.party.w,X                                  ; $03ABB2 |/
    JSR _get_battle_rng_0_98                                                    ; $03ABB5 |\
    CMP #70.b                                                                   ; $03ABB8 | | If a random number from 0 to 98 is >= 70, branch ahead.
    BCS ++                                                                      ; $03ABBA |/
    LDX r_current_slot_offset_command_list.w                                    ; $03ABBC | Set the X register to the character's command list offset.
    LDY #5.w                                                                    ; $03ABBF | Set the Y register to 5.
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03ABC2 |\
    CMP #BATTLE_COMMAND_WHITE.b                                                 ; $03ABC5 | | If either white magic or black magic is available, branch forward.
    BEQ +                                                                       ; $03ABC7 | |
    CMP #BATTLE_COMMAND_BLACK.b                                                 ; $03ABC9 | |
    BEQ +                                                                       ; $03ABCB |/
    INX                                                                         ; $03ABCD |\
    INX                                                                         ; $03ABCE | | Update the indexes and loop until all commands have been checked.
    INX                                                                         ; $03ABCF | |
    INX                                                                         ; $03ABD0 | |
    DEY                                                                         ; $03ABD1 | |
    BNE -                                                                       ; $03ABD2 |/
    BRA ++                                                                      ; $03ABD4 | If no magic is found, skip ahead to the physical attack code.
+   STZ <r_battle_select_charm_spell_result_status                              ; $03ABD6 | Initialize the charm spell result variable to zero.
    JSR _battle_select_charm_spell                                              ; $03ABD8 | Attempt to select a random white or black spell to cast.
    LDA <r_battle_select_charm_spell_result_status                              ; $03ABDB |\ If no enabled spell was found, branch forward to the physical
    BNE ++                                                                      ; $03ABDD |/ attack code.
    RTS                                                                         ; $03ABDF | If a spell was selected, return.
++  LDX <r_current_slot_offset_character_battle                                 ; $03ABE0 | Set the X register to the offset to the character record.
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $03ABE2 |\ Specify that the action type was a command.
    STA r_character_battle.1.action_flags.w,X                                   ; $03ABE4 |/
    STZ r_character_battle.1.command.w,X                                        ; $03ABE7 | Set the command byte to zero for a physical attack.
-   JSR _get_battle_rng_0_4                                                     ; $03ABEA |\
    TAX                                                                         ; $03ABED | | Select random slots until finding one that isn't empty.
    LDA r_battle_slot_empty.w,X                                                 ; $03ABEE | |
    BNE -                                                                       ; $03ABF1 |/
    TDC                                                                         ; $03ABF3 |\
    JSR _set_bit_x                                                              ; $03ABF4 | | Convert the slot number to a bit mask and store it in the
    LDX <r_current_slot_offset_character_battle                                 ; $03ABF7 | | character's party target byte.
    STA r_character_battle.1.targets.party.w,X                                  ; $03ABF9 |/
    RTS                                                                         ; $03ABFC

; _battle_select_charm_spell ($03:ABFD)
;
; Based on the current stat record offset stored in $A6 (calculated by
; _calculate_offsets), selects one of their spells in either the white or black
; spell list randomly to cast, and sets the subcommand for the character.
;
; It also determines the target for the spell: if the spell targets monsters by
; default, it will target the party and vice versa. If the spell supports single
; targeting, a single target of the specified type will be chosen randomly. It
; only requires that the slot has something in it, and not necessarily that it
; is alive. (The targeting system may automatically roll it over to a valid
; target, however. That is TODO.) If the spell does not support single
; targeting, it will target all.
;
; If the character has no spells that are currently able to be cast, it will
; increment the current value in $90.
_battle_select_charm_spell:
    LDX r_current_slot_offset_spell_list.w                                      ; $03ABFD |\ Save the offset for this character's spell list to a temporary
    STX <r_battle_select_charm_spell_tmp_index_1                                ; $03AC00 |/ variable, and keep it in the X register.
    LDY #48.w                                                                   ; $03AC02 | Initialize Y register to the number of white or black spell entries.
-   LDA r_current_spell_lists.1.flags.w,X                                       ; $03AC05 |\ Read the flags for this entry, and if the spell is not disabled,
    BPL @start                                                                  ; $03AC08 |/ branch to the next section.
    INX                                                                         ; $03AC0A |\
    INX                                                                         ; $03AC0B | | Increment the indexes and loop until all spell entries have been
    INX                                                                         ; $03AC0C | | checked.
    INX                                                                         ; $03AC0D | |
    DEY                                                                         ; $03AC0E | |
    BNE -                                                                       ; $03AC0F |/
    INC <r_battle_select_charm_spell_result_status                              ; $03AC11 |\ If no enabled spells have been found, increment the result variable
    JMP @done                                                                   ; $03AC13 |/ and jump to the end.
@start:
    TDC                                                                         ; $03AC16 |\
    TAX                                                                         ; $03AC17 | | Fetch a random number from 0 to 47 (inclusive) and multiply it by
    LDA #47.b                                                                   ; $03AC18 | | the size of a spell entry to get a random offset to one of the
    JSR _get_battle_rng                                                         ; $03AC1A | | character's spells.
    TAX                                                                         ; $03AC1D | |
    STX r_math_multiply_16bit_arg_1.w                                           ; $03AC1E | |
    LDX #_sizeof_spell_entry.w                                                  ; $03AC21 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03AC24 | |
    JSR _math_multiply_16bit                                                    ; $03AC27 |/
    CLC                                                                         ; $03AC2A |\
    LDA <r_battle_select_charm_spell_tmp_index_1_lo                             ; $03AC2B | | Add the offset to the individual spell to the base offset for this
    ADC r_math_multiply_16bit_result_lo_lo.w                                    ; $03AC2D | | character's spell lists and load it into the X register.
    STA <r_battle_select_charm_spell_tmp_index_2_lo                             ; $03AC30 | |
    LDA <r_battle_select_charm_spell_tmp_index_1_hi                             ; $03AC32 | |
    ADC r_math_multiply_16bit_result_lo_hi.w                                    ; $03AC34 | |
    STA <r_battle_select_charm_spell_tmp_index_2_hi                             ; $03AC37 | |
    LDX <r_battle_select_charm_spell_tmp_index_2                                ; $03AC39 |/
    LDA r_current_spell_lists.1.flags.w,X                                       ; $03AC3B |\ Load the flags for this spell entry to a temporary variable.
    STA <r_battle_select_charm_spell_tmp_flags                                  ; $03AC3E |/
    BMI @start                                                                  ; $03AC40 | If this spell is disabled, loop back and pick a new one.
    LDA r_current_spell_lists.1.id.w,X                                          ; $03AC42 | Load the spell ID into the accumulator.
    LDX <r_current_slot_offset_character_battle                                 ; $03AC45 | Load the offset into the character's stat record into X.
    STA r_character_battle.1.subcommand.w,X                                     ; $03AC47 | Set the spell ID as the character's subcommand.
    LDA #BATTLE_ACTION_FLAG_MAGIC.b                                             ; $03AC4A |\ Specify that the action is magic.
    STA r_character_battle.1.action_flags.w,X                                   ; $03AC4C |/
    LDA #BATTLE_COMMAND_WHITE.b                                                 ; $03AC4F |\ Set the command as white magic. (Magic is actually generic, so this
    STA r_character_battle.1.command.w,X                                        ; $03AC51 |/ will work for any spell.)
    LDA <r_battle_select_charm_spell_tmp_flags                                  ; $03AC54 |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_MONSTER.b                                ; $03AC56 | | If this spell has monster targeting by default, branch ahead.
    BNE +++                                                                     ; $03AC58 |/
    LDA <r_battle_select_charm_spell_tmp_flags                                  ; $03AC5A |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_SINGLE.b                                 ; $03AC5C | | If the spell can't be single targeted, branch ahead.
    BEQ +                                                                       ; $03AC5E |/
-   JSR _get_battle_rng_0_7                                                     ; $03AC60 |\
    STA <r_battle_select_charm_spell_tmp_index_2_lo                             ; $03AC63 | | If the spell targets the party by default and can be single-
    CLC                                                                         ; $03AC65 | | targeted, choose a random monster slot, make sure it's not empty,
    ADC #5.b                                                                    ; $03AC66 | | and set the proper targeting bit in the accumulator.
    TAX                                                                         ; $03AC68 | |
    LDA r_battle_slot_empty.w,X                                                 ; $03AC69 | |
    BNE -                                                                       ; $03AC6C | |
    LDA <r_battle_select_charm_spell_tmp_index_2_lo                             ; $03AC6E | |
    TAX                                                                         ; $03AC70 | |
    TDC                                                                         ; $03AC71 | |
    JSR _set_bit_x                                                              ; $03AC72 | |
    BRA ++                                                                      ; $03AC75 |/
+   LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03AC77 | If the spell can't be single targeted, set all target bits.
++  LDX <r_current_slot_offset_character_battle                                 ; $03AC79 |\
    STA r_character_battle.1.targets.monster.w,X                                ; $03AC7B | | Either way, set the character's monster target value.
    RTS                                                                         ; $03AC7E |/
+++ LDA <r_battle_select_charm_spell_tmp_flags                                  ; $03AC7F |\
    AND #BATTLE_COMMAND_FLAG_TARGETING_SINGLE.b                                 ; $03AC81 | | If the spell targets monsters by default and supports single
    BEQ +                                                                       ; $03AC83 | | targeting, select a random character slot and make sure it's not
-   JSR _get_battle_rng_0_4                                                     ; $03AC85 | | empty. Convert it to a targeting mask and keep it in the
    TAX                                                                         ; $03AC88 | | accumulator.
    LDA r_battle_slot_empty.w,X                                                 ; $03AC89 | |
    BNE -                                                                       ; $03AC8C | |
    TDC                                                                         ; $03AC8E | |
    JSR _set_bit_x                                                              ; $03AC8F | |
    BRA ++                                                                      ; $03AC92 |/
+   LDA #BATTLE_TARGET_PARTY_ALL.b                                              ; $03AC94 | Otherwise, load the targeting for the whole party.
++  LDX <r_current_slot_offset_character_battle                                 ; $03AC96 |\ Set the character's party targeting value.
    STA r_character_battle.1.targets.party.w,X                                  ; $03AC98 |/
@done:
    RTS                                                                         ; $03AC9B

; _battle_select_berserk_target ($03:AC9C)
;
; Given a slot offset in $A6 (produced by _calculate_offsets), this function
; determines if the character in question is charmed, and sets a random target
; accordingly. The character is assumed to be berserked. If charmed, a random
; character target is selected. Otherwise, a random monster target is selected.
;
; Note that this function suffers from a rather serious (if uncommon) bug. If
; the character in question is both berserked and charmed, and if there is a
; character in the middle slot who has any of the swoon, stone, magnetized,
; jumping or hiding statuses, the game will fall into an infinite loop. When
; testing the random target for these statusues, the multiplication is done
; incorrectly, which means it always tests slot 0 instead (or some other random
; area if the preexisting value of $E1 is not zero--however, it does appear to
; be zero at this time in the actual game). The fix is simple: replace the
; reference to $AB with $E1.
_battle_select_berserk_target:
    LDX <r_current_slot_offset_character_battle                                 ; $03AC9C | Set the X register to the offset to the character's battle record.
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $03AC9E |\ Set the character's action type to command.
    STA r_character_battle.1.action_flags.w,X                                   ; $03ACA0 |/
    STZ r_character_battle.1.command.w,X                                        ; $03ACA3 | Set the character's command to fight.
    STZ r_character_battle.1.targets.party.w,X                                  ; $03ACA6 |\ Initially set no targets.
    STZ r_character_battle.1.targets.monster.w,X                                ; $03ACA9 |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03ACAC |\
    AND #STATUS_2_CHARM.b                                                       ; $03ACAF | | If the character is not charmed, branch accordingly.
    BEQ @not_charmed                                                            ; $03ACB1 |/
-   LDX #0.w                                                                    ; $03ACB3 |\
    LDA #4.b                                                                    ; $03ACB6 | | Get a random character slot number and save it to memory.
    JSR _get_battle_rng                                                         ; $03ACB8 | |
    STA <r_battle_generic_tmp_slot                                              ; $03ACBB |/
    STA <r_math_multiply_8bit_arg_1                                             ; $03ACBD | Save the slot number as an argument for future multiplication.
    TAX                                                                         ; $03ACBF |\
    LDA r_battle_slot_empty.w,X                                                 ; $03ACC0 | | Loop until a non-empty slot is selected.
    BNE -                                                                       ; $03ACC3 |/
    LDA #_sizeof_character_battle.b                                             ; $03ACC5 |\ BUG: This probably was meant to write $E1 (not $AB), as the second
    STA $AB.b                                                                   ; $03ACC7 | |     multiply parameter. Instead, the result always refers to the
    JSR _math_multiply_8bit                                                     ; $03ACC9 | |     first slot, meaning the game will softlock if the character
    LDX <r_math_multiply_8bit_result                                            ; $03ACCC |/      in slot 0 has any of the undesired statuses checked below.
    LDA r_character_battle.1.status_1.w,X                                       ; $03ACCE |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03ACD1 | | Skip this slot if the character in slot 0 is stoned or swooned.
    BNE -                                                                       ; $03ACD3 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03ACD5 |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03ACD8 | | Skip this slot if the character is magnetized or jumping.
    BNE -                                                                       ; $03ACDA |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03ACDC |\ Skip this slot if the character in slot 0 is hiding.
    BMI -                                                                       ; $03ACDF |/
    LDA <r_battle_generic_tmp_slot                                              ; $03ACE1 |\ Transfer the slot number to the X register.
    TAX                                                                         ; $03ACE3 |/
    TDC                                                                         ; $03ACE4 |\ Convert the slot number into a bit to use as a target.
    JSR _set_bit_x                                                              ; $03ACE5 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03ACE8 |\ Save the target into the character's party target data.
    STA r_character_battle.1.targets.party.w,X                                  ; $03ACEA |/
    RTS                                                                         ; $03ACED
@not_charmed:
    JSR _get_battle_rng_0_7                                                     ; $03ACEE | Get a random monster slot number from 0 to 7.
    STA <r_battle_generic_tmp_slot                                              ; $03ACF1 | Save the slot number to a temporary variable.
    CLC                                                                         ; $03ACF3 |\ Add five to the slot to get the true slot number.
    ADC #5.b                                                                    ; $03ACF4 |/
    TAX                                                                         ; $03ACF6 | Transfer the slot to the X register.
    LDA r_battle_slot_empty.w,X                                                 ; $03ACF7 |\ Loop until a non-empty slot is found.
    BNE @not_charmed                                                            ; $03ACFA |/
    LDA <r_battle_generic_tmp_slot                                              ; $03ACFC |\
    TAX                                                                         ; $03ACFE | | Convert the slot number into a targeting mask.
    TDC                                                                         ; $03ACFF | |
    JSR _set_bit_x                                                              ; $03AD00 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AD03 |\ Set the character's monster target byte.
    STA r_character_battle.1.targets.monster.w,X                                ; $03AD05 |/
    RTS                                                                         ; $03AD08

; _battle_queue_auto_(hide/show) ($03:AD09)
;
; This pair of functions is used to queue Edward's auto-hide or auto-show
; actions. The timer value is explicitly set to 1.
_battle_queue_auto_hide:
    LDX <r_current_slot_offset_character_battle                                 ; $03AD09 | Set the X register to the offset to the character's stat record.
    LDA #BATTLE_COMMAND_HIDE.b                                                  ; $03AD0B |\ Set the character's command to hide.
    STA r_character_battle.1.command.w,X                                        ; $03AD0D |/
    BRA _battle_queue_auto_hide_show_finalize                                   ; $03AD10 | Branch to the main part of the function.
_battle_queue_auto_show:
    LDX <r_current_slot_offset_character_battle                                 ; $03AD12 | Set the X register to the offset to the character's stat record.
    LDA #BATTLE_COMMAND_SHOW.b                                                  ; $03AD14 |\ Set the character's command to show.
    STA r_character_battle.1.command.w,X                                        ; $03AD16 |/
_battle_queue_auto_hide_show_finalize:
    LDA #BATTLE_ACTION_FLAG_COMMAND.b                                           ; $03AD19 |\ Set the action type to command.
    STA r_character_battle.1.action_flags.w,X                                   ; $03AD1B |/
    STZ r_character_battle.1.targets.monster.w,X                                ; $03AD1E | Set the monster target to zero.
    LDA <r_battle_queue_auto_actions_slot                                       ; $03AD21 |\
    TAX                                                                         ; $03AD23 | | Set the targeting value to target the current character.
    TDC                                                                         ; $03AD24 | |
    JSR _set_bit_x                                                              ; $03AD25 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AD28 |\ Write the target to the character's record.
    STA r_character_battle.1.targets.party.w,X                                  ; $03AD2A |/
    LDX #1.w                                                                    ; $03AD2D |\ Set the value for the timer to 1, to allow it to execute as quickly
    STX <r_set_timer_value_arg                                                  ; $03AD30 |/ as possible.
    RTS                                                                         ; $03AD32

; _battle_count_living_characters ($03:AD33)
;
; Counts the number of characters in the battle party who are both currently
; alive and not stone. The 8-bit result is returned in $38DB and in the
; accumulator.
_battle_count_living_characters:
    PHX                                                                         ; $03AD33 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $03AD34 |/
    TDC                                                                         ; $03AD35 |\
    TAX                                                                         ; $03AD36 | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03AD37 |/
    STX <r_battle_count_living_characters_tmp                                   ; $03AD38 | Initialize the count to zero.
-   LDA r_battle_slot_empty.w,Y                                                 ; $03AD3A |\
    BNE +                                                                       ; $03AD3D | | If the current slot has a character in it and that character is
    LDA r_character_battle.1.status_1.w,X                                       ; $03AD3F | | not afflicted with either the swoon or stone statuses, increment
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03AD42 | | the counter.
    BNE +                                                                       ; $03AD44 | |
    INC <r_battle_count_living_characters_tmp_lo                                ; $03AD46 |/
+   JSR _increment_x_by_128                                                     ; $03AD48 |\
    INY                                                                         ; $03AD4B | | Increment the indexes and loop until all five slots are checked.
    CPY #5.w                                                                    ; $03AD4C | |
    BNE -                                                                       ; $03AD4F |/
    PLY                                                                         ; $03AD51 |\ Restore the X and Y registers.
    PLX                                                                         ; $03AD52 |/
    LDA <r_battle_count_living_characters_tmp_lo                                ; $03AD53 |\ Transfer the count into the result variable.
    STA r_battle_count_living_characters_result.w                               ; $03AD55 |/
    RTS                                                                         ; $03AD58

; battle_timer_expire_offset_data ($03:AD59)
;
; Offsets to the routines that handle expiration of timers.
battle_timer_expire_offset_data:
    .addr _battle_timer_expire_stop                                             ; $03AD59.AD5A
    .addr _battle_timer_expire_action                                           ; $03AD5B.AD5C
    .addr _battle_timer_expire_sap                                              ; $03AD5D.AD5E
    .addr _battle_timer_expire_poison                                           ; $03AD5F.AD60
    .addr _battle_timer_expire_stone                                            ; $03AD61.AD62
    .addr _battle_timer_expire_wall                                             ; $03AD63.AD64
    .addr _battle_timer_expire_count                                            ; $03AD65.AD66

; _battle_command_execute ($03:AD67)
;
; Handles the execution of an actor's next command.
_battle_command_execute:
    LDA #BATTLE_UPDATE_MODE_MONSTER_BACK_ROW.b                                  ; $03AD67 |\ Update which monsters are in the back row.
    JSR _battle_update                                                          ; $03AD69 |/
    LDX #_sizeof_character_battle.w * 5                                         ; $03AD6C | Initialize the X register to the first monster slot's offset.
    TDC                                                                         ; $03AD6F |\ Initialize the Y register to zero.
    TAY                                                                         ; $03AD70 |/
-   LDA r_character_battle.1.sprite_class.w,X                                   ; $03AD71 |\
    AND #SPRITE_CLASS_BACK_ROW.b ~ $FF                                          ; $03AD74 | | Update the back row status of each monster based on the results of
    ORA r_battle_monsters_back_row.w,Y                                          ; $03AD76 | | the back row update.
    STA r_character_battle.1.sprite_class.w,X                                   ; $03AD79 | |
    JSR _increment_x_by_128                                                     ; $03AD7C | |
    INY                                                                         ; $03AD7F | |
    CPY #8.w                                                                    ; $03AD80 | |
    BNE -                                                                       ; $03AD83 |/
    STZ r_battle_action_skip_action_timer_update.w                              ; $03AD85 | Zero out the flag that prevents the action timer update.
_battle_command_execute_counter:
    STZ r_battle_action_can_hit_swoon.w                                         ; $03AD88 | By default, an action cannot hit a swoon target.
    STZ r_battle_apply_pending_damage_result_deaths.w                           ; $03AD8B | Initialize the pending damage death count to zero.
    STZ r_battle_mask_damage_miss.w                                             ; $03AD8E | By default, don't mask out the miss in pending damage.
    STZ r_unknown_355c.w                                                        ; $03AD91 |/
    STZ r_battle_skip_character_battle_actor.w                                  ; $03AD94 | Don't skip the actor's stat record by default.
    STZ r_battle_current_action_uses_mp.w                                       ; $03AD97 | Actions don't generally require MP.
    STZ r_battle_current_spell_item.w                                           ; $03AD9A | Initialize the spell as item flag to zero.
    STZ r_battle_double_spell_power.w                                           ; $03AD9D | Initialize the double spell power flag to zero.
    STZ r_battle_effect_spell_animate_reeling.w                                 ; $03ADA0 | Initialize the reeling animation flag to zero.
    STZ r_battle_current_spell_weapon.w                                         ; $03ADA3 |\ Initially, the current spell is not either a weapon or a Grimoire.
    STZ r_battle_current_spell_grimoire.w                                       ; $03ADA6 |/
    LDA #4.b                                                                    ; $03ADA9 |\
    STA r_unknown_2c78.w                                                        ; $03ADAB | | TODO: Initialize two values to 4.
    STZ r_unknown_2c79.w                                                        ; $03ADAE |/
    LDA <r_battle_timer_slot                                                    ; $03ADB1 |\ Calculate the offsets for the acting slot.
    JSR _calculate_offsets                                                      ; $03ADB3 |/
    JSR _battle_initialize_action_audiovisual                                   ; $03ADB6 | Initializes audiovisual variables for the current action.
    LDA <r_battle_timer_slot                                                    ; $03ADB9 |\
    CMP #5.b                                                                    ; $03ADBB | | If this is a character slot, branch to other code.
    BCC +                                                                       ; $03ADBD |/
    SEC                                                                         ; $03ADBF |\
    LDA <r_battle_timer_slot                                                    ; $03ADC0 | | Subtract 5 from the slot number to determine the monster slot and
    SBC #5.b                                                                    ; $03ADC2 | | then multiply by the size of the action set to determine the
    STA <r_math_multiply_8bit_arg_1                                             ; $03ADC4 | | offset into that data. Set the Y register to zero.
    LDA #_sizeof_action_set.b                                                   ; $03ADC6 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03ADC8 | |
    JSR _math_multiply_8bit                                                     ; $03ADCA | |
    TDC                                                                         ; $03ADCD | |
    TAY                                                                         ; $03ADCE | |
    LDX <r_math_multiply_8bit_result                                            ; $03ADCF |/
-   LDA r_monster_script_current_modified_action_sets.w,X                       ; $03ADD1 |\
    STA r_battle_script_audiovisual.w,Y                                         ; $03ADD4 | | Copy the monster's modified action set to the audiovisual script.
    INX                                                                         ; $03ADD7 | |
    INY                                                                         ; $03ADD8 | |
    CPY #_sizeof_action_set.w                                                   ; $03ADD9 | |
    BNE -                                                                       ; $03ADDC |/
    LDA <r_battle_timer_slot                                                    ; $03ADDE |\
    SEC                                                                         ; $03ADE0 | | Set the accumulator to the monster slot value and set the high bit
    SBC #5.b                                                                    ; $03ADE1 | | to indicate it's a monster slot.
    ORA #%10000000.b                                                            ; $03ADE3 |/
+   STA <r_battle_command_actor_slot                                            ; $03ADE5 | Save the computed slot number to a temporary variable.
    PHA                                                                         ; $03ADE7 |\ Push it to the stack twice.
    PHA                                                                         ; $03ADE8 |/
    AND #%01111111.b                                                            ; $03ADE9 |\
    STA r_battle_current_action_details.actor.w                                 ; $03ADEB | | Split the slot value up into the flags and slot values needed in
    PLA                                                                         ; $03ADEE | | the action details structure.
    AND #%10000000.b                                                            ; $03ADEF | |
    STA r_battle_current_action_details.actor_flags.w                           ; $03ADF1 |/
    PLA                                                                         ; $03ADF4 |\ Calculate the offset to the slot's battle record and put it in $80.
    JSR _battle_calculate_modified_slot_offset                                  ; $03ADF5 |/
    LDY #_sizeof_character_battle.w - 1                                         ; $03ADF8 |\
-   LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03ADFB | | Copy the slot's stat record into the record for the current actor.
    STA r_character_battle_current_actor.w,Y                                    ; $03ADFD | |
    DEY                                                                         ; $03AE00 | |
    BPL -                                                                       ; $03AE01 |/
    TDC                                                                         ; $03AE03 |\ Initialize the X register to zero.
    TAX                                                                         ; $03AE04 |/
-   LDA r_battle_slot_empty.w,X                                                 ; $03AE05 |\
    STA r_battle_slot_empty_copy.w,X                                            ; $03AE08 | | TODO: Copy the battle slot empty array to another location.
    INX                                                                         ; $03AE0B | |
    CPX #(5 + 8).w                                                              ; $03AE0C | |
    BNE -                                                                       ; $03AE0F |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AE11 |\
    LDA r_character_battle.1.targets.monster.w,X                                ; $03AE13 | | Save the target value to a temporary variable.
    ORA r_character_battle.1.targets.party.w,X                                  ; $03AE16 | |
    STA <r_battle_process_action_tmp_target                                     ; $03AE19 |/
    BNE @target_check_start                                                     ; $03AE1B | If targets are set, branch ahead.
    LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03AE1D |\ Replace the slot's command with the Wait command.
    STA r_character_battle.1.command.w,X                                        ; $03AE1F |/
    LDA <r_battle_command_actor_slot                                            ; $03AE22 |\ Copy the actor slot into the target slot.
    STA <r_battle_command_target_slot                                           ; $03AE24 |/
    BPL +++                                                                     ; $03AE26 | If the actor is a character branch forward.
    JSR _battle_script_end_chain                                                ; $03AE28 | Check for a current chain, and end the chain if so.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03AE2B |\ If a chain was found, branch ahead.
    BNE +                                                                       ; $03AE2D |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AE2F |\
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03AE31 | | If a chain end command was not found in the script, set the
    STA r_character_battle.1.command.w,X                                        ; $03AE33 | | monster's command to wait, and set the audiovisual script to Wait.
    STA r_battle_script_audiovisual.w + 0                                       ; $03AE36 | |
    LDA #MONSTER_COMMAND_END.b                                                  ; $03AE39 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03AE3B |/
+   LDA <r_battle_command_actor_slot                                            ; $03AE3E |\ Load the actor slot and branch ahead.
    BRA +++                                                                     ; $03AE40 |/
@target_check_start:
    LDX #0.w                                                                    ; $03AE42 | Initialize the X register to zero.
-   ASL A                                                                       ; $03AE45 |\
    BCS +                                                                       ; $03AE46 | | Shift bits out of the target variable. Branch ahead when finding
    INX                                                                         ; $03AE48 | | one.
    BNE -                                                                       ; $03AE49 |/
+   TXA                                                                         ; $03AE4B |\ Set the target slot to the current target.
    STA <r_battle_command_target_slot                                           ; $03AE4C |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AE4E |\
    LDA r_character_battle.1.targets.monster.w,X                                ; $03AE50 | | If no monster targets are set, branch ahead.
    BEQ +                                                                       ; $03AE53 |/
    LDA #BATTLE_ACTION_DETAILS_TARGET_FLAG_MONSTER.b                            ; $03AE55 |\ Set the monster target flag.
    STA r_battle_current_action_details.target_flags.w                          ; $03AE57 |/
    LDA r_character_battle.1.targets.monster.w,X                                ; $03AE5A |\ Update the action details target value.
    JSR _battle_action_details_set_target                                       ; $03AE5D |/
    LDA <r_battle_command_target_slot                                           ; $03AE60 |\
    ORA #%10000000.b                                                            ; $03AE62 | | Set the monster flag on the target slot.
    STA <r_battle_command_target_slot                                           ; $03AE64 |/
    BRA +++                                                                     ; $03AE66 | Branch ahead to the next step.
+   STZ r_battle_current_action_details.target_flags.w                          ; $03AE68 | Unset any target flags.
    LDA r_character_battle.1.targets.party.w,X                                  ; $03AE6B |\ Set the target value and potentially set the all target flag.
    JSR _battle_action_details_set_target                                       ; $03AE6E |/
    LDA <r_battle_command_target_slot                                           ; $03AE71 | Load the target value into the accumulator.
+++ JSR _battle_calculate_modified_slot_offset                                  ; $03AE73 | Calculate the offset for the target slot.
    LDY #_sizeof_character_battle.w - 1                                         ; $03AE76 |\
-   LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03AE79 | | Copy the stat record for the target into the temporary target stat
    STA r_character_battle_current_target.w,Y                                   ; $03AE7B | | record.
    DEY                                                                         ; $03AE7E | |
    BPL -                                                                       ; $03AE7F |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03AE81 |\
    CMP #SPELL_MONSTER_LIFE_ALL.b                                               ; $03AE84 | | If the spell was the monster spell that revives the party, set the
    BNE +                                                                       ; $03AE86 | | "can hit swoon" flag and branch ahead to check for Cover.
    INC r_battle_action_can_hit_swoon.w                                         ; $03AE88 | | NOTE: This actually also triggers if using a Hermes item. This can
    JMP @check_cover                                                            ; $03AE8B |/        lead to strange behavior with Bersk.
+   LDA <r_battle_process_action_tmp_target                                     ; $03AE8E |\
    JSR _count_set_bits                                                         ; $03AE90 | | If the action has more than one target, branch ahead to process
    DEX                                                                         ; $03AE93 | | the action.
    BEQ +                                                                       ; $03AE94 | |
    JMP @process                                                                ; $03AE96 |/
+   LDA <r_battle_command_actor_slot                                            ; $03AE99 |\ If the actor is a monster, skip the next block.
    BMI +                                                                       ; $03AE9B |/
    LDA r_character_battle_current_actor.command.w                              ; $03AE9D |\ Transfer the command to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03AEA0 |/
    LDA <r_battle_command_target_slot                                           ; $03AEA2 |\
    BMI ++                                                                      ; $03AEA4 | | If the target is a character, load the command value, and if it's
    LDA <r_battle_generic_tmp_1_lo                                              ; $03AEA6 | | non-zero branch way ahead.
    BNE @can_hit_swoon                                                          ; $03AEA8 |/  BUG: This ends up setting the can hit swoon flag for Heal.
    BRA ++                                                                      ; $03AEAA | Otherwise, skip this short monster block.
+   SEC                                                                         ; $03AEAC |\
    LDA r_character_battle_current_actor.command.w                              ; $03AEAD | | If the actor is a monster, subtract the base command from the
    SBC #MONSTER_COMMAND_FIGHT.b                                                ; $03AEB0 | | command and save it to the variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03AEB2 |/
++  LDA r_character_battle_current_target.status_1.w                            ; $03AEB4 |\
    AND #STATUS_1_SWOON.b                                                       ; $03AEB7 | | If the target is not swooned, branch ahead to check for stone.
    BEQ @check_stone                                                            ; $03AEB9 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03AEBB |\ If the command is Fight, branch to replace the target.
    BEQ @replace_target                                                         ; $03AEBD |/
    CMP #BATTLE_COMMAND_BLACK.b                                                 ; $03AEBF |\ If the command is anything else other than White or Item, replace
    BCS @replace_target                                                         ; $03AEC1 |/ the target.
    CMP #BATTLE_COMMAND_WHITE.b                                                 ; $03AEC3 |\ If the command is Item, branch to the item check.
    BNE @swooned_item                                                           ; $03AEC5 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03AEC7 |\
    CMP #SPELL_LIFE1.b                                                          ; $03AECA | | If the command is White and the spell is any of Life1, Life2,
    BEQ @can_hit_swoon                                                          ; $03AECC | | the monster Recover, monster Remedy, or monster Vanish spells,
    CMP #SPELL_LIFE2.b                                                          ; $03AECE | | branch to the code to handle hitting swoon targets.
    BEQ @can_hit_swoon                                                          ; $03AED0 | |
    CMP #SPELL_MONSTER_RECOVER.b                                                ; $03AED2 | |
    BEQ @can_hit_swoon                                                          ; $03AED4 | |
    CMP #SPELL_MONSTER_REMEDY.b                                                 ; $03AED6 | |
    BEQ @can_hit_swoon                                                          ; $03AED8 | |
    CMP #SPELL_MONSTER_VANISH.b                                                 ; $03AEDA | |
    BEQ @can_hit_swoon                                                          ; $03AEDC |/
    BRA @replace_target                                                         ; $03AEDE | Otherwise, replace the target.
@swooned_item:
    LDA r_character_battle_current_actor.subcommand.w                           ; $03AEE0 |\
    CMP #ITEM_LIFE.b                                                            ; $03AEE3 | | Replace the target if using an item other than Life against a
    BNE @replace_target                                                         ; $03AEE5 |/  swoon target.
@can_hit_swoon:
    INC r_battle_action_can_hit_swoon.w                                         ; $03AEE7 | Set the flag that says it's okay to hit a swoon target.
    JMP @check_cover                                                            ; $03AEEA | Jump to check for Cover.
@check_stone:
    LDA r_character_battle_current_target.status_1.w                            ; $03AEED |\
    AND #STATUS_1_STONE.b                                                       ; $03AEF0 | | If the target is not stoned, skip this next block.
    BEQ ++                                                                      ; $03AEF2 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03AEF4 |\ If trying to Fight a stone target, replace the target.
    BEQ @replace_target                                                         ; $03AEF6 |/
    CMP #BATTLE_COMMAND_BLACK.b                                                 ; $03AEF8 |\ If using a command other than White or Item, replace the target.
    BCS @replace_target                                                         ; $03AEFA |/
    CMP #BATTLE_COMMAND_WHITE.b                                                 ; $03AEFC |\
    BNE +                                                                       ; $03AEFE | | If using the White command, check for the Heal spell. If using,
    LDA r_character_battle_current_actor.subcommand.w                           ; $03AF00 | | branch to check Cover. Otherwise, replace the target.
    CMP #SPELL_HEAL.b                                                           ; $03AF03 | |
    BEQ @check_cover                                                            ; $03AF05 | |
    BRA @replace_target                                                         ; $03AF07 |/
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03AF09 |\
    CMP #ITEM_GOLD_NEEDLE.b                                                     ; $03AF0C | | If using the Item command, check for the Heal item or the Gold
    BEQ @check_cover                                                            ; $03AF0E | | Needle item. If using either of those, branch to check Cover.
    CMP #ITEM_HEAL.b                                                            ; $03AF10 | | Otherwise, replace the target.
    BEQ @check_cover                                                            ; $03AF12 | |
    BRA @replace_target                                                         ; $03AF14 |/
++  LDA r_character_battle_current_target.status_3.w                            ; $03AF16 |\
    AND #STATUS_3_JUMPING.b                                                     ; $03AF19 | | If the target is jumping, replace the target.
    BNE @replace_target                                                         ; $03AF1B |/
    LDA r_character_battle_current_target.status_4.w                            ; $03AF1D |\ If the target is hiding, replace the target. Otherwise, jump to
    BPL @check_cover                                                            ; $03AF20 |/ check Cover.
@replace_target:
    LDA <r_battle_command_target_slot                                           ; $03AF22 |\
    BPL +                                                                       ; $03AF24 | | If the target is a monster, check for non-empty monster slots. If
    LDX #5.w                                                                    ; $03AF26 | | one is found, branch ahead.
-   LDA r_battle_slot_empty_copy.w,X                                            ; $03AF29 | |
    BEQ @non_empty                                                              ; $03AF2C | |
    INX                                                                         ; $03AF2E | |
    CPX #(5 + 8).w                                                              ; $03AF2F | |
    BNE -                                                                       ; $03AF32 | |
    BRA ++                                                                      ; $03AF34 |/
+   TDC                                                                         ; $03AF36 |\
    TAX                                                                         ; $03AF37 | | If the target is a character, check for non-empty character slots.
-   LDA r_battle_slot_empty_copy.w,X                                            ; $03AF38 | | If one is found, branch to the non-empty code.
    BEQ @non_empty                                                              ; $03AF3B | |
    INX                                                                         ; $03AF3D | |
    CPX #5.w                                                                    ; $03AF3E | |
    BNE -                                                                       ; $03AF41 |/
++  LDX <r_current_slot_offset_character_battle                                 ; $03AF43 |\
    CPX #_sizeof_character_battle.w * 5                                         ; $03AF45 | | If the actor is a character, branch ahead slightly.
    BCC ++                                                                      ; $03AF48 |/
    JSR _battle_script_end_chain                                                ; $03AF4A | End any currently active chain.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03AF4D |\
    BEQ +                                                                       ; $03AF4F | | If a chain was ended, set the monster's command to Wait and
    LDX <r_current_slot_offset_character_battle                                 ; $03AF51 | | branch ahead to processing.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03AF53 | |
    STA r_character_battle.1.command.w,X                                        ; $03AF55 | |
    BRA @check_cover                                                            ; $03AF58 |/
+   LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03AF5A |\ Otherwise, load the Wait command into the accumulator.
    BRA +                                                                       ; $03AF5C |/
++  LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03AF5E | For character actors, load the Wait battle command instead.
+   LDX <r_current_slot_offset_character_battle                                 ; $03AF60 |\
    STA r_character_battle.1.command.w,X                                        ; $03AF62 | | If a character actor or a monster with no chain, store the command
    STA r_battle_script_audiovisual.w + 0                                       ; $03AF65 | | and set the next command to end the audiovisual script.
    LDA #MONSTER_COMMAND_END.b                                                  ; $03AF68 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03AF6A |/
    BRA @check_cover                                                            ; $03AF6D
@non_empty:
    JSR _battle_select_fallback_target                                          ; $03AF6F | Select a new random target.
    PHA                                                                         ; $03AF72 |\
    LDA <r_battle_select_fallback_target_result_slot                            ; $03AF73 | | Flag that target slot as empty in the copied array, so we'll know
    TAX                                                                         ; $03AF75 | | that it has been checked.
    LDA #1.b                                                                    ; $03AF76 | |
    STA r_battle_slot_empty_copy.w,X                                            ; $03AF78 | |
    PLA                                                                         ; $03AF7B |/
    JMP @target_check_start                                                     ; $03AF7C | Jump to check the newly selected target.
@check_cover:
    LDA <r_battle_command_target_slot                                           ; $03AF7F |\ Skip to processing if this is a monster target.
    BMI @process                                                                ; $03AF81 |/
    LDA r_character_battle_current_target.status_4.w                            ; $03AF83 |\
    AND #STATUS_4_COVERED.b                                                     ; $03AF86 | | If the target is neither covered nor in HP critical, skip to
    BNE +                                                                       ; $03AF88 | | processing. They aren't covered.
    LDA r_character_battle_current_target.status_4.w                            ; $03AF8A | |
    AND #STATUS_4_CRITICAL.b                                                    ; $03AF8D | |
    BEQ @process                                                                ; $03AF8F |/
+   LDA r_character_battle_current_actor.command.w                              ; $03AF91 |\
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03AF94 | | Skip to processing if the command isn't the monster Fight command.
    BNE @process                                                                ; $03AF96 |/
    LDA r_cecil_paladin_slot.w                                                  ; $03AF98 |\ If no Paladin is present, skip to processing.
    BMI @process                                                                ; $03AF9B |/
    LDA <r_battle_command_actor_slot                                            ; $03AF9D |\
    CMP <r_battle_command_target_slot                                           ; $03AF9F | | If the actor is the same as the target, skip to processing.
    BEQ @process                                                                ; $03AFA1 |/
    CMP r_cecil_paladin_slot.w                                                  ; $03AFA3 |\ If the actor is the Paladin, skip to processing.
    BEQ @process                                                                ; $03AFA6 |/
    LDA r_cecil_paladin_slot.w                                                  ; $03AFA8 |\
    CMP <r_battle_command_target_slot                                           ; $03AFAB | | If the Paladin is the target, skip to processing.
    BEQ @process                                                                ; $03AFAD |/
    LDA r_cecil_paladin_slot.w                                                  ; $03AFAF |\ Calculate the offsets for the paladin slot.
    JSR _calculate_offsets                                                      ; $03AFB2 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03AFB5 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03AFB7 | | If the Paladin is swoon or stone, skip processing the Cover.
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03AFBA | |
    BNE +                                                                       ; $03AFBC |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03AFBE |\
    AND #%00111100.b                                                            ; $03AFC1 | | Same with paralyze, sleep, charm and berserk.
    BNE +                                                                       ; $03AFC3 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03AFC5 |\
    AND #(STATUS_3_STOP | STATUS_3_DEFENDING).b                                 ; $03AFC8 | | Skip the Cover if the Paladin has stop or is defending.
    BNE +                                                                       ; $03AFCA |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03AFCC |\
    AND #STATUS_4_CRITICAL.b                                                    ; $03AFCF | | Skip the Cover if the Paladin is HP critical.
    BNE +                                                                       ; $03AFD1 |/
    LDA r_battle_current_action_details.target.w                                ; $03AFD3 |\ Save the original target as the covered target for animation
    STA r_battle_current_action_details.covered_target.w                        ; $03AFD6 |/ purposes.
    LDX r_cecil_paladin_slot.w                                                  ; $03AFD9 |\
    TXA                                                                         ; $03AFDC | | Set the target slot to the Paladin slot.
    STA <r_battle_command_target_slot                                           ; $03AFDD |/
    TDC                                                                         ; $03AFDF |\
    JSR _set_bit_x                                                              ; $03AFE0 | | Set the action target.
    STA r_battle_current_action_details.target.w                                ; $03AFE3 |/
    LDA <r_battle_command_target_slot                                           ; $03AFE6 |\
    JSR _battle_calculate_modified_slot_offset                                  ; $03AFE8 | | Transfer the Paladin stat record to the target record.
    LDY #_sizeof_character_battle.w - 1                                         ; $03AFEB | |
-   LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03AFEE | |
    STA r_character_battle_current_target.w,Y                                   ; $03AFF0 | |
    DEY                                                                         ; $03AFF3 | |
    BPL -                                                                       ; $03AFF4 |/
+   LDA <r_battle_timer_slot                                                    ; $03AFF6 |\ Calculate the offsets for the acting slot.
    JSR _calculate_offsets                                                      ; $03AFF8 |/
@process:
    LDA <r_battle_command_actor_slot                                            ; $03AFFB |\
    BPL +                                                                       ; $03AFFD | | Calculate the true slot of the actor.
    AND #%01111111.b                                                            ; $03AFFF | |
    CLC                                                                         ; $03B001 | |
    ADC #5.b                                                                    ; $03B002 |/
+   TAX                                                                         ; $03B004 |\ Reset the auto-action queued flag for this slot.
    STZ r_battle_slot_auto_action_queued.w,X                                    ; $03B005 |/
    LDA <r_battle_timer_slot                                                    ; $03B008 |\ Calculate offsets for the acting slot.
    JSR _calculate_offsets                                                      ; $03B00A |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B00D |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03B00F | | If the actor is not swoon, stone, paralyze, or sleep, branch
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B012 | | ahead to the dispatch.
    BNE +                                                                       ; $03B014 | |
    LDA r_character_battle.1.status_2.w,X                                       ; $03B016 | |
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03B019 | |
    BEQ +++                                                                     ; $03B01B |/
+   LDA <r_battle_timer_slot                                                    ; $03B01D |\
    CMP #5.b                                                                    ; $03B01F | | Otherwise, change the actor's command to Wait.
    BCC +                                                                       ; $03B021 | |
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03B023 | |
    BRA ++                                                                      ; $03B025 | |
+   LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03B027 | |
++  STA r_character_battle.1.command.w,X                                        ; $03B029 |/
+++ JSR _battle_command_dispatch                                                ; $03B02C | Dispatch to the command handler.
    TDC                                                                         ; $03B02F |\
    LDA r_battle_counter_active.w                                               ; $03B030 | | Skip the next block if a counter is active.
    BNE ++                                                                      ; $03B033 |/
    LDA r_battle_command_actor_slot.w                                           ; $03B035 |\ Skip this next block if the actor is a character.
    BPL ++                                                                      ; $03B038 |/
    TDC                                                                         ; $03B03A |\
    TAX                                                                         ; $03B03B | | Scan through the audiovisual script for a chain end command. If
-   LDA r_battle_script_audiovisual.w,X                                         ; $03B03C | | finding the end of the script first, branch ahead.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B03F | |
    BEQ ++                                                                      ; $03B041 | |
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B043 | |
    BEQ +                                                                       ; $03B045 | |
    INX                                                                         ; $03B047 | |
    BRA -                                                                       ; $03B048 |/
+   LDA #$FF.b                                                                  ; $03B04A |\
    STA r_monster_script_chain_slot_lo.w                                        ; $03B04C | | If the chain is over, unset the chain slot variable.
    STA r_monster_script_chain_slot_hi.w                                        ; $03B04F |/
++  LDA r_battle_skip_victim_history_update.w                                   ; $03B052 |\
    BNE +                                                                       ; $03B055 | | If not disabled, update the victim history.
    JSR _battle_update_monster_victim_history                                   ; $03B057 |/
+   JSR _battle_apply_pending_status                                            ; $03B05A | Apply any pending status changes.
    STZ r_battle_skip_victim_history_update.w                                   ; $03B05D | Reset the victim history update flag.
    TDC                                                                         ; $03B060 |\
    TAX                                                                         ; $03B061 | | Copy the entire audiovisual script to the temporary area.
-   LDA r_battle_script_audiovisual.w,X                                         ; $03B062 | |
    STA r_battle_script_tmp_copy.w,X                                            ; $03B065 | | TODO: Why? This is the end of the function.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B068 | |
    BEQ +                                                                       ; $03B06A | |
    INX                                                                         ; $03B06C | |
    BRA -                                                                       ; $03B06D |/
+   LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03B06F |\ Animate any audiovisual effects.
    JSR _battle_update                                                          ; $03B071 |/
    LDA #BATTLE_UPDATE_MODE_CHARACTER_HP.b                                      ; $03B074 |\ Update the character HP dialog.
    JSR _battle_update                                                          ; $03B076 |/
    LDA #BATTLE_UPDATE_MODE_MONSTER_NAMES.b                                     ; $03B079 |\ Update monster name dialog.
    JSR _battle_update                                                          ; $03B07B |/
    LDA r_battle_action_skip_action_timer_update.w                              ; $03B07E |\ If the action timer update is to be skipped, branch to the end of
    BNE ++                                                                      ; $03B081 |/ the function.
    STZ <r_calculate_timer_value_arg_mode                                       ; $03B083 |\
    LDA <r_battle_command_actor_slot                                            ; $03B085 | | Otherwise, calculate a timer value for the acting slot using the
    BPL +                                                                       ; $03B087 | | relative speed method.
    AND #%01111111.b                                                            ; $03B089 | |
    CLC                                                                         ; $03B08B | |
    ADC #5.b                                                                    ; $03B08C | |
+   JSR _calculate_timer_value                                                  ; $03B08E |/
    LDX r_current_slot_offset_timer.w                                           ; $03B091 |\
    LDA r_battle_timers.1.action.flags.w,X                                      ; $03B094 | | Unset the command, expired and an unknown bit in the action timer
    AND #(TIMER_FLAG_UNKNOWN7 | TIMER_FLAG_COMMAND | TIMER_FLAG_EXPIRED) ~ $FF  ; $03B097 | | flags.
    STA r_battle_timers.1.action.flags.w,X                                      ; $03B099 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B09C |\
    LDA r_character_battle.1.status_2.w,X                                       ; $03B09E | | If the actor doesn't have the paralyze or sleep statuses, set the
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03B0A1 | | value to the action timer and unset any flags for the timer.
    BNE ++                                                                      ; $03B0A3 | |
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03B0A5 | |
    JSR _set_timer_value                                                        ; $03B0A7 | |
    STZ r_battle_timers.1.flags.w,X                                             ; $03B0AA |/
++  RTS                                                                         ; $03B0AD

; _battle_select_fallback_target ($03:B0AE)
;
; Given the currently active timer slot in $D2 and the active target slot in
; $CE, selects a fallback target and sets that value in the actor's target
; value. Note that if the target is a monster, it will never choose a back row
; monster.
_battle_select_fallback_target:
-   LDX #4.w                                                                    ; $03B0AE |\
    LDA <r_battle_command_target_slot                                           ; $03B0B1 | | Select a random number from 0 to either 4 if party targets or 7 if
    BPL +                                                                       ; $03B0B3 | | monster targets.
    LDX #7.w                                                                    ; $03B0B5 | |
+   TXA                                                                         ; $03B0B8 | |
    LDX #0.w                                                                    ; $03B0B9 | |
    JSR _get_battle_rng                                                         ; $03B0BC |/
    STA <r_battle_generic_tmp_1_hi                                              ; $03B0BF | Save the generated value to a temporary variable.
    STA <r_battle_select_fallback_target_result_slot                            ; $03B0C1 |\
    LDA <r_battle_command_target_slot                                           ; $03B0C3 | | Calculate the true slot number by adding five if it's a monster
    BPL +                                                                       ; $03B0C5 | | target.
    CLC                                                                         ; $03B0C7 | |
    LDA <r_battle_select_fallback_target_result_slot                            ; $03B0C8 | |
    ADC #5.b                                                                    ; $03B0CA | |
    STA <r_battle_select_fallback_target_result_slot                            ; $03B0CC | |
+   LDA <r_battle_select_fallback_target_result_slot                            ; $03B0CE |/
    TAX                                                                         ; $03B0D0 |\
    LDA r_battle_slot_empty.w,X                                                 ; $03B0D1 | | Loop back to try again if this slot is empty.
    BNE -                                                                       ; $03B0D4 |/
    LDA <r_battle_command_target_slot                                           ; $03B0D6 |\
    BPL +                                                                       ; $03B0D8 | | If the target is a monster, calculate the offset to its stat
    LDA <r_battle_select_fallback_target_result_slot                            ; $03B0DA | | record and then check to see if it's a back row monster. If so,
    STA <r_math_multiply_8bit_arg_1                                             ; $03B0DC | | loop back to try again.
    LDA #_sizeof_character_battle.b                                             ; $03B0DE | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03B0E0 | |
    JSR _math_multiply_8bit                                                     ; $03B0E2 | |
    LDX <r_math_multiply_8bit_result                                            ; $03B0E5 | |
    LDA r_character_battle.1.sprite_class.w,X                                   ; $03B0E7 | |
    BMI -                                                                       ; $03B0EA |/
+   LDA <r_battle_generic_tmp_1_hi                                              ; $03B0EC |\
    TAX                                                                         ; $03B0EE | | Convert the target slot to a standard target variable.
    TDC                                                                         ; $03B0EF | |
    JSR _set_bit_x                                                              ; $03B0F0 |/
    PHA                                                                         ; $03B0F3 | Preserve the calculated target value.
    LDA <r_battle_timer_slot                                                    ; $03B0F4 |\ Calculate offsets for the actor.
    JSR _calculate_offsets                                                      ; $03B0F6 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B0F9 | Set the X register to the offset to the actor's stats.
    LDA <r_battle_command_target_slot                                           ; $03B0FB |\
    BMI +                                                                       ; $03B0FD | | If the target is a party target, set the party target value for
    PLA                                                                         ; $03B0FF | | the actor.
    STA r_character_battle.1.targets.party.w,X                                  ; $03B100 | |
    STA r_character_battle_current_actor.targets.party.w                        ; $03B103 | |
    RTS                                                                         ; $03B106 |/
+   PLA                                                                         ; $03B107 |\
    STA r_character_battle.1.targets.monster.w,X                                ; $03B108 | | Otherwise, set the monster target value.
    STA r_character_battle_current_actor.targets.monster.w                      ; $03B10B |/
    RTS                                                                         ; $03B10E

; _battle_command_dispatch ($03:B10F)
;
; Dispatches to the correct command handler for the current actor (based on the
; current timer being processed).
_battle_command_dispatch:
    LDA <r_battle_timer_slot                                                    ; $03B10F |\
    CMP #5.b                                                                    ; $03B111 | | Branch ahead if the timer is a character.
    BCC @party                                                                  ; $03B113 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B115 |\
    LDA r_character_battle.1.command.w,X                                        ; $03B117 | | If the actor's command is not in the range $C0 to $E1, load $E1
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03B11A | | to use as the command.
    BCC +                                                                       ; $03B11C | |
    CMP #MONSTER_COMMAND_WAIT.b                                                 ; $03B11E | | NOTE: This is one set of code that disables the retreating monster
    BCC ++                                                                      ; $03B120 | |       mechanic (as the flee command is $E4).
+   LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03B122 |/
++  STA r_battle_last_action_command.w                                          ; $03B124 | Save the command to the last used command variable.
    SEC                                                                         ; $03B127 |\
    SBC #MONSTER_COMMAND_FIGHT.b                                                ; $03B128 | | Subtract the base value ($C0) and branch to the jump code.
    BRA @jump                                                                   ; $03B12A |/
@party:
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03B12C |\
    STA r_battle_script_audiovisual.w + 0                                       ; $03B12E | | Add audiovisual code to display the action name.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ACTION_NAME.b                           ; $03B131 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03B133 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B136 |\
    LDA r_character_battle.1.command.w,X                                        ; $03B138 | | If the command is White (used for all magic), Recall or the actual
    CMP #BATTLE_COMMAND_WHITE.b                                                 ; $03B13B | | Twin casting command, set the flag that indicates the action uses
    BEQ +                                                                       ; $03B13D | | MP.
    CMP #BATTLE_COMMAND_RECALL.b                                                ; $03B13F | |
    BEQ +                                                                       ; $03B141 | |
    CMP #BATTLE_COMMAND_TWIN_CAST.b                                             ; $03B143 | |
    BNE ++                                                                      ; $03B145 | |
+   INC r_battle_current_action_uses_mp.w                                       ; $03B147 |/
++  PHA                                                                         ; $03B14A | Preserve the command value.
    CLC                                                                         ; $03B14B |\
    ADC #MONSTER_COMMAND_FIGHT.b                                                ; $03B14C | | Save the command plus $C0 to the audiovisual code.
    STA r_battle_script_audiovisual.w + 2                                       ; $03B14E |/
    CMP #MONSTER_COMMAND_ITEM.b                                                 ; $03B151 |\
    BNE +                                                                       ; $03B153 | | Save the command to the last used command variable. If Item was
    LDA #MONSTER_COMMAND_WHITE.b                                                ; $03B155 | | used, save White instead.
+   STA r_battle_last_action_command.w                                          ; $03B157 |/
    STZ r_battle_script_audiovisual.w + 3                                       ; $03B15A | Zero out the next audiovisual byte initially.
    PLA                                                                         ; $03B15D | Restore the original command value.
@jump:
    ASL A                                                                       ; $03B15E |\
    TAX                                                                         ; $03B15F | | Load the pointer for the handler for this command.
    LDA battle_command_jump_data.l + 0,X                                        ; $03B160 | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03B164 | |
    LDA battle_command_jump_data.l + 1,X                                        ; $03B166 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03B16A | |
    LDA #:battle_command_jump_data.b                                            ; $03B16C | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03B16E |/
    JML [r_generic_tmp_ptr.w]                                                   ; $03B170 | Jump to the handler.

; _battle_calculate_modified_slot_offset ($03:B173)
;
; Given a modified slot value in the accumulator, returns the correct offset to
; that slot's battle stat record as a 16-bit value in $80. The modifies slot
; value consists of the 0-based slot number in the low seven bits, and the
; high bit should be set if it's a monster. Both the monster and player slots
; should start from zero, as they're treated independently.
_battle_calculate_modified_slot_offset:
    PHA                                                                         ; $03B173 | Preserve the parameter in the stack.
    AND #%01111111.b                                                            ; $03B174 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03B176 | | Multiply the low seven bits by the size of a character battle
    LDA #_sizeof_character_battle.b                                             ; $03B178 | | record.
    STA <r_math_multiply_8bit_arg_2                                             ; $03B17A | |
    JSR _math_multiply_8bit                                                     ; $03B17C |/
    PLA                                                                         ; $03B17F |\
    BMI +                                                                       ; $03B180 | | If the high bit of the original value was not set, then this is a
    CLC                                                                         ; $03B182 | | character slot. Add the previously calculated offset to the offset
    LDA <r_math_multiply_8bit_result_lo                                         ; $03B183 | | for the first stat record and save it to the result variable.
    ADC #<r_character_battle.1                                                  ; $03B185 | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03B187 | |
    LDA <r_math_multiply_8bit_result_hi                                         ; $03B189 | |
    ADC #>r_character_battle.1                                                  ; $03B18B | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03B18D | |
    RTS                                                                         ; $03B18F |/
+   CLC                                                                         ; $03B190 |\
    LDA <r_math_multiply_8bit_result_lo                                         ; $03B191 | | If the high bit was set, instead add the offset to the offset for
    ADC #<r_character_battle.6                                                  ; $03B193 | | the sixth overall slot (the first monster slot).
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03B195 | |
    LDA <r_math_multiply_8bit_result_hi                                         ; $03B197 | |
    ADC #>r_character_battle.6                                                  ; $03B199 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03B19B |/
    RTS                                                                         ; $03B19D

; _battle_action_details_set_target ($03:B19E)
;
; Given a target value in the accumulator, sets the current action details
; target value. If the number of targets was anything but one, also sets the
; all target flag.
_battle_action_details_set_target:
    STA r_battle_current_action_details.target.w                                ; $03B19E | Save the target value.
    JSR _count_set_bits                                                         ; $03B1A1 | Count the number of set targets.
    DEX                                                                         ; $03B1A4 |\
    BEQ +                                                                       ; $03B1A5 | | If the number wasn't exactly one, set the all target flag.
    LDA r_battle_current_action_details.target_flags.w                          ; $03B1A7 | |
    ORA #BATTLE_ACTION_DETAILS_TARGET_FLAG_ALL.b                                ; $03B1AA | |
    STA r_battle_current_action_details.target_flags.w                          ; $03B1AC |/
+   RTS                                                                         ; $03B1AF

; _battle_apply_pending_status ($03:B1B0)
;
; Loops through the 13 slots, updating the status of each slot with any pending
; statuses as specified in the array at $338E. In addition, updates the counts
; of monsters remaining and monster deaths.
_battle_apply_pending_status:
    TDC                                                                         ; $03B1B0 |\
    TAX                                                                         ; $03B1B1 | | Initialize the current slot and monster type index to zero.
    STX <r_battle_apply_pending_status_slot                                     ; $03B1B2 |/
@start:
    LDA <r_battle_apply_pending_status_slot                                     ; $03B1B4 |\ Calculate the offsets for this slot.
    JSR _calculate_offsets                                                      ; $03B1B6 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B1B9 | Set the X register to the battle record offset.
    LDA <r_battle_apply_pending_status_slot                                     ; $03B1BB |\
    JSR _math_multiply_by_4                                                     ; $03B1BD | | Set the Y register to slot times four.
    TAY                                                                         ; $03B1C0 |/
    LDA r_battle_pending_status.w,Y                                             ; $03B1C1 |\
    ORA r_character_battle.1.status_1.w,X                                       ; $03B1C4 | | Set any pending status to the first status variable.
    STA r_character_battle.1.status_1.w,X                                       ; $03B1C7 |/
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B1CA |\ If the slot isn't swooned or stoned, skip to the next section.
    BEQ @next                                                                   ; $03B1CC |/
    AND #STATUS_1_SWOON.b                                                       ; $03B1CE |\
    BEQ +                                                                       ; $03B1D0 | | If the slot is swooned, explicitly set the HP to zero.
    STZ r_character_battle.1.hp_lo.w,X                                          ; $03B1D2 | |
    STZ r_character_battle.1.hp_hi.w,X                                          ; $03B1D5 |/
+   PHX                                                                         ; $03B1D8 | Preserve the slot offset.
    LDA <r_battle_apply_pending_status_slot                                     ; $03B1D9 |\
    ASL A                                                                       ; $03B1DB | | Set the X register to the slot times two.
    TAX                                                                         ; $03B1DC |/
    TDC                                                                         ; $03B1DD |\ Disable the timers for this slot.
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03B1DE |/
    LDA <r_battle_apply_pending_status_slot                                     ; $03B1E1 |\
    CMP #5.b                                                                    ; $03B1E3 | | If this is a character slot, skip past the monster code.
    BCC +++                                                                     ; $03B1E5 |/
    SEC                                                                         ; $03B1E7 |\
    SBC #5.b                                                                    ; $03B1E8 | | Set the X register to the monster slot number.
    TAX                                                                         ; $03B1EA |/
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $03B1EB |\ Get the type index for this monster slot.
    STA <r_battle_apply_pending_status_monster_type_index                       ; $03B1EE |/
    LDA r_monster_slot_to_id_index.w,X                                          ; $03B1F0 |\ If there is no monster in this slot anymore, branch ahead past much
    BMI ++                                                                      ; $03B1F3 |/ of this code.
    LDA #$FF.b                                                                  ; $03B1F5 |\ Flag that this slot has been removed from battle.
    STA r_monster_slot_to_id_index.w,X                                          ; $03B1F7 |/
    LDA <r_battle_apply_pending_status_monster_type_index                       ; $03B1FA |\
    TAX                                                                         ; $03B1FC | | Decrement the monsters remaining counter if it's not already zero
    LDA r_monsters_remaining.w,X                                                ; $03B1FD | | for this type index.
    BEQ +                                                                       ; $03B200 | |
    DEC r_monsters_remaining.w,X                                                ; $03B202 |/
+   PLX                                                                         ; $03B205 |\ Switch the X register to the battle record offset.
    PHX                                                                         ; $03B206 |/
    LDA r_character_battle.1.command.w,X                                        ; $03B207 |\
    CMP #MONSTER_COMMAND_FLEE.b                                                 ; $03B20A | | If the monster's command is not Flee and if the death count update
    BEQ +                                                                       ; $03B20C | | has not been suppressed, increment the death counter for this
    LDA r_battle_monster_suppress_death_count.w                                 ; $03B20E | | monster type index.
    BNE +                                                                       ; $03B211 | |
    LDA <r_battle_apply_pending_status_monster_type_index                       ; $03B213 | |
    TAX                                                                         ; $03B215 | |
    INC r_monster_type_deaths.w,X                                               ; $03B216 |/
+   LDA <r_battle_apply_pending_status_monster_type_index                       ; $03B219 |\
    TAX                                                                         ; $03B21B | | If there are no monsters left of this type, set the value in the
    LDA r_monsters_remaining.w,X                                                ; $03B21C | | array that links types to monster IDs to $FF.
    BNE ++                                                                      ; $03B21F | |
    LDA <r_battle_apply_pending_status_monster_type_index                       ; $03B221 | |
    TAX                                                                         ; $03B223 | |
    LDA #$FF.b                                                                  ; $03B224 | |
    STA r_monster_ids.w,X                                                       ; $03B226 |/
++  CLC                                                                         ; $03B229 |\
    LDA r_monsters_remaining.1.w                                                ; $03B22A | | Update the total number of remaining monsters by adding the counts
    ADC r_monsters_remaining.2.w                                                ; $03B22D | | for each type.
    ADC r_monsters_remaining.3.w                                                ; $03B230 | |
    STA r_monsters_remaining_total.w                                            ; $03B233 |/
+++ PLX                                                                         ; $03B236 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03B237 | | If this slot has the swoon status, set the HP to zero.
    AND #STATUS_1_SWOON.b                                                       ; $03B23A | |
    BEQ @next                                                                   ; $03B23C | | NOTE: This is the second time this is done for some reason.
    STZ r_character_battle.1.hp_lo.w,X                                          ; $03B23E | |
    STZ r_character_battle.1.hp_hi.w,X                                          ; $03B241 |/
@next:
    INY                                                                         ; $03B244 |\
    LDA r_battle_pending_status.w,Y                                             ; $03B245 | | Set any pending statuses from the second status variable.
    ORA r_character_battle.1.status_2.w,X                                       ; $03B248 | |
    STA r_character_battle.1.status_2.w,X                                       ; $03B24B |/
    INY                                                                         ; $03B24E |\
    LDA r_battle_pending_status.w,Y                                             ; $03B24F | | Set any pending statuses from the third status variable.
    ORA r_character_battle.1.status_3.w,X                                       ; $03B252 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03B255 |/
    INY                                                                         ; $03B258 |\
    LDA r_battle_pending_status.w,Y                                             ; $03B259 | | Set any pending statuses from the fourth status variable.
    ORA r_character_battle.1.status_4.w,X                                       ; $03B25C | |
    STA r_character_battle.1.status_4.w,X                                       ; $03B25F |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03B262 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B265 | | If the slot has either the swoon or stone statuses, remove various
    BEQ +                                                                       ; $03B267 | | other statuses. The only ones that are allowed to remain are:
    LDA r_character_battle.1.status_1.w,X                                       ; $03B269 | | swoon, stone, toad, small, pig, mute, darkness, float, curse,
    AND #STATUS_1_POISON.b ~ $FF                                                ; $03B26C | | magnetized, egg, jumping, and hiding.
    STA r_character_battle.1.status_1.w,X                                       ; $03B26E | |
    LDA r_character_battle.1.status_2.w,X                                       ; $03B271 | |
    AND #(STATUS_2_FLOAT | STATUS_2_CURSE).b                                    ; $03B274 | |
    STA r_character_battle.1.status_2.w,X                                       ; $03B276 | |
    LDA r_character_battle.1.status_3.w,X                                       ; $03B279 | |
    AND #(STATUS_3_MAGNETIZED | STATUS_3_EGG | STATUS_3_JUMPING).b              ; $03B27C | |
    STA r_character_battle.1.status_3.w,X                                       ; $03B27E | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03B281 | |
    AND #STATUS_4_HIDING.b                                                      ; $03B284 | |
    STA r_character_battle.1.status_4.w,X                                       ; $03B286 |/
+   INC <r_battle_apply_pending_status_slot                                     ; $03B289 |\
    LDA <r_battle_apply_pending_status_slot                                     ; $03B28B | | Increment the slot and loop until all 13 slots have been
    CMP #(5 + 8).b                                                              ; $03B28D | | processed.
    BEQ +                                                                       ; $03B28F | |
    JMP @start                                                                  ; $03B291 |/
+   STZ r_battle_monster_suppress_death_count.w                                 ; $03B294 | Reset the death count update suppression flag.
    RTS                                                                         ; $03B297

; _battle_update_victim_history ($03:B298)
;
; If the targets of the current action are monsters, updates the victim action
; history of each target to reflect the current action. This routine suffers
; from a bug. If the attack is multi-target elemental attack, only the lowest
; slotted target will have the element reflected in their history.
_battle_update_monster_victim_history:
    LDA r_battle_current_action_details.target_flags.w                          ; $03B298 |\ Skip this function if the target is not a monster.
    BPL @done                                                                   ; $03B29B |/
    LDA r_battle_current_action_details.target.w                                ; $03B29D |\ Copy the target value to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03B2A0 |/
    TDC                                                                         ; $03B2A2 |\ Initialize the X register to zero.
    TAX                                                                         ; $03B2A3 |/
-   ASL <r_battle_generic_tmp_1_lo                                              ; $03B2A4 |\ Skip this index if not being targeted.
    BCC ++                                                                      ; $03B2A6 |/
    TXA                                                                         ; $03B2A8 |\
    JSR _math_multiply_by_32                                                    ; $03B2A9 | | Calculate the index for that monster's victim action history and
    TAY                                                                         ; $03B2AC | | store it in the argument for the shift function.
    STY <r_battle_generic_tmp_2                                                 ; $03B2AD |/
    LDA r_battle_monster_victim_action_index.w,X                                ; $03B2AF |\
    INC A                                                                       ; $03B2B2 | | If the current history index for this monster is already at the
    CMP #4.b                                                                    ; $03B2B3 | | maximum of 3, call a routine to shift the entries down one slot to
    BNE +                                                                       ; $03B2B5 | | make room for the new one. (The oldest is discarded.) Otherwise,
    PHX                                                                         ; $03B2B7 | | increment the index.
    JSR _battle_shift_victim_action_history                                     ; $03B2B8 | |
    PLX                                                                         ; $03B2BB | |
    LDA #3.b                                                                    ; $03B2BC | |
+   STA r_battle_monster_victim_action_index.w,X                                ; $03B2BE |/
    JSR _math_multiply_by_4.w                                                   ; $03B2C1 |\
    CLC                                                                         ; $03B2C4 | | Set the Y register to the offset to the desired index by adding
    ADC <r_battle_generic_tmp_2                                                 ; $03B2C5 | | the base offset for the monster to the offset for the new index.
    TAY                                                                         ; $03B2C7 |/
    LDA <r_battle_command_actor_slot                                            ; $03B2C8 |\ Save the actor to the history.
    STA r_battle_monster_victim_action_history.1.actor.w,Y                      ; $03B2CA |/
    LDA r_battle_last_action_command.w                                          ; $03B2CD |\ Save the command to the history.
    STA r_battle_monster_victim_action_history.1.command.w,Y                    ; $03B2D0 |/
    TDC                                                                         ; $03B2D3 |\ TODO: Zero out the third byte in the entry. Does this byte serve
    STA r_battle_monster_victim_action_history.1.unknown3.w,Y                   ; $03B2D4 |/       any purpose, or was it ultimately left unused?
    LDA r_battle_last_action_element.w                                          ; $03B2D7 |\ Save the element to the history.
    STA r_battle_monster_victim_action_history.1.element.w,Y                    ; $03B2DA |/
    STZ r_battle_last_action_element.w                                          ; $03B2DD | BUG: Zero out the element, even though there might be more entries.
++  INX                                                                         ; $03B2E0 |\
    CPX #8.w                                                                    ; $03B2E1 | | Increment the index and loop until all eight slots have been done.
    BNE -                                                                       ; $03B2E4 |/
@done:
    RTS                                                                         ; $03B2E6

; _battle_shift_victim_action_history ($03:B2E7)
;
; Shifts the victim action history for one monster. The entry at index zero is
; discarded, and all other entries are shifted down one index. The values in the
; new last entry are undefined. The 16-bit offset to the monster's history
; within the history data should be passed in $AB.
_battle_shift_victim_action_history:
    PHX                                                                         ; $03B2E7 | Preserve the value of the X register.
    TDC                                                                         ; $03B2E8 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03B2E9 |/
    LDX <r_battle_generic_tmp_2                                                 ; $03B2EA | Load the provided offset to the correct monster's history.
-   LDA r_battle_monster_victim_action_history.w,X                              ; $03B2EC |\
    STA r_battle_generic_tmp_block.w,Y                                          ; $03B2EF | | Copy the entire history to a temporary area.
    INX                                                                         ; $03B2F2 | |
    INY                                                                         ; $03B2F3 | |
    CPY #_sizeof_r_battle_current_monster_victim_action_history.w               ; $03B2F4 | |
    BNE -                                                                       ; $03B2F7 |/
    LDY #4.w                                                                    ; $03B2F9 |\
    LDX <r_battle_generic_tmp_2                                                 ; $03B2FC | | Copy the history back, except starting from the second entry, in
-   LDA r_battle_generic_tmp_block.w,Y                                          ; $03B2FE | | order to shift all the entires left one slot.
    STA r_battle_monster_victim_action_history.w,X                              ; $03B301 | |
    INX                                                                         ; $03B304 | | NOTE: This means the eighth entry is filled with whatever happens
    INY                                                                         ; $03B305 | |       to be hanging around in $289C. It may be possible for this
    CPY #_sizeof_r_battle_current_monster_victim_action_history.w + 4           ; $03B306 | |       to lead to unusual behavior. TODO: Examine possibility.
    BNE -                                                                       ; $03B309 |/
    PLX                                                                         ; $03B30B | Restore the value of the X register.
    RTS                                                                         ; $03B30C

; _battle_initialize_action_audiovisual ($03:B30D)
;
; Initializes several variables and arrays used during action processing.
_battle_initialize_action_audiovisual:
    LDA #MONSTER_COMMAND_END.b                                                  ; $03B30D |\
    LDX #_sizeof_r_battle_script_audiovisual.w - 1                              ; $03B30F | | Initialize the audiovisual script to all end commands.
-   STA r_battle_script_audiovisual.w,X                                         ; $03B312 | |
    DEX                                                                         ; $03B315 | |
    BPL -                                                                       ; $03B316 |/
    LDX #_sizeof_action_details.w + _sizeof_r_battle_alert_queue                ; $03B318 |\
-   STZ r_battle_current_action_details.w,X                                     ; $03B31B | | Initialize the current action details, the battle alert queue, and
    DEX                                                                         ; $03B31E | | the TODO $34D3 to zero.
    BPL -                                                                       ; $03B31F |/
    STZ r_unknown_3528.w                                                        ; $03B321 |\ TODO: Initialize two unknown variables to zero.
    STZ r_unknown_3529.w                                                        ; $03B324 |/
    STZ r_battle_current_spell_item.w                                           ; $03B327 | By default, the current spell is not an item.
    LDX #_sizeof_r_battle_pending_status.w - 1                                  ; $03B32A |\
-   STZ r_battle_pending_status.w,X                                             ; $03B32D | | Reset the pending status variables.
    DEX                                                                         ; $03B330 | |
    BPL -                                                                       ; $03B331 |/
    LDA #$FF.b                                                                  ; $03B333 |\
    LDX #_sizeof_r_battle_alert_queue.w                                         ; $03B335 | | TODO: Initialize the battle alert queue and the unknown $34D3 to
-   STA r_battle_alert_queue.w,X                                                ; $03B338 | |       $FF (despite just initializing it to zero a few lines ago).
    DEX                                                                         ; $03B33B | |
    BPL -                                                                       ; $03B33C |/
    LDA r_monster_script_chain_slot_lo.w                                        ; $03B33E |\
    CMP #$FF.b                                                                  ; $03B341 | | If there is no active chain, initialize the battle slot damage
    BNE +                                                                       ; $03B343 | | array and the TODO data beyond it to zero.
    LDX #_sizeof_r_battle_slot_damage.w + 52 - 1                                ; $03B345 | |
-   STZ r_battle_slot_damage.w,X                                                ; $03B348 | |
    DEX                                                                         ; $03B34B | |
    BPL -                                                                       ; $03B34C |/
+   RTS                                                                         ; $03B34E

; _battle_command_execute_wait ($03:B34F)
;
; Handles the Wait command, which does nothing but set a flag to prevent the
; actor from flashing during the audiovisual processing.
_battle_command_execute_wait:
    LDA r_battle_current_action_details.actor_flags.w                           ; $03B34F |\
    ORA #BATTLE_ACTION_DETAILS_ACTOR_FLAG_SILENT.b                              ; $03B352 | | Set the silent flag on the actor.
    STA r_battle_current_action_details.actor_flags.w                           ; $03B354 |/
    RTS                                                                         ; $03B357

; _battle_script_end_chain ($03:B358)
;
; If there is a chain end command present in the audiovisual script, replace the
; entire script with commands to end the chain.
_battle_script_end_chain:
    TDC                                                                         ; $03B358 |\ Initialize the X register to zero.
    TAX                                                                         ; $03B359 |/
    STX <r_battle_generic_tmp_1_lo                                              ; $03B35A | Initialize the chain result flag to zero.
-   LDA r_battle_script_audiovisual.w,X                                         ; $03B35C |\
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B35F | | If encountering the end of the script, branch to the end.
    BEQ ++                                                                      ; $03B361 |/
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B363 |\ If encountering the end of a chain, branch to the extra code.
    BEQ +                                                                       ; $03B365 |/
    INX                                                                         ; $03B367 |\ Increment the index and loop indefinitely.
    BRA -                                                                       ; $03B368 |/
+   INC <r_battle_generic_tmp_1_lo                                              ; $03B36A | Increment the chain result flag.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03B36C |\
    STA r_battle_script_audiovisual.w + 0                                       ; $03B36E | | Set commands to Wait, immediately end the chain, and end.
    LDA #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B371 | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03B373 | |
    LDA #MONSTER_COMMAND_END.b                                                  ; $03B376 | |
    STA r_battle_script_audiovisual.w + 2                                       ; $03B378 |/
++  RTS                                                                         ; $03B37B

; battle_command_jump_data ($03:B37C)
;
; For each battle command, contains the pointer to the handler for that command.
; The odd exception is magic (White, Black, Call, Ninja). All of those should
; use the handler for White, since the other pointers are not set.
battle_command_jump_data:
    .addr _battle_command_execute_fight                                         ; $03B37C.B37D | $00: Fight
    .addr _battle_command_execute_item                                          ; $03B37E.B37F | $01: Item
    .addr _battle_command_execute_magic                                         ; $03B380.B381 | $02: White
    .addr 0                                                                     ; $03B382.B383 | $03: Black
    .addr 0                                                                     ; $03B384.B385 | $04: Call
    .addr _battle_command_execute_dark_wave                                     ; $03B386.B387 | $05: Dark Wave
    .addr _battle_command_execute_jump                                          ; $03B388.B389 | $06: Jump
    .addr _battle_command_execute_recall                                        ; $03B38A.B38B | $07: Recall
    .addr _battle_command_execute_sing                                          ; $03B38C.B38D | $08: Sing
    .addr _battle_command_execute_hide                                          ; $03B38E.B38F | $09: Hide
    .addr _battle_command_execute_heal                                          ; $03B390.B391 | $0A: Heal
    .addr _battle_command_execute_pray                                          ; $03B392.B393 | $0B: Pray
    .addr _battle_command_execute_aim                                           ; $03B394.B395 | $0C: Aim
    .addr _battle_command_execute_build_up                                      ; $03B396.B397 | $0D: Build Up
    .addr _battle_command_execute_kick                                          ; $03B398.B399 | $0E: Kick
    .addr _battle_command_execute_endure                                        ; $03B39A.B39B | $0F: Endure
    .addr _battle_command_execute_twin                                          ; $03B39C.B39D | $10: Twin
    .addr _battle_command_execute_bluff                                         ; $03B39E.B39F | $11: Bluff
    .addr _battle_command_execute_cry                                           ; $03B3A0.B3A1 | $12: Cry
    .addr _battle_command_execute_cover                                         ; $03B3A2.B3A3 | $13: Cover
    .addr _battle_command_execute_peep                                          ; $03B3A4.B3A5 | $14: Peep
    .addr 0                                                                     ; $03B3A6.B3A7 | $15: <unused>
    .addr _battle_command_execute_dart                                          ; $03B3A8.B3A9 | $16: Dart
    .addr _battle_command_execute_sneak                                         ; $03B3AA.B3AB | $17: Sneak
    .addr 0                                                                     ; $03B3AC.B3AD | $18: Ninja
    .addr _battle_command_execute_bless                                         ; $03B3AE.B3AF | $19: Bless
    .addr _battle_command_execute_change                                        ; $03B3B0.B3B1 | $1A: Change
    .addr _battle_command_execute_parry                                         ; $03B3B2.B3B3 | $1B: Parry
    .addr _battle_command_execute_show                                          ; $03B3B4.B3B5 | $1C: Show
    .addr _battle_command_execute_off                                           ; $03B3B6.B3B7 | $1D: Off
    .addr _battle_command_execute_land                                          ; $03B3B8.B3B9 | $1E: <unnamed> (Land)
    .addr _battle_command_execute_release                                       ; $03B3BA.B3BB | $1F: <unnamed> (Release)
    .addr _battle_command_execute_twin_cast                                     ; $03B3BC.B3BD | $20: <unnamed> (Twin Cast)
    .addr _battle_command_execute_wait                                          ; $03B3BE.B3BF | $21: <unnamed> (Wait)
    .addr _battle_command_execute_bless_off                                     ; $03B3C0.B3C1 | $22: <unnamed> (Bless Off)
    .addr 0                                                                     ; $03B3C2.B3C3 | $23: <unused>
    .addr _battle_command_execute_flee                                          ; $03B3C4.B3C5 | $24: <unnamed> (Flee)

; _monster_script_execute ($03:B3C6)
;
; Process the script for the currently acting monster and sets its command,
; subcommand, targets, and action timer.
_monster_script_execute:
    JSR _monster_script_reset_modified_action_set                               ; $03B3C6 | Reset the monster's modified action set to all end commands.
    JSR _monster_script_reset_shared_modified_action_set                        ; $03B3C9 | Reset the shared modified action set.
    SEC                                                                         ; $03B3CC |\
    LDA <r_battle_timer_slot                                                    ; $03B3CD | | Calculate and store the current monster slot being processed.
    SBC #5.b                                                                    ; $03B3CF | |
    STA r_monster_script_current_monster_slot.w                                 ; $03B3D1 |/
    LDA r_monster_script_chain_active.w                                         ; $03B3D4 |\
    BEQ ++                                                                      ; $03B3D7 | | If a chain is active and the chain monster is this monster, jump
    LDA <r_battle_timer_slot                                                    ; $03B3D9 | | to start processing the action. If it's another monster, simply
    CMP r_monster_script_chain_slot_lo.w                                        ; $03B3DB | | skip processing.
    BEQ +                                                                       ; $03B3DE | |
    JMP @done                                                                   ; $03B3E0 | |
+   JMP @action_start                                                           ; $03B3E3 |/
++  JSR _battle_initialize_action_audiovisual                                   ; $03B3E6 | Initialize audiovisual data for the current action.
    LDX <r_current_slot_offset_character_battle                                 ; $03B3E9 |\
    STZ r_character_battle.1.action_flags.w,X                                   ; $03B3EB | | Initialize the action information for this slot to zeroes.
    STZ r_character_battle.1.subcommand.w,X                                     ; $03B3EE | |
    STZ r_character_battle.1.command_offset_lo.w,X                              ; $03B3F1 | |
    STZ r_character_battle.1.command_offset_hi.w,X                              ; $03B3F4 | |
    STZ r_character_battle.1.targets.monster.w,X                                ; $03B3F7 | |
    STZ r_character_battle.1.targets.party.w,X                                  ; $03B3FA |/
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03B3FD |\ Initially set the command to simply wait.
    STA r_character_battle.1.command.w,X                                        ; $03B3FF |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03B402 |\
    AND #(STATUS_2_CHARM | STATUS_2_BERSERK).b                                  ; $03B405 | | If this monster slot is not charmed or berserked, is not a boss,
    BNE +                                                                       ; $03B407 | | has a $2F stat (by default, their level plus ten) less than or
    LDA r_character_battle.1.monster_level_boss.w,X                             ; $03B409 | | equal to the minimum character level, if running is not disabled
    BMI +                                                                       ; $03B40C | | for this formation, and if a random number from 0 to 255 is less
    LDA r_battle_minimum_character_level.w                                      ; $03B40E | | than the monster's physical evade, set the monster's command to
    CMP r_character_battle.1.unknown2F.w,X                                      ; $03B411 | | the Flee command.
    BCC +                                                                       ; $03B414 | |
    JSR _get_battle_rng_0_255.w                                                 ; $03B416 | | NOTE: Due to a bug elsewhere, monsters have no physical evade, so
    LDX <r_current_slot_offset_character_battle                                 ; $03B419 | |       this code will never trigger. In addition, there are two
    CMP r_character_battle.1.physical_defense_evade.w,X                         ; $03B41B | |       other locations in the code that will reset the command to
    BCS +                                                                       ; $03B41E | |       Wait.
    LDA r_formation_flags2.w                                                    ; $03B420 | |
    AND #FORMATION_FLAGS_2_DISABLE_RUNNING.b                                    ; $03B423 | |
    BNE +                                                                       ; $03B425 | |
    LDA #MONSTER_COMMAND_FLEE.b                                                 ; $03B427 | |
    STA r_character_battle.1.command.w,X                                        ; $03B429 | |
    JSR _battle_timer_set_action_fixed                                          ; $03B42C | |
    JMP @done                                                                   ; $03B42F |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03B432 |\
    LDA r_character_battle.1.status_2.w,X                                       ; $03B434 | | Skip this next code unless the slot is berserked.
    AND #STATUS_2_BERSERK.b                                                     ; $03B437 | |
    BEQ ++                                                                      ; $03B439 |/
    LDA #5.b                                                                    ; $03B43B |\
    STA <r_battle_generic_tmp_2_lo                                              ; $03B43D | | Select a random party target, if any are available.
    LDX <r_current_slot_offset_character_battle                                 ; $03B43F | |
    STZ r_character_battle.1.command.w,X                                        ; $03B441 | |
    JSR _monster_script_select_random_target                                    ; $03B444 |/
    LDA r_character_battle.1.command.w,X                                        ; $03B447 |\
    CMP #MONSTER_COMMAND_WAIT.b                                                 ; $03B44A | | If the targeting routine didn't set the monster to wait, set its
    BEQ +                                                                       ; $03B44C | | command to instead fight.
    LDA #MONSTER_COMMAND_FIGHT.b                                                ; $03B44E | |
    STA r_character_battle.1.command.w,X                                        ; $03B450 | |
    STA r_monster_script_current_modified_action_set.w                          ; $03B453 |/
+   JSR _battle_timer_set_action_fixed                                          ; $03B456 | Set the action timer to a fixed value.
    JMP @done                                                                   ; $03B459 | Skip to the end.
++  STZ r_monster_script_script_index.w                                         ; $03B45C | Initialize the condition set index to zero.
    LDA r_monster_script_current_monster_slot.w                                 ; $03B45F |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03B462 | | Calculate the offset to the scripts for this monster slot.
    LDA #_sizeof_battle_script.b                                                ; $03B464 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03B466 | |
    JSR _math_multiply_8bit                                                     ; $03B468 | |
    LDX <r_math_multiply_8bit_result                                            ; $03B46B | |
    STX r_monster_script_script_offset_base.w                                   ; $03B46D | |
    STX r_monster_script_script_offset_current.w                                ; $03B470 |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B473 |\
    TAX                                                                         ; $03B476 | | Calculate the offset to the action sets for this slot.
    STX r_math_multiply_16bit_arg_1.w                                           ; $03B477 | |
    LDX #_sizeof_action_sets.w                                                  ; $03B47A | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03B47D | |
    JSR _math_multiply_16bit                                                    ; $03B480 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03B483 | |
    STX r_monster_script_action_set_offset_base.w                               ; $03B486 | |
    STX r_monster_script_action_set_offset_current.w                            ; $03B489 |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B48C |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03B48F | | Calculate the base offset for the condition sets for this slot.
    LDA #_sizeof_condition_sets.b                                               ; $03B491 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03B493 | |
    JSR _math_multiply_8bit                                                     ; $03B495 | |
    LDX <r_math_multiply_8bit_result                                            ; $03B498 | |
    STX r_monster_script_condition_set_offset_base.w                            ; $03B49A |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B49D |\
    TAX                                                                         ; $03B4A0 | | Calculate the base offset for the expanded condition sets for this
    STX r_math_multiply_16bit_arg_1.w                                           ; $03B4A1 | | slot.
    LDX #_sizeof_condition_sets_expanded.w                                      ; $03B4A4 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03B4A7 | |
    JSR _math_multiply_16bit                                                    ; $03B4AA | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03B4AD | |
    STX r_monster_script_condition_offset_base.w                                ; $03B4B0 |/
@condition_start:
    LDA r_monster_script_script_index.w                                         ; $03B4B3 |\
    JSR _math_multiply_by_4                                                     ; $03B4B6 | | Calculate the current condition set offset by adding the base
    CLC                                                                         ; $03B4B9 | | offset to the current condition set index times the size of a
    ADC r_monster_script_condition_set_offset_base_lo.w                         ; $03B4BA | | condition set.
    STA r_monster_script_condition_set_offset_current_lo.w                      ; $03B4BD | |
    LDA r_monster_script_condition_set_offset_base_hi.w                         ; $03B4C0 | |
    ADC #0.b                                                                    ; $03B4C3 | |
    STA r_monster_script_condition_set_offset_current_hi.w                      ; $03B4C5 |/
    LDA r_monster_script_script_index.w                                         ; $03B4C8 |\
    TAX                                                                         ; $03B4CB | | Calculate the current condition offset in much the same way. The
    REP #FLAG_P_ACCUMULATOR                                                     ; $03B4CC | | condition data is just expanded condition sets (the actual data
    TXA                                                                         ; $03B4CE | | is loaded instead of just the indexes to the data).
    JSR _math_multiply_by_16                                                    ; $03B4CF | |
    CLC                                                                         ; $03B4D2 | |
    ADC r_monster_script_condition_offset_base.w                                ; $03B4D3 | |
    STA r_monster_script_condition_offset_current.w                             ; $03B4D6 | |
    TDC                                                                         ; $03B4D9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03B4DA |/
    LDX r_monster_script_script_offset_current.w                                ; $03B4DC |\
    LDA r_monster_scripts.1.scripts.1.condition_set_index.w,X                   ; $03B4DF | | Skip to the action if the condition set index is zero.
    BEQ @action_start                                                           ; $03B4E2 |/
    STZ r_monster_script_condition_index.w                                      ; $03B4E4 | Initialize the condition index to zero.
--  LDX r_monster_script_condition_set_offset_current.w                         ; $03B4E7 |\
    LDA r_monster_condition_sets.w,X                                            ; $03B4EA | | If the condition index is $FF, skip ahead to the action.
    CMP #$FF.b                                                                  ; $03B4ED | | The current condition set completely matches.
    BEQ @action_start                                                           ; $03B4EF |/
    TDC                                                                         ; $03B4F1 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03B4F2 |/
    LDX r_monster_script_condition_offset_current.w                             ; $03B4F3 |\
-   LDA r_monster_conditions.w,X                                                ; $03B4F6 | | Copy the current condition data to a temporary location in memory.
    STA r_battle_tmp_monster_condition.w,Y                                      ; $03B4F9 | |
    INX                                                                         ; $03B4FC | |
    INY                                                                         ; $03B4FD | |
    CPY #_sizeof_condition.w                                                    ; $03B4FE | |
    BNE -                                                                       ; $03B501 |/
    STX r_monster_script_condition_offset_current.w                             ; $03B503 | Update the condition offset.
    JSR _monster_condition_check                                                ; $03B506 | Check to see if this condition matches.
    LDA <r_monster_condition_check_result                                       ; $03B509 |\
    BEQ +                                                                       ; $03B50B | | If it does, increment the index to move to the next condition in
    INC r_monster_script_condition_set_offset_current.w                         ; $03B50D | | the set and loop back to the beginning. If this was already the
    INC r_monster_script_condition_index.w                                      ; $03B510 | | fourth condition in the list, skip ahead to the action code.
    LDA r_monster_script_condition_index.w                                      ; $03B513 | |
    CMP #_sizeof_condition_set.b                                                ; $03B516 | |
    BNE --                                                                      ; $03B518 | |
    BEQ @action_start                                                           ; $03B51A |/
+   INC r_monster_script_script_offset_current.w                                ; $03B51C |\ Increment the script offset twice to move to the next script.
    INC r_monster_script_script_offset_current.w                                ; $03B51F |/
    INC r_monster_script_script_index.w                                         ; $03B522 | Increment the script index.
    BRA @condition_start                                                        ; $03B525 | Loop back to check the conditions for the next script.
@action_start:
    LDA r_monster_script_current_monster_slot.w                                 ; $03B527 |\
    TAX                                                                         ; $03B52A | | If the script index is different from the monster's current script
    LDA r_monster_script_script_index.w                                         ; $03B52B | | index, update it.
    CMP r_monster_current_script_index.w,X                                      ; $03B52E | |
    BEQ +                                                                       ; $03B531 | |
    STA r_monster_current_script_index.w,X                                      ; $03B533 | |
    JSR _battle_update_monster_current_script                                   ; $03B536 |/
    STZ r_monster_script_chain_active.w                                         ; $03B539 | Set that a chained attack is not currently active.
+   LDA r_monster_script_chain_active.w                                         ; $03B53C |\ If a chain is already active, skip forward to processing the
    BNE @action_process                                                         ; $03B53F |/ action.
    TDC                                                                         ; $03B541 |\
    TAX                                                                         ; $03B542 | | Initialize the action set offset to zero.
    STX r_monster_script_current_action_set_offset.w                            ; $03B543 |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B546 |\
    ASL A                                                                       ; $03B549 | | Load the offset for this monster slot's current action set and
    TAX                                                                         ; $03B54A | | transfer it to both a local variable and the X register.
    LDA r_monster_current_action_set_offset.w + 0,X                             ; $03B54B | |
    STA r_monster_script_action_set_offset_current_lo.w                         ; $03B54E | |
    LDA r_monster_current_action_set_offset.w + 1,X                             ; $03B551 | |
    STA r_monster_script_action_set_offset_current_hi.w                         ; $03B554 | |
    LDX r_monster_script_action_set_offset_current.w                            ; $03B557 |/
    TDC                                                                         ; $03B55A |\ Initialize the Y register to zero.
    TAY                                                                         ; $03B55B |/
    LDA r_monster_actions.w,X                                                   ; $03B55C |\
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B55F | | If the first action byte is $FF, write the wait command to the
    BNE @action_copy                                                            ; $03B561 | | temporary action set and branch forward.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03B563 | |
    STA r_monster_script_current_action_set.w,Y                                 ; $03B565 | |
    BRA ++                                                                      ; $03B568 |/
@action_copy:
    LDA r_monster_actions.w,X                                                   ; $03B56A |\ Read the next byte and increment the X register.
    INX                                                                         ; $03B56D |/
    STA r_monster_script_current_action_set.w,Y                                 ; $03B56E | Store the byte in the temporary action set.
    CMP #MONSTER_COMMAND_PAUSE.b                                                ; $03B571 |\ If the value is $FE, branch forward to later code.
    BEQ +                                                                       ; $03B573 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B575 |\ If the value is $FF, branch forward to later code, now that the
    BEQ ++                                                                      ; $03B577 |/ sequence is over.
    INY                                                                         ; $03B579 |\ Increment the Y register and loop to the next byte.
    BRA @action_copy                                                            ; $03B57A |/
++  JSR _battle_update_monster_current_script                                   ; $03B57C | Update the monster's current script.
    BRA @action_process                                                         ; $03B57F | Branch past the next code.
+   STX <r_battle_generic_tmp_1                                                 ; $03B581 |\
    LDA r_monster_script_current_monster_slot.w                                 ; $03B583 | | If the last read value was $FE, update the monster's current
    ASL A                                                                       ; $03B586 | | offset, so next time, it can resume from this location in the
    TAX                                                                         ; $03B587 | | action sequence.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B588 | |
    STA r_monster_current_action_set_offset.w + 0,X                             ; $03B58A | |
    LDA <r_battle_generic_tmp_1_hi                                              ; $03B58D | |
    STA r_monster_current_action_set_offset.w + 1,X                             ; $03B58F |/
@action_process:
    TDC                                                                         ; $03B592 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03B593 |/
    LDX r_monster_script_current_action_set_offset.w                            ; $03B594 | Load the current action set offset to the X register.
-   LDA r_monster_script_current_action_set.w,X                                 ; $03B597 |\
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03B59A | | If the action byte is $C0 or greater, branch to later code.
    BCS +                                                                       ; $03B59C |/
    STA r_monster_script_current_modified_action_set.w + 1,Y                    ; $03B59E | Save the spell number as the second byte in the modified action set.
    PHX                                                                         ; $03B5A1 |\
    LDX <r_current_slot_offset_character_battle                                 ; $03B5A2 | | Set the byte as the monster's subcommand.
    STA r_character_battle.1.subcommand.w,X                                     ; $03B5A4 | |
    PLX                                                                         ; $03B5A7 |/
    LDA #MONSTER_COMMAND_WHITE.b                                                ; $03B5A8 |\ Set the first byte in the modified action set to the code for white
    STA r_monster_script_current_modified_action_set.w + 0,Y                    ; $03B5AA |/ magic.
    INY                                                                         ; $03B5AD |\
    INX                                                                         ; $03B5AE | | Increment the indexes and skip ahead.
    BRA ++                                                                      ; $03B5AF |/
+   STA r_monster_script_current_modified_action_set.w + 0,Y                    ; $03B5B1 | Store the command value in the modified action set.
    INX                                                                         ; $03B5B4 | Increment the X register.
    CMP #MONSTER_COMMAND_UNKNOWN_FA.b                                           ; $03B5B5 |\ If the value is greater than or equal to $FA, branch to different
    BCS +                                                                       ; $03B5B7 |/ code.
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03B5B9 |\ If the value is less than $E8, branch ahead to loop back to the
    BCC ++                                                                      ; $03B5BB |/ next byte.
    INY                                                                         ; $03B5BD |\
    LDA r_monster_script_current_action_set.w,X                                 ; $03B5BE | | If the value is in the range $E8 to $F9, copy the byte directly to
    STA r_monster_script_current_modified_action_set.w,Y                        ; $03B5C1 | | the target array and then branch forward to loop back to the next
    INX                                                                         ; $03B5C4 | | byte.
    BRA ++                                                                      ; $03B5C5 |/
+   CMP #MONSTER_COMMAND_UNKNOWN_FB.b                                           ; $03B5C7 |\
    BEQ +++                                                                     ; $03B5C9 | | If the value is $FB or $FC, branch ahead to later code.
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B5CB | |
    BEQ +++                                                                     ; $03B5CD |/
    CMP #MONSTER_COMMAND_PAUSE.b                                                ; $03B5CF |\
    BEQ +                                                                       ; $03B5D1 | | If the value is $FE or $FF, branch ahead to slightly different
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B5D3 | | later code.
    BEQ +                                                                       ; $03B5D5 |/
++  INY                                                                         ; $03B5D7 |\ Increment the Y register and loop back to the next byte.
    BRA -                                                                       ; $03B5D8 |/
+   STZ r_monster_script_chain_active.w                                         ; $03B5DA | If the value is $FE or $FF, unset the chain variable.
+++ STX r_monster_script_current_action_set_offset.w                            ; $03B5DD | Save the current value of the action set offset.
    TDC                                                                         ; $03B5E0 |\ Initialize the X register to zero.
    TAX                                                                         ; $03B5E1 |/
    STX <r_battle_calculate_kick_dark_wave_damage_base_damage                   ; $03B5E2 |\ Save the zero (and reload it) to a temporary variable used in
    LDX <r_battle_calculate_kick_dark_wave_damage_base_damage                   ; $03B5E4 |/ certain damage calculation routines. TODO: Which?
@chain_process:
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B5E6 | Read the next byte from the modified action set.
    CMP #MONSTER_COMMAND_CHAIN_START.b                                          ; $03B5E9 |\ If the value is $FD, branch to the code that handles starting a
    BEQ @chain_start                                                            ; $03B5EB |/ chain.
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B5ED |\ If the value is $FC, branch to the code that handles ending a
    BEQ @chain_end                                                              ; $03B5EF |/ chain.
    CMP #MONSTER_COMMAND_UNKNOWN_FB.b                                           ; $03B5F1 |\ If the value is $FB, simply branch to the next section.
    BEQ @next                                                                   ; $03B5F3 |/
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03B5F5 |\ If the value is less than $E8, branch to some separate code.
    BCC @basic                                                                  ; $03B5F7 |/
    INX                                                                         ; $03B5F9 |\
    INX                                                                         ; $03B5FA | | Otherwise, increment the X register twice and loop.
    BRA @chain_process                                                          ; $03B5FB |/
@chain_start:
    INC r_monster_script_chain_active.w                                         ; $03B5FD | Increment the chain active variable.
    LDA <r_battle_timer_slot                                                    ; $03B600 |\
    STA r_monster_script_chain_slot_lo.w                                        ; $03B602 | | Set the active chain slot to the current slot.
    STZ r_monster_script_chain_slot_hi.w                                        ; $03B605 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B608 |\
    LDA r_character_battle.1.relative_speed_lo.w,X                              ; $03B60A | | Back up the slot's relative speed and temporarily set it to zero.
    STA r_monster_script_relative_speed_backup.w                                ; $03B60D | |
    TDC                                                                         ; $03B610 | | BUG: Only the low byte is copied, though this has minimal impact.
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $03B611 |/
    BRA @next                                                                   ; $03B614 | Branch ahead to the next section.
@chain_end:
    DEC r_monster_script_chain_active.w                                         ; $03B616 | Decrement the chain active variable (presumably to zero).
    LDX <r_current_slot_offset_character_battle                                 ; $03B619 |\
    LDA r_monster_script_relative_speed_backup.w                                ; $03B61B | | Restore the preserved relative speed low byte.
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $03B61E |/
    BRA @next                                                                   ; $03B621 | Branch ahead to the next section.
@basic:
    INX                                                                         ; $03B623 | Increment the X register.
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B624 | Load the next byte.
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03B627 |\ If the value is $FC, branch to end the chain.
    BEQ @chain_end                                                              ; $03B629 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B62B |\ Loop until either the chain ends or the sequence ends.
    BNE @basic                                                                  ; $03B62D |/
@next:
    TDC                                                                         ; $03B62F |\ Initialize the X register to zero.
    TAX                                                                         ; $03B630 |/
-   LDA r_monster_script_current_modified_action_set.w,X                        ; $03B631 |\
    CMP #MONSTER_COMMAND_UNKNOWN_FA.b                                           ; $03B634 | | Loop through the sequence until finding a value less than $E8.
    BCS +                                                                       ; $03B636 | |
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03B638 | |
    BCC ++                                                                      ; $03B63A | |
    INX                                                                         ; $03B63C | |
+   INX                                                                         ; $03B63D | |
    BRA -                                                                       ; $03B63E |/
++  LDX <r_current_slot_offset_character_battle                                 ; $03B640 |\ Set the slot's command to the read value.
    STA r_character_battle.1.command.w,X                                        ; $03B642 |/
    TDC                                                                         ; $03B645 |\
    TAX                                                                         ; $03B646 | | Initialize the offset to zero.
    STX <r_generic_tmp_ptr_addr                                                 ; $03B647 |/
@decode_start:
    LDX <r_generic_tmp_ptr_addr                                                 ; $03B649 | Set the X register to the current offset.
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B64B | Load the next byte.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03B64E |\ If it's an ending byte, branch to the end code.
    BEQ @end                                                                    ; $03B650 |/
    CMP #MONSTER_COMMAND_SET_TARGET.b                                           ; $03B652 |\ If the byte is the set target byte, branch to the targeting code.
    BEQ @target                                                                 ; $03B654 |/
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03B656 |\ For codes less than $E8, branch to the code for normal codes.
    BCC @single                                                                 ; $03B658 |/
    CMP #MONSTER_COMMAND_UNKNOWN_FB.b                                           ; $03B65A |\ Repeat the above for codes of $FB or greater.
    BCS @single                                                                 ; $03B65C |/
    CMP #MONSTER_COMMAND_SET_MONSTER_SPRITE.b                                   ; $03B65E |\ Branch slightly ahead for codes of $F0 through $FA.
    BCS +                                                                       ; $03B660 |/
    PHA                                                                         ; $03B662 |\
    INX                                                                         ; $03B663 | | If the code is in the range $E8 through $EF, load the next byte,
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B664 | | store it to a variable, reload the instruction into the
    STA <r_battle_generic_tmp_1_lo                                              ; $03B667 | | accumulator, and call the stat change subroutine.
    PLA                                                                         ; $03B669 | |
    JSR _monster_script_command_stat_change                                     ; $03B66A |/
    BRA @double                                                                 ; $03B66D | Branch ahead to increment for a double byte instruction.
+   CMP #$F4.b                                                                  ; $03B66F |\ For codes $F0 through $F3, branch ahead to increment for a double
    BCC @double                                                                 ; $03B671 |/ byte instruction.
    PHA                                                                         ; $03B673 |\
    INX                                                                         ; $03B674 | | For codes $F4 through $F7 (and technically $F8 and $FA), load the
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B675 | | parameter and call the update flag routine.
    STA <r_battle_generic_tmp_1_lo                                              ; $03B678 | |
    PLA                                                                         ; $03B67A | |
    JSR _monster_script_command_update_flag                                     ; $03B67B |/
    BRA @double                                                                 ; $03B67E | Branch to increment for a double byte instruction.
@target:
    INX                                                                         ; $03B680 |\
    LDA r_monster_script_current_modified_action_set.w,X                        ; $03B681 | | For code $F9, load the parameter byte and call the target setting
    STA <r_battle_generic_tmp_1_lo                                              ; $03B684 | | routine.
    JSR _monster_script_command_set_target                                      ; $03B686 |/
@double:
    INC <r_generic_tmp_ptr_addr_lo                                              ; $03B689 | Increment the pointer once specifically for double byte codes.
@single:
    INC <r_generic_tmp_ptr_addr_lo                                              ; $03B68B | Increment it again for all codes.
    BRA @decode_start                                                           ; $03B68D | Branch back to process the next instruction.
@end:
    JSR _battle_monster_script_default_set_target                               ; $03B68F | If the end of the sequence was reached, set a default target.
    JSR _battle_timer_set_action_fixed                                          ; $03B692 | Set the action timer to a fixed value.
    LDA r_monster_script_current_monster_slot.w                                 ; $03B695 |\
    TAX                                                                         ; $03B698 | | Unset the monster's target set flag.
    STZ r_monster_target_set.w,X                                                ; $03B699 |/
@done:
    JMP _monster_script_copy_shared_modified_action_set_to_monster              ; $03B69C | Copy the shared modified action set back to the main array.

; _battle_monster_script_default_set_target ($03:B69F)
;
; If a monster slot has not otherwise set a target for the current command, this
; routine will select an appropriate random target depending on the command and
; subcommand. All commands other than spells will choose a random party target.
; Spells will choose a target depending on the properties of the spell itself
; and the given spell ID. If the spell ID is $00 through $30, the routine will
; select a random target from either the party or monster depending on what the
; spell defaults to (if it defaults to monsters, it will choose a party target).
; If the spell ID is $31 through $5E, $30 will be subtracted from the spell ID
; and then it will either target all monsters or all party members depending on
; the spell properties. Finally, for spells $5F or greater, it will choose all
; targets if the spell targets all, or a single target if not. Spells that have
; no targeting bits set will target the acting monster itself.
_battle_monster_script_default_set_target:
    LDA r_monster_script_current_monster_slot.w                                 ; $03B69F |\
    TAX                                                                         ; $03B6A2 | | If the monster already has party target set (e.g. from the Search
    LDA r_monster_next_party_target.w,X                                         ; $03B6A3 | | spell), set their party target to the specified value.
    BEQ +                                                                       ; $03B6A6 | |
    STZ r_monster_next_party_target.w,X                                         ; $03B6A8 | |
    LDX <r_current_slot_offset_character_battle                                 ; $03B6AB | |
    STA r_character_battle.1.targets.party.w,X                                  ; $03B6AD | |
    STZ r_character_battle.1.targets.monster.w,X                                ; $03B6B0 | |
    JMP @done                                                                   ; $03B6B3 |/
+   LDA r_monster_script_current_monster_slot.w                                 ; $03B6B6 |\
    TAX                                                                         ; $03B6B9 | | If this monster has already manually set a target, skip to the end
    LDA r_monster_target_set.w,X                                                ; $03B6BA | | of the function.
    BEQ +                                                                       ; $03B6BD | |
    JMP @done                                                                   ; $03B6BF |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03B6C2 |\
    LDA r_character_battle.1.command.w,X                                        ; $03B6C4 | | If the command was anything other than magic, jump to simply
    CMP #MONSTER_COMMAND_WHITE.b                                                ; $03B6C7 | | select a party target.
    BEQ +                                                                       ; $03B6C9 | |
    JMP @party                                                                  ; $03B6CB |/
+   LDA r_character_battle.1.subcommand.w,X                                     ; $03B6CE |\
    CMP #$31.b                                                                  ; $03B6D1 | | Skip ahead if the subcommand is $31 or greater.
    BCS ++                                                                      ; $03B6D3 |/
    TAX                                                                         ; $03B6D5 |\
    STX <r_copy_from_array_arg_index                                            ; $03B6D6 | | Load the data for the specified spell.
    LDX #bank0F.spell_property_data.w                                           ; $03B6D8 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03B6DB | |
    LDA #:bank0F.spell_property_data.b                                          ; $03B6DD | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03B6DF | |
    LDA #_sizeof_spell.b                                                        ; $03B6E1 | |
    JSR _copy_from_array                                                        ; $03B6E3 |/
@single:
    LDA r_copy_from_array_result.w + spell.time_targeting                       ; $03B6E6 |\
    BPL +                                                                       ; $03B6E9 | | If the spell targets monsters by default, branch forward to choose
    JMP @party                                                                  ; $03B6EB | | a party target. Otherwise, branch forward to choose an enemy
+   LDA #8.b                                                                    ; $03B6EE | | target.
    BRA @manual                                                                 ; $03B6F0 |/
++  CMP #$5F.b                                                                  ; $03B6F2 |\ If the spell ID is $5F or greater, branch forward.
    BCS ++                                                                      ; $03B6F4 |/
    SEC                                                                         ; $03B6F6 |\
    SBC #$30.b                                                                  ; $03B6F7 | | Subtract $30 from the spell ID and load the properties for the
    LDX <r_current_slot_offset_character_battle                                 ; $03B6F9 | | spell.
    STA r_character_battle.1.subcommand.w,X                                     ; $03B6FB | |
    TAX                                                                         ; $03B6FE | |
    STX <r_copy_from_array_arg_index                                            ; $03B6FF | |
    LDX #bank0F.spell_property_data.w                                           ; $03B701 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03B704 | |
    LDA #:bank0F.spell_property_data.b                                          ; $03B706 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03B708 | |
    LDA #_sizeof_spell.b                                                        ; $03B70A | |
    JSR _copy_from_array                                                        ; $03B70C |/
-   LDX <r_current_slot_offset_character_battle                                 ; $03B70F |\
    LDA r_copy_from_array_result.w + spell.time_targeting                       ; $03B711 | | If the spell targets the party by default, set the target to all
    BMI +                                                                       ; $03B714 | | monsters.
    LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03B716 | |
    STA r_character_battle.1.targets.monster.w,X                                ; $03B718 | |
    BRA @done                                                                   ; $03B71B |/
+   LDA #BATTLE_TARGET_PARTY_ALL.b                                              ; $03B71D |\
    LDX <r_current_slot_offset_character_battle                                 ; $03B71F | | Otherwise, set the target to all party members.
    STA r_character_battle.1.targets.party.w,X                                  ; $03B721 | |
    BRA @done                                                                   ; $03B724 |/
++  TAX                                                                         ; $03B726 |\
    STX <r_copy_from_array_arg_index                                            ; $03B727 | | Finally, if the spell ID is $5F or greater, load the properties
    LDX #bank0F.spell_property_data.w                                           ; $03B729 | | for the spell.
    STX <r_generic_tmp_ptr_addr                                                 ; $03B72C | |
    LDA #:bank0F.spell_property_data.b                                          ; $03B72E | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03B730 | |
    LDA #_sizeof_spell.b                                                        ; $03B732 | |
    JSR _copy_from_array                                                        ; $03B734 |/
    LDA r_copy_from_array_result.w + spell.time_targeting                       ; $03B737 |\
    AND #SPELL_TIME_TARGETING_TARGETING.b                                       ; $03B73A | | If the spell has any targeting bits set, branch forward.
    BNE +                                                                       ; $03B73C |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B73E |\
    TAX                                                                         ; $03B741 | | If not, the target is the monster itself. Set the appropriate bit
    TDC                                                                         ; $03B742 | | and branch to the end.
    JSR _set_bit_x                                                              ; $03B743 | |
    LDX <r_current_slot_offset_character_battle                                 ; $03B746 | |
    STA r_character_battle.1.targets.monster.w,X                                ; $03B748 | |
    BRA @done                                                                   ; $03B74B |/
+   AND #SPELL_TIME_TARGETING_TARGET_ALL.b                                      ; $03B74D |\ If the spell targets all, branch backward to code that will set the
    BNE -                                                                       ; $03B74F |/ target appropriately.
    JMP @single                                                                 ; $03B751 | Otherwise, jump to code that will set a single target.
@party:
    LDA #5.b                                                                    ; $03B754 | Load the value to select party targets.
@manual:
    STA <r_battle_generic_tmp_2                                                 ; $03B756 |\ Select a random target.
    JSR _monster_script_select_random_target                                    ; $03B758 |/
@done:
    RTS                                                                         ; $03B75B

; _battle_update_monster_current_script ($03:B75C)
;
; Intended to be called from within the monster script processing functions,
; updates the monster's current action set offset in the array at $360C with
; the offset for the action set determined by the monster's base offset at
; $35BF and the script index at $35BE.
_battle_update_monster_current_script:
    LDA r_monster_script_script_index.w                                         ; $03B75C |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03B75F | | Multiply the script index by the size of an action set to get the
    LDA #_sizeof_action_set.b                                                   ; $03B761 | | offset to the correct action set within a slot's data.
    STA <r_math_multiply_8bit_arg_2                                             ; $03B763 | |
    JSR _math_multiply_8bit                                                     ; $03B765 |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03B768 |\
    ASL A                                                                       ; $03B76B | | Set the X register to the monster slot times two.
    TAX                                                                         ; $03B76C |/
    CLC                                                                         ; $03B76D |\
    LDA r_monster_script_action_set_offset_base_lo.w                            ; $03B76E | | Set the monster's current action set offset to the base offset for
    ADC <r_math_multiply_8bit_result_lo                                         ; $03B771 | | this slot and then add the previously calculated offset above.
    STA r_monster_current_action_set_offset.w + 0,X                             ; $03B773 | |
    LDA r_monster_script_action_set_offset_base_hi.w                            ; $03B776 | |
    ADC <r_math_multiply_8bit_result_hi                                         ; $03B779 | |
    STA r_monster_current_action_set_offset.w + 1,X                             ; $03B77B |/
    RTS                                                                         ; $03B77E

; _monster_script_command_stat_change ($03:B77F)
;
; Handles several monster commands that cause stat changes in the monster. The
; actual instruction is passed in the accumulator, and its single parameter is
; passed in $A9. The different operations for each instruction are:
;  $E8 - Changes the monster's race to the parameter.
;  $E9 - Sets the monster's physical attack stats (loaded from table in ROM).
;  $EA - Sets the monster's physical defense stats (loaded from table in ROM).
;  $EB - Sets the monster's magic defense stats (loaded from table in ROM).
;  $EC - Adjusts the monster's speed (by a buggy formula).
;  $ED - Sets the element resistance and immunity properties.
;  $EE - Sets the monster's magic power (wisdom).
;  $EF - Sets the monster's element weakness bytes.
_monster_script_command_stat_change:
    LDX <r_current_slot_offset_character_battle                                 ; $03B77F | Set the X register to the stat record offset.
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03B781 |\
    BNE +                                                                       ; $03B783 | | If the command is $E8, change the monster's race to the value in
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B785 | | the parameter.
    STA r_character_battle.1.monster_race.w,X                                   ; $03B787 | |
    JMP @done                                                                   ; $03B78A |/
+   CMP #MONSTER_COMMAND_SET_PHYSICAL_ATTACK                                    ; $03B78D |\
    BNE +                                                                       ; $03B78F | | If the command is $E9, load the stats indicated by the parameter
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B791 | | and set the monster's physical attack stats.
    JSR _load_monster_derived_stats                                             ; $03B793 | |
    LDA r_copy_from_array_result.w + 128                                        ; $03B796 | |
    STA r_character_battle.1.physical_attack_multiplier.w,X                     ; $03B799 | |
    LDA r_copy_from_array_result.w + 129                                        ; $03B79C | |
    STA r_character_battle.1.physical_attack_accuracy.w,X                       ; $03B79F | |
    LDA r_copy_from_array_result.w + 130                                        ; $03B7A2 | |
    STA r_character_battle.1.physical_attack_base.w,X                           ; $03B7A5 | |
    RTS                                                                         ; $03B7A8 |/
+   CMP #MONSTER_COMMAND_SET_PHYSICAL_DEFENSE.b                                 ; $03B7A9 |\
    BNE +                                                                       ; $03B7AB | | If the command is $EA, load the stats indicated by the parameter
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B7AD | | and set the monster's physical defense stats.
    JSR _load_monster_derived_stats                                             ; $03B7AF | |
    LDA r_copy_from_array_result.w + 128                                        ; $03B7B2 | | NOTE: Unlike the main stat loading that takes place at the start
    STA r_character_battle.1.physical_defense_multiplier.w,X                    ; $03B7B5 | |       of battle, this one correctly sets the evade value.
    LDA r_copy_from_array_result.w + 129                                        ; $03B7B8 | |
    STA r_character_battle.1.physical_defense_evade.w,X                         ; $03B7BB | |
    LDA r_copy_from_array_result.w + 130                                        ; $03B7BE | |
    STA r_character_battle.1.physical_defense_base.w,X                          ; $03B7C1 | |
    RTS                                                                         ; $03B7C4 |/
+   CMP #MONSTER_COMMAND_SET_MAGIC_DEFENSE.b                                    ; $03B7C5 |\
    BNE +                                                                       ; $03B7C7 | | If the command is $EB, load the stats indicated by the parameter
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B7C9 | | and set the monster's magic defense stats.
    JSR _load_monster_derived_stats                                             ; $03B7CB | |
    LDA r_copy_from_array_result.w + 128                                        ; $03B7CE | | BUG: Similar to the main stat loading, this one fails to set magic
    STA r_character_battle.1.magic_defense_multiplier.w,X                       ; $03B7D1 | |      evade correctly.
    LDA r_copy_from_array_result.w + 129                                        ; $03B7D4 | |
    STA r_character_battle.1.magic_defense_base.w,X                             ; $03B7D7 | |
    LDA r_copy_from_array_result.w + 130                                        ; $03B7DA | |
    STA r_character_battle.1.magic_defense_base.w,X                             ; $03B7DD | |
    RTS                                                                         ; $03B7E0 |/
+   CMP #MONSTER_COMMAND_ADJUST_SPEED.b                                         ; $03B7E1 |\
    BNE +                                                                       ; $03B7E3 | | If the command is $EC, branch forward to the speed handler.
    JMP @adjust_speed                                                           ; $03B7E5 |/
+   CMP #MONSTER_COMMAND_SET_ELEMENT_DEFENSE.b                                  ; $03B7E8 |\
    BNE +                                                                       ; $03B7EA | | If the command is $ED, set the monster's element resistance to the
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B7EC | | parameter. If the immune bit is set, however, set immunity instead
    STA r_character_battle.1.element_resistance.w,X                             ; $03B7EE | | of resistance.
    BPL @done                                                                   ; $03B7F1 | |
    STA r_character_battle.1.element_immunity.w,X                               ; $03B7F3 | | NOTE: If trying to set both, immunity must be set first.
    STZ r_character_battle.1.element_resistance.w,X                             ; $03B7F6 | | TODO: Is that even a valid combination?
    RTS                                                                         ; $03B7F9 |/
+   CMP #MONSTER_COMMAND_SET_MAGIC_POWER.b                                      ; $03B7FA |\
    BNE +                                                                       ; $03B7FC | | If the command is $EE, set the monster's magic power.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B7FE | |
    STA r_character_battle.1.wisdom.w,X                                         ; $03B800 | |
    RTS                                                                         ; $03B803 |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03B804 |\
    BPL +                                                                       ; $03B806 | | If the command is $EF, set the element weakness byte if the immune
    STA r_character_battle.1.element_weakness_strong.w,X                        ; $03B808 | | bit is not set, and both weakness bytes if it is.
+   STA r_character_battle.1.element_weakness.w,X                               ; $03B80B |/
@done:
    RTS                                                                         ; $03B80E
@adjust_speed:
    PHX                                                                         ; $03B80F | Preserve the value of the X register (stat record offset).
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B810 |\
    STA r_math_multiply_16bit_arg_1_lo.w                                        ; $03B812 | | Multiply the parameter by the slot's relative speed.
    STZ r_math_multiply_16bit_arg_1_hi.w                                        ; $03B815 | |
    LDA r_character_battle.1.relative_speed_lo.w,X                              ; $03B818 | | NOTE: The high bit of the parameter is not masked out before
    STA r_math_multiply_16bit_arg_2_lo.w                                        ; $03B81B | |       multiplying, so it will taint the result.
    LDA r_character_battle.1.relative_speed_hi.w,X                              ; $03B81E | |
    STA r_math_multiply_16bit_arg_2_hi.w                                        ; $03B821 | |
    JSR _math_multiply_16bit                                                    ; $03B824 |/
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03B827 |\
    STX r_math_multiply_16bit_arg_1.w                                           ; $03B82A | | Multiply that value by 100 and then immediately divide by 1000.
    LDX #100.w                                                                  ; $03B82D | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03B830 | | NOTE: This is probably their "solution" to not masking out the
    JSR _math_multiply_16bit                                                    ; $03B833 | |       high bit, but it doesn't cover all cases and makes the
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03B836 | |       calculation even more vulnerable to overflow.
    STX r_math_divide_16bit_arg_1.w                                             ; $03B839 | |
    LDX #1000.w                                                                 ; $03B83C | |
    STX r_math_divide_16bit_arg_2.w                                             ; $03B83F | |
    JSR _math_divide_16bit                                                      ; $03B842 |/
    LDA r_math_divide_16bit_result_lo.w                                         ; $03B845 |\
    ORA r_math_divide_16bit_result_hi.w                                         ; $03B848 | | If the result was zero, set it to one.
    BNE +                                                                       ; $03B84B | |
    INC r_math_divide_16bit_result_lo.w                                         ; $03B84D |/
+   PLX                                                                         ; $03B850 | Restore the X register.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B851 |\
    BMI +                                                                       ; $03B853 | | If the parameter does not have the high bit set, add the result to
    CLC                                                                         ; $03B855 | | the slot's relative speed to calculate their new relative speed.
    LDA r_character_battle.1.relative_speed_lo.w,X                              ; $03B856 | |
    ADC r_math_divide_16bit_result_lo.w                                         ; $03B859 | |
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $03B85C | |
    LDA r_character_battle.1.relative_speed_hi.w,X                              ; $03B85F | |
    ADC r_math_divide_16bit_result_hi.w                                         ; $03B862 | |
    STA r_character_battle.1.relative_speed_hi.w,X                              ; $03B865 | |
    RTS                                                                         ; $03B868 |/
+   SEC                                                                         ; $03B869 |\
    LDA r_character_battle.1.relative_speed_lo.w,X                              ; $03B86A | | If the high bit is set, subtract the result from the relative
    SBC r_math_divide_16bit_result_lo.w                                         ; $03B86D | | speed instead.
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $03B870 | |
    LDA r_character_battle.1.relative_speed_hi.w,X                              ; $03B873 | |
    SBC r_math_divide_16bit_result_hi.w                                         ; $03B876 | |
    STA r_character_battle.1.relative_speed_hi.w,X                              ; $03B879 |/
    BCS +                                                                       ; $03B87C |\
    LDA #1.b                                                                    ; $03B87E | | If the result became negative, set the result to one.
    STA r_character_battle.1.relative_speed_lo.w,X                              ; $03B880 | | NOTE: This means a zero result is left at zero.
    STZ r_character_battle.1.relative_speed_hi.w,X                              ; $03B883 |/
+   RTS                                                                         ; $03B886

; _monster_script_command_update_flag ($03:B887)
;
; Given a command value in the accumulator and a parameter in $A9, updates the
; array at $35F3. The target array is indexed by the command minus $F4. The low
; six bits of the parameter are the update value. If neither of the high bits is
; set, the update value is added to the existing value. If the uppermost bit is
; set, the update value is used directly as the new value. Finally, if the
; second highest bit is set, the update value is subtracted from the existing
; value.
;
; NOTE: This is primarily meant to handle commands $F4 through $F7. However, $F8
;       and $FA also end up calling this routine, though they're not going to
;       end up modifying anything useful.
_monster_script_command_update_flag:
    SEC                                                                         ; $03B887 |\
    SBC #MONSTER_COMMAND_UNKNOWN_F4.b                                           ; $03B888 | | Determine the Y register by subtracting the base value.
    TAY                                                                         ; $03B88A |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B88B |\
    PHA                                                                         ; $03B88D | | Mask out the low six bits and save it back to the original
    AND #%00111111.b                                                            ; $03B88E | | location.
    STA <r_battle_generic_tmp_1_lo                                              ; $03B890 |/
    PLA                                                                         ; $03B892 |\
    AND #%11000000.b                                                            ; $03B893 | | If neither high bit is set, determine the new value by loading the
    BNE +                                                                       ; $03B895 | | previous value and adding the lower six bits of the parameter.
    CLC                                                                         ; $03B897 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03B898 | |
    ADC r_battle_monster_script_flags.w,Y                                       ; $03B89A | |
    BRA ++                                                                      ; $03B89D |/
+   AND #%10000000.b                                                            ; $03B89F |\
    BNE +                                                                       ; $03B8A1 | | If only the second highest bit is set, determine the new value by
    SEC                                                                         ; $03B8A3 | | subtracting the low six bits of the parameter from the original
    LDA r_battle_monster_script_flags.w,Y                                       ; $03B8A4 | | value.
    SBC <r_battle_generic_tmp_1_lo                                              ; $03B8A7 | |
    BRA ++                                                                      ; $03B8A9 |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03B8AB | If the highest bit is set, set the value directly.
++  STA r_battle_monster_script_flags.w,Y                                       ; $03B8AD | Store the new value back in the array.
    RTS                                                                         ; $03B8B0

; _monster_script_command_set_target ($03:B8B1)
;
; Handles processing the set target command and its various modes of operation.
; The X register should point to the current offset into the action data,
; specifically pointing to the parameter to this function. That value should
; also be passed in $A9. Parameters from $00 to $15 set the target to the
; character in question. The remaining modes all have dedicated handlers.
_monster_script_command_set_target:
    STX <r_monster_script_command_set_target_action_offset                      ; $03B8B1 | Save the current action offset.
    LDA r_monster_script_current_monster_slot.w                                 ; $03B8B3 |\
    TAX                                                                         ; $03B8B6 | | Indicate that this monster has manually set a target.
    INC r_monster_target_set.w,X                                                ; $03B8B7 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B8BA |\
    STZ r_character_battle.1.targets.monster.w,X                                ; $03B8BC | | Initially set the target values to zero.
    STZ r_character_battle.1.targets.party.w,X                                  ; $03B8BF |/
    LDA <r_battle_generic_tmp_1                                                 ; $03B8C2 |\
    CMP #MONSTER_SCRIPT_TARGET_SELF.b                                           ; $03B8C4 | | If the parameter value is less than $16, branch to the handler.
    BCC +                                                                       ; $03B8C6 |/
    SEC                                                                         ; $03B8C8 |\
    SBC #MONSTER_SCRIPT_TARGET_SELF.b                                           ; $03B8C9 | | Determine the index by subtracting the base value and multiplying
    ASL A                                                                       ; $03B8CB | | by two.
    TAX                                                                         ; $03B8CC |/
    LDA monster_script_command_set_target_pointer_data.l + 0,X                  ; $03B8CD |\
    STA <r_monster_script_command_set_target_tmp_ptr_addr_lo                    ; $03B8D1 | | Load the pointer for the appropriate handler and jump to it.
    LDA monster_script_command_set_target_pointer_data.l + 1,X                  ; $03B8D3 | |
    STA <r_monster_script_command_set_target_tmp_ptr_addr_hi                    ; $03B8D7 | |
    LDA #:monster_script_command_set_target_pointer_data.b                      ; $03B8D9 | |
    STA <r_monster_script_command_set_target_tmp_ptr_bank                       ; $03B8DB | |
    JML [r_monster_script_command_set_target_tmp_ptr.w]                         ; $03B8DD |/
+   TDC                                                                         ; $03B8E0 |\
    TAX                                                                         ; $03B8E1 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03B8E2 |/
-   LDA r_battle_slot_empty.w,Y                                                 ; $03B8E3 |\ Skip this slot if empty.
    BNE +                                                                       ; $03B8E6 |/
    LDA r_character_battle.1.id.w,X                                             ; $03B8E8 |\
    AND #%00011111.b                                                            ; $03B8EB | | Read the ID for this slot and skip the slot if it doesn't match
    CMP <r_battle_generic_tmp_1_lo                                              ; $03B8ED | | the desired value.
    BNE +                                                                       ; $03B8EF |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03B8F1 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B8F4 | | If the character is swooned, stoned, magnetized or jumping, branch
    BNE ++                                                                      ; $03B8F6 | | to code that jumps to another function.
    LDA r_character_battle.1.status_3.w,X                                       ; $03B8F8 | |
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03B8FB | |
    BNE ++                                                                      ; $03B8FD |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03B8FF |\ If the character is not hiding, skip to the end. Otherwise, ignore
    BPL +++                                                                     ; $03B902 |/ this slot.
+   JSR _increment_x_by_128                                                     ; $03B904 |\
    INY                                                                         ; $03B907 | | Increment the slot and loop until all five character slots have
    CPY #5.w                                                                    ; $03B908 | | been checked.
    BNE -                                                                       ; $03B90B |/
++  JMP _monster_script_wait                                                    ; $03B90D | If the character wasn't found or was dead, change command to wait.
+++ LDX <r_current_slot_offset_character_battle                                 ; $03B910 |\
    SEC                                                                         ; $03B912 | | Set the party target variable based on the determined slot number.
-   ROR r_character_battle.1.targets.party.w,X                                  ; $03B913 | |
    DEY                                                                         ; $03B916 | |
    BPL -                                                                       ; $03B917 |/
    RTS                                                                         ; $03B919

; _monster_script_command_set_target_self ($03:B91A)
;
; Sets the target for the current slot to the current monster itself.
_monster_script_command_set_target_self:
    LDA r_monster_script_current_monster_slot.w                                 ; $03B91A |\ Set the Y register to the current monster slot.
    TAY                                                                         ; $03B91D |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B91E |\
    SEC                                                                         ; $03B920 | | Shift the bit into the monster target value until the correct slot
-   ROR r_character_battle.1.targets.monster.w,X                                ; $03B921 | | number is set.
    DEY                                                                         ; $03B924 | |
    BPL -                                                                       ; $03B925 |/
    RTS                                                                         ; $03B927

; _monster_script_command_set_target_all_monsters ($03:B928)
;
; Sets the slot's target to all monsters.
_monster_script_command_set_target_all_monsters:
    LDX <r_current_slot_offset_character_battle                                 ; $03B928 |\
    LDA #%11111111.b                                                            ; $03B92A | | Set the target to all monsters.
    STA r_character_battle.1.targets.monster.w,X                                ; $03B92C |/
    RTS                                                                         ; $03B92F

; _monster_script_command_set_target_all_monsters_except_self ($03:B930)
;
; Sets the slot's target to all monsters except the calling monster. If there
; are no other monsters, the monster's command is changed to wait.
_monster_script_command_set_target_all_monsters_except_self:
    LDA r_monsters_remaining_total.w                                            ; $03B930 |\
    DEC A                                                                       ; $03B933 | | If there is only one monster remaining, change the monster's
    BNE +                                                                       ; $03B934 | | command to wait, as there are no other targets.
    JMP _monster_script_wait                                                    ; $03B936 |/
+   LDA r_monster_script_current_monster_slot.w                                 ; $03B939 |\
    TAX                                                                         ; $03B93C | | Set all bits except the one for the current slot.
    LDA #%11111111.b                                                            ; $03B93D | |
    JSR _unset_bit_x                                                            ; $03B93F |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B942 |\ Update the monster target value.
    STA r_character_battle.1.targets.monster.w,X                                ; $03B944 |/
    RTS                                                                         ; $03B947

; _monster_script_command_set_target_monster_type_0 ($03:B948)
;
; Sets the slot's target to any monster that has type index 0.
_monster_script_command_set_target_monster_type_0:
    LDA #0.b                                                                    ; $03B948 |\ Set the desired type index to zero and jump to the core routine.
    JMP _monster_script_command_set_target_monster_type_x                       ; $03B94A |/

; _monster_script_command_set_target_monster_type_x ($03:B94D)
;
; Sets the slot's target to any monster that has the type index passed in the
; accumulator.
_monster_script_command_set_target_monster_type_x:
    STA <r_battle_generic_tmp_1_lo                                              ; $03B94D | Save the desired type index to a temporary variable.
    TDC                                                                         ; $03B94F |\ Initialize the X register to zero.
    TAX                                                                         ; $03B950 |/
    STX <r_battle_generic_tmp_2                                                 ; $03B951 | Initialize the target value to zero.
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03B953 |\
    CMP <r_battle_generic_tmp_1_lo                                              ; $03B956 | | If the monster has the desired type index, set that bit in the
    BNE +                                                                       ; $03B958 | | target value.
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B95A | |
    JSR _set_bit_x                                                              ; $03B95C | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03B95F |/
+   INX                                                                         ; $03B961 |\
    CPX #8.w                                                                    ; $03B962 | | Increment the slot and loop until all eight have been checked.
    BNE -                                                                       ; $03B965 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03B967 |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B969 | | If no target was set, change the monster's command to wait.
    BNE +                                                                       ; $03B96B | |
    JMP _monster_script_wait                                                    ; $03B96D |/
+   STA r_character_battle.1.targets.monster.w,X                                ; $03B970 | Otherwise, set the target variable in its record.
    RTS                                                                         ; $03B973

; _monster_script_command_set_target_monster_type_1 ($03:B974)
;
; Sets the slot's target to any monster that has type index 1.
_monster_script_command_set_target_monster_type_1:
    LDA #1.b                                                                    ; $03B974 |\ Set the desired type index to one and jump to the core routine.
    JMP _monster_script_command_set_target_monster_type_x                       ; $03B976 |/

; _monster_script_command_set_target_monster_type_2 ($03:B979)
;
; Sets the slot's target to any monster that has type index 2.
_monster_script_command_set_target_monster_type_2:
    LDA #2.b                                                                    ; $03B979 |\ Set the desired type index to two and jump to the core routine.
    JMP _monster_script_command_set_target_monster_type_x                       ; $03B97B |/

; _monster_script_command_set_target_party_front_row ($03:B97E)
;
; Sets the slot's target to all party members in the front row who are not
; swooned, stone, magnetized, jumping or hiding.
_monster_script_command_set_target_party_front_row:
    JSR _monster_script_command_helper_get_party_front_row                      ; $03B97E | Get the target variable for all valid front row party members.
    LDX <r_current_slot_offset_character_battle                                 ; $03B981 |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B983 | | If no targets were set, change the monster's command to wait.
    BNE +                                                                       ; $03B985 | |
    JMP _monster_script_wait                                                    ; $03B987 |/
+   STA r_character_battle.1.targets.party.w,X                                  ; $03B98A | Otherwise, set the target variable.
    RTS                                                                         ; $03B98D

; _monster_script_command_helper_get_party_front_row ($03:B98E)
;
; Returns a target variable in $AB that has bits set for the characters who are
; in the front row. Characters are only added if they have none of the following
; statuses: swoon, stone, magnetized, jumping and hiding.
_monster_script_command_helper_get_party_front_row:
    TDC                                                                         ; $03B98E |\
    TAX                                                                         ; $03B98F | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03B990 |/
    STX <r_battle_generic_tmp_2                                                 ; $03B991 | Initialize the target variable to zero.
-   LDA r_battle_slot_empty.w,X                                                 ; $03B993 |\ Skip this slot if it's empty.
    BNE +                                                                       ; $03B996 |/
    LDA r_character_battle.1.status_1.w,Y                                       ; $03B998 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B99B | | Skip this slot if swooned or stone.
    BNE +                                                                       ; $03B99D |/
    LDA r_character_battle.1.status_3.w,Y                                       ; $03B99F |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03B9A2 | | Skip this slot if magnetized or jumping.
    BNE +                                                                       ; $03B9A4 |/
    LDA r_character_battle.1.status_4.w,Y                                       ; $03B9A6 |\ Skip this slot if hiding.
    BMI +                                                                       ; $03B9A9 |/
    LDA r_character_battle.1.sprite_class.w,Y                                   ; $03B9AB |\ Skip this slot if in the back row.
    BMI +                                                                       ; $03B9AE |/
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B9B0 |\
    JSR _set_bit_x                                                              ; $03B9B2 | | Set this slot in the target variable.
    STA <r_battle_generic_tmp_2_lo                                              ; $03B9B5 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03B9B7 |\
    TYA                                                                         ; $03B9B9 | | Increment the indexes and loop until all five slots have been
    CLC                                                                         ; $03B9BA | | checked.
    ADC #_sizeof_character_battle.w                                             ; $03B9BB | |
    TAY                                                                         ; $03B9BE | |
    TDC                                                                         ; $03B9BF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03B9C0 | |
    INX                                                                         ; $03B9C2 | |
    CPX #5.w                                                                    ; $03B9C3 | |
    BNE -                                                                       ; $03B9C6 |/
    RTS                                                                         ; $03B9C8

; _monster_script_command_set_target_party_back_row ($03:B9C9)
;
; Sets the slot's target to all party members in the back row who are not
; swooned, stone, magnetized, jumping or hiding.
_monster_script_command_set_target_party_back_row:
    JSR _monster_script_command_helper_get_party_back_row                       ; $03B9C9 | Get the target variable value for all valid back row party members.
    LDX <r_current_slot_offset_character_battle                                 ; $03B9CC |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B9CE | | If no targets were set, change the monster's command to wait.
    BNE +                                                                       ; $03B9D0 | |
    JMP _monster_script_wait                                                    ; $03B9D2 |/
+   STA r_character_battle.1.targets.party.w,X                                  ; $03B9D5 | Otherwise, set the target variable.
    RTS                                                                         ; $03B9D8

; _monster_script_command_helper_get_party_back_row ($03:B9D9)
;
; Returns a target variable in $AB that has bits set for the characters who are
; in the back row. Characters are only added if they have none of the following
; statuses: swoon, stone, magnetized, jumping and hiding.
_monster_script_command_helper_get_party_back_row:
    TDC                                                                         ; $03B9D9 |\
    TAX                                                                         ; $03B9DA | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03B9DB |/
    STX <r_battle_generic_tmp_2                                                 ; $03B9DC | Initialize the target result variable to zero.
-   LDA r_battle_slot_empty.w,X                                                 ; $03B9DE |\ Skip this slot if empty.
    BNE +                                                                       ; $03B9E1 |/
    LDA r_character_battle.1.status_1.w,Y                                       ; $03B9E3 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03B9E6 | | Skip this slot if stoned or swooned.
    BNE +                                                                       ; $03B9E8 |/
    LDA r_character_battle.1.status_3.w,Y                                       ; $03B9EA |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03B9ED | | Skip this slot if magnetized or jumping.
    BNE +                                                                       ; $03B9EF |/
    LDA r_character_battle.1.status_4.w,Y                                       ; $03B9F1 |\ Skip this slot if hiding.
    BMI +                                                                       ; $03B9F4 |/
    LDA r_character_battle.1.sprite_class.w,Y                                   ; $03B9F6 |\ Skip this slot if not in the back row.
    BPL +                                                                       ; $03B9F9 |/
    LDA <r_battle_generic_tmp_2_lo                                              ; $03B9FB |\
    JSR _set_bit_x                                                              ; $03B9FD | | Set the appropriate bit in the target variable.
    STA <r_battle_generic_tmp_2_lo                                              ; $03BA00 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03BA02 |\
    TYA                                                                         ; $03BA04 | | Increment the indexes and loop until all five slots have been
    CLC                                                                         ; $03BA05 | | checked.
    ADC #_sizeof_character_battle                                               ; $03BA06 | |
    TAY                                                                         ; $03BA09 | |
    TDC                                                                         ; $03BA0A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BA0B | |
    INX                                                                         ; $03BA0D | |
    CPX #5.w                                                                    ; $03BA0E | |
    BNE -                                                                       ; $03BA11 |/
    RTS                                                                         ; $03BA13

; _monster_script_command_set_target_monster_status_paralyze ($03:BA14)
;
; Sets the slot's target to the monster with the lowest slot number that has
; the paralyze status.
_monster_script_command_set_target_monster_status_paralyze:
    LDA #STATUS_2_PARALYZE.b                                                    ; $03BA14 |\
    STA <r_monster_script_command_arg_status_2_mask                             ; $03BA16 | | Check for monsters who have the paralyze status.
    STZ <r_monster_script_command_arg_status_4_mask                             ; $03BA18 | |
    STZ <r_monster_script_command_arg_status_1_mask                             ; $03BA1A |/
    STZ <r_monster_script_command_arg_all                                       ; $03BA1C | Check for the first monster.
    JMP _monster_script_command_set_target_monster_status                       ; $03BA1E | Execute the search.

; _monster_script_command_set_target_monster_status ($03:BA21)
;
; Sets the slot's target to monsters based on matching status bytes, with the
; desired masks passed in $AD (second byte), $AE (fourth byte) and $AF (first
; byte). Additionally, if $B0 is non-zero, it will scan for all matching
; monsters. Otherwise, it simply finds the first.
_monster_script_command_set_target_monster_status:
    LDY #_sizeof_character_battle.w * 5                                         ; $03BA21 | Initialize the Y register to the first monster's stats offset.
    TDC                                                                         ; $03BA24 |\ Initialize the X register to zero.
    TAX                                                                         ; $03BA25 |/
    STX <r_battle_generic_tmp_2                                                 ; $03BA26 | Initialize target variable to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03BA28 | Initialize monster slot to zero.
-   CLC                                                                         ; $03BA2A |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BA2B | | If this slot is empty, skip to the next slot.
    ADC #5.b                                                                    ; $03BA2D | |
    TAX                                                                         ; $03BA2F | |
    LDA r_battle_slot_empty.w,X                                                 ; $03BA30 | |
    BNE ++                                                                      ; $03BA33 |/
    LDA r_character_battle.1.status_1.w,Y                                       ; $03BA35 |\
    AND <r_monster_script_command_arg_status_1_mask                             ; $03BA38 | | Check if any of the desired status bits are set. If not, branch
    BNE +                                                                       ; $03BA3A | | to the next iteration of the loop.
    LDA r_character_battle.1.status_2.w,Y                                       ; $03BA3C | |
    AND <r_monster_script_command_arg_status_2_mask                             ; $03BA3F | |
    BNE +                                                                       ; $03BA41 | |
    LDA r_character_battle.1.status_4.w,Y                                       ; $03BA43 | |
    AND <r_monster_script_command_arg_status_4_mask                             ; $03BA46 | |
    BEQ ++                                                                      ; $03BA48 |/
+   LDX <r_battle_generic_tmp_1                                                 ; $03BA4A |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BA4C | | Update the target variable with the slot number being examined.
    JSR _set_bit_x                                                              ; $03BA4E | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03BA51 |/
    LDA <r_monster_script_command_arg_all                                       ; $03BA53 |\ If the all argument isn't set, skip to the end.
    BEQ +                                                                       ; $03BA55 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $03BA57 |\
    TYA                                                                         ; $03BA59 | | Increment the indexes and loop until all eight slots have been
    CLC                                                                         ; $03BA5A | | checked.
    ADC #_sizeof_character_battle.w                                             ; $03BA5B | |
    TAY                                                                         ; $03BA5E | |
    TDC                                                                         ; $03BA5F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BA60 | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03BA62 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BA64 | |
    CMP #8.b                                                                    ; $03BA66 | |
    BNE -                                                                       ; $03BA68 |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03BA6A |\
    LDA <r_battle_generic_tmp_2                                                 ; $03BA6C | | If no targets were set, set the monster's command to wait.
    BNE +                                                                       ; $03BA6E | |
    JMP _monster_script_wait                                                    ; $03BA70 |/
+   STA r_character_battle.1.targets.monster.w,X                                ; $03BA73 | Otherwise, set the target variable.
    RTS                                                                         ; $03BA76

; _monster_script_command_set_target_monster_status_sleep ($03:BA77)
;
; Sets the slot's target to the monster with the lowest slot number that has the
; sleep status.
_monster_script_command_set_target_monster_status_sleep:
    LDA #STATUS_2_SLEEP.b                                                       ; $03BA77 |\
    STA <r_monster_script_command_arg_status_2_mask                             ; $03BA79 | | Set the arguments to search for one sleeping monster.
    STZ <r_monster_script_command_arg_status_4_mask                             ; $03BA7B | |
    STZ <r_monster_script_command_arg_status_1_mask                             ; $03BA7D | |
    STZ <r_monster_script_command_arg_all                                       ; $03BA7F |/
    JMP _monster_script_command_set_target_monster_status                       ; $03BA81 | Execute the search.

; _monster_script_command_set_target_monster_status_charm ($03:BA84)
;
; Sets the slot's target to the monster with the lowest slot number that has the
; charm status.
_monster_script_command_set_target_monster_status_charm:
    LDA #STATUS_2_CHARM.b                                                       ; $03BA84 |\
    STA <r_monster_script_command_arg_status_2_mask                             ; $03BA86 | | Set the arguments to search for one charmed monster.
    STZ <r_monster_script_command_arg_status_4_mask                             ; $03BA88 | |
    STZ <r_monster_script_command_arg_status_1_mask                             ; $03BA8A | |
    STZ <r_monster_script_command_arg_all                                       ; $03BA8C |/
    JMP _monster_script_command_set_target_monster_status                       ; $03BA8E | Execute the search.

; _monster_script_command_set_target_monster_status_critical ($03:BA91)
;
; Sets the slot's target to the monster with the lowest slot number that has the
; HP critical status.
_monster_script_command_set_target_monster_status_critical:
    STZ <r_monster_script_command_arg_status_2_mask                             ; $03BA91 |\
    LDA #STATUS_4_CRITICAL                                                      ; $03BA93 | | Set the argument to search for one HP critical monster.
    STA <r_monster_script_command_arg_status_4_mask                             ; $03BA95 | |
    STZ <r_monster_script_command_arg_status_1_mask                             ; $03BA97 | |
    STZ <r_monster_script_command_arg_all                                       ; $03BA99 |/
    JMP _monster_script_command_set_target_monster_status                       ; $03BA9B | Execute the search.

; _monster_script_command_set_target_random_any ($03:BA9E)
;
; Sets the slot's target to a random character or monster.
_monster_script_command_set_target_random_any:
    LDA #(5 + 8 - 1).b                                                          ; $03BA9E |\
    STA <r_monster_set_target_random_arg_maximum                                ; $03BAA0 | | Configure the target search to select a random character or
    LDA #0.b                                                                    ; $03BAA2 | | monster with no exclusion.
    STA <r_monster_set_target_random_arg_minimum                                ; $03BAA4 | |
    DEC A                                                                       ; $03BAA6 | |
    STA <r_monster_set_target_random_arg_exclude                                ; $03BAA7 |/
    JMP _monster_script_command_set_target_random                               ; $03BAA9 | Execute the search.

; _monster_script_command_set_target_random ($03:BAAC)
;
; Sets the slot's target to a random monster or character, depending on the
; parameters. The minimum slot number is passed in $AF, the maximum slot number
; is passed in $B0, and a slot number that should be excluded from consideration
; is passed in $AD.
;
; BUG: If for whatever reason, none of the slots is a valid target, the game
;      will loop indefinitely.
_monster_script_command_set_target_random:
-   LDA <r_monster_set_target_random_arg_minimum                                ; $03BAAC |\
    TAX                                                                         ; $03BAAE | | Fetch random slots in the desired range until finding one that is
    LDA <r_monster_set_target_random_arg_maximum                                ; $03BAAF | | not the excluded slot.
    JSR _get_battle_rng                                                         ; $03BAB1 | |
    CMP <r_monster_set_target_random_arg_exclude                                ; $03BAB4 | |
    BEQ -                                                                       ; $03BAB6 |/
    STA <r_battle_generic_tmp_1_lo                                              ; $03BAB8 | Save the slot number to a variable.
    TAX                                                                         ; $03BABA |\
    LDA r_battle_slot_empty.w,X                                                 ; $03BABB | | Loop until the slot is not empty.
    BNE -                                                                       ; $03BABE |/
    TXA                                                                         ; $03BAC0 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03BAC1 | | Set the X register to the offset to that slot's stat record.
    LDA #_sizeof_character_battle.b                                             ; $03BAC3 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03BAC5 | |
    JSR _math_multiply_8bit                                                     ; $03BAC7 | |
    LDX <r_math_multiply_8bit_result                                            ; $03BACA |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03BACC |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03BACF | | Skip this slot if swoon or stone.
    BNE -                                                                       ; $03BAD1 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03BAD3 |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03BAD6 | | Skip this slot if magnetized or jumping.
    BNE -                                                                       ; $03BAD8 |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03BADA |\ Skip this slot if hiding.
    BMI -                                                                       ; $03BADD |/
    LDA <r_battle_generic_tmp_1                                                 ; $03BADF |\
    CMP #5.b                                                                    ; $03BAE1 | | If this is a monster slot, branch forward to the monster code.
    BCS +                                                                       ; $03BAE3 |/
    TAX                                                                         ; $03BAE5 |\
    TDC                                                                         ; $03BAE6 | | Set the party target to the correct value for this slot.
    JSR _set_bit_x                                                              ; $03BAE7 | |
    LDX <r_current_slot_offset_character_battle                                 ; $03BAEA | |
    STA r_character_battle.1.targets.party.w,X                                  ; $03BAEC | |
    BRA ++                                                                      ; $03BAEF |/
+   SEC                                                                         ; $03BAF1 |\
    SBC #5.b                                                                    ; $03BAF2 | | If this is a monster slot, set the monstet target to the correct
    TAX                                                                         ; $03BAF4 | | value for this slot.
    TDC                                                                         ; $03BAF5 | |
    JSR _set_bit_x                                                              ; $03BAF6 | |
    LDX <r_current_slot_offset_character_battle                                 ; $03BAF9 | |
    STA r_character_battle.1.targets.monster.w,X                                ; $03BAFB |/
++  RTS                                                                         ; $03BAFE

; _monster_script_command_set_target_random_any_except_self ($03:BAFF)
;
; Sets the slot's target to a random character or monster other than the acting
; monster itself.
_monster_script_command_set_target_random_any_except_self:
    LDA #0.b                                                                    ; $03BAFF |\
    STA <r_monster_set_target_random_arg_minimum                                ; $03BB01 | | Configure the search to find a random character or monster, except
    LDA #(5 + 8 - 1).b                                                          ; $03BB03 | | for the acting monster.
    STA <r_monster_set_target_random_arg_maximum                                ; $03BB05 | |
    LDA <r_battle_timer_slot                                                    ; $03BB07 | |
    STA <r_monster_set_target_random_arg_exclude                                ; $03BB09 |/
    JMP _monster_script_command_set_target_random                               ; $03BB0B | Execute the search.

; _monster_script_command_set_target_random_monster ($03:BB0E)
;
; Sets the slot's target to a random monster.
_monster_script_command_set_target_random_monster:
    LDA #5.b                                                                    ; $03BB0E |\
    STA <r_monster_set_target_random_arg_minimum                                ; $03BB10 | | Configure the target search to find a random monster.
    LDA #(5 + 8 - 1).b                                                          ; $03BB12 | |
    STA <r_monster_set_target_random_arg_maximum                                ; $03BB14 | |
    LDA #$FF.b                                                                  ; $03BB16 | |
    STA <r_monster_set_target_random_arg_exclude                                ; $03BB18 |/
    JMP _monster_script_command_set_target_random                               ; $03BB1A | Execute the search.

; _monster_script_command_set_target_random_monster_except_self ($03:BB1D)
;
; Sets the slot's target to a random monster except the acting monster itself.
; If there are no other monsters, the monster's command is instead replaced with
; the wait command.
_monster_script_command_set_target_random_monster_except_self:
    LDA r_monsters_remaining_total.w                                            ; $03BB1D |\
    DEC A                                                                       ; $03BB20 | | If there is only one remaining monster, set the command to wait.
    BNE +                                                                       ; $03BB21 | |
    JMP _monster_script_wait                                                    ; $03BB23 |/
+   LDA #5.b                                                                    ; $03BB26 |\
    STA <r_monster_set_target_random_arg_minimum                                ; $03BB28 | | Otherwise, configure the search to find a random monster other
    LDA #$0C.b                                                                  ; $03BB2A | | than the acting monster.
    STA <r_monster_set_target_random_arg_maximum                                ; $03BB2C | |
    LDA <r_battle_timer_slot                                                    ; $03BB2E | |
    STA <r_monster_set_target_random_arg_exclude                                ; $03BB30 |/
    JMP _monster_script_command_set_target_random                               ; $03BB32 | Execute the search.

; _monster_script_command_set_target_random_party_front_row ($03:BB35)
;
; Sets the slot's target to a random front row party member.
_monster_script_command_set_target_random_party_front_row:
    JSR _monster_script_command_helper_get_party_front_row                      ; $03BB35 |\ Get the target variable for the front row of the party (who are
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BB38 |/ valid targets).
    BNE @start                                                                  ; $03BB3A |\ If there were no targets set, change the command to wait.
    JMP _monster_script_wait                                                    ; $03BB3C |/
@start:
    JSR _get_battle_rng_0_4                                                     ; $03BB3F |\
    TAX                                                                         ; $03BB42 | | Select a random slot among those returned in the previous check.
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BB43 | | Mask out only that bit.
    JSR _mask_bit_x                                                             ; $03BB45 | |
    BEQ @start                                                                  ; $03BB48 |/
    TDC                                                                         ; $03BB4A |\ Set that same bit in a fresh variable for some reason.
    JSR _set_bit_x                                                              ; $03BB4B |/
    LDX <r_current_slot_offset_character_battle                                 ; $03BB4E |\ Set that as the monster's target.
    STA r_character_battle.1.targets.party.w,X                                  ; $03BB50 |/
    RTS                                                                         ; $03BB53

; _monster_script_command_set_target_random_party_back_row ($03:BB54)
;
; Sets the slot's target to a random back row party member.
_monster_script_command_set_target_random_party_back_row:
    JSR _monster_script_command_helper_get_party_back_row                       ; $03BB54 |\ Get the target variable for the back row of the party (who are
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BB57 |/ valid targets).
    BNE @start                                                                  ; $03BB59 |\ If there were no targets set, change the command to wait.
    JMP _monster_script_wait                                                    ; $03BB5B |/
@start:
    JSR _get_battle_rng_0_4                                                     ; $03BB5E |\
    TAX                                                                         ; $03BB61 | | Select a random slot from those returned by the previous routine.
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BB62 | |
    JSR _mask_bit_x                                                             ; $03BB64 | |
    BEQ @start                                                                  ; $03BB67 |/
    TDC                                                                         ; $03BB69 |\ Set that bit in a fresh variable.
    JSR _set_bit_x                                                              ; $03BB6A |/
    LDX <r_current_slot_offset_character_battle                                 ; $03BB6D |\ Set that value as the slot's party target value.
    STA r_character_battle.1.targets.party.w,X                                  ; $03BB6F |/
    RTS                                                                         ; $03BB72

; _monster_script_command_set_target_party_all ($03:BB73)
;
; Sets the slot's target to all party members.
_monster_script_command_set_target_party_all:
    LDX <r_current_slot_offset_character_battle                                 ; $03BB73 |\
    LDA #%11111000.b                                                            ; $03BB75 | | Set the target to all party members.
    STA r_character_battle.1.targets.party.w,X                                  ; $03BB77 |/
    RTS                                                                         ; $03BB7A

; _monster_script_command_set_target_monster_dead_all ($03:BB7B)
;
; Sets the slot's target to all dead monsters.
_monster_script_command_set_target_monster_dead_all:
    STZ <r_monster_script_command_arg_status_2_mask                             ; $03BB7B |\
    STZ <r_monster_script_command_arg_status_4_mask                             ; $03BB7D | | Set the target to target all dead monsters.
    LDA #STATUS_1_SWOON.b                                                       ; $03BB7F | |
    STA <r_monster_script_command_arg_status_1_mask                             ; $03BB81 | |
    STA <r_monster_script_command_arg_all                                       ; $03BB83 | |
    JMP _monster_script_command_set_target_monster_status                       ; $03BB85 |/

UNUSED_CODE_03BB88:
    RTS                                                                         ; $03BB88

; _monster_script_wait ($03:BB89)
;
; Replaces the monster's next command with commands to wait. If a counter is
; active, modifies $3659,X. Otherwise, it modifies $3839.
;
; TODO: Why are these separate anyway?
_monster_script_wait:
    LDA r_battle_counter_active.w                                               ; $03BB89 |\ If a counter is not active, branch to other code.
    BEQ +                                                                       ; $03BB8C |/
    JSR _monster_script_wait_if_chain                                           ; $03BB8E | If a chain is active, set the monster's script to wait.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BB91 |\
    BNE ++                                                                      ; $03BB93 | | Otherwise, update the script manually.
    LDX r_battle_current_action_set_offset.w                                    ; $03BB95 | |
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03BB98 | |
    STA r_monster_script_current_modified_action_sets.w + 0,X                   ; $03BB9A | |
    TDC                                                                         ; $03BB9D | |
    STA r_monster_script_current_modified_action_sets.w + 1,X                   ; $03BB9E | |
    DEC A                                                                       ; $03BBA1 | |
    STA r_monster_script_current_modified_action_sets.w + 2,X                   ; $03BBA2 | |
    BRA ++                                                                      ; $03BBA5 |/
+   LDX <r_monster_script_command_set_target_action_offset                      ; $03BBA7 |\ Increment the action offset to affect the next command.
    INX                                                                         ; $03BBA9 |/
    JSR _monster_script_wait_if_chain_separate                                  ; $03BBAA | If there is a chain, change it to wait and end the chain.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BBAD |\
    BNE ++                                                                      ; $03BBAF | | Otherwise, simply set it to wait.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03BBB1 | |
    STA r_monster_script_current_modified_action_set.w + 0,X                    ; $03BBB3 | |
    TDC                                                                         ; $03BBB6 | |
    STA r_monster_script_current_modified_action_set.w + 1,X                    ; $03BBB7 | |
    DEC A                                                                       ; $03BBBA | |
    STA r_monster_script_current_modified_action_set.w + 2,X                    ; $03BBBB |/
++  LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03BBBE |\
    LDX <r_current_slot_offset_character_battle                                 ; $03BBC0 | | Set the monster's command to wait.
    STA r_character_battle.1.command.w,X                                        ; $03BBC2 |/
    RTS                                                                         ; $03BBC5

; monster_script_command_set_target_pointer_data ($03:BBC6)
;
; For each of the set target parameters of $16 and above, provides a pointer to
; the handler for that option.
monster_script_command_set_target_pointer_data:
    .addr _monster_script_command_set_target_self                               ; $03BBC6.BBC7 | $16: Self
    .addr _monster_script_command_set_target_all_monsters                       ; $03BBC8.BBC9 | $17: All monsters
    .addr _monster_script_command_set_target_all_monsters_except_self           ; $03BBCA.BBCB | $18: All monsters except self
    .addr _monster_script_command_set_target_monster_type_0                     ; $03BBCC.BBCD | $19: All monsters of type 0
    .addr _monster_script_command_set_target_monster_type_1                     ; $03BBCE.BBCF | $1A: All monsters of type 1
    .addr _monster_script_command_set_target_monster_type_2                     ; $03BBD0.BBD1 | $1B: All monsters of type 2
    .addr _monster_script_command_set_target_party_front_row                    ; $03BBD2.BBD3 | $1C: Party front row
    .addr _monster_script_command_set_target_party_back_row                     ; $03BBD4.BBD5 | $1D: Party back row
    .addr _monster_script_command_set_target_monster_status_paralyze            ; $03BBD6.BBD7 | $1E: First paralyzed monster
    .addr _monster_script_command_set_target_monster_status_sleep               ; $03BBD8.BBD9 | $1F: First sleeping monster
    .addr _monster_script_command_set_target_monster_status_charm               ; $03BBDA.BBDB | $20: First charmed monster
    .addr _monster_script_command_set_target_monster_status_critical            ; $03BBDC.BBDD | $21: First HP critical monster
    .addr _monster_script_command_set_target_random_any                         ; $03BBDE.BBDF | $22: Random character or monster
    .addr _monster_script_command_set_target_random_any_except_self             ; $03BBE0.BBE1 | $23: Random character or monster except self
    .addr _monster_script_command_set_target_random_monster                     ; $03BBE2.BBE3 | $24: Random monster
    .addr _monster_script_command_set_target_random_monster_except_self         ; $03BBE4.BBE5 | $25: Random monster except self
    .addr _monster_script_command_set_target_random_party_front_row             ; $03BBE6.BBE7 | $26: Random front row party member
    .addr _monster_script_command_set_target_random_party_back_row              ; $03BBE8.BBE9 | $27: Random back row party member
    .addr _monster_script_command_set_target_party_all                          ; $03BBEA.BBEB | $28: All party members
    .addr _monster_script_command_set_target_monster_dead_all                   ; $03BBEC.BBED | $29: All dead monsters

; _battle_timer_set_action_fixed ($03:BBEE)
;
; Given a slot number in the timer slot variable at $D2, sets the action timer
; for that slot using the fixed timer calculation mode and sets the command
; flag.
_battle_timer_set_action_fixed:
    LDA #TIMER_MODE_FIXED_2.b                                                   ; $03BBEE |\ Set the timer calculation mode to fixed.
    STA <r_calculate_timer_value_arg_mode                                       ; $03BBF0 |/
    LDA <r_battle_timer_slot                                                    ; $03BBF2 |\ Calculate the timer value.
    JSR _calculate_timer_value                                                  ; $03BBF4 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03BBF7 |\ Set the timer value for the action timer.
    JSR _set_timer_value                                                        ; $03BBF9 |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03BBFC |\ Flag the timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03BBFE |/
    RTS                                                                         ; $03BC01

; _monster_script_reset_modified_action_set ($03:BC02)
;
; Resets the modified action set for the slot in $D2, by writing nothing but
; $FF to the monster's section of the array at $3659.
_monster_script_reset_modified_action_set:
    SEC                                                                         ; $03BC02 |\
    LDA <r_battle_timer_slot                                                    ; $03BC03 | | Determine the monster slot number by subtracting five from the
    SBC #5.b                                                                    ; $03BC05 | | actual slot for the timer being processed.
    STA <r_math_multiply_8bit_arg_1                                             ; $03BC07 |/
    LDA #_sizeof_action_set.b                                                   ; $03BC09 |\
    STA <r_math_multiply_8bit_arg_2                                             ; $03BC0B | | Multiply that slot by the size of an action set.
    JSR _math_multiply_8bit                                                     ; $03BC0D |/
    LDY #_sizeof_action_set.w                                                   ; $03BC10 | Set the Y register to the size of an action set.
    LDX <r_math_multiply_8bit_result                                            ; $03BC13 | Set the X register to the offset to this monster's action set.
    STX r_battle_current_action_set_offset.w                                    ; $03BC15 | Save the action set offset to memory for later use.
    LDA #MONSTER_COMMAND_END.b                                                  ; $03BC18 |\
-   STA r_monster_script_current_modified_action_sets.w,X                       ; $03BC1A | | Clear the monster's individual modified action set.
    INX                                                                         ; $03BC1D | |
    DEY                                                                         ; $03BC1E | |
    BNE -                                                                       ; $03BC1F |/
    RTS                                                                         ; $03BC21

; _monster_script_reset_shared_modified_action_set ($03:BC22)
;
; Resets the shared modified action set at $3839 by writing nothing but $FF
; commands to that array.
_monster_script_reset_shared_modified_action_set:
    LDX #_sizeof_action_set.w - 1                                               ; $03BC22 |\
    LDA #MONSTER_COMMAND_END.b                                                  ; $03BC25 | | Write nothing but end commands to the shared modified action set.
-   STA r_monster_script_current_modified_action_set.w,X                        ; $03BC27 | |
    DEX                                                                         ; $03BC2A | |
    BPL -                                                                       ; $03BC2B |/
    RTS                                                                         ; $03BC2D

; _monster_script_copy_shared_modified_action_set_to_monster ($03:BC2E)
;
; Copies the shared modified action set at $3839 back to the $3659 array at the
; index passed in $38BB.
_monster_script_copy_shared_modified_action_set_to_monster:
    LDX r_battle_current_action_set_offset.w                                    ; $03BC2E | Load the current action set offset into the X register.
    TDC                                                                         ; $03BC31 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03BC32 |/
-   LDA r_monster_script_current_modified_action_set.w,Y                        ; $03BC33 |\
    STA r_monster_script_current_modified_action_sets.w,X                       ; $03BC36 | | Copy the data from the shared modified action set back to the
    INX                                                                         ; $03BC39 | | monster's actual modified action set.
    INY                                                                         ; $03BC3A | |
    CPY #_sizeof_action_set.w                                                   ; $03BC3B | |
    BNE -                                                                       ; $03BC3E |/
    RTS                                                                         ; $03BC40

; _monster_script_select_random_target ($03:BC41)
;
; Given the current slot offset in $A6 and either 5 (for the party) or 8 (for
; the monsters) in $AB, selects a random target and sets the slot's target
; variables appropriately. If choosing among party targets and there are none
; that are valid, the function sets the monster's action code to simply wait.
_monster_script_select_random_target:
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BC41 |\
    CMP #8.b                                                                    ; $03BC43 | | If the number of targets was set to 8, branch to other code.
    BEQ @random_target                                                          ; $03BC45 |/
    TDC                                                                         ; $03BC47 |\
    TAX                                                                         ; $03BC48 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03BC49 |/
    STX <r_battle_generic_tmp_1                                                 ; $03BC4A | Initialize the target scan result to zero.
-   LDA r_battle_slot_empty.w,Y                                                 ; $03BC4C |\ Skip this slot if it's empty.
    BNE +                                                                       ; $03BC4F |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03BC51 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03BC54 | | Skip this slot if it has the swoon or stone statuses.
    BNE +                                                                       ; $03BC56 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03BC58 |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03BC5B | | Skip this slot if it's magnetized or jumping.
    BNE +                                                                       ; $03BC5D |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03BC5F |\ Skip this slot if it's hiding.
    BMI +                                                                       ; $03BC62 |/
    INC <r_battle_generic_tmp_1_lo                                              ; $03BC64 |\ We found a valid target, so set the scan result to one and branch
    BRA ++                                                                      ; $03BC66 |/ forward.
+   JSR _increment_x_by_128                                                     ; $03BC68 |\
    INY                                                                         ; $03BC6B | | Increment the indexes and loop until all five slots have been
    CPY #5.w                                                                    ; $03BC6C | | tested.
    BNE -                                                                       ; $03BC6F |/
++  LDA <r_battle_generic_tmp_1_lo                                              ; $03BC71 |\ If a valid target was found, branch ahead to a later section.
    BNE @random_target                                                          ; $03BC73 |/
    TDC                                                                         ; $03BC75 |\ Set the X register to zero.
    TAX                                                                         ; $03BC76 |/
    JSR _monster_script_wait_if_chain_separate                                  ; $03BC77 | Set the monster's command to wait if there is a chain.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BC7A |\
    BNE +                                                                       ; $03BC7C | | If there wasn't, update the the monster's modified action set
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03BC7E | | manually.
    STA r_monster_script_current_modified_action_set.w + 0                      ; $03BC80 | |
    TDC                                                                         ; $03BC83 | |
    STA r_monster_script_current_modified_action_set.w + 1                      ; $03BC84 | |
    DEC A                                                                       ; $03BC87 | |
    STA r_monster_script_current_modified_action_set.w + 2                      ; $03BC88 |/
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03BC8B |\
    LDX <r_current_slot_offset_character_battle                                 ; $03BC8D | | Set the slot's command to wait.
    STA r_character_battle.1.command.w,X                                        ; $03BC8F |/
+   RTS                                                                         ; $03BC92
@random_target:
    STZ <r_battle_generic_tmp_3_lo                                              ; $03BC93 |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BC95 | | If targeting monsters, set a temporary variable to 1. Otherwise,
    CMP #8.b                                                                    ; $03BC97 | | set it to zero.
    BNE @start                                                                  ; $03BC99 | |
    INC <r_battle_generic_tmp_3_lo                                              ; $03BC9B |/
@start:
    LDX #1.w                                                                    ; $03BC9D |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BCA0 | | Get a random slot number based on the number of targets parameter
    JSR _get_battle_rng                                                         ; $03BCA2 | | passed in.
    DEC A                                                                       ; $03BCA5 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03BCA6 |/
    LDA <r_battle_generic_tmp_3_lo                                              ; $03BCA8 |\
    BEQ +                                                                       ; $03BCAA | | If this is a monster target, add five to the slot number to get
    CLC                                                                         ; $03BCAC | | the true slot number.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BCAD | |
    ADC #5.b                                                                    ; $03BCAF | |
    BRA ++                                                                      ; $03BCB1 |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03BCB3 |\
++  ASL A                                                                       ; $03BCB5 | | Ensure that this slot has active timers.
    TAY                                                                         ; $03BCB6 | |
    LDA r_battle_enabled_timers.1.hi.w,Y                                        ; $03BCB7 | |
    BEQ @start                                                                  ; $03BCBA |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BCBC |\
    TAY                                                                         ; $03BCBE | | Load the slot and add one (to determine number of bit shifts).
    INY                                                                         ; $03BCBF |/
    LDX <r_current_slot_offset_character_battle                                 ; $03BCC0 |\
    STZ r_character_battle.1.targets.party.w,X                                  ; $03BCC2 | | Initialize the targeting values to zero.
    STZ r_character_battle.1.targets.monster.w,X                                ; $03BCC5 |/
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BCC8 |\
    CMP #8.b                                                                    ; $03BCCA | | If targeting a character slot, set the party target variable by
    BEQ +                                                                       ; $03BCCC | | shifting the bit the appropriate number of places.
    SEC                                                                         ; $03BCCE | |
-   ROR r_character_battle.1.targets.party.w,X                                  ; $03BCCF | |
    DEY                                                                         ; $03BCD2 | |
    BNE -                                                                       ; $03BCD3 | |
    RTS                                                                         ; $03BCD5 |/
+   SEC                                                                         ; $03BCD6 |\
-   ROR r_character_battle.1.targets.monster.w,X                                ; $03BCD7 | | Otherwise, do the same with the monster target.
    DEY                                                                         ; $03BCDA | |
    BNE -                                                                       ; $03BCDB |/
    RTS                                                                         ; $03BCDD

; _monster_condition_check ($03:BCDE)
;
; Given the monster condition data in the array at $289C, executes the
; appropriate handler for that condition. The result is returned in $DE: a 1 if
; the condition matched and a 0 if it did not.
_monster_condition_check:
    STZ <r_monster_condition_check_result                                       ; $03BCDE | Initialize the result variable to zero.
    LDA r_battle_tmp_monster_condition.opcode.w                                 ; $03BCE0 |\
    ASL A                                                                       ; $03BCE3 | | Load the pointer to the handling function for the specified
    TAX                                                                         ; $03BCE4 | | opcode.
    LDA monster_condition_opcode_jump_data.l + 0,X                              ; $03BCE5 | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03BCE9 | |
    LDA monster_condition_opcode_jump_data.l + 1,X                              ; $03BCEB | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03BCEF | |
    LDA #:monster_condition_opcode_jump_data.b                                  ; $03BCF1 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03BCF3 |/
    JML [r_generic_tmp_ptr.w]                                                   ; $03BCF5 | Jump to the handler.

; _monster_condition_opcode_check_status ($03:BCF8)
;
; This opcode, identified by a value of $00, checks the target specified in the
; first parameter for a given set of statuses. In particular, the status byte
; checked is given in the second parameter, and the third parameter is applied
; using a bitwise AND operation to the byte. If the result is non-zero (i.e. if
; the slot has any of the given statuses) it is considered a positive test. If
; the uppermost bit of the first parameter is unset, the result will be true
; if any of the matching targets has the given status. If the uppermost bit is
; set, all matching targets must have the given status. The result is returned
; in $DE, and will be a 0 if negative and a 1 if positive.
_monster_condition_opcode_check_status:
    JSR _monster_condition_helper_get_offset                                    ; $03BCF8 | Get the offsets to slots matching this condition.
    LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BCFB |\ If none match, skip to the end of the function.
    BEQ @done                                                                   ; $03BCFD |/
    CLC                                                                         ; $03BCFF |\
    LDA #<r_character_battle.1.status_1                                         ; $03BD00 | | Calculate the offset to the desired status byte by adding the base
    ADC r_battle_tmp_monster_condition.parameter_2.w                            ; $03BD02 | | status offset to the value in the second parameter.
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03BD05 | |
    LDA #>r_character_battle.1.status_1                                         ; $03BD07 | |
    ADC #0.b                                                                    ; $03BD09 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03BD0B |/
    TDC                                                                         ; $03BD0D |\ Initialize the X register to zero.
    TAX                                                                         ; $03BD0E |/
-   LDA r_monster_condition_helper_get_offset_result_offsets.w + 0,X            ; $03BD0F |\
    STA <r_battle_generic_tmp_1_lo                                              ; $03BD12 | | Load the offset for this slot from the result array. If the value
    LDA r_monster_condition_helper_get_offset_result_offsets.w + 1,X            ; $03BD14 | | is $FFFF, branch forward to the code to move to the next
    STA <r_battle_generic_tmp_1_hi                                              ; $03BD17 | | iteration.
    LDY <r_battle_generic_tmp_1                                                 ; $03BD19 | |
    CPY #$FFFF.w                                                                ; $03BD1B | |
    BEQ ++                                                                      ; $03BD1E |/
    LDA (<r_generic_tmp_ptr_addr)                                               ; $03BD20 |\
    AND r_battle_tmp_monster_condition.parameter_3.w                            ; $03BD22 | | If the slot has at least one of the requested statuses, branch.
    BNE +                                                                       ; $03BD25 |/
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BD27 |\
    BPL ++                                                                      ; $03BD2A | | If no status matched and the high bit was set, return 0.
    STZ <r_monster_condition_check_result                                       ; $03BD2C | | Otherwise, move to the next iteration.
    RTS                                                                         ; $03BD2E |/
+   LDA #1.b                                                                    ; $03BD2F |\
    STA <r_monster_condition_check_result                                       ; $03BD31 | | If a status matched, set the result to 1. If the high bit of
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BD33 | | parameter 1 wasn't set, skip to the end.
    BPL @done                                                                   ; $03BD36 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $03BD38 |\
    CLC                                                                         ; $03BD3A | | Increment the offset to the next slot.
    LDA <r_generic_tmp_ptr_addr                                                 ; $03BD3B | |
    ADC #_sizeof_character_battle.w                                             ; $03BD3D | |
    STA <r_generic_tmp_ptr_addr                                                 ; $03BD40 | |
    TDC                                                                         ; $03BD42 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BD43 |/
    INX                                                                         ; $03BD45 |\ Increment the X register by two to move to the next slot.
    INX                                                                         ; $03BD46 |/
    CPX #_sizeof_r_monster_condition_helper_get_offset_result_offsets.w         ; $03BD47 |\ Loop until all slots have been examined.
    BNE -                                                                       ; $03BD4A |/
@done:
    RTS                                                                         ; $03BD4C

; _monster_condition_opcode_check_hp ($03:BD4D)
;
; This opcode, identified by a value of $01, checks if the HP of the target
; specified in the first parameter is less than a value determined by the
; index given in the third parameter. The value loaded will either be a
; specific HP value to check or $FFFF, which causes the test value to be the
; slot's maximum HP. As with the status check opcode, the high bit of the
; target being set indicates that all matching targets must meet the HP
; condition, versus the default of any matching target.
_monster_condition_opcode_check_hp:
    JSR _monster_condition_helper_get_offset                                    ; $03BD4D | Get the offsets of the matching targets.
    LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BD50 |\ If there are no matching targets, skip to the end.
    BEQ @done                                                                   ; $03BD52 |/
    LDA r_battle_tmp_monster_condition.parameter_3.w                            ; $03BD54 |\
    ASL A                                                                       ; $03BD57 | | Load the HP value to check against from ROM.
    TAX                                                                         ; $03BD58 | |
    LDA bank0E.monster_condition_hp_check_data.l + 0,X                          ; $03BD59 | |
    STA <r_battle_generic_tmp_3_lo                                              ; $03BD5D | |
    LDA bank0E.monster_condition_hp_check_data.l + 1,X                          ; $03BD5F | |
    STA <r_battle_generic_tmp_3_hi                                              ; $03BD63 |/
    TDC                                                                         ; $03BD65 |\
    TAX                                                                         ; $03BD66 | | Initialize the X register and slot to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03BD67 |/
@start:
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BD69 |\
    ASL A                                                                       ; $03BD6B | | If this slot didn't match as a target, branch to the next
    TAY                                                                         ; $03BD6C | | iteration to move to the next slot.
    LDA r_monster_condition_helper_get_offset_result_offsets.w + 0,Y            ; $03BD6D | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03BD70 | |
    LDA r_monster_condition_helper_get_offset_result_offsets.w + 1,Y            ; $03BD72 | |
    STA <r_battle_generic_tmp_2_hi                                              ; $03BD75 | |
    LDY <r_battle_generic_tmp_2                                                 ; $03BD77 | |
    CPY #$FFFF.w                                                                ; $03BD79 | |
    BEQ @next                                                                   ; $03BD7C |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03BD7E |\
    LDA <r_battle_generic_tmp_3                                                 ; $03BD80 | | If the loaded HP test value was $FFFF, then compare the current
    CMP #$FFFF.w                                                                ; $03BD82 | | HP of the target to the maximum HP. Branch accordingly.
    BNE +                                                                       ; $03BD85 | |
    LDA r_character_battle.1.hp.w,X                                             ; $03BD87 | |
    CMP r_character_battle.1.hp_max.w,X                                         ; $03BD8A | |
    BNE +++                                                                     ; $03BD8D | |
    BEQ ++                                                                      ; $03BD8F |/
+   LDA <r_battle_generic_tmp_3                                                 ; $03BD91 |\
    CMP r_character_battle.1.hp.w,X                                             ; $03BD93 | | Otherwise, test current HP and branch accordingly.
    BCS +++                                                                     ; $03BD96 |/
++  TDC                                                                         ; $03BD98 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BD99 | | If the test value was $FFFF and the current HP equals the maximum
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BD9B | | HP or if the test value was anything else and the current HP was
    BPL @next                                                                   ; $03BD9E | | greater than or equal to the test value, skip to the next
    STZ <r_monster_condition_check_result                                       ; $03BDA0 | | iteration if all mode isn't set, otherwise return 0.
    RTS                                                                         ; $03BDA2 |/
+++ TDC                                                                         ; $03BDA3 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BDA4 | | If the test value was $FFFF and the current HP doesn't equal the
    INC <r_monster_condition_check_result                                       ; $03BDA6 | | maximum HP or the current HP is less than the test value,
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BDA8 | | increment the result. Return if all mode is not set.
    BPL @done                                                                   ; $03BDAB |/
@next:
    JSR _increment_x_by_128                                                     ; $03BDAD |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03BDB0 | | Increment the indexes and loop until all slots have been checked.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BDB2 | |
    CMP #(5 + 8).b                                                              ; $03BDB4 | |
    BNE @start                                                                  ; $03BDB6 |/
@done:
    RTS                                                                         ; $03BDB8

; _monster_condition_opcode_check_flag ($03:BDB9)
;
; This opcode checks the value of one of the four script flags. Which flag is
; checked is determined by the second parameter. The third parameter is the
; value that should be checked for. The first parameter is ignored.
_monster_condition_opcode_check_flag:
    LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BDB9 |\
    TAX                                                                         ; $03BDBC | | Read the value of the specified flag.
    LDA r_battle_monster_script_flags.w,X                                       ; $03BDBD |/
    CMP r_battle_tmp_monster_condition.parameter_3.w                            ; $03BDC0 |\
    BNE +                                                                       ; $03BDC3 | | If the flag matches, increment the result variable.
    INC <r_monster_condition_check_result                                       ; $03BDC5 |/
+   RTS                                                                         ; $03BDC7

; _monster_condition_opcode_check_living ($03:BDC8)
;
; This opcode revolves primarily around checking the living status of the target
; specified in the first parameter byte. If the value of the second parameter is
; zero, the condition will match if the target is alive and able to act. If the
; second parameter is 1, it will match if the target is not alive and able to
; act (potentially even if they're simply not in the party). Finally, for other
; values, it will match if at least one target matches and there is exactly one
; character slot with active timers. It is important to note that this function
; does not directly check the living status of the targets. This status is
; instead inferred by being a matching target.
_monster_condition_opcode_check_living:
    JSR _monster_condition_helper_get_offset                                    ; $03BDC8 | Get the offsets of the matching targets.
    LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BDCB |\
    BNE +                                                                       ; $03BDCE | | If the value of the second parameter is zero, return true if there
    LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BDD0 | | were matching targets and false otherwise.
    BNE @true                                                                   ; $03BDD2 | |
    BEQ @false                                                                  ; $03BDD4 |/
+   LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BDD6 |\
    DEC A                                                                       ; $03BDD9 | | If the value of the second parameter is 1, return true if there
    BNE +                                                                       ; $03BDDA | | were no matching targets, and false otherwise.
    LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BDDC | |
    BEQ @true                                                                   ; $03BDDE | |
    BNE @false                                                                  ; $03BDE0 |/
+   LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BDE2 |\ Otherwise, return false if there were no matching targets.
    BEQ @false                                                                  ; $03BDE4 |/
    TDC                                                                         ; $03BDE6 |\ Initialize the X register to zero.
    TAX                                                                         ; $03BDE7 |/
    STX <r_battle_generic_tmp_1                                                 ; $03BDE8 | Initialize the timer count to zero.
-   LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03BDEA |\
    BEQ +                                                                       ; $03BDED | | If this timer is enabled, increment the count.
    INC <r_battle_generic_tmp_1_lo                                              ; $03BDEF |/
+   INX                                                                         ; $03BDF1 |\
    INX                                                                         ; $03BDF2 | | Increment the indexes and loop until the timers for the first five
    CPX #(5 * 2).w                                                              ; $03BDF3 | | slots have been checked.
    BNE -                                                                       ; $03BDF6 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BDF8 |\
    DEC A                                                                       ; $03BDFA | | Return false unless exactly one timer was enabled.
    BNE @false                                                                  ; $03BDFB |/
@true:
    INC <r_monster_condition_check_result                                       ; $03BDFD | If returning true, increment the result variable.
@false:
    RTS                                                                         ; $03BDFF

; _monster_condition_opcode_check_monster_count ($03:BE00)
;
; This opcode is primarily used to check if a particular monster is dead. It
; generally assumes that there is only one monster type with a given ID, so in
; random battles where the same ID is used in multiple types, it may not behave
; as expected. The third parameter byte specifies the desired monster ID, as
; found in the array at $7E29AD. The opcode matches in different circumstances
; depending on the value of the second parameter byte:
;  $00 - Matches if there are monsters remaining of the specified ID and there
;        are also other monsters remaining.
;  $01 - Matches if the specified monster is either not in the battle or there
;        are none remaining.
;  $02 - Matches if there are monsters remaining of the specified ID and they
;        are the only monsters remaining.
_monster_condition_opcode_check_monster_count:
    TDC                                                                         ; $03BE00 |\ Initialize the X register to zero.
    TAX                                                                         ; $03BE01 |/
    STX <r_battle_generic_tmp_1                                                 ; $03BE02 | Initialize the temporary variable to zero.
-   LDA r_battle_tmp_monster_condition.parameter_3.w                            ; $03BE04 |\
    CMP r_monster_ids.w,X                                                       ; $03BE07 | | Scan through the monster IDs until finding the one that matches
    BEQ +                                                                       ; $03BE0A | | the parameter.
    INX                                                                         ; $03BE0C | |
    CPX #_sizeof_r_monster_ids.w - 1                                            ; $03BE0D | |
    BNE -                                                                       ; $03BE10 |/
-   INC <r_battle_generic_tmp_1_lo                                              ; $03BE12 |\ If not found, increment the temporary variable and branch ahead.
    BRA ++                                                                      ; $03BE14 |/
+   LDA r_monsters_remaining.w,X                                                ; $03BE16 |\ If there are no monsters remaining of this type, branch to
    BEQ -                                                                       ; $03BE19 |/ increment the temporary variable and branch forward.
    CMP r_monsters_remaining_total.w                                            ; $03BE1B |\
    BNE ++                                                                      ; $03BE1E | | If there are monsters remaining of this type and they are the only
    INC <r_battle_generic_tmp_1_lo                                              ; $03BE20 | | remaining monsters, increment the temporary variable by two.
    INC <r_battle_generic_tmp_1_lo                                              ; $03BE22 |/
++  LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BE24 |\
    CMP <r_battle_generic_tmp_1_lo                                              ; $03BE27 | | Return true if the value of the temporary is equal to the second
    BNE +                                                                       ; $03BE29 | | parameter byte.
    INC <r_monster_condition_check_result                                       ; $03BE2B |/
+   RTS                                                                         ; $03BE2D

; _monster_condition_opcode_check_formation ($03:BE2E)
;
; This opcode checks that the 16-bit formation number matches the values in
; parameter 2 and parameter 3. Note that the parameters are in big endian order,
; with the high byte coming first.
_monster_condition_opcode_check_formation:
    LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BE2E |\
    CMP r_battle_formation_hi.w                                                 ; $03BE31 | | Return false if the high byte of the formation doesn't match.
    BNE +                                                                       ; $03BE34 |/
    LDA r_battle_tmp_monster_condition.parameter_3.w                            ; $03BE36 |\
    CMP r_battle_formation_lo.w                                                 ; $03BE39 | | Return false if the low byte of the formation doesn't match.
    BNE +                                                                       ; $03BE3C | | Otherwise, return true.
    INC <r_monster_condition_check_result                                       ; $03BE3E |/
+   RTS                                                                         ; $03BE40

; _monster_condition_opcode_check_acting_type_alone ($03:BE41)
;
; This opcode matches if the type of the acting monster is the only type with
; monsters remaining.
_monster_condition_opcode_check_acting_type_alone:
    SEC                                                                         ; $03BE41 |\
    LDA <r_battle_timer_slot                                                    ; $03BE42 | | Determine the type index for this monster and transfer it to the X
    SBC #5.b                                                                    ; $03BE44 | | register.
    TAX                                                                         ; $03BE46 | |
    LDA r_monster_slot_to_id_index.w,X                                          ; $03BE47 | |
    TAX                                                                         ; $03BE4A |/
    LDA r_monsters_remaining.w,X                                                ; $03BE4B |\
    CMP r_monsters_remaining_total.w                                            ; $03BE4E | | Increment the result variable if the number of monsters remaining
    BNE +                                                                       ; $03BE51 | | of this type equals the total number of monsters remaining.
    INC <r_monster_condition_check_result                                       ; $03BE53 |/
+   RTS                                                                         ; $03BE55

; _monster_condition_opcode_check_recent_attack ($03:BE56)
;
; This opcode checks that the most recent attack for which the monster was a
; victim had an actor that matches the targeting byte in parameter 1, had the
; command specified by parameter 2, and if parameter 3 is non-zero, had an
; element matching that value.
_monster_condition_opcode_check_recent_attack:
    SEC                                                                         ; $03BE56 |\
    LDA <r_battle_timer_slot                                                    ; $03BE57 | | Set the X register to the acting monster's slot minus five (to
    SBC #5.b                                                                    ; $03BE59 | | determine the monster slot number).
    TAX                                                                         ; $03BE5B |/
    JSR _math_multiply_by_32                                                    ; $03BE5C |\ Calculate the offset into the monster's victim history.
    STA <r_battle_generic_tmp_1_lo                                              ; $03BE5F |/
    LDA r_battle_monster_victim_action_index.w,X                                ; $03BE61 |\
    CMP #$FF.b                                                                  ; $03BE64 | | Return false if there were no actions in the history.
    BEQ @false                                                                  ; $03BE66 |/
    JSR _math_multiply_by_4                                                     ; $03BE68 |\
    CLC                                                                         ; $03BE6B | | Set the X register to the offset to the particular entry in the
    ADC <r_battle_generic_tmp_1_lo                                              ; $03BE6C | | victim history.
    TAX                                                                         ; $03BE6E |/
    TDC                                                                         ; $03BE6F |\
    TAY                                                                         ; $03BE70 | | Copy that entry to the temporary array.
-   LDA r_battle_monster_victim_action_history.w,X                              ; $03BE71 | |
    STA r_battle_current_monster_victim_action_history.w,Y                      ; $03BE74 | |
    INX                                                                         ; $03BE77 | |
    INY                                                                         ; $03BE78 | |
    CPY #_sizeof_victim_history_entry.w                                         ; $03BE79 | |
    BNE -                                                                       ; $03BE7C |/
    JSR _monster_condition_helper_get_offset                                    ; $03BE7E | Get the offsets based on the option in parameter 1.
    LDA <r_monster_condition_helper_get_offset_result_count                     ; $03BE81 |\ If there were no matches, return false.
    BEQ @false                                                                  ; $03BE83 |/
    LDA r_battle_current_monster_victim_action_history.1.actor.w                ; $03BE85 |\
    BPL +                                                                       ; $03BE88 | | Load the true slot of the actor in the history.
    AND #%01111111.b                                                            ; $03BE8A | |
    CLC                                                                         ; $03BE8C | |
    ADC #5.b                                                                    ; $03BE8D |/
+   ASL A                                                                       ; $03BE8F |\
    TAX                                                                         ; $03BE90 | | If that actor didn't match the matching targets, return false.
    LDA r_monster_condition_helper_get_offset_result_offsets.w + 0,X            ; $03BE91 | |
    AND r_monster_condition_helper_get_offset_result_offsets.w + 1,X            ; $03BE94 | |
    CMP #$FF.b                                                                  ; $03BE97 | |
    BEQ @false                                                                  ; $03BE99 |/
    LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BE9B |\
    CMP r_battle_current_monster_victim_action_history.1.command.w              ; $03BE9E | | Return false if the command didn't match parameter 2.
    BNE @false                                                                  ; $03BEA1 |/
    LDA r_battle_tmp_monster_condition.parameter_3.w                            ; $03BEA3 |\ Return true if the third parameter is zero.
    BEQ @true                                                                   ; $03BEA6 |/
    AND r_battle_current_monster_victim_action_history.1.element.w              ; $03BEA8 |\ Return false if the attack element and third parameter didn't match
    BEQ @false                                                                  ; $03BEAB |/ at least one bit.
@true:
    INC <r_monster_condition_check_result                                       ; $03BEAD | Increment the result variable to indicate true.
@false:
    RTS                                                                         ; $03BEAF

; _monster_condition_opcode_check_recent_attacks_all ($03:BEB0)
;
; This opcode checks that one of the recent attacks for which the monster was a
; victim had the command specified by parameter 2, and if parameter 3 is non-
; zero, had an element matching that value.
_monster_condition_opcode_check_recent_attacks_all:
    SEC                                                                         ; $03BEB0 |\
    LDA <r_battle_timer_slot                                                    ; $03BEB1 | | Calculate the offset into the victim history array.
    SBC #5.b                                                                    ; $03BEB3 | |
    JSR _math_multiply_by_32                                                    ; $03BEB5 | |
    TAX                                                                         ; $03BEB8 |/
    TDC                                                                         ; $03BEB9 |\
    TAY                                                                         ; $03BEBA | | Copy this monster's victim action history to the current array.
-   LDA r_battle_monster_victim_action_history.w,X                              ; $03BEBB | |
    STA r_battle_current_monster_victim_action_history.w,Y                      ; $03BEBE | |
    INX                                                                         ; $03BEC1 | |
    INY                                                                         ; $03BEC2 | |
    CPY #_sizeof_r_battle_current_monster_victim_action_history.w               ; $03BEC3 | |
    BNE -                                                                       ; $03BEC6 |/
    TDC                                                                         ; $03BEC8 |\
    TAX                                                                         ; $03BEC9 | | Search through the monster's victim history searching for attacks
-   LDA r_battle_tmp_monster_condition.parameter_2.w                            ; $03BECA | | that used the command indicated by the second parameter. If found,
    CMP r_battle_current_monster_victim_action_history.1.command.w,X            ; $03BECD | | branch ahead to the next check.
    BEQ +                                                                       ; $03BED0 | |
    INX                                                                         ; $03BED2 | |
    INX                                                                         ; $03BED3 | |
    INX                                                                         ; $03BED4 | |
    INX                                                                         ; $03BED5 | |
    CPX #_sizeof_r_battle_current_monster_victim_action_history.w               ; $03BED6 | |
    BNE -                                                                       ; $03BED9 |/
    RTS                                                                         ; $03BEDB | Otherwise, return.
+   TDC                                                                         ; $03BEDC |\
-   LDA r_battle_tmp_monster_condition.parameter_3.w                            ; $03BEDD | | If the third parameter is zero, branch to return success.
    BEQ +                                                                       ; $03BEE0 |/
    AND r_battle_current_monster_victim_action_history.1.element.w,X            ; $03BEE2 |\ If the attack element matched the required attack element, branch
    BNE +                                                                       ; $03BEE5 |/ to success.
    INX                                                                         ; $03BEE7 |\
    INX                                                                         ; $03BEE8 | | Otherwise, loop through all the entries.
    INX                                                                         ; $03BEE9 | |
    INX                                                                         ; $03BEEA | |
    CPX #_sizeof_r_battle_current_monster_victim_action_history.w               ; $03BEEB | |
    BNE -                                                                       ; $03BEEE |/
    RTS                                                                         ; $03BEF0 | Return if no matching entries were found.
+   INC <r_monster_condition_check_result                                       ; $03BEF1 | Increment the result variable.
    RTS                                                                         ; $03BEF3

; _monster_condition_opcode_check_running_with_spell ($03:BEF4)
;
; This unusual opcode checks to see if the party is currently running through
; the use of a spell. Of course, since the flag isn't set until the spell is
; executing, this condition is completely useless. Perhaps it had an intended
; use during development.
_monster_condition_opcode_check_running_with_spell:
    LDA r_battle_running_with_spell.w                                           ; $03BEF4 |\
    BEQ +                                                                       ; $03BEF7 | | Return a positive result if the party is running with a spell.
    INC <r_monster_condition_check_result                                       ; $03BEF9 |/
+   RTS                                                                         ; $03BEFB

; _monster_condition_opcode_check_damage ($03:BEFC)
;
; This opcode matches if the monster in the acting slot has taken damage from
; the current action. This only really makes sense as a reaction condition.
_monster_condition_opcode_check_damage:
    SEC                                                                         ; $03BEFC |\
    LDA <r_battle_timer_slot                                                    ; $03BEFD | | Calculate the index into the damage by taking the acting slot,
    SBC #5.b                                                                    ; $03BEFF | | subtracting 5, and then multiplying by two.
    ASL A                                                                       ; $03BF01 | |
    TAX                                                                         ; $03BF02 |/
    LDA r_battle_slot_damage.w + 0,X                                            ; $03BF03 |\
    ORA r_battle_slot_damage.w + 1,X                                            ; $03BF06 | | Return if this slot has no damage.
    BEQ +                                                                       ; $03BF09 |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03BF0B |\
    AND #(BATTLE_DAMAGE_RESTORE | BATTLE_DAMAGE_MISS).b >> 8                    ; $03BF0E | | Return if the damage was either a miss or restoration.
    BNE +                                                                       ; $03BF10 |/
    INC <r_monster_condition_check_result                                       ; $03BF12 | Otherwise, increment the result variable.
+   RTS                                                                         ; $03BF14

; _monster_condition_opcode_check_alone ($03:BF15)
;
; This opcode matches if the monster is the only monster remaining.
_monster_condition_opcode_check_alone:
    LDA r_monsters_remaining_total.w                                            ; $03BF15 |\
    CMP #1.b                                                                    ; $03BF18 | | Check if the total number of remaining monsters is one.
    BNE +                                                                       ; $03BF1A | |
    INC <r_monster_condition_check_result                                       ; $03BF1C |/
+   RTS                                                                         ; $03BF1E

; _monster_condition_helper_get_offset ($03:BF1F)
;
; Reads the first parameter byte of the current monster condition at $289C and
; jumps to a function that will return various offsets in $35D0 depending on the
; function itself.
_monster_condition_helper_get_offset:
    STZ <r_monster_condition_helper_get_offset_result_count                     ; $03BF1F | Initialize the result counter to zero.
    LDX #_sizeof_r_monster_condition_helper_get_offset_result_offsets.w - 1     ; $03BF21 |\
    LDA #$FF.b                                                                  ; $03BF24 | | Initialize the result array to all $FF, which signifies a slot
-   STA r_monster_condition_helper_get_offset_result_offsets.w,X                ; $03BF26 | | that did not match the given criterion.
    DEX                                                                         ; $03BF29 | |
    BPL -                                                                       ; $03BF2A |/
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BF2C |\
    AND #%01111111.b                                                            ; $03BF2F | | Set the X register by taking the first parameter, masking out the
    ASL A                                                                       ; $03BF31 | | highest bit, and multiplying by two.
    TAX                                                                         ; $03BF32 |/
    LDA monster_condition_helper_get_offset_jump_data.l + 0,X                   ; $03BF33 |\
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03BF37 | | Load the pointer to the target function and jump to it.
    LDA monster_condition_helper_get_offset_jump_data.l + 1,X                   ; $03BF39 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03BF3D | |
    LDA #:monster_condition_helper_get_offset_jump_data.b                       ; $03BF3F | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03BF41 | |
    JML [r_generic_tmp_ptr.w]                                                   ; $03BF43 |/

; _monster_condition_helper_get_offset_character ($03:BF46)
;
; Reads the second byte in the current monster condition at $289C and finds the
; first slot that contains the character ID specified in that byte.
_monster_condition_helper_get_offset_character:
    LDA r_battle_tmp_monster_condition.parameter_1.w                            ; $03BF46 |\ Load the first parameter into a temporary variable, as that's the
    STA <r_battle_generic_tmp_2_lo                                              ; $03BF49 |/ character ID we are looking for.
    TDC                                                                         ; $03BF4B |\
    TAX                                                                         ; $03BF4C | | Initialize the X register and slot number to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03BF4D |/
-   LDA <r_battle_generic_tmp_1_lo                                              ; $03BF4F |\
    TAY                                                                         ; $03BF51 | | If this slot is empty, skip any further checks and go to the next
    LDA r_battle_slot_empty.w,Y                                                 ; $03BF52 | | iteration.
    BNE +                                                                       ; $03BF55 |/
    LDA r_character_battle.1.id.w,X                                             ; $03BF57 |\
    AND #%00011111.b                                                            ; $03BF5A | | If the character ID in this slot does not match the parameter,
    CMP <r_battle_generic_tmp_2_lo                                              ; $03BF5C | | skip to the next iteration.
    BNE +                                                                       ; $03BF5E |/
    JSR _battle_check_invalid_target                                            ; $03BF60 |\
    LDA r_battle_check_invalid_target_result.w                                  ; $03BF63 | | Skip if this slot is swoon, stone, magnetized, jumping, or hiding.
    BNE +                                                                       ; $03BF66 |/
    STX r_battle_generic_tmp_2.w                                                ; $03BF68 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BF6B | | Transfer the offset of the current slot into the result array at
    ASL A                                                                       ; $03BF6D | | the index of this slot.
    TAX                                                                         ; $03BF6E | |
    LDA <r_battle_generic_tmp_2_lo                                              ; $03BF6F | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 0,X            ; $03BF71 | |
    LDA <r_battle_generic_tmp_2_hi                                              ; $03BF74 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 1,X            ; $03BF76 |/
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03BF79 |\ Increment the count result variable and branch to the end.
    BRA ++                                                                      ; $03BF7B |/
+   JSR _increment_x_by_128                                                     ; $03BF7D |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03BF80 | | Increment the slot and offset and loop until all five character
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BF82 | | slots have been checked.
    CMP #5.b                                                                    ; $03BF84 | |
    BNE -                                                                       ; $03BF86 |/
++  RTS                                                                         ; $03BF88

; _monster_condition_helper_get_offset_monster_type_broken ($03:BF89)
;
; Checks for monsters that are of the same type index as the acting monster, and
; sets their offsets in the result array to zeroes. This probably does not work
; in any meaningful way. It does not appear that this function is used by the
; default game code.
_monster_condition_helper_get_offset_monster_type_broken:
    SEC                                                                         ; $03BF89 |\
    LDA <r_battle_timer_slot                                                    ; $03BF8A | | Find the type index of the currently acting monster and save it in
    SBC #5.b                                                                    ; $03BF8C | | a temporary variable.
    TAX                                                                         ; $03BF8E | |
    LDA r_monster_slot_to_id_index.w,X                                          ; $03BF8F | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03BF92 |/
    LDX #5.w                                                                    ; $03BF94 |\ Set the current index to 5 (the first monster slot).
    STX <r_battle_generic_tmp_1                                                 ; $03BF97 |/
    TDC                                                                         ; $03BF99 |\ Initialize the X register to zero.
    TAX                                                                         ; $03BF9A |/
-   SEC                                                                         ; $03BF9B |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BF9C | | Load the type index of the current monster slot.
    SBC #5.b                                                                    ; $03BF9E | |
    TAY                                                                         ; $03BFA0 | |
    LDA r_monster_slot_to_id_index.w,Y                                          ; $03BFA1 |/
    CMP <r_battle_generic_tmp_2_lo                                              ; $03BFA4 |\ If it doesn't match the previously stored type index, skip this
    BNE +                                                                       ; $03BFA6 |/ iteration.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BFA8 |\
    ASL A                                                                       ; $03BFAA | | Store a zero in the result variable for this slot.
    TAY                                                                         ; $03BFAB | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $03BFAC | | BUG?: This seems kind of dumb, since you'd want the actual offset
    TDC                                                                         ; $03BFAE | |       for the slot. It doesn't appear that this code is actually
    STA r_monster_condition_helper_get_offset_result_offsets.w,Y                ; $03BFAF | |       used by the game data, however.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BFB2 |/
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03BFB4 | Increment the result count.
+   JSR _increment_x_by_128                                                     ; $03BFB6 |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03BFB9 | | Increment the slot and the X register and loop until all slots
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BFBB | | are checked.
    CMP #(5 + 8).b                                                              ; $03BFBD | |
    BNE -                                                                       ; $03BFBF |/
    RTS                                                                         ; $03BFC1

; _monster_condition_helper_get_offset_self ($03:BFC2)
;
; Finds the slot and offset for the acting monster and returns the appropriate
; data in the result array at $35D0.
_monster_condition_helper_get_offset_self:
    LDA <r_battle_timer_slot                                                    ; $03BFC2 |\
    ASL A                                                                       ; $03BFC4 | | Set the result array to contain the offset for the acting monster
    TAY                                                                         ; $03BFC5 | | slot.
    LDA <r_current_slot_offset_character_battle_lo                              ; $03BFC6 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 0,Y            ; $03BFC8 | |
    LDA <r_current_slot_offset_character_battle_hi                              ; $03BFCB | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 1,Y            ; $03BFCD |/
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03BFD0 | Increment the result count.
    RTS                                                                         ; $03BFD2

; _monster_condition_helper_get_offset_character_all ($03:BFD3)
;
; Finds the slots and offsets for all characters that do not have one of the
; following statuses: swoon, stone, magnetized, hiding or jumping.
_monster_condition_helper_get_offset_character_all:
    STZ <r_battle_generic_tmp_1_lo                                              ; $03BFD3 | Initialize the slot number to 0.
    LDA #5.b                                                                    ; $03BFD5 |\ Initialize the slot number limit to 5.
    STA <r_battle_generic_tmp_2_lo                                              ; $03BFD7 |/
_monster_condition_helper_get_offset_range:
    TDC                                                                         ; $03BFD9 |\ Initialize the offset to zero.
    TAX                                                                         ; $03BFDA |/
-   LDA <r_battle_generic_tmp_1_lo                                              ; $03BFDB |\
    TAY                                                                         ; $03BFDD | | If this slot is empty, skip to the next iteration.
    LDA r_battle_slot_empty.w,Y                                                 ; $03BFDE | |
    BNE +                                                                       ; $03BFE1 |/
    JSR _battle_check_invalid_target                                            ; $03BFE3 |\
    LDA r_battle_check_invalid_target_result.w                                  ; $03BFE6 | | If the character in this slot is an invalid target, skip.
    BNE +                                                                       ; $03BFE9 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BFEB |\
    ASL A                                                                       ; $03BFED | | Store the offset for this slot to the appropriate place in the
    TAY                                                                         ; $03BFEE | | result array.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03BFEF | |
    TXA                                                                         ; $03BFF1 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w,Y                ; $03BFF2 | |
    TDC                                                                         ; $03BFF5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03BFF6 |/
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03BFF8 | Increment the count.
+   JSR _increment_x_by_128                                                     ; $03BFFA |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03BFFD | | Increment the indexes and loop until the maximum value of 5 is
    LDA <r_battle_generic_tmp_1_lo                                              ; $03BFFF | | reached.
    CMP <r_battle_generic_tmp_2_lo                                              ; $03C001 | |
    BNE -                                                                       ; $03C003 |/
    RTS                                                                         ; $03C005

; _monster_condition_helper_get_offset_monster_type_0 ($03:C006)
;
; Finds the slots and offsets for all monsters that are of type index zero that
; are also valid targets who do not have any of the following statuses: swoon,
; stone, magnetized, hiding or jumping.
_monster_condition_helper_get_offset_monster_type_0:
    STZ <r_battle_generic_tmp_2_lo                                              ; $03C006 | Set the parameter to search for type index zero.
    JMP _monster_condition_helper_get_offset_monster_type                       ; $03C008 | Search for the specified monsters.

; _monster_condition_helper_get_offset_monster_type ($03:C00B)
;
; Finds the slots and offsets for all monsters that match the 8-bit monster type
; index passed in $AB that do not have one of the following statuses: swoon,
; stone, magnetized, hiding or jumping.
_monster_condition_helper_get_offset_monster_type:
    TDC                                                                         ; $03C00B |\
    TAY                                                                         ; $03C00C | | Initialize the slot number to zero.
    STY <r_battle_generic_tmp_1                                                 ; $03C00D |/
    LDX #_sizeof_character_battle.w * 5                                         ; $03C00F | Initialize the X register to the offset to the first monster record.
-   LDY <r_battle_generic_tmp_1                                                 ; $03C012 | Load the current slot into the Y register.
    LDA r_monster_slot_to_id_index.w,Y                                          ; $03C014 |\
    CMP <r_battle_generic_tmp_2_lo                                              ; $03C017 | | Skip this slot if it is not of the correct type.
    BNE +                                                                       ; $03C019 |/
    CLC                                                                         ; $03C01B |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C01C | | Calculate the true slot number for this monster by adding 5 and
    ADC #5.b                                                                    ; $03C01E | | saving it to a local variable.
    STA <r_battle_generic_tmp_2_hi                                              ; $03C020 |/
    TAY                                                                         ; $03C022 |\
    LDA r_battle_slot_empty.w,Y                                                 ; $03C023 | | Skip this slot if it's empty.
    BNE +                                                                       ; $03C026 |/
    JSR _battle_check_invalid_target                                            ; $03C028 |\
    LDA r_battle_check_invalid_target_result.w                                  ; $03C02B | | Skip this slot if it has an invalid target.
    BNE +                                                                       ; $03C02E |/
    LDA <r_battle_generic_tmp_2_hi                                              ; $03C030 |\
    ASL A                                                                       ; $03C032 | | Set the Y register to the true slot times two.
    TAY                                                                         ; $03C033 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03C034 |\
    TXA                                                                         ; $03C036 | | Save the offset to the current slot to the result array.
    STA r_monster_condition_helper_get_offset_result_offsets.w,Y                ; $03C037 | |
    TDC                                                                         ; $03C03A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C03B |/
    INC r_monster_condition_helper_get_offset_result_count.b                    ; $03C03D | Increment the result count.
+   JSR _increment_x_by_128                                                     ; $03C03F | Increment the X register by the size of the record.
    INC <r_battle_generic_tmp_1_lo                                              ; $03C042 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C044 | | Increment the slot and loop until all eight monsters have been
    CMP #8.b                                                                    ; $03C046 | | checked.
    BNE -                                                                       ; $03C048 |/
    RTS                                                                         ; $03C04A

; _monster_condition_helper_get_offset_monster_type_1 ($03:C04B)
;
; Finds slot and offsets for monsters of type index 1.
_monster_condition_helper_get_offset_monster_type_1:
    LDA #1.b                                                                    ; $03C04B |\ Set the parameter to search for monster type 1.
    STA <r_battle_generic_tmp_2_lo                                              ; $03C04D |/
    JMP _monster_condition_helper_get_offset_monster_type                       ; $03C04F | Search for the specified monster types.

; _monster_condition_helper_get_offset_monster_type_2 ($03:C052)
;
; Finds slot and offsets for monsters of type index 2.
_monster_condition_helper_get_offset_monster_type_2:
    LDA #2.b                                                                    ; $03C052 |\ Set the parameter to search for monster type 2.
    STA <r_battle_generic_tmp_2_lo                                              ; $03C054 |/
    JMP _monster_condition_helper_get_offset_monster_type                       ; $03C056 | Search for the specified monster types.

; _monster_condition_helper_get_offset_all ($03:C059)
;
; Finds slot and offsets for all characters and monsters that don't have any of
; the following statuses: swoon, stone, magnetized, hiding or jumping.
_monster_condition_helper_get_offset_all:
    JSR _monster_condition_helper_get_offset_character_all                      ; $03C059 | Search for all characters.
    JMP _monster_condition_helper_get_offset_monster_all                        ; $03C05C | Search for all monsters.

; _monster_condition_helper_get_offset_all_except_self ($03:C05F)
;
; Finds slot and offsets for all characters and monsters except the actor. This
; falls through to the next function.
_monster_condition_helper_get_offset_all_except_self:
    JSR _monster_condition_helper_get_offset_all                                ; $03C05F | Find all characters and monsters.

; _monster_condition_helper_get_offset_except_self ($03:C062)
;
; Erases the actor's offset from the offset result array. This routine assumes
; desirable targets have already been searched for, and is used to eliminate the
; actor from the results.
_monster_condition_helper_get_offset_except_self:
    LDA <r_battle_timer_slot                                                    ; $03C062 |\
    ASL A                                                                       ; $03C064 | | Erase the offset for the acting slot.
    TAX                                                                         ; $03C065 | |
    LDA #$FF.b                                                                  ; $03C066 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 0,X            ; $03C068 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w + 1,X            ; $03C06B |/
    DEC <r_monster_condition_helper_get_offset_result_count                     ; $03C06E | Decrement the result counter.
    RTS                                                                         ; $03C070

; _monster_condition_helper_get_offset_monster_all ($03:C071)
;
; Finds slots and offsets for all monsters that are valid targets.
_monster_condition_helper_get_offset_monster_all:
    LDA #5.b                                                                    ; $03C071 |\ Set the starting slot to slot 5.
    STA <r_battle_generic_tmp_1_lo                                              ; $03C073 |/
    LDA #(5 + 8).b                                                              ; $03C075 |\ Set the slot limit to 13.
    STA <r_battle_generic_tmp_2_lo                                              ; $03C077 |/
    JMP _monster_condition_helper_get_offset_range                              ; $03C079 | Jump to find all monsters.

; _monster_condition_helper_get_offset_monster_all_except_self ($03:C07C)
;
; Finds slots and offsets for all monsters except the actor.
_monster_condition_helper_get_offset_monster_all_except_self:
    JSR _monster_condition_helper_get_offset_monster_all                        ; $03C07C |\ Search for all monsters except self.
    JMP _monster_condition_helper_get_offset_except_self                        ; $03C07F |/

; _monster_condition_helper_get_offset_character_front_row ($03:C082)
;
; Finds slots and offsets for all valid characters in the front row.
_monster_condition_helper_get_offset_character_front_row:
    TDC                                                                         ; $03C082 |\
    TAX                                                                         ; $03C083 | | Initialize the current slot and offset to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03C084 |/
-   LDA <r_battle_generic_tmp_1_lo                                              ; $03C086 |\ Transfer the current slot to the Y register.
    TAY                                                                         ; $03C088 |/
    LDA r_battle_slot_empty.w,Y                                                 ; $03C089 |\ Skip this slot if empty.
    BNE +                                                                       ; $03C08C |/
    JSR _battle_check_invalid_target                                            ; $03C08E |\
    LDA r_battle_check_invalid_target_result.w                                  ; $03C091 | | Skip this slot if swoon, stoned, magnetized, hiding or jumping.
    BNE +                                                                       ; $03C094 |/
    LDA r_character_battle.1.sprite_class.w,X                                   ; $03C096 |\ Skip this slot if in the back row.
    BMI +                                                                       ; $03C099 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C09B |\
    ASL A                                                                       ; $03C09D | | Store this slot's offset into the result array and increment
    TAY                                                                         ; $03C09E | | the result count.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03C09F | |
    TXA                                                                         ; $03C0A1 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w,Y                ; $03C0A2 | |
    TDC                                                                         ; $03C0A5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C0A6 | |
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03C0A8 |/
+   JSR _increment_x_by_128                                                     ; $03C0AA |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03C0AD | | Increment the slot and offset and loop until all 5 slots have been
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C0AF | | checked.
    CMP #5.b                                                                    ; $03C0B1 | |
    BNE -                                                                       ; $03C0B3 |/
    RTS                                                                         ; $03C0B5

; _monster_condition_helper_get_offset_character_back_row ($03:C0B6)
;
; Finds slots and offsets for all valid characters in the back row.
_monster_condition_helper_get_offset_character_back_row:
    TDC                                                                         ; $03C0B6 |\
    TAX                                                                         ; $03C0B7 | | Initialize the slot and offset to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03C0B8 |/
-   LDA <r_battle_generic_tmp_1_lo                                              ; $03C0BA |\ Transfer the current slot to the Y register.
    TAY                                                                         ; $03C0BC |/
    LDA r_battle_slot_empty.w,Y                                                 ; $03C0BD |\ Skip this slot if empty.
    BNE +                                                                       ; $03C0C0 |/
    JSR _battle_check_invalid_target                                            ; $03C0C2 |\
    LDA r_battle_check_invalid_target_result.w                                  ; $03C0C5 | | Skip this slot if swoon, stoned, magnetized, hiding or jumping.
    BNE +                                                                       ; $03C0C8 |/
    LDA r_character_battle.1.sprite_class.w,X                                   ; $03C0CA |\ Skip this slot if in the front row.
    BPL +                                                                       ; $03C0CD |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C0CF |\
    ASL A                                                                       ; $03C0D1 | | Store the offset for this slot in the result array and increment
    TAY                                                                         ; $03C0D2 | | the result count.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03C0D3 | |
    TXA                                                                         ; $03C0D5 | |
    STA r_monster_condition_helper_get_offset_result_offsets.w,Y                ; $03C0D6 | |
    TDC                                                                         ; $03C0D9 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C0DA | |
    INC <r_monster_condition_helper_get_offset_result_count                     ; $03C0DC |/
+   JSR _increment_x_by_128                                                     ; $03C0DE |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03C0E1 | | Increment the slot and offset and loop until all five character
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C0E3 | | slots have been checked.
    CMP #5.b                                                                    ; $03C0E5 | |
    BNE -                                                                       ; $03C0E7 |/
    RTS                                                                         ; $03C0E9

; _battle_check_invalid_target ($03:C0EA)
;
; Given the offset to a character battle record in the X register, determines
; if that slot contains a valid target, specifically by checking for the swoon,
; stone, magnetized, jumping and hiding stauses. It assumes that the slot has
; something in it. The result is returned in $35EA.
_battle_check_invalid_target:
    STZ r_battle_check_invalid_target_result.w                                  ; $03C0EA | Initialize the result to zero.
    LDA r_character_battle.1.status_1.w,X                                       ; $03C0ED |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03C0F0 | | If the slot has the swoon, stone, magnetized, jumping or hiding
    BNE +                                                                       ; $03C0F2 | | statuses, increment the result variable to one. Otherwise, return
    LDA r_character_battle.1.status_3.w,X                                       ; $03C0F4 | | the initial zero.
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03C0F7 | |
    BNE +                                                                       ; $03C0F9 | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03C0FB | |
    BPL ++                                                                      ; $03C0FE | |
+   INC r_battle_check_invalid_target_result.w                                  ; $03C100 |/
++  RTS                                                                         ; $03C103

; monster_condition_opcode_jump_data ($03:C104)
;
; For each monster condition opcode, contains the address for the handler for
; that opcode.
monster_condition_opcode_jump_data:
    .addr _monster_condition_opcode_check_status                                ; $03C104.C105 | $00: Check Status
    .addr _monster_condition_opcode_check_hp                                    ; $03C106.C107 | $01: Check HP
    .addr _monster_condition_opcode_check_flag                                  ; $03C108.C109 | $02: Check Flag
    .addr _monster_condition_opcode_check_living                                ; $03C10A.C10B | $03: Check Living or Dead
    .addr _monster_condition_opcode_check_monster_count                         ; $03C10C.C10D | $04: Check Monster Living or Dead
    .addr _monster_condition_opcode_check_formation                             ; $03C10E.C10F | $05: Check Formation
    .addr _monster_condition_opcode_check_acting_type_alone                     ; $03C110.C111 | $06: Check if acting monster type is only remaining type.
    .addr _monster_condition_opcode_check_recent_attack                         ; $03C112.C113 | $07: Check the most recent attack against the monster.
    .addr _monster_condition_opcode_check_recent_attacks_all                    ; $03C114.C115 | $08: Check recent attacks against monster, ignore actor.
    .addr _monster_condition_opcode_check_running_with_spell                    ; $03C116.C117 | $09: Checks if the party is running with a spell (useless).
    .addr _monster_condition_opcode_check_damage                                ; $03C118.C119 | $0A: Checks if the monster took damage.
    .addr _monster_condition_opcode_check_alone                                 ; $03C11A.C11B | $0B: Checks if the monster is alone.

; monster_condition_helper_get_offset_jump_data ($03:C11C)
;
; Contains pointers to various routines used to get offsets to character or
; monster slots.
monster_condition_helper_get_offset_jump_data:
    .addr _monster_condition_helper_get_offset_character                        ; $03C11C.C11D | $00
    .addr _monster_condition_helper_get_offset_character                        ; $03C11E.C11F | $01
    .addr _monster_condition_helper_get_offset_character                        ; $03C120.C121 | $02
    .addr _monster_condition_helper_get_offset_character                        ; $03C122.C123 | $03
    .addr _monster_condition_helper_get_offset_character                        ; $03C124.C125 | $04
    .addr _monster_condition_helper_get_offset_character                        ; $03C126.C127 | $05
    .addr _monster_condition_helper_get_offset_character                        ; $03C128.C129 | $06
    .addr _monster_condition_helper_get_offset_character                        ; $03C12A.C12B | $07
    .addr _monster_condition_helper_get_offset_character                        ; $03C12C.C12D | $08
    .addr _monster_condition_helper_get_offset_character                        ; $03C12E.C12F | $09
    .addr _monster_condition_helper_get_offset_character                        ; $03C130.C131 | $0A
    .addr _monster_condition_helper_get_offset_character                        ; $03C132.C133 | $0B
    .addr _monster_condition_helper_get_offset_character                        ; $03C134.C135 | $0C
    .addr _monster_condition_helper_get_offset_character                        ; $03C136.C137 | $0D
    .addr _monster_condition_helper_get_offset_character                        ; $03C138.C139 | $0E
    .addr _monster_condition_helper_get_offset_character                        ; $03C13A.C13B | $0F
    .addr _monster_condition_helper_get_offset_character                        ; $03C13C.C13D | $10
    .addr _monster_condition_helper_get_offset_character                        ; $03C13E.C13F | $11
    .addr _monster_condition_helper_get_offset_character                        ; $03C140.C141 | $12
    .addr _monster_condition_helper_get_offset_character                        ; $03C142.C143 | $13
    .addr _monster_condition_helper_get_offset_character                        ; $03C144.C145 | $14
    .addr _monster_condition_helper_get_offset_character                        ; $03C146.C147 | $15
    .addr _monster_condition_helper_get_offset_monster_type_broken              ; $03C148.C149 | $16
    .addr _monster_condition_helper_get_offset_self                             ; $03C14A.C14B | $17
    .addr _monster_condition_helper_get_offset_character_all                    ; $03C14C.C14D | $18
    .addr _monster_condition_helper_get_offset_character_all                    ; $03C14E.C14F | $19
    .addr _monster_condition_helper_get_offset_monster_type_0                   ; $03C150.C151 | $1A
    .addr _monster_condition_helper_get_offset_monster_type_1                   ; $03C152.C153 | $1B
    .addr _monster_condition_helper_get_offset_monster_type_2                   ; $03C154.C155 | $1C
    .addr _monster_condition_helper_get_offset_all                              ; $03C156.C157 | $1D
    .addr _monster_condition_helper_get_offset_all_except_self                  ; $03C158.C159 | $1E
    .addr _monster_condition_helper_get_offset_monster_all                      ; $03C15A.C15B | $1F
    .addr _monster_condition_helper_get_offset_monster_all_except_self          ; $03C15C.C15D | $20
    .addr _monster_condition_helper_get_offset_character_front_row              ; $03C15E.C15F | $21
    .addr _monster_condition_helper_get_offset_character_back_row               ; $03C160.C161 | $22
    .addr _monster_condition_helper_get_offset_monster_all_except_self          ; $03C162.C163 | $23
    .addr _monster_condition_helper_get_offset_monster_all                      ; $03C164.C165 | $24
    .addr _monster_condition_helper_get_offset_monster_type_0                   ; $03C166.C167 | $25
    .addr _monster_condition_helper_get_offset_monster_type_1                   ; $03C168.C169 | $26
    .addr _monster_condition_helper_get_offset_monster_type_2                   ; $03C16A.C16B | $27
    .addr _monster_condition_helper_get_offset_character_front_row              ; $03C16C.C16D | $28
    .addr _monster_condition_helper_get_offset_character_back_row               ; $03C16E.C16F | $29
    .addr _battle_check_invalid_target                                          ; $03C170.C171 | $2A: These four don't really make sense, since they don't set
    .addr _battle_check_invalid_target                                          ; $03C172.C173 | $2B: the result array.
    .addr _battle_check_invalid_target                                          ; $03C174.C175 | $2C
    .addr _battle_check_invalid_target                                          ; $03C176.C177 | $2D
    .addr _monster_condition_helper_get_offset_character_all                    ; $03C178.C179 | $2E
    .addr _monster_condition_helper_get_offset_monster_all                      ; $03C17A.C17B | $2F

; _battle_process_monster_counters ($03:C17C)
;
; Reads the target data for the current action and processes any counters for
; the targets if they were monsters.
_battle_process_monster_counters:
    LDA r_battle_current_action_details.target_flags.w                          ; $03C17C |\
    BMI +                                                                       ; $03C17F | | If the target wasn't a monster, skip this function entirely.
    RTS                                                                         ; $03C181 |/
+   LDA #BATTLE_UPDATE_MODE_NEXT_FRAME_ACTIVE.b                                 ; $03C182 |\ Update everything and wait for the next frame.
    JSR _battle_update                                                          ; $03C184 |/
    LDA r_battle_current_action_details.target.w                                ; $03C187 |\ Copy the action target to a temporary variable.
    STA r_battle_counter_tmp_target.w                                           ; $03C18A |/
@target_start:
    LDA r_monster_script_chain_active.w                                         ; $03C18D |\ Skip any counterattacks if there is a chain active.
    BNE @no_counter_proxy                                                       ; $03C190 |/
    LDA r_battle_counter_tmp_target.w                                           ; $03C192 |\
    BNE ++                                                                      ; $03C195 | | If there were no targets, skip this function.
@no_counter_proxy:                                                              ;         | |
    JMP @no_counter                                                             ; $03C197 |/
++  JSR _battle_get_first_party_target                                          ; $03C19A |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03C19D | | Skip this function if there are no valid party targets.
    BNE @no_counter_proxy                                                       ; $03C19F |/
    LDA #1.b                                                                    ; $03C1A1 |\ Set the skip action timer update flag, as this action shouldn't
    STA r_battle_action_skip_action_timer_update.w                              ; $03C1A3 |/ affect that timer.
    STA r_battle_counter_active.w                                               ; $03C1A6 | Set the counter active flag.
    LDX #5.w                                                                    ; $03C1A9 |\
    LDA r_battle_counter_tmp_target.w                                           ; $03C1AC | | Loop through the target variable until finding the first target.
-   ASL A                                                                       ; $03C1AF | | The true slot will be in the X register.
    BCS +                                                                       ; $03C1B0 | |
    INX                                                                         ; $03C1B2 | |
    BRA -                                                                       ; $03C1B3 | |
+   TXA                                                                         ; $03C1B5 |/
    STA <r_battle_timer_slot                                                    ; $03C1B6 | Set the current monster as the timer slot.
    SEC                                                                         ; $03C1B8 |\
    SBC #5.b                                                                    ; $03C1B9 | | Set the X register to the monster's relative slot.
    TAX                                                                         ; $03C1BB |/
    LDA r_battle_counter_tmp_target.w                                           ; $03C1BC |\
    JSR _unset_bit_x                                                            ; $03C1BF | | Unset this monster in the temporary target variable.
    STA r_battle_counter_tmp_target.w                                           ; $03C1C2 |/
    LDA r_monster_has_counters.w,X                                              ; $03C1C5 |\ If this monster doesn't have counters, branch to code to unset the
    BEQ +                                                                       ; $03C1C8 |/ two skip flags and skip to the next monster.
    LDA <r_battle_timer_slot                                                    ; $03C1CA |\ Calculate the offsets for this monster.
    JSR _calculate_offsets                                                      ; $03C1CC |/
    TDC                                                                         ; $03C1CF |\ Initialize the Y register to zero.
    TAY                                                                         ; $03C1D0 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03C1D1 | Set the X register to this monster's stat offset.
    LDA r_character_battle.1.status_1.w,X                                       ; $03C1D3 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03C1D6 | | Skip this slot if it has the swoon or stone statuses.
    BNE +                                                                       ; $03C1D8 |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03C1DA |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03C1DD | | Skip this slot if it has paralyze, sleep, charm or berserk.
    BNE +                                                                       ; $03C1DF |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03C1E1 |\
    AND #STATUS_3_STOP.b                                                        ; $03C1E4 | | Skip this slot if stopped.
    BEQ @backup_action                                                          ; $03C1E6 |/
+   STZ r_battle_action_skip_action_timer_update.w                              ; $03C1E8 |\
    STZ r_battle_counter_active.w                                               ; $03C1EB | | If skipping this slot, unset the flags and branch back.
    BRA @target_start                                                           ; $03C1EE |/
@backup_action:
    LDA r_character_battle.1.action_flags.w,X                                   ; $03C1F0 |\
    STA r_battle_counter_monster_action_backup.w,Y                              ; $03C1F3 | | Backup the monster's currently existing action information bytes.
    INX                                                                         ; $03C1F6 | |
    INY                                                                         ; $03C1F7 | |
    CPY #_sizeof_r_battle_counter_monster_action_backup.w                       ; $03C1F8 | |
    BNE @backup_action                                                          ; $03C1FB |/
    TDC                                                                         ; $03C1FD |\
    TAY                                                                         ; $03C1FE | | Zero out the monster's action information bytes.
    LDX <r_current_slot_offset_character_battle                                 ; $03C1FF | |
-   STZ r_character_battle.1.action_flags.w,X                                   ; $03C201 | |
    INX                                                                         ; $03C204 | |
    INY                                                                         ; $03C205 | |
    CPY #_sizeof_r_battle_counter_monster_action_backup.w                       ; $03C206 | |
    BNE -                                                                       ; $03C209 |/
    SEC                                                                         ; $03C20B |\
    LDA <r_battle_timer_slot                                                    ; $03C20C | | Save the relative monster slot to another variable.
    SBC #5.b                                                                    ; $03C20E | |
    STA r_monster_script_current_monster_slot.w                                 ; $03C210 |/
    STA <r_math_multiply_8bit_arg_1                                             ; $03C213 |\
    LDA #_sizeof_action_set.b                                                   ; $03C215 | | Set the X register to the offset for this monster's modified
    STA <r_math_multiply_8bit_arg_2                                             ; $03C217 | | action set.
    JSR _math_multiply_8bit                                                     ; $03C219 | |
    LDX <r_math_multiply_8bit_result                                            ; $03C21C |/
    TDC                                                                         ; $03C21E |\
    TAY                                                                         ; $03C21F | | Copy the monster's modified action set from the base array to the
-   LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C220 | | shared location, as a backup.
    STA r_monster_script_current_modified_action_set.w,Y                        ; $03C223 | |
    INX                                                                         ; $03C226 | |
    INY                                                                         ; $03C227 | |
    CPY #_sizeof_action_set.w                                                   ; $03C228 | |
    BNE -                                                                       ; $03C22B |/
    JSR _monster_script_reset_modified_action_set                               ; $03C22D | Reset the monster's individual action set to all end commands.
    STZ r_monster_script_script_index.w                                         ; $03C230 | Set the monster script index to zero.
    LDA r_monster_script_current_monster_slot.w                                 ; $03C233 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03C236 | | Calculate the offset to this monster's scripts.
    LDA #_sizeof_battle_script.b                                                ; $03C238 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03C23A | |
    JSR _math_multiply_8bit                                                     ; $03C23C | |
    LDX <r_math_multiply_8bit_result                                            ; $03C23F | |
    STX r_monster_script_script_offset_base.w                                   ; $03C241 | |
    STX r_monster_script_script_offset_current.w                                ; $03C244 |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03C247 |\
    TAX                                                                         ; $03C24A | | Calculate the offset for this monster's action sets.
    STX r_math_multiply_16bit_arg_1.w                                           ; $03C24B | |
    LDX #_sizeof_action_sets.w                                                  ; $03C24E | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03C251 | |
    JSR _math_multiply_16bit                                                    ; $03C254 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03C257 | |
    STX r_monster_script_action_set_offset_base.w                               ; $03C25A | |
    STX r_monster_script_action_set_offset_current.w                            ; $03C25D |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03C260 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03C263 | | Calculate the offset for this monster's condition sets.
    LDA #_sizeof_condition_sets.b                                               ; $03C265 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03C267 | |
    JSR _math_multiply_8bit                                                     ; $03C269 | |
    LDX <r_math_multiply_8bit_result                                            ; $03C26C | |
    STX r_monster_script_condition_set_offset_base.w                            ; $03C26E |/
    LDA r_monster_script_current_monster_slot.w                                 ; $03C271 |\
    TAX                                                                         ; $03C274 | | Calculate the offset for this monster's actual condition data.
    STX r_math_multiply_16bit_arg_1.w                                           ; $03C275 | |
    LDX #_sizeof_condition_sets_expanded.w                                      ; $03C278 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03C27B | |
    JSR _math_multiply_16bit.w                                                  ; $03C27E | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03C281 | |
    STX r_monster_script_condition_offset_base.w                                ; $03C284 |/
@condition_check:
    LDA r_monster_script_script_index.w                                         ; $03C287 |\
    JSR _math_multiply_by_4                                                     ; $03C28A | | Multiply the script index by four and add the base condition set
    CLC                                                                         ; $03C28D | | offset to get the current condition set offset.
    ADC r_monster_script_condition_set_offset_base_lo.w                         ; $03C28E | |
    STA r_monster_script_condition_set_offset_current_lo.w                      ; $03C291 | |
    LDA r_monster_script_condition_set_offset_base_hi.w                         ; $03C294 | |
    ADC #0.b                                                                    ; $03C297 | |
    STA r_monster_script_condition_set_offset_current_hi.w                      ; $03C299 |/
    LDA r_monster_script_script_index.w                                         ; $03C29C |\
    TAX                                                                         ; $03C29F | | Multiply the script index by 16 and add the base condition data
    REP #FLAG_P_ACCUMULATOR                                                     ; $03C2A0 | | offset to get the current condition data offset.
    TXA                                                                         ; $03C2A2 | |
    JSR _math_multiply_by_16                                                    ; $03C2A3 | |
    CLC                                                                         ; $03C2A6 | |
    ADC r_monster_script_condition_offset_base.w                                ; $03C2A7 | |
    STA r_monster_script_condition_offset_current.w                             ; $03C2AA | |
    TDC                                                                         ; $03C2AD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C2AE |/
    LDX r_monster_script_script_offset_current.w                                ; $03C2B0 |\ Load the first condition index for this script.
    LDA r_monster_counter_scripts.w,X                                           ; $03C2B3 |/
    CMP #$FF.b                                                                  ; $03C2B6 |\ Branch forward if this is the end of the script.
    BEQ @next                                                                   ; $03C2B8 |/
    STZ r_monster_script_condition_index.w                                      ; $03C2BA | Set the condition index to zero.
--  LDX r_monster_script_condition_set_offset_current.w                         ; $03C2BD |\
    LDA r_monster_counter_condition_sets.w,X                                    ; $03C2C0 | | Load the next condition in the condition set and branch forward if
    CMP #$FF.b                                                                  ; $03C2C3 | | reaching the end.
    BEQ +                                                                       ; $03C2C5 |/
    TDC                                                                         ; $03C2C7 |\
    TAY                                                                         ; $03C2C8 | | Copy the data for that condition into a temporary area in memory.
    LDX r_monster_script_condition_offset_current.w                             ; $03C2C9 | |
-   LDA r_monster_counter_conditions.w,X                                        ; $03C2CC | |
    STA r_battle_tmp_monster_condition.w,Y                                      ; $03C2CF | |
    INX                                                                         ; $03C2D2 | |
    INY                                                                         ; $03C2D3 | |
    CPY #_sizeof_condition.w                                                    ; $03C2D4 | |
    BNE -                                                                       ; $03C2D7 |/
    STX r_monster_script_condition_offset_current.w                             ; $03C2D9 |\ Check the condition.
    JSR _monster_condition_check                                                ; $03C2DC |/
    LDA <r_monster_condition_check_result                                       ; $03C2DF |\
    BEQ ++                                                                      ; $03C2E1 | | If the condition matched, increment the indexes and loop until all
    INC r_monster_script_condition_set_offset_current.w                         ; $03C2E3 | | potential conditions have been checked.
    INC r_monster_script_condition_index.w                                      ; $03C2E6 | |
    LDA r_monster_script_condition_index.w                                      ; $03C2E9 | |
    CMP #_sizeof_condition_set.b                                                ; $03C2EC | |
    BNE --                                                                      ; $03C2EE |/
+   INC r_monster_script_script_index.w                                         ; $03C2F0 |\ If all conditions matched, increment the script index and branch
    BRA @next                                                                   ; $03C2F3 |/ ahead.
++  INC r_monster_script_script_offset_current.w                                ; $03C2F5 |\
    INC r_monster_script_script_offset_current.w                                ; $03C2F8 | | If any condition didn't match, increment the script index and try
    INC r_monster_script_script_index.w                                         ; $03C2FB | | again with the next script.
    BRA @condition_check                                                        ; $03C2FE |/
@next:
    LDA <r_monster_condition_check_result                                       ; $03C300 |\ If the last condition check was a failure, branch to code to jump
    BEQ +                                                                       ; $03C302 |/ to the end. No action will be taken.
    LDA r_monster_script_script_index.w                                         ; $03C304 |\
    DEC A                                                                       ; $03C307 | | Decrement from the script index to have it point to the right
    STA r_monster_script_script_index.w                                         ; $03C308 | | script.
    BRA ++                                                                      ; $03C30B |/
+   JMP @done                                                                   ; $03C30D | Jump to the end if failure.
++  LDA r_monster_script_current_monster_slot.w                                 ; $03C310 |\
    TAX                                                                         ; $03C313 | | Calculate the offset to this monster's action sets.
    STX r_math_multiply_16bit_arg_1.w                                           ; $03C314 | |
    LDX #_sizeof_action_sets.w                                                  ; $03C317 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03C31A | |
    JSR _math_multiply_16bit                                                    ; $03C31D |/
    LDA r_monster_script_script_index.w                                         ; $03C320 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03C323 | | Calculate the offset to the current action set within that data.
    LDA #_sizeof_action_set.b                                                   ; $03C325 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03C327 | |
    JSR _math_multiply_8bit                                                     ; $03C329 |/
    CLC                                                                         ; $03C32C |\
    LDA r_math_multiply_16bit_result_lo_lo.w                                    ; $03C32D | | Add the two results together and copy the final result to the X
    ADC <r_math_multiply_8bit_result_lo                                         ; $03C330 | | register.
    STA <r_math_multiply_8bit_result_lo                                         ; $03C332 | |
    LDA r_math_multiply_16bit_result_lo_hi.w                                    ; $03C334 | |
    ADC <r_math_multiply_8bit_result_hi                                         ; $03C337 | |
    STA <r_math_multiply_8bit_result_hi                                         ; $03C339 | |
    LDX <r_math_multiply_8bit_result                                            ; $03C33B |/
    TDC                                                                         ; $03C33D |\ Initialize the Y register to zero.
    TAY                                                                         ; $03C33E |/
-   LDA r_monster_counter_actions.l,X                                           ; $03C33F |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03C343 | | Copy the entire counter script to a temporary area in memory.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C346 | |
    BEQ +                                                                       ; $03C348 | |
    INX                                                                         ; $03C34A | |
    INY                                                                         ; $03C34B | |
    BRA -                                                                       ; $03C34C |/
+   TDC                                                                         ; $03C34E |\ Initialize the X register to zero.
    TAX                                                                         ; $03C34F |/
    LDY r_battle_current_action_set_offset.w                                    ; $03C350 | Set the Y register to the current action set offset.
-   LDA r_battle_script_tmp_copy.w,X                                            ; $03C353 |\ Read the next byte of the script.
    STA r_monster_script_current_modified_action_sets.w,Y                       ; $03C356 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C359 |\ If reaching the end of the script, branch ahead.
    BEQ +++                                                                     ; $03C35B |/
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03C35D |\
    BCS +                                                                       ; $03C35F | | If the next byte is less than $C0, it's a spell. Store the byte as
    STA r_monster_script_current_modified_action_sets.w + 1,Y                   ; $03C361 | | the next byte in the script, set it also as the monster's
    PHX                                                                         ; $03C364 | | subcommand, and set the current byte in the script to the command
    LDX <r_current_slot_offset_character_battle                                 ; $03C365 | | for magic.
    STA r_character_battle.1.subcommand.w,X                                     ; $03C367 | |
    PLX                                                                         ; $03C36A | |
    LDA #MONSTER_COMMAND_WHITE.b                                                ; $03C36B | |
    STA r_monster_script_current_modified_action_sets.w,Y                       ; $03C36D | |
    INY                                                                         ; $03C370 |/
+   CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03C371 |\
    BCC +                                                                       ; $03C373 | | Otherwise, branch according to the byte range.
    CMP #MONSTER_COMMAND_UNKNOWN_FA.b                                           ; $03C375 | |
    BCS ++                                                                      ; $03C377 |/
    INX                                                                         ; $03C379 |\
    INY                                                                         ; $03C37A | | If the byte is in the range $E8 to $FA, it has a parameter byte,
    LDA r_battle_script_tmp_copy.w,X                                            ; $03C37B | | so copy that byte to the script.
    STA r_monster_script_current_modified_action_sets.w,Y                       ; $03C37E | |
    BRA ++                                                                      ; $03C381 |/
+   PHX                                                                         ; $03C383 |\
    LDX <r_current_slot_offset_character_battle                                 ; $03C384 | | If the byte is less than $E8, it's either a command or spell, so
    STA r_character_battle.1.command.w,X                                        ; $03C386 | | set the byte as the monster's command ($C2 if a spell).
    PLX                                                                         ; $03C389 |/
++  INX                                                                         ; $03C38A |\
    INY                                                                         ; $03C38B | | Increment the indexes and move on to the next byte.
    BRA -                                                                       ; $03C38C |/
+++ LDX r_battle_current_action_set_offset.w                                    ; $03C38E | Set the X register to the offset to the action set.
@start:
    LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C391 | Read the next byte.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C394 |\ If this is the end of the script, branch to handle the end.
    BEQ @end                                                                    ; $03C396 |/
    CMP #MONSTER_COMMAND_SET_TARGET.b                                           ; $03C398 |\ If setting the target, branch to the set target code.
    BEQ @set_target                                                             ; $03C39A |/
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03C39C |\ If less than $E8, branch to increment once, as there is no
    BCC @single                                                                 ; $03C39E |/ parameter.
    CMP #MONSTER_COMMAND_SET_MONSTER_SPRITE.b                                   ; $03C3A0 |\ If the byte is from $E8 to $EF, branch to handle the stat change
    BCC +                                                                       ; $03C3A2 |/ functions.
    CMP #MONSTER_COMMAND_UNKNOWN_F4.b                                           ; $03C3A4 |\ If in the range $F0 to $F3, branch to increment the index twice.
    BCC @double                                                                 ; $03C3A6 |/
    CMP #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03C3A8 |\ If greater or equal to $F8, branch ahead to increment without a
    BCS @single                                                                 ; $03C3AA |/ parameter byte.
    PHX                                                                         ; $03C3AC |\
    PHA                                                                         ; $03C3AD | | If in the range $F4 to $F7, load the next byte as the parameter
    INX                                                                         ; $03C3AE | | and call code to update the associated flag.
    LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C3AF | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03C3B2 | |
    PLA                                                                         ; $03C3B4 | |
    JSR _monster_script_command_update_flag                                     ; $03C3B5 | |
    PLX                                                                         ; $03C3B8 | |
    BRA @double                                                                 ; $03C3B9 |/
+   PHX                                                                         ; $03C3BB |\
    PHA                                                                         ; $03C3BC | | If a stat change, load the parameter byte and call the code to
    INX                                                                         ; $03C3BD | | handle the stat change.
    LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C3BE | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03C3C1 | |
    PLA                                                                         ; $03C3C3 | |
    JSR _monster_script_command_stat_change                                     ; $03C3C4 | |
    PLX                                                                         ; $03C3C7 | |
    BRA @double                                                                 ; $03C3C8 |/
@set_target:
    PHX                                                                         ; $03C3CA |\
    INX                                                                         ; $03C3CB | | If setting the target, read the parameter byte and call the
    LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C3CC | | function to set the target.
    STA <r_battle_generic_tmp_1_lo                                              ; $03C3CF | |
    JSR _monster_script_command_set_target                                      ; $03C3D1 | |
    PLX                                                                         ; $03C3D4 |/
@double:
    INX                                                                         ; $03C3D5 | Increment the index once for double byte instructions.
@single:
    INX                                                                         ; $03C3D6 | Increment the index for all instructions.
    BRA @start                                                                  ; $03C3D7 | Loop back to move to the next byte.
@end:
    JSR _battle_monster_script_default_set_target                               ; $03C3D9 | Set a default target if none was set.
    LDA r_monster_script_current_monster_slot.w                                 ; $03C3DC |\
    TAX                                                                         ; $03C3DF | | Unset the monster's target set flag.
    STZ r_monster_target_set.w,X                                                ; $03C3E0 |/
    JSR _battle_command_execute_counter                                         ; $03C3E3 | Execute the counterattack.
@done:
    LDA <r_battle_timer_slot                                                    ; $03C3E6 |\ Calculate offsets for the slot.
    JSR _calculate_offsets                                                      ; $03C3E8 |/
    TDC                                                                         ; $03C3EB |\
    TAY                                                                         ; $03C3EC | | Copy the monster's action data from the backup back to the
    LDX <r_current_slot_offset_character_battle                                 ; $03C3ED | | monster's stat record.
-   LDA r_battle_counter_monster_action_backup.w,Y                              ; $03C3EF | |
    STA r_character_battle.1.action_flags.w,X                                   ; $03C3F2 | |
    INX                                                                         ; $03C3F5 | |
    INY                                                                         ; $03C3F6 | |
    CPY #_sizeof_r_battle_counter_monster_action_backup.w                       ; $03C3F7 | |
    BNE -                                                                       ; $03C3FA |/
    LDX r_battle_current_action_set_offset.w                                    ; $03C3FC |\
    TDC                                                                         ; $03C3FF | | Copy the backed up action set data for the monster back to the
    TAY                                                                         ; $03C400 | | main array.
-   LDA r_monster_script_current_modified_action_set.w,Y                        ; $03C401 | |
    STA r_monster_script_current_modified_action_sets.w,X                       ; $03C404 | |
    INX                                                                         ; $03C407 | |
    INY                                                                         ; $03C408 | |
    CPY #_sizeof_action_set.w                                                   ; $03C409 | |
    BNE -                                                                       ; $03C40C |/
    JMP @target_start                                                           ; $03C40E | Jump back to handle the next target.
@no_counter:
    STZ r_battle_action_skip_action_timer_update.w                              ; $03C411 |\ Reset the two flags before returning.
    STZ r_battle_counter_active.w                                               ; $03C414 |/
    RTS                                                                         ; $03C417

; _battle_get_first_party_target ($03:C418)
;
; Loops through the party slots until it finds a valid target (a slot that is
; non-empty and has none of the swoon, stone, magnetized, jumping or hiding
; statuses). The offset to that slot will be left in the X register, the actual
; slot number will be in the Y register, and $A9 will be set to 1 if none was
; found.
_battle_get_first_party_target:
    TDC                                                                         ; $03C418 |\
    TAX                                                                         ; $03C419 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03C41A |/
    STY <r_battle_generic_tmp_1                                                 ; $03C41B | Initialize the result flag to zero.
-   LDA r_battle_slot_empty.w,Y                                                 ; $03C41D |\ Skip this slot if it's empty.
    BNE +                                                                       ; $03C420 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03C422 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03C425 | | Skip this slot if it has the swoon or stone statuses.
    BNE +                                                                       ; $03C427 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03C429 |\
    AND #(STATUS_3_MAGNETIZED | STATUS_3_JUMPING).b                             ; $03C42C | | Skip this slot if magnetized or jumping.
    BNE +                                                                       ; $03C42E |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03C430 |\ Return if the slot is not hiding.
    BPL ++                                                                      ; $03C433 |/
+   JSR _increment_x_by_128                                                     ; $03C435 | Increment the X register by 128.
    INY                                                                         ; $03C438 |\
    CPY #5.w                                                                    ; $03C439 | | Loop until all five character slots have been checked.
    BNE -                                                                       ; $03C43C |/
    INC <r_battle_generic_tmp_1_lo                                              ; $03C43E | If none was found, increment the result variable.
++  RTS                                                                         ; $03C440

; _monster_script_wait_if_chain ($03:C441)
;
; Writes a script into the monster's modified action set at $3659,X to simply
; wait and then end a chain, but only if there is a chain end command in the
; current action set. Sets $A9 to 1 if so. The new script data will be written
; to the modified action set starting at the 16-bit offset passed in $38BB.
;
; BUG: The value in $38BB is used to index both $3839 and $3659. Either a) the
;      passed value is relative to a single action set and the code will always
;      overwrite the script for monster zero or b) the passed value is relative
;      to the entire modified action set array and the search part will read
;      random data from later in RAM. Either way, it doesn't seem quite right.
_monster_script_wait_if_chain:
    TDC                                                                         ; $03C441 |\
    TAY                                                                         ; $03C442 | | Initialize the result variable to zero.
    STY <r_battle_generic_tmp_1                                                 ; $03C443 |/
    LDX r_battle_current_action_set_offset.w                                    ; $03C445 | Load the offset to the current action set.
-   LDA r_monster_script_current_modified_action_sets.w,X                       ; $03C448 |\
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C44B | | Scan through the script searching for either the end command or a
    BEQ ++                                                                      ; $03C44D | | chain end command. If the end, simply skip the rest of the
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03C44F | | function. If finding the end of a chain, branch to the next code.
    BEQ +                                                                       ; $03C451 | |
    INX                                                                         ; $03C453 | |
    BRA -                                                                       ; $03C454 |/
+   INC <r_battle_generic_tmp_1_lo                                              ; $03C456 | Increment the result variable.
    LDX r_battle_current_action_set_offset.w                                    ; $03C458 | Load the offset to the action set into the X register.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03C45B |\
    STA r_monster_script_current_modified_action_sets.w + 0,X                   ; $03C45D | | Write a script to have the monster wait and then end the chain.
    TDC                                                                         ; $03C460 | |
    STA r_monster_script_current_modified_action_sets.w + 1,X                   ; $03C461 | | NOTE: The end command that is written here is immediately
    DEC A                                                                       ; $03C464 | |       overwritten by the chain end command. This means any other
    STA r_monster_script_current_modified_action_sets.w + 2,X                   ; $03C465 | |       bytes may still be executed.
    LDA #MONSTER_COMMAND_CHAIN_END.b                                            ; $03C468 | |       TODO: Are they?
    STA r_monster_script_current_modified_action_sets.w + 2,X                   ; $03C46A |/
++  RTS                                                                         ; $03C46D

; _monster_script_wait_if_chain_separate ($03:C46E)
;
; If the current script in the array at $3839 starting at the offset in the X
; register has a chain end command, sets $A9 to 1, and writes command to wait
; and end a chain at the same location in the array at $3659.
;
; BUG: The X register is used to index both $3839 and $3659. Either a) the
;      passed value is relative to a single action set and the code will always
;      overwrite the script for monster zero or b) the passed value is relative
;      to the entire modified action set array and the search part will read
;      random data from later in RAM. Either way, it doesn't seem quite right.
_monster_script_wait_if_chain_separate:
    TDC                                                                         ; $03C46E |\
    TAY                                                                         ; $03C46F | | Initialize the result variable to zero.
    STY <r_battle_generic_tmp_1                                                 ; $03C470 |/
    PHX                                                                         ; $03C472 | Preserve the current value of the X register.
-   LDA r_monster_script_current_modified_action_set.w,X                        ; $03C473 |\
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C476 | | Scan through the current modified action set at $3839 for either
    BEQ ++                                                                      ; $03C478 | | the end command or the chain end command. If the end, skip the
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03C47A | | rest of the function. Otherwise, execute the rest of the function.
    BEQ +                                                                       ; $03C47C | |
    INX                                                                         ; $03C47E | |
    BRA -                                                                       ; $03C47F |/
+   INC <r_battle_generic_tmp_1_lo                                              ; $03C481 | Increment the result variable.
    PLX                                                                         ; $03C483 | Set the X register to its previous value.
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03C484 |\
    STA r_monster_script_current_modified_action_sets.w + 0,X                   ; $03C486 | | Write a script to wait and end the chain.
    TDC                                                                         ; $03C489 | |
    STA r_monster_script_current_modified_action_sets.w + 1,X                   ; $03C48A | |
    DEC A                                                                       ; $03C48D | |
    STA r_monster_script_current_modified_action_sets.w + 3,X                   ; $03C48E | |
    LDA #MONSTER_COMMAND_CHAIN_END.b                                            ; $03C491 | |
    STA r_monster_script_current_modified_action_sets.w + 2,X                   ; $03C493 | |
    RTS                                                                         ; $03C496 |/
++  PLX                                                                         ; $03C497 | Restore the X register to its previous value.
    RTS                                                                         ; $03C498

; _battle_command_execute_fight ($03:C499)
;
; Handles the Fight battle command and calculating damage and processing status
; effects of the attack.
_battle_command_execute_fight:
    STZ r_battle_current_action_details.action_flags.w                          ; $03C499 | Initialize the action flags to zero.
    STZ r_battle_update_hand_inventory_pending.w                                ; $03C49C | Initially no hand inventory update is necessary.
    TDC                                                                         ; $03C49F |\
    TAX                                                                         ; $03C4A0 | | Initialize the script index to zero.
    STX r_battle_script_tmp_index.w                                             ; $03C4A1 |/
    LDA r_battle_command_actor_slot.b                                           ; $03C4A4 |\
    BMI +                                                                       ; $03C4A6 | | If the actor is a character, set the next two bytes of the
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03C4A8 | | audiovisual script to display the damage. Subtract an arrow from
    STA r_battle_script_audiovisual.w + 4                                       ; $03C4AA | | the character's hand inventory, if equipped, and then branch to
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03C4AD | | the actual calculation.
    STA r_battle_script_audiovisual.w + 5                                       ; $03C4AF | |
    JSR _battle_subtract_arrow_if_equipped                                      ; $03C4B2 | |
    BRA @calculation_start                                                      ; $03C4B5 |/
+   LDA r_monster_script_chain_slot.w                                           ; $03C4B7 |\
    CMP #$FF.b                                                                  ; $03C4BA | | If there is an active chain, scan through the audiovisual script
    BEQ +                                                                       ; $03C4BC | | looking for either the end of a chain or the end of the script. If
    TDC                                                                         ; $03C4BE | | finding the end of the chain first, branch ahead to the next
    TAX                                                                         ; $03C4BF | | block. If finding the end of the script, branch ahead to the start
-   LDA r_battle_script_audiovisual.w,X                                         ; $03C4C0 | | of the calculation.
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03C4C3 | |
    BEQ +                                                                       ; $03C4C5 | |
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C4C7 | |
    BEQ @calculation_start                                                      ; $03C4C9 | |
    INX                                                                         ; $03C4CB | |
    BRA -                                                                       ; $03C4CC |/
+   TDC                                                                         ; $03C4CE |\
    TAX                                                                         ; $03C4CF | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03C4D0 |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03C4D1 |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03C4D4 | | Copy the audiovisual script up until the end of the script to a
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C4D7 | | copy array.
    BEQ +                                                                       ; $03C4D9 | |
    INX                                                                         ; $03C4DB | |
    INY                                                                         ; $03C4DC | |
    BRA -                                                                       ; $03C4DD |/
+   TDC                                                                         ; $03C4DF |\
    TAX                                                                         ; $03C4E0 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03C4E1 |/
-   LDA r_battle_script_tmp_copy.w,X                                            ; $03C4E2 |\ Copy bytes back from the copy to the main script.
    STA r_battle_script_audiovisual.w,Y                                         ; $03C4E5 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C4E8 |\ If copying the end of the script, branch ahead to the start of the
    BEQ @calculation_start                                                      ; $03C4EA |/ calculation.
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03C4EC |\
    BEQ +                                                                       ; $03C4EE | | If the command is not Fight, Jump or land, branch ahead to move to
    CMP #MONSTER_COMMAND_JUMP.b                                                 ; $03C4F0 | | the next byte.
    BEQ +                                                                       ; $03C4F2 | |
    CMP #MONSTER_COMMAND_LAND.b                                                 ; $03C4F4 | |
    BNE ++                                                                      ; $03C4F6 |/
+   INY                                                                         ; $03C4F8 |\
    STY r_battle_script_tmp_index.w                                             ; $03C4F9 | | If the command is one of the above three, insert the commands to
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03C4FC | | display damage afterward.
    STA r_battle_script_audiovisual.w,Y                                         ; $03C4FE | |
    INY                                                                         ; $03C501 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03C502 | |
    STA r_battle_script_audiovisual.w,Y                                         ; $03C504 |/
++  INX                                                                         ; $03C507 |\
    INY                                                                         ; $03C508 | | Either way, increment the indexes and loop to the next byte.
    BRA -                                                                       ; $03C509 |/
@calculation_start:
    STZ <r_battle_apply_physical_status_arg_status_offset_lo                    ; $03C50B | Initialize the status offset to zero.
    STZ r_battle_damage_hits.w                                                  ; $03C50D | Initialize the total number of hits to zero.
    LDA r_character_battle_current_actor.physical_attack_accuracy.w             ; $03C510 |\ Load the acting slot's physical accuracy into a local variable.
    STA r_battle_physical_attack_hits.w                                         ; $03C513 |/
    LDA r_character_battle_current_actor.status_1.w                             ; $03C516 |\
    AND #STATUS_1_DARKNESS.b                                                    ; $03C519 | | If the actor is afflicted with darkness, reduce their accuracy by
    BEQ +                                                                       ; $03C51B | | one half.
    LSR r_battle_physical_attack_hits.w                                         ; $03C51D |/
+   LDA r_character_battle_current_actor.sprite_class.w                         ; $03C520 |\
    BPL +                                                                       ; $03C523 | | If the actor is in the back row and does not have either the long
    LDA r_character_battle_current_actor.sprite_class.w                         ; $03C525 | | range bit or the jumping status, reduce accuracy by one half.
    AND #SPRITE_CLASS_LONG_RANGE.b                                              ; $03C528 | |
    BNE +                                                                       ; $03C52A | |
    LDA r_character_battle_current_actor.status_3.w                             ; $03C52C | |
    AND #STATUS_3_JUMPING.b                                                     ; $03C52F | |
    BNE +                                                                       ; $03C531 | |
    LSR r_battle_physical_attack_hits.w                                         ; $03C533 |/
+   LDA <r_battle_command_actor_slot                                            ; $03C536 |\
    AND #%01111111.b                                                            ; $03C538 | | If the actor is a character and is in the middle slot, or if a
    BNE +                                                                       ; $03C53A | | monster in monster slot zero, multiply their accuracy by 5/4.
    LDA r_battle_physical_attack_hits.w                                         ; $03C53C | |
    STA <r_math_multiply_8bit_arg_1                                             ; $03C53F | | BUG: If the actor's base accuracy times 5/4 overflows beyond 255,
    LDA #5.b                                                                    ; $03C541 | |      this code will cause it to be drastically reduced. The only
    STA <r_math_multiply_8bit_arg_2                                             ; $03C543 | |      time this happens naturally is if Aim is used, which forces
    JSR _math_multiply_8bit                                                     ; $03C545 | |      the accuracy to 255.
    LSR <r_math_multiply_8bit_result_hi                                         ; $03C548 | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03C54A | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03C54C | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03C54E | |
    LDA <r_math_multiply_8bit_result_lo                                         ; $03C550 | |
    STA r_battle_physical_attack_hits.w                                         ; $03C552 |/
+   LDA r_character_battle_current_target.sprite_class.w                        ; $03C555 |\
    BPL +                                                                       ; $03C558 | | If the target is in the back row and the actor has neither the
    LDA r_character_battle_current_actor.sprite_class.w                         ; $03C55A | | long range bit or the jumping status, reduce the accuracy by one
    AND #SPRITE_CLASS_LONG_RANGE.b                                              ; $03C55D | | half.
    BNE +                                                                       ; $03C55F | |
    LDA r_character_battle_current_actor.status_3.w                             ; $03C561 | |
    AND #STATUS_3_JUMPING.b                                                     ; $03C564 | |
    BNE +                                                                       ; $03C566 | |
    LSR r_battle_physical_attack_hits.w                                         ; $03C568 |/
+   LDA r_battle_physical_attack_hits.w                                         ; $03C56B |\
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03C56E | | Based on the actor's physical attack multiplier and accuracy,
    LDA r_character_battle_current_actor.physical_attack_multiplier.w           ; $03C571 | | determine the number of hits.
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03C574 | |
    JSR _battle_calculate_hits                                                  ; $03C577 | |
    LDA r_battle_calculate_hits_result.w                                        ; $03C57A | |
    STA r_battle_physical_attack_hits.w                                         ; $03C57D |/
    LDA <r_battle_command_target_slot                                           ; $03C580 |\
    BPL +                                                                       ; $03C582 | | Calculate the offsets for the target slot.
    AND #%01111111.b                                                            ; $03C584 | |
    CLC                                                                         ; $03C586 | |
    ADC #5.b                                                                    ; $03C587 | |
+   JSR _calculate_offsets                                                      ; $03C589 |/
    LDA r_character_battle_current_target.status_4.w                            ; $03C58C |\
    AND #STATUS_4_BARRIER.b                                                     ; $03C58F | | If the target has barrier status or doesn't have image status,
    BNE +                                                                       ; $03C591 | | skip the image code.
    LDA r_character_battle_current_target.status_4.w                            ; $03C593 | |
    AND #(STATUS_4_IMAGE_ONE_HIT | STATUS_4_IMAGE_TWO_HITS).b                   ; $03C596 | |
    BEQ ++                                                                      ; $03C598 |/
    LSR A                                                                       ; $03C59A |\
    AND #STATUS_4_IMAGE_ONE_HIT.b                                               ; $03C59B | | If the target has image status, change the image status to remove
    STA <r_battle_generic_tmp_1_lo                                              ; $03C59D | | one hit.
    LDX <r_current_slot_offset_character_battle                                 ; $03C59F | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03C5A1 | |
    AND #(STATUS_4_IMAGE_ONE_HIT | STATUS_4_IMAGE_TWO_HITS).b ~ $FF             ; $03C5A4 | |
    ORA <r_battle_generic_tmp_1_lo                                              ; $03C5A6 | |
    STA r_character_battle.1.status_4.w,X                                       ; $03C5A8 |/
+   LDA #$FF.b                                                                  ; $03C5AB |\ If the target has barrier or image status, load $FF into the
    BRA @total_hits                                                             ; $03C5AD |/ accumulator and branch ahead past the next block.
++  LDA r_character_battle_current_target.physical_defense_evade.w              ; $03C5AF |\ Load the target's physical evade into a temporary variable.
    STA r_battle_physical_evade_hits.w                                          ; $03C5B2 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03C5B5 |\
    AND #STATUS_1_DARKNESS.b                                                    ; $03C5B8 | | If the target has the darkness status, reduce the target's evade
    BEQ +                                                                       ; $03C5BA | | by one half.
    LSR r_battle_physical_evade_hits.w                                          ; $03C5BC |/
+   LDA <r_battle_command_target_slot                                           ; $03C5BF |\
    AND #%01111111.b                                                            ; $03C5C1 | | If the target is in either character or monster slot zero,
    BNE +                                                                       ; $03C5C3 | | multiply their evade by 5/4. Monsters generally don't have evade,
    LDA r_battle_physical_evade_hits.w                                          ; $03C5C5 | | so this doesn't end up doing much for monsters.
    STA <r_math_multiply_8bit_arg_1                                             ; $03C5C8 | |
    LDA #5.b                                                                    ; $03C5CA | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03C5CC | |
    JSR _math_multiply_8bit                                                     ; $03C5CE | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03C5D1 | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03C5D3 | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03C5D5 | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03C5D7 | |
    LDA <r_math_multiply_8bit_result_lo                                         ; $03C5D9 | |
    STA r_battle_physical_evade_hits.w                                          ; $03C5DB |/
+   LDA r_battle_physical_evade_hits.w                                          ; $03C5DE |\
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03C5E1 | | Based on the target's defense multiplier and their evade,
    LDA r_character_battle_current_target.physical_defense_multiplier.w         ; $03C5E4 | | determine the number of hits they evade. If the target has either
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03C5E7 | | the toad or small status, their defense multiplier is assumed to
    LDA r_character_battle_current_target.status_1.w                            ; $03C5EA | | be zero.
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03C5ED | |
    BEQ +                                                                       ; $03C5EF | |
    STZ r_battle_calculate_hits_arg_attempts.w                                  ; $03C5F1 | |
+   JSR _battle_calculate_hits                                                  ; $03C5F4 |/
    LDA r_battle_calculate_hits_result.w                                        ; $03C5F7 | Load the number of evaded hits into the accumulator.
@total_hits:
    STA r_battle_physical_evade_hits.w                                          ; $03C5FA | Save the number of evaded hits ($FF if barrier or image).
    SEC                                                                         ; $03C5FD |\
    LDA r_battle_physical_attack_hits.w                                         ; $03C5FE | | Determine the total number of hits by subtracting the number of
    SBC r_battle_physical_evade_hits.w                                          ; $03C601 | | evaded hits from the number of attack hits.
    STA r_battle_current_action_details.action.w                                ; $03C604 | |
    STA r_battle_damage_hits.w                                                  ; $03C607 |/
    BEQ @miss                                                                   ; $03C60A |\ If the final number was greater than zero, branch ahead.
    BCS @hit                                                                    ; $03C60C |/
@miss:
    TDC                                                                         ; $03C60E |\ Explicitly set the number of hits to zero.
    STA r_battle_damage_hits.w                                                  ; $03C60F |/
    INC A                                                                       ; $03C612 |\ Set the action byte to one. TODO: Why? It's the number of hits if >=1.
    STA r_battle_current_action_details.action.w                                ; $03C613 |/
    LDA <r_battle_command_target_slot                                           ; $03C616 |\
    STA <r_battle_generic_tmp_1_lo                                              ; $03C618 | | Calculate the true slot number for the target.
    BPL +                                                                       ; $03C61A | |
    AND #%01111111.b                                                            ; $03C61C | |
    CLC                                                                         ; $03C61E | |
    ADC #5.b                                                                    ; $03C61F |/
+   ASL A                                                                       ; $03C621 |\
    TAX                                                                         ; $03C622 | | If the slot doesn't already have damage, set the damage for this
    LDA r_battle_slot_damage.w + 0,X                                            ; $03C623 | | slot to a miss.
    ORA r_battle_slot_damage.w + 1,X                                            ; $03C626 | |
    BNE +                                                                       ; $03C629 | |
    LDA #(BATTLE_DAMAGE_MISS >> 8).b                                            ; $03C62B | |
    STA r_battle_slot_damage.w + 1.w,X                                          ; $03C62D |/
+   JMP @post_damage                                                            ; $03C630
@hit:
    LDA <r_battle_command_target_slot                                           ; $03C633 |\
    BPL +                                                                       ; $03C635 | | If the target is a monster and monsters are currently flagged as
    LDA r_monsters_invincible.w                                                 ; $03C637 | | invincible, branch to the miss code instead.
    BNE @miss                                                                   ; $03C63A |/
+   LDA r_battle_current_action_details.action_flags.w                          ; $03C63C |\
    ORA #BATTLE_ACTION_DETAILS_ACTION_FLAG_PHYSICAL.b                           ; $03C63F | | Set the current action details physical flag.
    STA r_battle_current_action_details.action_flags.w                          ; $03C641 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03C644 |\
    LDA r_character_battle.1.status_2.w,X                                       ; $03C646 | | If the target has the Charm status, remove it.
    STA <r_battle_generic_tmp_1_lo                                              ; $03C649 | |
    AND #STATUS_2_CHARM.b ~ $FF                                                 ; $03C64B | |
    STA r_character_battle.1.status_2.w,X                                       ; $03C64D |/
    LDA #2.b                                                                    ; $03C650 |\
    STA r_battle_damage_element_multiplier.w                                    ; $03C652 | | Initialize the elemental and racial multipliers to two.
    STA r_battle_damage_race_multiplier.w                                       ; $03C655 |/
    LDA r_character_battle_current_actor.physical_attack_element.w              ; $03C658 |\ Save the attack element for later usage.
    STA r_battle_last_action_element.w                                          ; $03C65B |/
    AND r_character_battle_current_target.element_weakness_strong.w             ; $03C65E |\
    BEQ +                                                                       ; $03C661 | | If the target has a strong weakness to an attack element, set the
    LDA #8.b                                                                    ; $03C663 | | elemental multiplier to eight.
    STA r_battle_damage_element_multiplier.w                                    ; $03C665 | |
    BRA ++                                                                      ; $03C668 |/
+   LDA r_character_battle_current_actor.physical_attack_element.w              ; $03C66A |\
    AND r_character_battle_current_target.element_weakness.w                    ; $03C66D | | If the target has a regular weakness to an attack element, set the
    BEQ +                                                                       ; $03C670 | | elemental multiplier to four.
    LDA #4.b                                                                    ; $03C672 | |
    STA r_battle_damage_element_multiplier.w                                    ; $03C674 | |
    BRA ++                                                                      ; $03C677 |/
+   LDA r_character_battle_current_actor.physical_attack_element.w              ; $03C679 |\
    AND r_character_battle_current_target.element_immunity.w                    ; $03C67C | | If the target is immune to an attack element, set the elemental
    BEQ +                                                                       ; $03C67F | | multiplier to zero.
    LDA #0.b                                                                    ; $03C681 | |
    STA r_battle_damage_element_multiplier.w                                    ; $03C683 | |
    BRA ++                                                                      ; $03C686 |/
+   LDA r_character_battle_current_actor.physical_attack_element.w              ; $03C688 |\
    AND r_character_battle_current_target.element_resistance.w                  ; $03C68B | | If the target resists an attack element, set the elemental
    BEQ ++                                                                      ; $03C68E | | multiplier to one.
    LDA #1.b                                                                    ; $03C690 | |
    STA r_battle_damage_element_multiplier.w                                    ; $03C692 |/
++  LDA <r_battle_command_actor_slot                                            ; $03C695 |\
    BMI +                                                                       ; $03C697 | | If the actor is a character, the target is a monster, and the
    LDA <r_battle_command_target_slot                                           ; $03C699 | | character's attack race matches the monster's race, set the race
    BPL ++                                                                      ; $03C69B | | multiplier to 8.
    LDA r_character_battle_current_actor.physical_attack_race.w                 ; $03C69D | |
    AND r_character_battle_current_target.monster_race.w                        ; $03C6A0 | |
    BEQ ++                                                                      ; $03C6A3 | |
    LDA #8.b                                                                    ; $03C6A5 | |
    STA r_battle_damage_race_multiplier.w                                       ; $03C6A7 | |
    BRA ++                                                                      ; $03C6AA |/
+   LDA <r_battle_command_target_slot                                           ; $03C6AC |\
    BMI ++                                                                      ; $03C6AE | | If the actor is a monster, the target is a character, and the
    LDA r_character_battle_current_actor.monster_race.w                         ; $03C6B0 | | character's racial defense matches the attacking monster, set the
    AND r_character_battle_current_target.physical_defense_race.w               ; $03C6B3 | | racial multiplier to 1.
    BEQ ++                                                                      ; $03C6B6 | |
    LDA #1.b                                                                    ; $03C6B8 | |
    STA r_battle_damage_race_multiplier.w                                       ; $03C6BA |/
++  STZ r_battle_damage_critical.w                                              ; $03C6BD | Initialize the critical flag to zero.
    LDA r_character_battle_current_actor.physical_attack_base.w                 ; $03C6C0 |\
    TAX                                                                         ; $03C6C3 | | Copy the physical attack power to a local variable.
    STX r_battle_damage_attack_power.w                                          ; $03C6C4 |/
    LDA r_character_battle_current_actor.status_2.w                             ; $03C6C7 |\
    AND #STATUS_2_BERSERK.b                                                     ; $03C6CA | | If the actor has berserk status, add one half the attack power to
    BEQ +                                                                       ; $03C6CC | | the attack power.
    STX <r_battle_generic_tmp_1                                                 ; $03C6CE | |
    LSR <r_battle_generic_tmp_1_hi                                              ; $03C6D0 | |
    ROR <r_battle_generic_tmp_1_lo                                              ; $03C6D2 | |
    CLC                                                                         ; $03C6D4 | |
    LDA r_battle_damage_attack_power_lo.w                                       ; $03C6D5 | |
    ADC <r_battle_generic_tmp_1_lo                                              ; $03C6D8 | |
    STA r_battle_damage_attack_power_lo.w                                       ; $03C6DA | |
    LDA r_battle_damage_attack_power_hi.w                                       ; $03C6DD | |
    ADC <r_battle_generic_tmp_1_hi                                              ; $03C6E0 | |
    STA r_battle_damage_attack_power_hi.w                                       ; $03C6E2 | |
    BRA ++                                                                      ; $03C6E5 |/
+   LDA r_character_battle_current_actor.status_3.w                             ; $03C6E7 |\
    AND #(STATUS_3_CHARGING | STATUS_3_JUMPING).b                               ; $03C6EA | | If the actor has either the charging or jumping statuses, multiply
    BEQ ++                                                                      ; $03C6EC | | the attack power by two.
    ASL r_battle_damage_attack_power_lo.w                                       ; $03C6EE | |
    ROL r_battle_damage_attack_power_hi.w                                       ; $03C6F1 |/
++  LDA r_character_battle_current_actor.status_2.w                             ; $03C6F4 |\
    AND #STATUS_2_CURSE.b                                                       ; $03C6F7 | | If the actor has the curse status, divide their attack power by
    BEQ +                                                                       ; $03C6F9 | | two.
    LSR r_battle_damage_attack_power_hi.w                                       ; $03C6FB | |
    ROR r_battle_damage_attack_power_lo.w                                       ; $03C6FE |/
+   LDA r_character_battle_current_target.physical_defense_base.w               ; $03C701 |\
    TAX                                                                         ; $03C704 | | Copy the target's physical defense into a local variable.
    STX r_battle_damage_defense_power.w                                         ; $03C705 |/
    LDA r_character_battle_current_target.sprite_class.w                        ; $03C708 |\
    BPL +                                                                       ; $03C70B | | If the target is in the back row, multiply their defense power by
    ASL r_battle_damage_defense_power_lo.w                                      ; $03C70D | | two.
    ROL r_battle_damage_defense_power_hi.w                                      ; $03C710 |/
+   LDA r_character_battle_current_target.status_2.w                            ; $03C713 |\
    AND #STATUS_2_CURSE.b                                                       ; $03C716 | | If the target has the curse status, divide their defense power by
    BEQ +                                                                       ; $03C718 | | two.
    LSR r_battle_damage_defense_power_hi.w                                      ; $03C71A | |
    ROR r_battle_damage_defense_power_lo.w                                      ; $03C71D |/
+   JSR _get_battle_rng_0_98                                                    ; $03C720 |\
    CMP r_character_battle_current_actor.critical_rate.w                        ; $03C723 | | If a random number from 0 to 98 is less than the actor's critical
    BCS +                                                                       ; $03C726 | | rate, flag the action as a critical and increment the critical
    INC r_battle_damage_critical.w                                              ; $03C728 | | flag.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_CRITICAL.b                           ; $03C72B | |
    ORA r_battle_current_action_details.action_flags.w                          ; $03C72D | |
    STA r_battle_current_action_details.action_flags.w                          ; $03C730 |/
+   LDA r_character_battle_current_target.status_3.w                            ; $03C733 |\
    AND #STATUS_3_DEFENDING.b                                                   ; $03C736 | | If the target is defending, multiply their defense power by two.
    BEQ +                                                                       ; $03C738 | |
    ASL r_battle_damage_defense_power_lo.w                                      ; $03C73A | |
    ROL r_battle_damage_defense_power_hi.w                                      ; $03C73D |/
+   LDA r_character_battle_current_target.status_3.w                            ; $03C740 |\
    AND #STATUS_3_CHARGING.b                                                    ; $03C743 | | If the target is charging, divide their defense power by two.
    BEQ +                                                                       ; $03C745 | |
    LSR r_battle_damage_defense_power_hi.w                                      ; $03C747 | |
    ROR r_battle_damage_defense_power_lo.w                                      ; $03C74A |/
+   LDA r_character_battle_current_actor.status_1.w                             ; $03C74D |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03C750 | | If the actor is a toad or small, set their attack power directly
    BEQ +                                                                       ; $03C752 | | to one, and unset the critical flag.
    LDX #1.w                                                                    ; $03C754 | |
    STX r_battle_damage_attack_power.w                                          ; $03C757 | |
    STZ r_battle_damage_critical.w                                              ; $03C75A |/
+   LDA r_character_battle_current_target.status_1.w                            ; $03C75D |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03C760 | | If the target is either a toad or small, multiply the actor's
    BEQ +                                                                       ; $03C762 | | attack power by two, and set the target's defense power to zero.
    ASL r_battle_damage_attack_power_lo.w                                       ; $03C764 | |
    ROL r_battle_damage_attack_power_hi.w                                       ; $03C767 | |
    TDC                                                                         ; $03C76A | |
    TAX                                                                         ; $03C76B | |
    STX r_battle_damage_defense_power.w                                         ; $03C76C |/
+   LDA #1.b                                                                    ; $03C76F |\ Split the damage to only one target.
    STA r_battle_calculate_damage_arg_split.w                                   ; $03C771 |/
    LDA r_character_battle_current_actor.critical_bonus.w                       ; $03C774 |\ Set the critical bonus.
    STA r_battle_damage_critical_bonus.w                                        ; $03C777 |/
    JSR _battle_calculate_damage                                                ; $03C77A | Calculate the total damage.
    LDA r_character_battle_current_actor.physical_attack_element.w              ; $03C77D |\
    AND #ELEMENT_ABSORB.b                                                       ; $03C780 | | If the actor is attacking with the absorb element, branch ahead.
    BNE +++                                                                     ; $03C782 |/
    LDA <r_battle_command_target_slot                                           ; $03C784 |\
    JSR _battle_get_damage_offset                                               ; $03C786 | | If the slot currently has no pending damage, skip this next block.
    LDA r_battle_slot_damage.w + 0,X                                            ; $03C789 | |
    ORA r_battle_slot_damage.w + 1,X                                            ; $03C78C | |
    BEQ +                                                                       ; $03C78F |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03C791 |\
    PHA                                                                         ; $03C794 | | Save the restore bit of the existing damage to a temporary
    AND #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03C795 | | variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03C797 |/
    PLA                                                                         ; $03C799 |\
    AND #(BATTLE_DAMAGE_VALUE >> 8).b                                           ; $03C79A | | Unset either the miss or restore bit of the existing damage.
    STA r_battle_slot_damage.w + 1,X                                            ; $03C79C |/
    CLC                                                                         ; $03C79F |\
    LDA r_battle_slot_damage.w + 0,X                                            ; $03C7A0 | | Add in the new damage and then reset the restore bit if it was
    ADC <r_battle_calculate_damage_result_lo                                    ; $03C7A3 | | set, and then branch ahead.
    STA r_battle_slot_damage.w + 0,X                                            ; $03C7A5 | |
    LDA r_battle_slot_damage.w + 1,X                                            ; $03C7A8 | |
    ADC <r_battle_calculate_damage_result_hi                                    ; $03C7AB | |
    ORA <r_battle_generic_tmp_1_lo                                              ; $03C7AD | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03C7AF | |
    BRA ++                                                                      ; $03C7B2 |/
+   LDA <r_battle_calculate_damage_result_lo                                    ; $03C7B4 |\
    STA r_battle_slot_damage.w + 0,X                                            ; $03C7B6 | | If there was no pending damage, simply set the damage value to the
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C7B9 | | calculated value and branch ahead.
    STA r_battle_slot_damage.w + 1,X                                            ; $03C7BB | |
++  BRA @post_damage                                                            ; $03C7BE |/
+++ LDA <r_battle_command_target_slot                                           ; $03C7C0 |\
    BEQ +                                                                       ; $03C7C2 | | If the target is not in slot zero and has the high bit set in the
    LDA r_character_battle_current_target.monster_race.w                        ; $03C7C4 | | race variable (meaning undead), set the damage such that the
    BPL +                                                                       ; $03C7C7 | | target is healed by the calculated value and the actor is damaged
    LDA <r_battle_command_target_slot                                           ; $03C7C9 | | by the calculated value.
    JSR _battle_get_damage_offset                                               ; $03C7CB | |
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C7CE | | NOTE: The check against slot zero doesn't really make any sense.
    STA r_battle_slot_damage.w + 0,X                                            ; $03C7D0 | |       It's possible they meant to make sure that this code only
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C7D3 | |       applied against monster targets, but that's the practical
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03C7D5 | |       result anyway, since party members are never going to have
    STA r_battle_slot_damage.w + 1,X                                            ; $03C7D7 | |       the undead race bit set.
    LDA <r_battle_command_actor_slot                                            ; $03C7DA | |
    JSR _battle_get_damage_offset                                               ; $03C7DC | |
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C7DF | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03C7E1 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C7E4 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03C7E6 | |
    BRA @post_damage                                                            ; $03C7E9 |/
+   LDA <r_battle_command_actor_slot                                            ; $03C7EB |\
    JSR _battle_get_damage_offset                                               ; $03C7ED | | Otherwise, set the damage to heal the actor by the calculated
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C7F0 | | value, and damage the target by the calculated value.
    STA r_battle_slot_damage.w + 0,X                                            ; $03C7F2 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C7F5 | |
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03C7F7 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03C7F9 | |
    LDA <r_battle_command_target_slot                                           ; $03C7FC | |
    JSR _battle_get_damage_offset                                               ; $03C7FE | |
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C801 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03C803 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C806 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03C808 |/
@post_damage:
    LDA <r_battle_command_actor_slot                                            ; $03C80B |\
    BPL +                                                                       ; $03C80D | | If the actor is a monster, check the audiovisual script. If the
    LDX r_battle_script_tmp_index.w                                             ; $03C80F | | next command is not a dialog display code, skip the pending damage
    LDA r_battle_script_audiovisual.w + 0,X                                     ; $03C812 | | application.
    CMP #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03C815 | |
    BNE ++                                                                      ; $03C817 |/
+   JSR _battle_apply_pending_damage.w                                          ; $03C819 | Apply the pending damage.
++  LDA r_battle_apply_pending_damage_result_deaths.w                           ; $03C81C |\ If there was a death, branch to the end.
    BNE @done_proxy                                                             ; $03C81F |/
    LDA r_battle_damage_hits.w                                                  ; $03C821 |\
    BNE ++                                                                      ; $03C824 | | If there were no hits, branch to the end.
@done_proxy:                                                                    ;         | |
    JMP @done                                                                   ; $03C826 |/
++  LDA r_character_battle_current_actor.physical_attack_status_1.w             ; $03C829 |\
    ORA r_character_battle_current_actor.physical_attack_status_2.w             ; $03C82C | | Skip to the end if the actor is not attacking with status.
    BEQ @done_proxy                                                             ; $03C82F |/
    LDA r_character_battle_current_actor.physical_attack_status_1.w             ; $03C831 |\
    AND r_character_battle_current_target.status_1_immunity.w                   ; $03C834 | | Skip to the end if the target is immune to any of the actor's
    BNE @done_proxy                                                             ; $03C837 | | attacking statuses.
    LDA r_character_battle_current_actor.physical_attack_status_2.w             ; $03C839 | |
    AND r_character_battle_current_target.status_2_immunity.w                   ; $03C83C | |
    BNE @done_proxy                                                             ; $03C83F |/
    SEC                                                                         ; $03C841 |\
    LDA r_character_battle_current_actor.physical_attack_accuracy.w             ; $03C842 | | Skip to the end if the target's evade is greater than or equal to
    SBC r_character_battle_current_target.physical_defense_evade.w              ; $03C845 | | the actor's accuracy.
    BEQ @done_proxy                                                             ; $03C848 | |
    BCC @done_proxy                                                             ; $03C84A |/
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03C84C |\
    LDA r_battle_damage_hits.w                                                  ; $03C84F | | Calculate a number of hits based on the difference between the
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03C852 | | actor's accuracy and the target's evade, with the number of actual
    JSR _battle_calculate_hits                                                  ; $03C855 | | hits as the number of attempts. If the result was zero, skip to
    LDA r_battle_calculate_hits_result.w                                        ; $03C858 | | the end.
    BEQ @done_proxy                                                             ; $03C85B |/
    LDA r_character_battle_current_target.monster_level_boss.w                  ; $03C85D |\ If the target is a boss, skip to the end.
    BMI @done_proxy                                                             ; $03C860 |/
    LDA r_character_battle_current_actor.physical_attack_status_1.w             ; $03C862 |\
    STA r_battle_apply_physical_status_arg_status.status_1.w                    ; $03C865 | | Set the first status byte argument. If the target already has any
    STA <r_battle_generic_tmp_1_hi                                              ; $03C868 | | of these statusues, skip to the end.
    AND r_character_battle_current_target.status_1.w                            ; $03C86A | |
    BNE @done_proxy                                                             ; $03C86D |/
    LDA r_character_battle_current_actor.physical_attack_status_2.w             ; $03C86F |\
    STA r_battle_apply_physical_status_arg_status.status_2.w                    ; $03C872 | | Repeat with the second status byte. Again, if the target already
    STA <r_battle_generic_tmp_1_lo                                              ; $03C875 | | has any of the attacking statuses, skip to the end.
    AND r_character_battle_current_target.status_2.w                            ; $03C877 | |
    BNE @bne_done_proxy                                                         ; $03C87A |/
    LDA <r_battle_command_target_slot                                           ; $03C87C |\
    BPL +                                                                       ; $03C87E | | Calculate the true slot number for the target.
    AND #%01111111.b                                                            ; $03C880 | |
    CLC                                                                         ; $03C882 | |
    ADC #5.b                                                                    ; $03C883 | |
+   STA <r_battle_command_target_true_slot                                      ; $03C885 |/
    JSR _math_multiply_by_4                                                     ; $03C887 |\
    TAX                                                                         ; $03C88A | | Calculate the status offset by multiplying the slot by four.
    STX <r_battle_apply_physical_status_arg_status_offset                       ; $03C88B |/
    LDA <r_battle_command_target_true_slot                                      ; $03C88D |\ Calculate the offsets for the target slot.
    JSR _calculate_offsets                                                      ; $03C88F |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03C892 |\
    JSR _add_timer_offset                                                       ; $03C894 | | Load the current flags for the action timer of the target. If any
    LDX r_add_timer_offset_result.w                                             ; $03C897 | | flags are set, return without doing anything.
    LDA r_battle_timers.1.flags.w,X                                             ; $03C89A | |
@bne_done_proxy:
    BNE @done                                                                   ; $03C89D |/
    LDA r_character_battle_current_actor.status_1.w                             ; $03C89F |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03C8A2 | | If the current actor is a toad or small, skip to the end.
    BNE @bne_done_proxy                                                         ; $03C8A4 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03C8A6 |\
    TDC                                                                         ; $03C8A8 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $03C8A9 | |
    TXY                                                                         ; $03C8AA |/
-   ASL <r_battle_generic_tmp_1                                                 ; $03C8AB |\
    BCC +                                                                       ; $03C8AD | | Loop through the attacking status bits, adding the appropriate
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C8AF | | message to the battle alert queue for each status being
    TXA                                                                         ; $03C8B1 | | inflicted. $25 is the index of the first status battle alert.
    CLC                                                                         ; $03C8B2 | |
    ADC #$25.b                                                                  ; $03C8B3 | |
    STA r_battle_alert_queue.w,Y                                                ; $03C8B5 | |
    INY                                                                         ; $03C8B8 | |
    REP #FLAG_P_ACCUMULATOR.b                                                   ; $03C8B9 | |
+   INX                                                                         ; $03C8BB | |
    CPX #16.w                                                                   ; $03C8BC | |
    BNE -                                                                       ; $03C8BF | |
    TDC                                                                         ; $03C8C1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03C8C2 |/
    JSR _battle_apply_physical_status                                           ; $03C8C4 | Apply the statuses (pending a few additional checks).
    LDA r_battle_apply_physical_status_arg_status.status_1.w                    ; $03C8C7 |\
    ORA r_battle_apply_physical_status_arg_status.status_2.w                    ; $03C8CA | | If no statuses were applied, return immediately.
    BNE +                                                                       ; $03C8CD | |
    BRA @done                                                                   ; $03C8CF |/
+   LDA <r_battle_command_actor_slot                                            ; $03C8D1 |\
    BMI +                                                                       ; $03C8D3 | | If the actor is a character, set the audiovisual script to display
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03C8D5 | | the pending battle alerts.
    BRA @done                                                                   ; $03C8D8 |/
+   TDC                                                                         ; $03C8DA |\ Initialize the X register to zero.
    TAX                                                                         ; $03C8DB |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03C8DC |\
    STA r_battle_script_tmp_copy.w,X                                            ; $03C8DF | | Copy the audiovisual script to a temporary location.
    INX                                                                         ; $03C8E2 | |
    CMP #$FF.b                                                                  ; $03C8E3 | |
    BNE -                                                                       ; $03C8E5 |/
    TDC                                                                         ; $03C8E7 |\
    TAX                                                                         ; $03C8E8 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03C8E9 |/
-   LDA r_battle_script_tmp_copy.w,X                                            ; $03C8EA |\ Copy the next byte from the temporary area to the main script.
    STA r_battle_script_audiovisual.w,Y                                         ; $03C8ED |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03C8F0 |\ If copying an end byte, branch to the end.
    BEQ @done                                                                   ; $03C8F2 |/
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03C8F4 |\
    BEQ +                                                                       ; $03C8F6 | | If the current byte is not a fight, jump or land byte, skip to the
    CMP #MONSTER_COMMAND_JUMP.b                                                 ; $03C8F8 | | next byte.
    BEQ +                                                                       ; $03C8FA | |
    CMP #MONSTER_COMMAND_LAND.b                                                 ; $03C8FC | |
    BNE ++                                                                      ; $03C8FE |/
+   INY                                                                         ; $03C900 |\
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03C901 | | If it was one of those three, insert the command to display the
    STA r_battle_script_audiovisual.w,Y                                         ; $03C903 | | battle alerts afterward.
    INY                                                                         ; $03C906 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ALERT.b                                 ; $03C907 | |
    STA r_battle_script_audiovisual.w,Y                                         ; $03C909 |/
++  INX                                                                         ; $03C90C |\
    INY                                                                         ; $03C90D | | Increment the registers and loop back to the next byte.
    BRA -                                                                       ; $03C90E |/
@done:
    LDA r_battle_update_hand_inventory_pending.w                                ; $03C910 |\
    BEQ +                                                                       ; $03C913 | | If a hand inventory update is pending (essentially if an arrow was
    LDA <r_battle_command_actor_slot                                            ; $03C915 | | used), set the argumenst and update the hand inventory.
    STA <r_battle_update_arg_slot                                               ; $03C917 | |
    LDA r_battle_update_hand_inventory_index.w                                  ; $03C919 | |
    STA <r_battle_update_arg_index                                              ; $03C91C | |
    LDA #BATTLE_UPDATE_MODE_HAND_INVENTORY_ENTRY                                ; $03C91E | |
    JSR _battle_update                                                          ; $03C920 |/
+   RTS                                                                         ; $03C923

; _battle_subtract_arrow_if_equipped ($03:C924)
;
; If the current acting slot has arrows equipped, this routine will generally
; subtract one from that arrow's count. If the count would be zero, however, it
; instead sets a flag that will be resolved by a routine that executes
; elsewhere.
_battle_subtract_arrow_if_equipped:
    LDA r_character_battle_current_actor.status_1.w                             ; $03C924 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03C927 | | If the character is toad or small, skip to the end.
    BNE @done                                                                   ; $03C929 |/
    LDA <r_battle_command_actor_slot                                            ; $03C92B |\ Calculate the offsets for this slot.
    JSR _calculate_offsets                                                      ; $03C92D |/
    CLC                                                                         ; $03C930 |\
    LDA r_current_slot_offset_equipment_lo.w                                    ; $03C931 | | Calculate the offset to the character's right hand equipment by
    ADC #character_equipment.right_hand.b                                       ; $03C934 | | taking their base equipment offset and adding the offset to the
    STA <r_battle_generic_tmp_1_lo                                              ; $03C936 | | right hand within it.
    LDA r_current_slot_offset_equipment_hi.w                                    ; $03C938 | |
    ADC #0.b                                                                    ; $03C93B | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03C93D |/
    TDC                                                                         ; $03C93F |\ Initialize the Y register to zero.
    TAY                                                                         ; $03C940 |/
    STY <r_battle_generic_tmp_2                                                 ; $03C941 | Initialize the hand flag variable to zero.
    STA r_battle_update_hand_inventory_index.w                                  ; $03C943 | Initialize the hand inventory update value to the right hand.
    LDX <r_battle_generic_tmp_1                                                 ; $03C946 | Load the right hand equipment offset into the X register.
    LDA r_equipment.w + equipment_full.data.flags,X                             ; $03C948 |\
    AND #EQUIPMENT_FLAG_WEAPON_ARROW.b                                          ; $03C94B | | If the right hand has an arrow in it, set the Y register to one
    BEQ +                                                                       ; $03C94D | | and branch forward.
    INY                                                                         ; $03C94F | |
    BRA ++                                                                      ; $03C950 |/
+   LDA r_equipment.w + equipment_full.data.flags + _sizeof_equipment_full,X    ; $03C952 |\
    AND #EQUIPMENT_FLAG_WEAPON_ARROW.b                                          ; $03C955 | | Otherwise, if the left hand has arrows in it, set the high bit in
    BEQ ++                                                                      ; $03C957 | | the flags variable, set the hand inventory update index to the
    LDA #%10000000.b                                                            ; $03C959 | | left hand, and set the Y register to two.
    STA <r_battle_generic_tmp_2_lo                                              ; $03C95B | |
    INC r_battle_update_hand_inventory_index.w                                  ; $03C95D | |
    INY                                                                         ; $03C960 | |
    INY                                                                         ; $03C961 |/
++  LDA <r_battle_command_actor_slot                                            ; $03C962 |\
    JSR _math_multiply_by_8                                                     ; $03C964 | | Set the X register to the slot times eight.
    TAX                                                                         ; $03C967 |/
    TYA                                                                         ; $03C968 |\ If no arrows were equipped, skip to the end.
    BEQ @done                                                                   ; $03C969 |/
    DEY                                                                         ; $03C96B |\
    BEQ +                                                                       ; $03C96C | | If arrows were equipped in the left hand, increment the X register
    INX                                                                         ; $03C96E | | by four to index the left hand instead of the right hand in the
    INX                                                                         ; $03C96F | | hand inventory.
    INX                                                                         ; $03C970 | |
    INX                                                                         ; $03C971 |/
+   SEC                                                                         ; $03C972 |\
    LDA r_battle_hand_inventory.1.count.w,X                                     ; $03C973 | | Subtract one from the arrow count in the appropriate hand.
    SBC #1.b                                                                    ; $03C976 |/
    BNE +                                                                       ; $03C978 | If there is still at least one arrow left, skip the next block.
    LDA <r_battle_command_actor_slot                                            ; $03C97A |\ Load the slot into the X register.
    TAX                                                                         ; $03C97C |/
    LDA r_battle_remove_arrow_pending.w,X                                       ; $03C97D |\
    INC A                                                                       ; $03C980 | | Set the arrow pending value to 1 and then add in the flags
    ORA <r_battle_generic_tmp_2_lo                                              ; $03C981 | | variable so the hand will be indicated.
    STA r_battle_remove_arrow_pending.w,X                                       ; $03C983 |/
    BRA ++                                                                      ; $03C986 | Branch ahead.
+   STA r_battle_hand_inventory.1.count.w,X                                     ; $03C988 | Otherwise, update the arrow count.
++  INC r_battle_update_hand_inventory_pending.w                                ; $03C98B | Flag that a hand inventory update is pending.
    LDA <r_battle_command_actor_slot                                            ; $03C98E |\
    STA r_battle_generic_arg_slot.w                                             ; $03C990 | | Copy the updated hand inventory to the character's stat record.
    JSR _copy_equipment_from_hand_inventory                                     ; $03C993 |/
@done:
    RTS                                                                         ; $03C996

; _battle_calculate_hits ($03:C997)
;
; Given a number of attempts in $38FB and the probability of an attempt
; succeeding in $38FA, returns the number of successes in $38FD. Note that an
; attempt is deemed successful if a random number from 0 to 98, inclusive, is
; less than the accuracy. This means that an accuracy of 99 is always
; successful and that an accuracy of 0 is never successful.
_battle_calculate_hits:
    STZ r_battle_calculate_hits_result.w                                        ; $03C997 | Initialize the result to zero.
    LDA r_battle_calculate_hits_arg_attempts.w                                  ; $03C99A |\ If the number of attempts is zero, simply return.
    BEQ ++                                                                      ; $03C99D |/
    TAY                                                                         ; $03C99F | Transfer the number of attempts to the Y register.
-   JSR _get_battle_rng_0_98                                                    ; $03C9A0 |\
    CMP r_battle_calculate_hits_arg_accuracy.w                                  ; $03C9A3 | | Increment the result if a random number from 0 to 98 is less than
    BCS +                                                                       ; $03C9A6 | | the accuracy.
    INC r_battle_calculate_hits_result.w                                        ; $03C9A8 |/
+   DEY                                                                         ; $03C9AB |\ Decrement the Y register and loop until all attempts have been
    BNE -                                                                       ; $03C9AC |/ made.
++  RTS                                                                         ; $03C9AE

; _battle_calculate_damage ($03:C9AF)
;
; Given a 16-bit power value in $3902, a 16-bit defense power value in $3904, a
; number of hits in $38FC, elemental and racial multipliers in $38FE and $38FF,
; a critical hit flag in $3900 and a critical hit bonus in $3901, and a number
; of targets to split to in $3906, calculates the total damage per target and
; caps it at 9999. Note that a single attack, regardless of the number of split
; targets cannot do more than 65535 damage in total.
_battle_calculate_damage:
    LDX r_battle_damage_attack_power.w                                          ; $03C9AF |\
    STX r_math_add_16bit_arg_1.w                                                ; $03C9B2 | | Copy the attack power into both of the add arguments.
    STX r_math_add_16bit_arg_2.w                                                ; $03C9B5 |/
    LSR r_math_add_16bit_arg_1_hi.w                                             ; $03C9B8 |\ Divide the first copy by two.
    ROR r_math_add_16bit_arg_1_lo.w                                             ; $03C9BB |/
    LDA r_math_add_16bit_arg_1_hi.w                                             ; $03C9BE |\
    BEQ +                                                                       ; $03C9C1 | | If the attack power divided by two is greater than 255, explicitly
    LDX #255.w                                                                  ; $03C9C3 | | set it to 255.
    STX r_math_add_16bit_arg_1.w                                                ; $03C9C6 |/
+   TDC                                                                         ; $03C9C9 |\
    TAX                                                                         ; $03C9CA | | Set the first argument to a random number from 0 to the calculated
    LDA r_math_add_16bit_arg_1_lo.w                                             ; $03C9CB | | value.
    JSR _get_battle_rng                                                         ; $03C9CE | |
    TAX                                                                         ; $03C9D1 | |
    STX r_math_add_16bit_arg_1.w                                                ; $03C9D2 |/
    JSR _math_add_16bit                                                         ; $03C9D5 | Add the random value to the modified attack power.
    LDX r_math_add_16bit_result_lo.w                                            ; $03C9D8 |\ Set the final value as the argument to the multiplier applying
    STX <r_battle_calculate_damage_result                                       ; $03C9DB |/ routine.
    LDA r_battle_damage_element_multiplier.w                                    ; $03C9DD |\ Apply the elemental multiplier.
    JSR _battle_calculate_damage_apply_multiplier                               ; $03C9E0 |/
    LDA r_battle_damage_race_multiplier.w                                       ; $03C9E3 |\ Apply the racial multiplier.
    JSR _battle_calculate_damage_apply_multiplier                               ; $03C9E6 |/
    LDA r_battle_damage_critical.w                                              ; $03C9E9 |\
    BEQ +                                                                       ; $03C9EC | | If the hit is a critical hit, add the actor's critical bonus to
    CLC                                                                         ; $03C9EE | | to the attack power.
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C9EF | |
    ADC r_battle_damage_critical_bonus.w                                        ; $03C9F1 | |
    STA <r_battle_calculate_damage_result_lo                                    ; $03C9F4 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03C9F6 | |
    ADC #0.b                                                                    ; $03C9F8 | |
    STA <r_battle_calculate_damage_result_hi                                    ; $03C9FA |/
+   SEC                                                                         ; $03C9FC |\
    LDA <r_battle_calculate_damage_result_lo                                    ; $03C9FD | | Subtract the target's defense power from the calculated attack
    SBC r_battle_damage_defense_power_lo.w                                      ; $03C9FF | | power.
    STA <r_battle_calculate_damage_result_lo                                    ; $03CA02 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03CA04 | |
    SBC r_battle_damage_defense_power_hi.w                                      ; $03CA06 | |
    STA <r_battle_calculate_damage_result_hi                                    ; $03CA09 |/
    BCS +                                                                       ; $03CA0B |\
    TDC                                                                         ; $03CA0D | | If the result was negative, set it explicitly to zero.
    TAX                                                                         ; $03CA0E | |
    STX <r_battle_calculate_damage_result                                       ; $03CA0F |/
+   LDX <r_battle_calculate_damage_result                                       ; $03CA11 |\
    STX r_math_multiply_16bit_arg_1.w                                           ; $03CA13 | | Multiply the resulting power by the number of hits.
    LDA r_battle_damage_hits.w                                                  ; $03CA16 | |
    TAX                                                                         ; $03CA19 | |
    STX r_math_multiply_16bit_arg_2.w                                           ; $03CA1A | |
    JSR _math_multiply_16bit                                                    ; $03CA1D |/
    LDX r_math_multiply_16bit_result_hi.w                                       ; $03CA20 |\
    BEQ +                                                                       ; $03CA23 | | If the result was greater than 65535, explicitly set it to 65535.
    LDX #65535.w                                                                ; $03CA25 | |
    STX r_math_multiply_16bit_result_lo.w                                       ; $03CA28 |/
+   LDX r_math_multiply_16bit_result_lo.w                                       ; $03CA2B |\
    STX r_math_divide_16bit_arg_1.w                                             ; $03CA2E | | Divide the result by the split parameter.
    LDA r_battle_calculate_damage_arg_split.w                                   ; $03CA31 | |
    TAX                                                                         ; $03CA34 | |
    STX r_math_divide_16bit_arg_2.w                                             ; $03CA35 | |
    JSR _math_divide_16bit                                                      ; $03CA38 | |
    LDX r_math_divide_16bit_result.w                                            ; $03CA3B | |
    STX <r_battle_calculate_damage_result                                       ; $03CA3E |/
    CPX #9999.w                                                                 ; $03CA40 |\
    BCC +                                                                       ; $03CA43 | | If the final result was greater than 9999, set the result to 9999.
    LDX #9999.w                                                                 ; $03CA45 | |
    STX <r_battle_calculate_damage_result                                       ; $03CA48 |/
+   LDX <r_battle_calculate_damage_result                                       ; $03CA4A |\
    BNE +                                                                       ; $03CA4C | | If the final result was zero, set it to one.
    INC <r_battle_calculate_damage_result                                       ; $03CA4E |/
+   RTS                                                                         ; $03CA50

; _battle_calculate_damage_apply_multiplier ($03:CA51)
;
; Given a multiplier in the accumulator and a 16-bit value in $A4, multiplies
; the value by half the multiplier. If the passed multiplier is 1, the result is
; set to half the value. Any other non-even multiplier will result in a
; truncated value.
_battle_calculate_damage_apply_multiplier:
    BNE +                                                                       ; $03CA51 |\
    STZ <r_battle_calculate_damage_result_lo                                    ; $03CA53 | | If the multiplier value was 0, set the result to zero and return.
    STZ <r_battle_calculate_damage_result_hi                                    ; $03CA55 | |
    RTS                                                                         ; $03CA57 |/
+   LSR A                                                                       ; $03CA58 |\
    BNE +                                                                       ; $03CA59 | | If the multiplier value was 1, set the result to the argument
    LSR <r_battle_calculate_damage_result_hi                                    ; $03CA5B | | divided by two and return. Otherwise, leave half the multiplier in
    ROR <r_battle_calculate_damage_result_lo                                    ; $03CA5D | | the accumulator.
    RTS                                                                         ; $03CA5F |/
+   TAX                                                                         ; $03CA60 |\
    STX r_math_multiply_16bit_arg_1.w                                           ; $03CA61 | | Multiply the value by the now halved multiplier and set that as
    LDX <r_battle_calculate_damage_result                                       ; $03CA64 | | the result.
    STX r_math_multiply_16bit_arg_2.w                                           ; $03CA66 | |
    JSR _math_multiply_16bit                                                    ; $03CA69 | |
    LDX r_math_multiply_16bit_result_lo.w                                       ; $03CA6C | |
    STX <r_battle_calculate_damage_result                                       ; $03CA6F |/
    RTS                                                                         ; $03CA71

; _battle_get_damage_offset ($03:CA72)
;
; Given a modified slot value in the accumulator, stores that value in $A9 and
; sets the X register to the offset to that slot's damage value in the battle
; slot damage array at $34D4. (A modified slot uses the high bit to indicate
; monster or party, and the rest of the bits give the slot number relative to
; the base slot for that group.)
_battle_get_damage_offset:
    STA <r_battle_generic_tmp_1_lo                                              ; $03CA72 | Save the modified slot value to $A9.
    BPL +                                                                       ; $03CA74 |\
    AND #%01111111.b                                                            ; $03CA76 | | If this is a monster slot, add 5 to the slot number.
    CLC                                                                         ; $03CA78 | |
    ADC #5.b                                                                    ; $03CA79 |/
+   ASL A                                                                       ; $03CA7B |\ Multiply the true slot number by two.
    TAX                                                                         ; $03CA7C |/
    RTS                                                                         ; $03CA7D

; _battle_apply_pending_damage ($03:CA7E)
;
; For each of the 13 slots, updates the slot's HP based on the value in the
; pending damage array at $34D4. Ensures that the resulting HP is in range
; between zero and the slot's maximum and also sets the swoon status and sets
; or removes the HP critical status as necessary. Any pending poison status
; change is also canceled if the result is death.
_battle_apply_pending_damage:
    REP #FLAG_P_ACCUMULATOR                                                     ; $03CA7E | Switch to 16-bit accumulator mode.
    TDC                                                                         ; $03CA80 |\ Initialize the X register to zero.
    TAX                                                                         ; $03CA81 |/
    STX <r_battle_apply_pending_damage_slot_offset                              ; $03CA82 | Initialize the current slot offset to zero.
    TAY                                                                         ; $03CA84 | Initialize the Y register to zero.
@start:
    TYA                                                                         ; $03CA85 |\
    LSR A                                                                       ; $03CA86 | | Determine the current slot by dividing the Y register by two.
    TAX                                                                         ; $03CA87 |/
    LDA r_battle_slot_empty.w,X                                                 ; $03CA88 |\
    AND #$00FF.w                                                                ; $03CA8B | | If this slot is empty, branch to the next iteration of the loop.
    BEQ +                                                                       ; $03CA8E | |
    JMP @next                                                                   ; $03CA90 |/
+   LDX <r_battle_apply_pending_damage_slot_offset                              ; $03CA93 | Load the current slot offset into the X register.
    LDA r_battle_slot_damage.w,Y                                                ; $03CA95 |\
    AND #BATTLE_DAMAGE_MISS.w                                                   ; $03CA98 | | If the attack was flagged as a miss and the mask miss damage flag
    BEQ +                                                                       ; $03CA9B | | is set, unset the miss bit and branch to the next iteration.
    LDA r_battle_mask_damage_miss.w                                             ; $03CA9D | |
    BEQ +                                                                       ; $03CAA0 | |
    LDA r_battle_slot_damage.w,Y                                                ; $03CAA2 | |
    AND #~BATTLE_DAMAGE_MISS.w                                                  ; $03CAA5 | |
    STA r_battle_slot_damage.w,Y                                                ; $03CAA8 | |
    JMP @next                                                                   ; $03CAAB |/
+   LDA r_battle_slot_damage.w,Y                                                ; $03CAAE |\
    BPL +                                                                       ; $03CAB1 | | If the uppermost bit is set, add the damage value to the slot's
    CLC                                                                         ; $03CAB3 | | existing HP value, capping the value at $FFFF if it overflows.
    LDA r_battle_slot_damage.w,Y                                                ; $03CAB4 | |
    AND #BATTLE_DAMAGE_VALUE.w                                                  ; $03CAB7 | |
    ADC r_character_battle.1.hp.w,X                                             ; $03CABA | |
    BCC +++                                                                     ; $03CABD | |
    LDA #$FFFF.w                                                                ; $03CABF | |
    BRA +++                                                                     ; $03CAC2 |/
+   LDA r_battle_slot_damage.w,Y                                                ; $03CAC4 |\
    AND #~BATTLE_DAMAGE_MISS.w                                                  ; $03CAC7 | | Otherwise prepare to subtract the value by masking out the miss
    STA r_battle_apply_pending_damage_tmp.w                                     ; $03CACA | | bit and saving the value to memory.
    SEC                                                                         ; $03CACD |/
    LDA r_character_battle.1.hp.w,X                                             ; $03CACE |\ If the HP is already zero, skip any subtraction.
    BEQ ++                                                                      ; $03CAD1 |/
    SBC r_battle_apply_pending_damage_tmp.w                                     ; $03CAD3 |\
    BEQ +                                                                       ; $03CAD6 | | Subtract the value and branch away if no borrow was needed.
    BCS +++                                                                     ; $03CAD8 |/
+   SEP #FLAG_P_ACCUMULATOR                                                     ; $03CADA |\
    INC r_battle_apply_pending_damage_result_deaths.w                           ; $03CADC | | If the result is zero or less, increment the death counter.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03CADF |/
++  TYA                                                                         ; $03CAE1 |\
    ASL A                                                                       ; $03CAE2 | | Set the X register to the Y register times two (slot times four).
    TAX                                                                         ; $03CAE3 |/
    TDC                                                                         ; $03CAE4 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CAE5 | | Ensure that poison is not set in the pending status variable and
    LDA r_battle_pending_status.1.status_1.w,X                                  ; $03CAE7 | | flag swoon as being pending.
    AND #(STATUS_1_POISON ~ $FF).b                                              ; $03CAEA | |
    ORA #STATUS_1_SWOON.b                                                       ; $03CAEC | |
    STA r_battle_pending_status.1.status_1.w,X                                  ; $03CAEE | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $03CAF1 |/
    TDC                                                                         ; $03CAF3 | Set the accumulator to zero.
    LDX <r_battle_apply_pending_damage_slot_offset                              ; $03CAF4 | Set the X register to the offset in the character battle record.
+++ STA r_character_battle.1.hp.w,X                                             ; $03CAF6 | Write the new HP value to the slot's HP.
    CMP r_character_battle.1.hp_max.w,X                                         ; $03CAF9 |\
    BCC +                                                                       ; $03CAFC | | If the new value is greater than the maximum HP, explicitly
    LDA r_character_battle.1.hp_max.w,X                                         ; $03CAFE | | replace it with the maximum HP.
    STA r_character_battle.1.hp.w,X                                             ; $03CB01 | |
    BRA ++                                                                      ; $03CB04 |/
+   LDA r_character_battle.1.hp_max.w,X                                         ; $03CB06 |\
    JSR _math_divide_by_4                                                       ; $03CB09 | | The next block only applies if the current's HP is less than or
    CMP r_character_battle.1.hp.w,X                                             ; $03CB0C | | equal to one quarter the maximum HP.
    BCC ++                                                                      ; $03CB0F |/
    TYA                                                                         ; $03CB11 |\
    ASL A                                                                       ; $03CB12 | | In that case, set the HP critical status as pending on this slot.
    TAX                                                                         ; $03CB13 | |
    TDC                                                                         ; $03CB14 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CB15 | |
    LDA r_battle_pending_status.1.status_4.w,X                                  ; $03CB17 | |
    ORA #STATUS_4_CRITICAL.b                                                    ; $03CB1A | |
    STA r_battle_pending_status.1.status_4.w,X                                  ; $03CB1C | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $03CB1F | |
    BRA @next                                                                   ; $03CB21 |/
++  TDC                                                                         ; $03CB23 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CB24 | | Otherwise, remove the HP critical status from this slot.
    LDX <r_battle_apply_pending_damage_slot_offset                              ; $03CB26 | |
    LDA r_character_battle.1.status_4.w,X                                       ; $03CB28 | |
    AND #STATUS_4_CRITICAL.b ~ $FF                                              ; $03CB2B | |
    STA r_character_battle.1.status_4.w,X                                       ; $03CB2D | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $03CB30 |/
@next:
    LDX <r_battle_apply_pending_damage_slot_offset                              ; $03CB32 |\
    TXA                                                                         ; $03CB34 | | Update the slot offset for the next slot.
    CLC                                                                         ; $03CB35 | |
    ADC #_sizeof_character_battle.w                                             ; $03CB36 | |
    TAX                                                                         ; $03CB39 | |
    STX <r_battle_apply_pending_damage_slot_offset                              ; $03CB3A |/
    INY                                                                         ; $03CB3C |\ Increment the Y register by two (slot times two).
    INY                                                                         ; $03CB3D |/
    CPY #(5 + 8).w * 2                                                          ; $03CB3E |\
    BEQ +                                                                       ; $03CB41 | | Loop until all 13 slots have been processed.
    JMP @start                                                                  ; $03CB43 |/
+   TDC                                                                         ; $03CB46 |\ Return to 8-bit accumulator mode before returning.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CB47 |/
    RTS                                                                         ; $03CB49

; _battle_apply_physical_status ($03:CB4A)
;
; Applies the physical status bits given in $3908 and $3909 (corresponding to
; the first two status bytes) to the target slot passed in $CF and the 16-bit
; target status offset in $C7. IF the statuses are not applied, the arguments
; will be set to zero.
_battle_apply_physical_status:
    LDA r_battle_apply_physical_status_arg_status.status_1.w                    ; $03CB4A |\
    BPL +                                                                       ; $03CB4D | | If the swoon bit is set in the attack status parameter and the
    LDA r_character_battle_current_target.monster_race.w                        ; $03CB4F | | target is a monster that is either undead or a machine, unset the
    AND #(MONSTER_RACE_UNDEAD | MONSTER_RACE_MACHINE).b                         ; $03CB52 | | parameters and return without applying any statuses.
    BEQ +                                                                       ; $03CB54 | |
    STZ r_battle_apply_physical_status_arg_status.status_1.w                    ; $03CB56 | |
    STZ r_battle_apply_physical_status_arg_status.status_2.w                    ; $03CB59 | |
    RTS                                                                         ; $03CB5C |/
+   REP #FLAG_P_ACCUMULATOR.b                                                   ; $03CB5D |\
    LDA r_character_battle_current_target.status_1.w                            ; $03CB5F | | If the target already has a status with a higher bit value (taking
    AND #(STATUS_2_FLOAT << 8).w ~ $FFFF                                        ; $03CB62 | | the first two status bytes as a little endian word) than the
    CMP r_battle_apply_physical_status_arg_status.w                             ; $03CB65 | | attacking status, return without doing anything.
    BCC +                                                                       ; $03CB68 | |
    STZ r_battle_apply_physical_status_arg_status.w                             ; $03CB6A | |
    JMP @done_16bit                                                             ; $03CB6D |/
+   LDX <r_battle_apply_physical_status_arg_status_offset                       ; $03CB70 |\
    LDA r_character_battle_current_target.status_1.w                            ; $03CB72 | | Set the pending status to the target's existing status with the
    ORA r_battle_apply_physical_status_arg_status.w                             ; $03CB75 | | new status bits added in.
    STA r_battle_pending_status.1.status_1.w,X                                  ; $03CB78 |/
    LDA r_battle_apply_physical_status_arg_status.w                             ; $03CB7B |\
    AND #%0011101100000001.w                                                    ; $03CB7E | | If setting any of the paralyze, sleep, charm, gradual petrify or
    BNE +                                                                       ; $03CB81 | | poison statuses, branch ahead. Otherwise, return.
    JMP @done_16bit                                                             ; $03CB83 | |
+   TDC                                                                         ; $03CB86 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CB87 |/
    LDA r_battle_apply_physical_status_arg_status.status_1.w                    ; $03CB89 |\
    AND #STATUS_1_POISON.b                                                      ; $03CB8C | | If not setting the poison status, skip the next block.
    BEQ +                                                                       ; $03CB8E |/
    LDA #TIMER_MODE_POISON.b                                                    ; $03CB90 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03CB92 | | Set the poison timer value using the poison timer mode.
    LDA <r_battle_command_target_true_slot                                      ; $03CB94 | |
    JSR _calculate_timer_value                                                  ; $03CB96 | |
    LDA #TIMER_OFFSET_POISON.b                                                  ; $03CB99 | |
    JSR _set_timer_value                                                        ; $03CB9B |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03CB9E |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03CBA0 |/
    LDA <r_battle_command_target_true_slot                                      ; $03CBA3 |\
    ASL A                                                                       ; $03CBA5 | | Flag that the poison timer is enabled.
    TAX                                                                         ; $03CBA6 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03CBA7 | |
    ORA #(TIMER_ENABLED_POISON >> 8).b                                          ; $03CBAA | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03CBAC |/
    LDA <r_set_timer_value_arg_lo                                               ; $03CBAF |\
    STA r_battle_poison_interval.w + 0,X                                        ; $03CBB1 | | Save the calculated timer value to memory as the poison interval.
    LDA <r_set_timer_value_arg_hi                                               ; $03CBB4 | |
    STA r_battle_poison_interval.w + 1,X                                        ; $03CBB6 |/
+   LDA r_battle_apply_physical_status_arg_status.status_2.w                    ; $03CBB9 |\
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03CBBC | | If not applying the paralyze or sleep statuses, branch ahead.
    BEQ +                                                                       ; $03CBBE |/
    LDA #TIMER_MODE_PARALYZE_SLEEP_STONE.b                                      ; $03CBC0 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03CBC2 | | Otherwise, calculate the timer value using the paralyze/sleep mode
    LDA <r_battle_command_target_true_slot                                      ; $03CBC4 | | and set the value in the action timer.
    JSR _calculate_timer_value                                                  ; $03CBC6 | |
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03CBC9 | |
    JSR _set_timer_value                                                        ; $03CBCB |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03CBCE |\
    STA r_battle_timers.1.flags.w,X                                             ; $03CBD0 | | Flag the timer as being status-related.
    RTS                                                                         ; $03CBD3 |/
+   LDA r_battle_apply_physical_status_arg_status.status_2.w                    ; $03CBD4 |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $03CBD7 | | If not applying gradual petrification, skip to the end.
    BEQ @done                                                                   ; $03CBD9 |/
    LDX <r_battle_apply_physical_status_arg_status_offset                       ; $03CBDB | Set the X register to the pending status offset.
    LDA r_character_battle_current_target.status_2.w                            ; $03CBDD |\
    AND #STATUS_2_STONE_STATUS.b ~ $FF                                          ; $03CBE0 | | Mask out any stone status bits and save the result.
    STA <r_battle_generic_tmp_1_lo                                              ; $03CBE2 |/
    LDA r_character_battle_current_target.status_2.w                            ; $03CBE4 |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $03CBE7 | | If no stone status bits are already set, branch ahead.
    BEQ ++                                                                      ; $03CBE9 |/
    CLC                                                                         ; $03CBEB |\
    ADC r_character_battle_current_actor.physical_attack_status_2.w             ; $03CBEC | | Add the attack status value to any existing stone status.
    STA <r_battle_generic_tmp_1_hi                                              ; $03CBEF |/
    AND #STATUS_2_BERSERK.b                                                     ; $03CBF1 |\ If it didn't overflow and set the berserk status bit, branch
    BEQ +                                                                       ; $03CBF3 |/ ahead.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03CBF5 |\
    STA r_battle_pending_status.1.status_2.w,X                                  ; $03CBF7 | | Otherwise, set the pending status to unset the gradual
    LDA r_character_battle_current_target.status_1.w                            ; $03CBFA | | petrification bits and to set the full stone status.
    ORA #STATUS_1_STONE.b                                                       ; $03CBFD | |
    STA r_battle_pending_status.1.status_1.w,X                                  ; $03CBFF |/
    LDA <r_battle_command_target_true_slot                                      ; $03CC02 |\
    ASL A                                                                       ; $03CC04 | | Unset the stone timer and return.
    TAX                                                                         ; $03CC05 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03CC06 | |
    AND #(TIMER_ENABLED_STONE >> 8).b ~ $FF                                     ; $03CC09 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03CC0B | |
    RTS                                                                         ; $03CC0E |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03CC0F |\
    ORA <r_battle_generic_tmp_1_hi                                              ; $03CC11 | | If there was no overflow, set the pending status to update the
    STA r_battle_pending_status.1.status_2.w,X                                  ; $03CC13 | | stone status to the new level and return.
    RTS                                                                         ; $03CC16 |/
++  LDA #TIMER_MODE_PARALYZE_SLEEP_STONE.b                                      ; $03CC17 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03CC19 | | If there was no pre-existing gradual petrification, calculate the
    LDA <r_battle_command_target_true_slot                                      ; $03CC1B | | timer value using the paralyze/sleep mode.
    JSR _calculate_timer_value                                                  ; $03CC1D | |
    LDA #TIMER_OFFSET_STONE.b                                                   ; $03CC20 | |
    JSR _set_timer_value                                                        ; $03CC22 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03CC25 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03CC27 |/
    LDA <r_battle_command_target_true_slot                                      ; $03CC2A |\
    ASL A                                                                       ; $03CC2C | | Flag the stone timer as enabled.
    TAX                                                                         ; $03CC2D | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03CC2E | |
    ORA #(TIMER_ENABLED_STONE >> 8).b                                           ; $03CC31 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03CC33 |/
    LDA <r_set_timer_value_arg_lo                                               ; $03CC36 |\
    STA r_battle_stone_interval.w + 0,X                                         ; $03CC38 | | Set the stone timer interval for later updates.
    LDA <r_set_timer_value_arg_hi                                               ; $03CC3B | |
    STA r_battle_stone_interval.w + 1,X                                         ; $03CC3D |/
    RTS                                                                         ; $03CC40
@done:
    RTS                                                                         ; $03CC41
@done_16bit:
    TDC                                                                         ; $03CC42
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03CC43
    RTS                                                                         ; $03CC45

; _battle_command_execute_magic ($03:CC46)
;
; Handles the execution and damage calculation of the three primary magic
; commands.
_battle_command_execute_magic:
    TDC                                                                         ; $03CC46 |\
    TAX                                                                         ; $03CC47 | | Set the battle script index to zero.
    STX r_battle_script_tmp_index.w                                             ; $03CC48 |/
    LDA <r_battle_command_actor_slot                                            ; $03CC4B |\
    BMI +                                                                       ; $03CC4D | | If the actor is a party member, branch to the party code.
    JMP @party                                                                  ; $03CC4F |/
+   TDC                                                                         ; $03CC52 |\
    TAX                                                                         ; $03CC53 | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03CC54 |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03CC55 |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03CC58 | | Copy the entire audiovisual script to a temporary area.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03CC5B | |
    BEQ +                                                                       ; $03CC5D | |
    INX                                                                         ; $03CC5F | |
    INY                                                                         ; $03CC60 | |
    BRA -                                                                       ; $03CC61 |/
+   TDC                                                                         ; $03CC63 |\
    TAX                                                                         ; $03CC64 | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03CC65 |/
@start_1:
    LDA r_battle_script_tmp_copy.w,X                                            ; $03CC66 |\ Copy the next byte from the temporary area to the script.
    STA r_battle_script_audiovisual.w,Y                                         ; $03CC69 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03CC6C |\ If that was the end of the script, branch to the next section.
    BEQ @end_1                                                                  ; $03CC6E |/
    CMP #MONSTER_COMMAND_UNKNOWN_FA.b                                           ; $03CC70 |\ If the code was $FA to $FE (mostly chain commands), simply move on
    BCS @next_1                                                                 ; $03CC72 |/ to the next byte.
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03CC74 |\ If the code was $E8 to $F9, branch to code to copy its parameter
    BCS +                                                                       ; $03CC76 |/ byte.
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03CC78 |\ If the code was less than $C0, branch to code to add the code to
    BCC ++                                                                      ; $03CC7A |/ display the action name.
    BRA @next_1                                                                 ; $03CC7C | Any other code can simply move to the next byte.
+   INX                                                                         ; $03CC7E |\
    INY                                                                         ; $03CC7F | | For double byte instructions, copy the parameter byte back to the
    LDA r_battle_script_tmp_copy.w,X                                            ; $03CC80 | | script and branch to the next byte.
    STA r_battle_script_audiovisual.w,Y                                         ; $03CC83 | |
    BRA @next_1                                                                 ; $03CC86 |/
++  PHA                                                                         ; $03CC88 |\
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03CC89 | | For the commands less than $C0 (spells), add the dialog code to
    STA r_battle_script_audiovisual.w + 0,Y                                     ; $03CC8B | | display the name of the action.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_ACTION_NAME.b                           ; $03CC8E | |
    STA r_battle_script_audiovisual.w + 1,Y                                     ; $03CC90 | |
    PLA                                                                         ; $03CC93 |/
    CMP #SPELL_FIRST_CALL_PROXY.b                                               ; $03CC94 |\
    BCC +                                                                       ; $03CC96 | | For spells in the range $31 to $5E, subtract $30 to determine the
    CMP #SPELL_FIRST_MONSTER.b                                                  ; $03CC98 | | actual spell number.
    BCS +                                                                       ; $03CC9A | |
    SEC                                                                         ; $03CC9C | |
    SBC #48.b                                                                   ; $03CC9D | |
    BRA +                                                                       ; $03CC9F |/
+   STA r_battle_script_audiovisual.w + 2,Y                                     ; $03CCA1 | Save the spell number to the audiovisual script.
    INY                                                                         ; $03CCA4 |\ Increment the Y register to account for the extra two bytes.
    INY                                                                         ; $03CCA5 |/
@next_1:
    INX                                                                         ; $03CCA6 |\
    INY                                                                         ; $03CCA7 | | Increment the indexes and loop back to the next byte.
    BRA @start_1                                                                ; $03CCA8 |/
@end_1:
    LDA r_monster_script_chain_slot_lo.w                                        ; $03CCAA |\
    CMP #$FF.b                                                                  ; $03CCAD | | If there is no active chain, skip this next block.
    BEQ +                                                                       ; $03CCAF |/
    TDC                                                                         ; $03CCB1 |\
    TAX                                                                         ; $03CCB2 | | Loop through the script to check how it ends. A chain is active,
-   LDA r_battle_script_audiovisual.w,X                                         ; $03CCB3 | | so if we find the end of the script before the end of the chain,
    CMP #MONSTER_COMMAND_CHAIN_END.b                                            ; $03CCB6 | | skip to the end, as we don't yet want to display damage. If we
    BEQ +                                                                       ; $03CCB8 | | find the end of the chain, however, branch ahead to the code that
    CMP #MONSTER_COMMAND_END.b                                                  ; $03CCBA | | adds the damage display code.
    BEQ @end_2                                                                  ; $03CCBC | |
    INX                                                                         ; $03CCBE | |
    BRA -                                                                       ; $03CCBF |/
+   TDC                                                                         ; $03CCC1 |\
    TAX                                                                         ; $03CCC2 | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03CCC3 |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03CCC4 |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03CCC7 | | Copy the entire audiovisual script to a temporary area.
    CMP #MONSTER_COMMAND_END.b                                                  ; $03CCCA | |
    BEQ +                                                                       ; $03CCCC | |
    INX                                                                         ; $03CCCE | |
    INY                                                                         ; $03CCCF | |
    BRA -                                                                       ; $03CCD0 |/
+   TDC                                                                         ; $03CCD2 |\
    TAX                                                                         ; $03CCD3 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03CCD4 |/
@start_2:
    LDA r_battle_script_tmp_copy.w,X                                            ; $03CCD5 |\ Read the next byte and copy it back to the main script.
    STA r_battle_script_audiovisual.w,Y                                         ; $03CCD8 |/
    CMP #MONSTER_COMMAND_END.b                                                  ; $03CCDB |\ If it's the end of the script, branch to the end.
    BEQ @end_2                                                                  ; $03CCDD |/
    CMP #MONSTER_COMMAND_UNKNOWN_FA.b                                           ; $03CCDF |\ If it's $FA to $FE, move to the next byte.
    BCS +++                                                                     ; $03CCE1 |/
    CMP #MONSTER_COMMAND_CHANGE_RACE.b                                          ; $03CCE3 |\ If it's a double byte instruction ($E8 to $F9), copy the paraameter
    BCS +                                                                       ; $03CCE5 |/ byte as well.
    CMP #MONSTER_COMMAND_FIGHT.b                                                ; $03CCE7 |\ If it's less than $C0 (a spell), branch to add the damage display.
    BCC ++                                                                      ; $03CCE9 |/
    BRA +++                                                                     ; $03CCEB | Otherwise, branch to the next byte.
+   INX                                                                         ; $03CCED |\
    INY                                                                         ; $03CCEE | | For double-byte instructions, copy the parameter byte.
    LDA r_battle_script_tmp_copy.w,X                                            ; $03CCEF | |
    STA r_battle_script_audiovisual.w,Y                                         ; $03CCF2 | |
    BRA +++                                                                     ; $03CCF5 |/
++  INY                                                                         ; $03CCF7 |\
    STY r_battle_script_tmp_index.w                                             ; $03CCF8 | | If the instruction is less than $C0 (spell), add the code to
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03CCFB | | display the damage after the spell. Also set the current script
    STA r_battle_script_audiovisual.w,Y                                         ; $03CCFD | | index.
    INY                                                                         ; $03CD00 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03CD01 | |
    STA r_battle_script_audiovisual.w,Y                                         ; $03CD03 |/
+++ INX                                                                         ; $03CD06 |\
    INY                                                                         ; $03CD07 | | Increment the indexes and loop back to the next byte.
    BRA @start_2                                                                ; $03CD08 |/
@end_2:
    TDC                                                                         ; $03CD0A |\ Set the X register to zero.
    TAX                                                                         ; $03CD0B |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03CD0C |\
    CMP #MONSTER_COMMAND_WHITE.b                                                ; $03CD0F | | Search through the audiovisual script for the white magic command
    BNE +                                                                       ; $03CD11 | | and replace it with a zero. The actual spell will take care of the
    LDA #0.b                                                                    ; $03CD13 | | animation.
    STA r_battle_script_audiovisual.w,X                                         ; $03CD15 | |
    BRA ++                                                                      ; $03CD18 | |
+   INX                                                                         ; $03CD1A | |
    BRA -                                                                       ; $03CD1B |/
++  JMP _battle_calculate_magic_damage_skip_audiovisual_setup                   ; $03CD1D | Jump to calculate the magic damage, but skip the audiovisual setup.
@party:
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CD20 |\
    CMP #SPELL_FIRST_BLACK.b                                                    ; $03CD23 | | If the spell is in the white magic range, branch to calculation.
    BCC _battle_calculate_magic_damage                                          ; $03CD25 |/
    CMP #SPELL_FIRST_CALL_PROXY.b                                               ; $03CD27 |\
    BCC +                                                                       ; $03CD29 | | Otherwise, branch depending on if it's in the black magic range
    CMP #SPELL_FIRST_TWIN.b                                                     ; $03CD2B | | or the call range.
    BCC ++                                                                      ; $03CD2D |/
+   LDA #MONSTER_COMMAND_BLACK.b                                                ; $03CD2F |\ If black magic, load the black magic code into the accumulator.
    BRA +                                                                       ; $03CD31 |/
++  JSR _battle_command_helper_update_call                                      ; $03CD33 |\ If Call, update the spell to the actual call spell instead of the
    LDA #MONSTER_COMMAND_CALL.b                                                 ; $03CD36 |/ proxy, and load the Call value into the accumulator.
    STA r_battle_last_action_command.w                                          ; $03CD38 | Save the updated command value to the last used command.
+   STA r_battle_script_audiovisual.w + 2                                       ; $03CD3B | Save the command to the audiovisual script and fall through.

; _battle_calculate_magic_damage ($03:CD3E)
;
; Handles all the damage and stat effects of a magical spell, including spells,
; items and weapons used as items.
_battle_calculate_magic_damage:
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CD3E |\ Copy the subcommand into the audiovisual script.
    STA r_battle_script_audiovisual.w + 3                                       ; $03CD41 |/
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03CD44 |\
    STA r_battle_script_audiovisual.w + 4                                       ; $03CD46 | | Add the codes to display damage to the end of the audiovisual
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03CD49 | | script.
    STA r_battle_script_audiovisual.w + 5                                       ; $03CD4B |/
_battle_calculate_magic_damage_skip_audiovisual_setup:
    INC r_battle_mask_damage_miss.w                                             ; $03CD4E | Mask the miss bit from pending damage. TODO: Does this even matter?
    LDA <r_battle_command_target_slot                                           ; $03CD51 |\
    AND #%10000000.b                                                            ; $03CD53 | | Set the target flags to $80 if targeting monsters.
    STA r_battle_current_action_details.target_flags.w                          ; $03CD55 |/
    STZ r_battle_command_wall_sources.w                                         ; $03CD58 |\ Set the wall sources and targets both to zero.
    STZ r_battle_command_wall_targets.w                                         ; $03CD5B |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CD5E |\
    CMP #SPELL_MONSTER_RETREAT.b                                                ; $03CD61 | | If using the monster Retreat spell, set the monster transition to
    BNE +                                                                       ; $03CD63 | | retreat and set the flag to suppress the death counter being
    PHA                                                                         ; $03CD65 | | incremented.
    LDA #BATTLE_MONSTER_TRANSITION_RETREAT.b                                    ; $03CD66 | |
    STA r_battle_monster_special_transition.w                                   ; $03CD68 | |
    PLA                                                                         ; $03CD6B | |
    INC r_battle_monster_suppress_death_count.w                                 ; $03CD6C |/
+   TAX                                                                         ; $03CD6F |\ Transfer the subcommand to the copy_from_array index parameter.
    STX <r_copy_from_array_arg_index                                            ; $03CD70 |/
    LDA r_battle_current_spell_item.w                                           ; $03CD72 |\ If the spell being used is an item, branch to separate code.
    BNE ++                                                                      ; $03CD75 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CD77 |\
    JSR _battle_check_spell_display_name                                        ; $03CD7A | | Determine if the spell being cast should have its name displayed.
    STA r_battle_current_action_details.action.w                                ; $03CD7D | | If so, copy the spell number into the action. Otherwise, store a
    BNE +                                                                       ; $03CD80 | | zero into the action byte and set the actor flag to prevent them
    LDA r_battle_current_action_details.actor_flags.w                           ; $03CD82 | | from flashing.
    ORA #BATTLE_ACTION_DETAILS_ACTOR_FLAG_SILENT.b                              ; $03CD85 | |
    STA r_battle_current_action_details.actor_flags.w                           ; $03CD87 |/
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03CD8A |\
    JSR _battle_check_spell_suppress_flash                                      ; $03CD8D | | If the monster flashing effect should be suppressed for this
    BEQ +                                                                       ; $03CD90 | | spell, set the silent actor flag.
    LDA r_battle_current_action_details.actor_flags.w                           ; $03CD92 | |
    ORA #BATTLE_ACTION_DETAILS_ACTOR_FLAG_SILENT.b                              ; $03CD95 | |
    STA r_battle_current_action_details.actor_flags.w                           ; $03CD97 |/
+   LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_SPELL.b                              ; $03CD9A |\ Flag the current action as being a spell.
    STA r_battle_current_action_details.action_flags.w                          ; $03CD9C |/
    LDX #bank0F.spell_property_data.w                                           ; $03CD9F |\
    STX <r_generic_tmp_ptr_addr                                                 ; $03CDA2 | | Set the copy_from_array pointer argument to the spell property
    LDA #:bank0F.spell_property_data                                            ; $03CDA4 | | data.
    STA <r_generic_tmp_ptr_bank                                                 ; $03CDA6 |/
    BRA +++                                                                     ; $03CDA8 | Branch ahead past the item-specific code.
++  LDA r_character_battle_current_actor.subcommand.w                           ; $03CDAA |\ If the spell being used is an item, set the action to the item ID.
    STA r_battle_current_action_details.action.w                                ; $03CDAD |/
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_ITEM.b                               ; $03CDB0 |\ Set the action flags to indicate this is an item.
    STA r_battle_current_action_details.action_flags.w                          ; $03CDB2 |/
    LDX #bank0F.battle_item_property_data.w                                     ; $03CDB5 |\
    STX <r_generic_tmp_ptr_addr                                                 ; $03CDB8 | | Set the copy_from_array pointer argument to the item property
    LDA #:bank0F.battle_item_property_data.b                                    ; $03CDBA | | data.
    STA <r_generic_tmp_ptr_bank                                                 ; $03CDBC |/
    SEC                                                                         ; $03CDBE |\
    LDA <r_copy_from_array_arg_index                                            ; $03CDBF | | Subtract $B0 from the argument since the desired table starts at
    SBC #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03CDC1 | | item $B0.
    STA <r_copy_from_array_arg_index                                            ; $03CDC3 |/
+++ LDA #_sizeof_spell.b                                                        ; $03CDC5 |\ Copy the data about the item or spell to the destination array.
    JSR _copy_from_array                                                        ; $03CDC7 |/
    LDA r_current_spell_properties.data.element_status_index.w                  ; $03CDCA |\
    PHA                                                                         ; $03CDCD | | If the high bit of the spell's element status index is set, save
    AND #SPELL_ELEMENT_STATUS_DAMAGES.b                                         ; $03CDCE | | that value to the flag that will enable the reeling animation
    STA r_battle_effect_spell_animate_reeling.w                                 ; $03CDD0 | | after the spell.
    PLA                                                                         ; $03CDD3 |/
    AND #SPELL_ELEMENT_STATUS_INDEX.b                                           ; $03CDD4 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03CDD6 | | Multiply the element status index by the size of the element
    LDA #_sizeof_element_status.b                                               ; $03CDD8 | | status data and transfer that offset to the X register.
    STA <r_math_multiply_8bit_arg_2                                             ; $03CDDA | |
    JSR _math_multiply_8bit                                                     ; $03CDDC | |
    LDX <r_math_multiply_8bit_result                                            ; $03CDDF |/
    TDC                                                                         ; $03CDE1 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03CDE2 |/
-   LDA bank0F.equipment_element_status_data.l,X                                ; $03CDE3 |\
    STA r_current_spell_properties.element_status.w,Y                           ; $03CDE7 | | Copy the three element status bytes to the spell properties in
    INY                                                                         ; $03CDEA | | memory.
    INX                                                                         ; $03CDEB | |
    CPY #_sizeof_element_status.w                                               ; $03CDEC | |
    BNE -                                                                       ; $03CDEF |/
    LDA r_current_spell_properties.element_status.element.w                     ; $03CDF1 |\ Save the spell's element to the last used element variable.
    STA r_battle_last_action_element.w                                          ; $03CDF4 |/
    LDA <r_battle_command_target_slot                                           ; $03CDF7 |\
    AND #%10000000.b                                                            ; $03CDF9 | | Save the target type to a variable.
    STA r_battle_command_current_target_type.w                                  ; $03CDFB |/
    BMI +                                                                       ; $03CDFE |\
    JSR _battle_get_first_party_target                                          ; $03CE00 | | If targeting the party and there are no available party targets,
    LDA <r_battle_generic_tmp_1_lo                                              ; $03CE03 | | set the actual targets to zero and jump to the end.
    BEQ +                                                                       ; $03CE05 | |
-   STZ r_battle_command_actual_targets.w                                       ; $03CE07 | |
    JMP @done                                                                   ; $03CE0A |/
+   LDA r_character_battle_current_actor.targets.monster.w                      ; $03CE0D |\
    BNE +                                                                       ; $03CE10 | | Load the current target value into the accumulator.
    LDA r_character_battle_current_actor.targets.party.w                        ; $03CE12 |/
+   JSR _battle_remove_unavailable_spell_targets_if_not_life                    ; $03CE15 | If not casting a revive spell, remove any dead targets.
    STA r_battle_command_available_targets.w                                    ; $03CE18 | Save the current targets to the available targets value.
    STA r_battle_command_actual_targets.w                                       ; $03CE1B | Save the current targets to the actual targets value.
    JSR _count_set_bits                                                         ; $03CE1E |\
    TXA                                                                         ; $03CE21 | | Set the split value to the number of set targets.
    STA r_battle_calculate_damage_arg_split.w                                   ; $03CE22 |/
    STA r_battle_command_magic_target_count.w                                   ; $03CE25 | Set the number of targets to the counter.
    BEQ -                                                                       ; $03CE28 | If no targets set, branch to set $3550 to zero and to the end.
    LDA r_current_spell_properties.data.time_targeting.w                        ; $03CE2A |\
    AND #SPELL_TIME_TARGETING_TARGET_ALL.b | SPELL_TIME_TARGETING_TARGET_SINGLE ; $03CE2D | | If the spell is not able to target single targets, set the split
    CMP #SPELL_TIME_TARGETING_TARGET_ALL.b                                      ; $03CE2F | | value to 1.
    BNE +                                                                       ; $03CE31 | |
    LDA #1.b                                                                    ; $03CE33 | |
    STA r_battle_calculate_damage_arg_split.w                                   ; $03CE35 |/
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03CE38 |\ Skip the next block if the subcommand is zero.
    BEQ ++                                                                      ; $03CE3B |/
    LDA r_battle_current_action_uses_mp.w                                       ; $03CE3D |\ Skip the next block if the current command doesn't use MP.
    BEQ ++                                                                      ; $03CE40 |/
    LDA <r_battle_command_actor_slot                                            ; $03CE42 |\ Skip the next block if the actor is a monster.
    BMI ++                                                                      ; $03CE44 |/
    LDA r_battle_auto.w                                                         ; $03CE46 |\ Skip the next block if this is an automatic battle.
    BNE ++                                                                      ; $03CE49 |/
    LDA r_current_spell_properties.data.wall_mp.w                               ; $03CE4B |\
    AND #SPELL_WALL_MP_MP.b                                                     ; $03CE4E | | Save the spell's MP cost to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03CE50 |/
    SEC                                                                         ; $03CE52 |\
    LDA r_character_battle_current_actor.mp_lo.w                                ; $03CE53 | | Subtract the cost from the actor's current MP to determine their
    SBC <r_battle_generic_tmp_1_lo                                              ; $03CE56 | | new MP value.
    STA <r_battle_generic_tmp_1_lo                                              ; $03CE58 | |
    LDA r_character_battle_current_actor.mp_hi.w                                ; $03CE5A | |
    SBC #0.b                                                                    ; $03CE5D | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03CE5F |/
    BCS +                                                                       ; $03CE61 |\
    STZ r_battle_command_actual_targets.w                                       ; $03CE63 | | If the value went negative, set the actual targets to zero, set
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03CE66 | | commands to draw the "not enough MP" alert, and jump to the end
    LDA #BATTLE_ALERT_NOT_ENOUGH_MP.b                                           ; $03CE69 | | of the function.
    STA r_battle_alert_queue.w                                                  ; $03CE6B | |
    JMP @done                                                                   ; $03CE6E |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03CE71 |\
    STA r_character_battle_current_actor.mp_lo.w                                ; $03CE73 | | Set the actor's MP to the new value.
    LDA <r_battle_generic_tmp_1_hi                                              ; $03CE76 | |
    STA r_character_battle_current_actor.mp_hi.w                                ; $03CE78 |/
++  LDA r_battle_current_spell_item.w                                           ; $03CE7B |\ If the current spell is from an item, branch forward.
    BNE +++                                                                     ; $03CE7E |/
    LDA r_battle_current_spell_weapon.w                                         ; $03CE80 |\ If the current spell is from a weapon, branch forward.
    BNE +++                                                                     ; $03CE83 |/
    LDA r_character_battle_current_actor.status_1.w                             ; $03CE85 |\
    AND #STATUS_1_MUTE.b                                                        ; $03CE88 | | If the actor has the mute status and the spell is not a monster
    BEQ +                                                                       ; $03CE8A | | spell, branch to set the actual targets to zero and return.
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CE8C | |
    CMP #SPELL_FIRST_MONSTER.b                                                  ; $03CE8F | |
    BCC ++                                                                      ; $03CE91 |/
+   LDA r_character_battle_current_actor.status_1.w                             ; $03CE93 |\
    AND #STATUS_1_TOAD.b                                                        ; $03CE96 | | If the actor has the toad status and the spell is Toad, branch to
    BEQ +                                                                       ; $03CE98 | | the actual spell handling code. If any other spell, branch to set
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CE9A | | the actual targets to zero and return.
    CMP #SPELL_TOAD.b                                                           ; $03CE9D | |
    BEQ +++                                                                     ; $03CE9F | |
    BNE ++                                                                      ; $03CEA1 |/
+   LDA r_character_battle_current_actor.status_1.w                             ; $03CEA3 |\
    AND #STATUS_1_PIG.b                                                         ; $03CEA6 | | If the actor has the pig status and the spell is anything but
    BEQ +++                                                                     ; $03CEA8 | | Piggy, set the actual targets to zero and return.
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CEAA | |
    CMP #SPELL_PIGGY.b                                                          ; $03CEAD | |
    BEQ +++                                                                     ; $03CEAF | |
++  STZ r_battle_command_actual_targets.w                                       ; $03CEB1 | |
    JMP @done                                                                   ; $03CEB4 |/
+++ TDC                                                                         ; $03CEB7 |\ Initialize the X register to zero.
    TAX                                                                         ; $03CEB8 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03CEB9 |\
    CMP #SPELL_FIRST_BLACK.b                                                    ; $03CEBC | | If the spell number places it in the white magic range, increment
    BCS +                                                                       ; $03CEBE | | the X register to use will instead of wisdom.
    INX                                                                         ; $03CEC0 |/
+   STX <r_battle_command_magic_stat_offset                                     ; $03CEC1 | Save the magic stat offset for later use.
    LDA r_character_battle_current_actor.wisdom.w,X                             ; $03CEC3 |\
    LSR A                                                                       ; $03CEC6 | | Calculate accuracy by adding half the selected magic stat to the
    STA <r_battle_generic_tmp_1_lo                                              ; $03CEC7 | | spell's base accuracy. If the value exceeds 255, set it explicitly
    LDA r_current_spell_properties.data.boss_accuracy.w                         ; $03CEC9 | | to 255.
    AND #SPELL_BOSS_ACCURACY_ACCURACY.b                                         ; $03CECC | |
    CLC                                                                         ; $03CECE | |
    ADC <r_battle_generic_tmp_1_lo                                              ; $03CECF | |
    BCC +                                                                       ; $03CED1 | |
    LDA #255.b                                                                  ; $03CED3 | |
+   STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03CED5 |/
    LDA r_character_battle_current_actor.status_1.w                             ; $03CED8 |\
    AND #STATUS_1_DARKNESS.b                                                    ; $03CEDB | | If the actor has the darkness status, divide the accuracy by two.
    BEQ +                                                                       ; $03CEDD | |
    LSR r_battle_calculate_hits_arg_accuracy.w                                  ; $03CEDF |/
+   LDA <r_battle_command_actor_slot                                            ; $03CEE2 |\
    AND #%01111111.b                                                            ; $03CEE4 | | If the actor is in relative slot zero (middle character or monster
    BNE +                                                                       ; $03CEE6 | | slot zero), multiply the accuracy by 5/4.
    LDA r_battle_calculate_hits_arg_accuracy.w                                  ; $03CEE8 | |
    STA <r_math_multiply_8bit_arg_1                                             ; $03CEEB | | BUG: If this overflows, the result will be incorrect, as the high
    LDA #5.b                                                                    ; $03CEED | |      byte is discarded.
    STA <r_math_multiply_8bit_arg_2                                             ; $03CEEF | |
    JSR _math_multiply_8bit                                                     ; $03CEF1 | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03CEF4 | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03CEF6 | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03CEF8 | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03CEFA | |
    LDA <r_math_multiply_8bit_result_lo                                         ; $03CEFC | |
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03CEFE |/
+   LDA r_current_spell_properties.data.effect.w                                ; $03CF01 |\
    AND #SPELL_EFFECT_HIT_MISS.b                                                ; $03CF04 | | If the spell is flagged as hit/miss, set the number of attempts
    BEQ +                                                                       ; $03CF06 | | to one.
    LDA #1.b                                                                    ; $03CF08 | |
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03CF0A | |
    BRA ++                                                                      ; $03CF0D |/
+   LDX <r_battle_command_magic_stat_offset                                     ; $03CF0F |\
    LDA r_character_battle_current_actor.wisdom.w,X                             ; $03CF11 | | Otherwise, set the number of attempts equal to the magic stat
    JSR _math_divide_by_4                                                       ; $03CF14 | | divided by four, plus one.
    INC A                                                                       ; $03CF17 | |
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03CF18 |/
++  JSR _battle_calculate_hits                                                  ; $03CF1B | Calculate the number of hits.
    LDA r_battle_calculate_hits_result.w                                        ; $03CF1E |\ Save the number of hits to a new variable.
    STA r_battle_command_magic_hits.w                                           ; $03CF21 |/
    LDA r_battle_current_spell_item.w                                           ; $03CF24 |\
    BNE +                                                                       ; $03CF27 | | If the current spell is an item or if it was caused by a Grimoire,
    LDA r_battle_current_spell_grimoire.w                                       ; $03CF29 | | explicitly set the number of hits to eight.
    BEQ ++                                                                      ; $03CF2C | |
+   LDA #8.b                                                                    ; $03CF2E | |
    STA r_battle_command_magic_hits.w                                           ; $03CF30 |/
++  LDA r_battle_current_spell_weapon.w                                         ; $03CF33 |\
    BEQ @loop_start                                                             ; $03CF36 | | If the current spell is a weapon, set the number of hits as
    LDA r_battle_current_spell_weapon_hits.w                                    ; $03CF38 | | defined by the weapon.
    STA r_battle_command_magic_hits.w                                           ; $03CF3B |/
@loop_start:
    STZ r_battle_command_wall_active.w                                          ; $03CF3E | Initially specify that no wall is active.
    TDC                                                                         ; $03CF41 |\ Initialize the X register to zero.
    TAX                                                                         ; $03CF42 |/
    LDA r_battle_command_available_targets.w                                    ; $03CF43 |\
-   ASL A                                                                       ; $03CF46 | | Loop through the target variable until the first set target is
    BCS +                                                                       ; $03CF47 | | found.
    INX                                                                         ; $03CF49 | |
    BNE -                                                                       ; $03CF4A |/
+   LDA r_battle_command_available_targets.w                                    ; $03CF4C |\
    JSR _unset_bit_x                                                            ; $03CF4F | | Unset the current target in the available targets byte.
    STA r_battle_command_available_targets.w                                    ; $03CF52 |/
    TXA                                                                         ; $03CF55 | Transfer the slot number to the accumulator.
    ORA r_battle_command_current_target_type.w                                  ; $03CF56 |\ Set the high bit if the target is a monster and save the target
    STA <r_battle_command_target_slot                                           ; $03CF59 |/ slot to memory.
    LDA <r_battle_command_target_slot                                           ; $03CF5B |\
    BPL +                                                                       ; $03CF5D | | Calculate the true slot number and transfer it to the X register.
    AND #%01111111.b                                                            ; $03CF5F | |
    CLC                                                                         ; $03CF61 | |
    ADC #5.b                                                                    ; $03CF62 | |
+   TAX                                                                         ; $03CF64 |/
    LDA r_battle_slot_empty.w,X                                                 ; $03CF65 |\
    BEQ +                                                                       ; $03CF68 | | If this slot is empty, skip to the slot failure code.
    JMP @slot_failure                                                           ; $03CF6A |/
+   LDA <r_battle_command_target_slot                                           ; $03CF6D |\
    JSR _battle_calculate_modified_slot_offset                                  ; $03CF6F | | Copy the target's stat record from its main location to the
    LDY #_sizeof_character_battle.w - 1                                         ; $03CF72 | | temporary area.
-   LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03CF75 | |
    STA r_character_battle_current_target.w,Y                                   ; $03CF77 | |
    DEY                                                                         ; $03CF7A | |
    BPL -                                                                       ; $03CF7B |/
    LDA r_character_battle_current_target.status_4.w                            ; $03CF7D |\
    AND #STATUS_4_WALL.b                                                        ; $03CF80 | | If the target does not have the wall status, or if the spell
    BEQ +                                                                       ; $03CF82 | | is set to bypass wall, jump to a later section of code.
    LDA r_current_spell_properties.data.wall_mp.w                               ; $03CF84 | |
    BPL ++                                                                      ; $03CF87 | |
+   JMP @skip_wall                                                              ; $03CF89 |/
++  LDA <r_battle_command_target_slot                                           ; $03CF8C |\
    BPL +                                                                       ; $03CF8E | | If the target is a monster and there is no available party target,
    JSR _battle_get_first_party_target                                          ; $03CF90 | | set the actual targets value to zero and skip the rest of the
    LDA <r_battle_generic_tmp_1_lo                                              ; $03CF93 | | calculation.
    BEQ +                                                                       ; $03CF95 | |
    STZ r_battle_command_actual_targets.w                                       ; $03CF97 | |
    JMP @done                                                                   ; $03CF9A |/
+   JSR _battle_unset_target                                                    ; $03CF9D | Unset the current target (with the wall status).
    LDA <r_battle_command_target_slot                                           ; $03CFA0 |\
    AND #%01111111.b                                                            ; $03CFA2 | | Add the target with wall to the wall sources.
    TAX                                                                         ; $03CFA4 | |
    TDC                                                                         ; $03CFA5 | |
    JSR _set_bit_x                                                              ; $03CFA6 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03CFA9 | |
    LDA r_battle_command_wall_sources.w                                         ; $03CFAB | |
    ORA <r_battle_generic_tmp_1_lo                                              ; $03CFAE | |
    STA r_battle_command_wall_sources.w                                         ; $03CFB0 |/
--  LDA r_battle_command_current_target_type.w                                  ; $03CFB3 |\
    EOR #%10000000.b                                                            ; $03CFB6 | | If after the wall, the new target type is a monster, load 7 into
    BPL +                                                                       ; $03CFB8 | | the accumulator. Otherwise. load 4.
    LDA #7.b                                                                    ; $03CFBA | |
    BRA ++                                                                      ; $03CFBC | |
+   LDA #4.b                                                                    ; $03CFBE |/
++  LDX #0.w                                                                    ; $03CFC0 |\
    JSR _get_battle_rng                                                         ; $03CFC3 | | Get a random number from 0 to the maximum slot for this type.
    STA <r_battle_generic_tmp_1_lo                                              ; $03CFC6 |/
    LDA r_battle_command_current_target_type.w                                  ; $03CFC8 |\
    EOR #%10000000.b                                                            ; $03CFCB | | Calculate the true slot number for this new target.
    BPL +                                                                       ; $03CFCD | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03CFCF | |
    CLC                                                                         ; $03CFD1 | |
    ADC #5.b                                                                    ; $03CFD2 | |
    BRA ++                                                                      ; $03CFD4 | |
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03CFD6 |/
++  TAX                                                                         ; $03CFD8 |\
    LDA r_battle_slot_empty.w,X                                                 ; $03CFD9 | | If this slot is empty, loop back and try again.
    BNE --                                                                      ; $03CFDC |/
    LDA r_battle_command_current_target_type.w                                  ; $03CFDE |\
    AND #%10000000.b                                                            ; $03CFE1 | | Set the new target slot to the randomly chosen slot, flipping the
    EOR #%10000000.b                                                            ; $03CFE3 | | type bit in the process.
    ORA <r_battle_generic_tmp_1_lo                                              ; $03CFE5 | |
    STA <r_battle_command_target_slot                                           ; $03CFE7 |/
    JSR _battle_calculate_modified_slot_offset                                  ; $03CFE9 |\
    LDY #_sizeof_character_battle.w - 1                                         ; $03CFEC | | Copy the new target's stat record into the temporary area.
-   LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03CFEF | |
    STA r_character_battle_current_target.w,Y                                   ; $03CFF1 | |
    DEY                                                                         ; $03CFF4 | |
    BPL -                                                                       ; $03CFF5 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03CFF7 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03CFFA | | If the new target is swoon or stone, loop back and try again.
    BNE --                                                                      ; $03CFFC |/
    LDA <r_battle_command_target_slot                                           ; $03CFFE |\
    AND #%01111111.b                                                            ; $03D000 | | Set this target in the wall targets variable.
    TAX                                                                         ; $03D002 | |
    TDC                                                                         ; $03D003 | |
    JSR _set_bit_x                                                              ; $03D004 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03D007 | |
    LDA r_battle_command_wall_targets.w                                         ; $03D009 | |
    ORA <r_battle_generic_tmp_1_lo                                              ; $03D00C | |
    STA r_battle_command_wall_targets.w                                         ; $03D00E |/
    INC r_battle_command_wall_active.w                                          ; $03D011 | Flag that a wall is active.
@skip_wall:
    LDA r_character_battle_current_target.status_1.w                            ; $03D014 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03D017 | | If the target slot has neither of the swoon or stone statuses, but is
    BNE +                                                                       ; $03D019 | | jumping, branch to the slot failure code.
    LDA r_character_battle_current_target.status_3.w                            ; $03D01B | |
    AND #STATUS_3_JUMPING.b                                                     ; $03D01E | |
    BNE @slot_failure                                                           ; $03D020 |/
    LDA r_character_battle_current_target.status_4.w                            ; $03D022 |\ If the target is not swoon, stone or hiding, branch ahead.
    BPL +++                                                                     ; $03D025 |/
+   AND #(STATUS_1_SWOON | STATUS_4_HIDING).b                                   ; $03D027 |\
    BNE +                                                                       ; $03D029 | | If the target has the stone status, and the spell's effect is not
    LDA r_current_spell_properties.data.effect.w                                ; $03D02B | | the healing effect, branch to the slot failure. If it is the
    AND #SPELL_EFFECT_EFFECT.b                                                  ; $03D02E | | healing effect, branch to the next section.
    CMP #SPELL_EFFECT_HEAL.b                                                    ; $03D030 | |
    BEQ +++                                                                     ; $03D032 | |
    BNE @slot_failure                                                           ; $03D034 |/
+   LDA r_current_spell_properties.data.effect.w                                ; $03D036 |\
    AND #SPELL_EFFECT_EFFECT.b                                                  ; $03D039 | | If the target has the swoon status and the spell effect is life
    CMP #SPELL_EFFECT_LIFE.b                                                    ; $03D03B | | or recover, branch ahead. Otherwise, fall through to the failure.
    BEQ +++                                                                     ; $03D03D | |
    CMP #SPELL_EFFECT_RECOVER.b                                                 ; $03D03F | |
    BEQ +++                                                                     ; $03D041 |/
@slot_failure:
    JSR _battle_unset_target                                                    ; $03D043 |\ Unset the target and branch to the next iteration of the loop.
    JMP @next                                                                   ; $03D046 |/
+++ LDA #2.b                                                                    ; $03D049 |\
    STA r_battle_damage_element_multiplier.w                                    ; $03D04B | | Set the initial element and race multiplier to two.
    STA r_battle_damage_race_multiplier.w                                       ; $03D04E |/
    LDA #0.b                                                                    ; $03D051 |\ Flag this as not a critical hit.
    STA r_battle_damage_critical.w                                              ; $03D053 |/
    STA <r_battle_generic_tmp_1_hi                                              ; $03D056 |\
    LDA r_current_spell_properties.data.power.w                                 ; $03D058 | | Transfer the spell power value to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03D05B |/
    LDA r_battle_double_spell_power.w                                           ; $03D05D |\
    BEQ +                                                                       ; $03D060 | | If spell power is doubled, multiply the spell power by eight.
    ASL <r_battle_generic_tmp_1_lo                                              ; $03D062 | |
    ROL <r_battle_generic_tmp_1_hi                                              ; $03D064 | |
    ASL <r_battle_generic_tmp_1_lo                                              ; $03D066 | |
    ROL <r_battle_generic_tmp_1_hi                                              ; $03D068 | |
    ASL <r_battle_generic_tmp_1_lo                                              ; $03D06A | |
    ROL <r_battle_generic_tmp_1_hi                                              ; $03D06C | |
    BRA ++                                                                      ; $03D06E |/
+   ASL <r_battle_generic_tmp_1_lo                                              ; $03D070 |\
    ROL <r_battle_generic_tmp_1_hi                                              ; $03D072 | | Otherwise, multiply by four.
    ASL <r_battle_generic_tmp_1_lo                                              ; $03D074 | |
    ROL <r_battle_generic_tmp_1_hi                                              ; $03D076 |/
++  LDX <r_battle_generic_tmp_1                                                 ; $03D078 |\ Save the result as the per-hit attack power.
    STX r_battle_damage_attack_power.w                                          ; $03D07A |/
    TDC                                                                         ; $03D07D |\
    TAX                                                                         ; $03D07E | | Initialize the damage variables to zero.
    STX <r_battle_calculate_damage_result                                       ; $03D07F | |
    STX <r_battle_damage_actor_damage                                           ; $03D081 |/
    LDA <r_battle_command_actor_slot                                            ; $03D083 |\
    AND #%10000000.b                                                            ; $03D085 | | If a party member is casting magic against another party member,
    BNE +                                                                       ; $03D087 | | set the defense value to zero.
    LDA <r_battle_command_target_slot                                           ; $03D089 | |
    AND #%10000000.b                                                            ; $03D08B | |
    BNE +                                                                       ; $03D08D | |
    STX r_battle_damage_defense_power.w                                         ; $03D08F | |
    BRA ++                                                                      ; $03D092 |/
+   LDA r_character_battle_current_target.magic_defense_base.w                  ; $03D094 |\
    TAX                                                                         ; $03D097 | | Otherwise, set it to the target's magic defense base.
    STX r_battle_damage_defense_power.w                                         ; $03D098 |/
++  LDA <r_battle_command_target_slot                                           ; $03D09B |\
    BPL +                                                                       ; $03D09D | | Calculate and store the true slot number for the target.
    AND #%01111111.b                                                            ; $03D09F | |
    CLC                                                                         ; $03D0A1 | |
    ADC #5.b                                                                    ; $03D0A2 | |
+   STA <r_battle_command_target_true_slot                                      ; $03D0A4 |/
    JSR _calculate_offsets                                                      ; $03D0A6 |\
    LDA r_character_battle_current_target.magic_defense_evade.w                 ; $03D0A9 | | Set the new accuracy to the target's evade value.
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03D0AC |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D0AF |\
    AND #STATUS_1_DARKNESS.b                                                    ; $03D0B2 | | If the target has the darkness status, divide the evade accuracy
    BEQ +                                                                       ; $03D0B4 | | by two.
    LSR r_battle_calculate_hits_arg_accuracy.w                                  ; $03D0B6 |/
+   LDA <r_battle_command_actor_slot                                            ; $03D0B9 |\
    AND #%01111111.b                                                            ; $03D0BB | | If the actor is in slot zero (the middle for the party or the
    BNE +                                                                       ; $03D0BD | | lowest monster slot), multiply the target's evade accuracy by 5/4.
    LDA r_battle_calculate_hits_arg_accuracy.w                                  ; $03D0BF | |
    STA <r_math_multiply_8bit_arg_1                                             ; $03D0C2 | | BUG: This was probably meant to check the target's slot number, to
    LDA #5.b                                                                    ; $03D0C4 | |      match the 5/4 bonus given in other places. This is just odd.
    STA <r_math_multiply_8bit_arg_2                                             ; $03D0C6 | |
    JSR _math_multiply_8bit                                                     ; $03D0C8 | | BUG: If this calculation overflows, the high byte will be
    LSR <r_math_multiply_8bit_result_hi                                         ; $03D0CB | |      discarded.
    ROR <r_math_multiply_8bit_result_lo                                         ; $03D0CD | |
    LSR <r_math_multiply_8bit_result_hi                                         ; $03D0CF | |
    ROR <r_math_multiply_8bit_result_lo                                         ; $03D0D1 | |
    LDA <r_math_multiply_8bit_result_lo                                         ; $03D0D3 | |
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03D0D5 |/
+   LDA r_character_battle_current_target.magic_defense_multiplier.w            ; $03D0D8 |\ Set the number of evade attempts to the target's magic defense
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03D0DB |/ multiplier.
    BEQ +                                                                       ; $03D0DE |\
    LDA r_current_spell_properties.data.effect.w                                ; $03D0E0 | | If the number of evade attempts is non-zero and the spell has the
    AND #SPELL_EFFECT_HIT_MISS.b                                                ; $03D0E3 | | hit/miss bit set, change the number of evade attempts to 1.
    BEQ +                                                                       ; $03D0E5 | |
    LDA #1.b                                                                    ; $03D0E7 | |
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03D0E9 |/
+   LDA r_character_battle_current_target.status_1.w                            ; $03D0EC |\
    AND #STATUS_1_TOAD.b                                                        ; $03D0EF | | If the target has the toad status or is charging, set the number
    BNE +                                                                       ; $03D0F1 | | of evade attempts to zero.
    LDA r_character_battle_current_target.status_3.w                            ; $03D0F3 | |
    AND #STATUS_3_CHARGING.b                                                    ; $03D0F6 | |
    BEQ ++                                                                      ; $03D0F8 | |
+   STZ r_battle_calculate_hits_arg_attempts.w                                  ; $03D0FA |/
++  LDA <r_battle_command_target_slot                                           ; $03D0FD |\
    BPL +                                                                       ; $03D0FF | | If the target is a monster and has a magic defense base of 255,
    LDA r_character_battle_current_target.magic_defense_base.w                  ; $03D101 | | explicitly set their evade accuracy and attempts to 99.
    CMP #255.b                                                                  ; $03D104 | |
    BNE +                                                                       ; $03D106 | |
    LDA #99.b                                                                   ; $03D108 | |
    STA r_battle_calculate_hits_arg_attempts.w                                  ; $03D10A | |
    STA r_battle_calculate_hits_arg_accuracy.w                                  ; $03D10D |/
+   JSR _battle_calculate_hits                                                  ; $03D110 | Calculate the number of successful evades.
    LDA <r_battle_command_actor_slot                                            ; $03D113 |\
    AND #%10000000.b                                                            ; $03D115 | | If this is a party member casting against another party member,
    BNE +                                                                       ; $03D117 | | load the number of hits into the accumulator and branch ahead.
    LDA <r_battle_command_target_slot                                           ; $03D119 | |
    AND #%10000000.b                                                            ; $03D11B | |
    BNE +                                                                       ; $03D11D | |
    SEC                                                                         ; $03D11F | |
    LDA r_battle_command_magic_hits.w                                           ; $03D120 | |
    BRA ++                                                                      ; $03D123 |/
+   LDA r_character_battle_current_target.monster_level_boss.w                  ; $03D125 |\
    BPL +                                                                       ; $03D128 | | If the target is a boss and the spell is flagged as boss immune,
    LDA r_current_spell_properties.data.boss_accuracy.w                         ; $03D12A | | branch ahead without setting the number of hits.
    BMI @zero_hits                                                              ; $03D12D |/
+   SEC                                                                         ; $03D12F |\
    LDA r_battle_command_magic_hits.w                                           ; $03D130 | | Otherwise, for monsters, load the number of hits minus the evades.
    SBC r_battle_calculate_hits_result.w                                        ; $03D133 |/
++  STA r_battle_damage_hits.w                                                  ; $03D136 | Set the number of hits.
    BEQ @zero_hits                                                              ; $03D139 |\ If the number of hits was greater than zero, jump to that code.
    BCS @successful_hit                                                         ; $03D13B |/
@zero_hits:
    LDA r_battle_current_spell_item.w                                           ; $03D13D |\ If this spell was the result of an item, there's no saving it.
    BNE @unsuccessful_hit                                                       ; $03D140 |/ Branch to the unsuccessful code.
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D142 |\
    CMP #SPELL_MONSTER_EXPLODE.b                                                ; $03D145 | | If the current spell is the monster Explode spell, in the range
    BEQ +                                                                       ; $03D147 | | $5F to $93 (numerous monster spells), or greater than $A9 (script
    CMP #SPELL_FIRST_MONSTER.b                                                  ; $03D149 | | spells that aren't really attacks), set the number of hits to one
    BCC @unsuccessful_hit                                                       ; $03D14B | | and branch to the succesful code.
    CMP #SPELL_FIRST_MONSTER_EVADE.b                                            ; $03D14D | |
    BCC +                                                                       ; $03D14F | |
    CMP #SPELL_FIRST_SCRIPT.b                                                   ; $03D151 | |
    BCC @unsuccessful_hit                                                       ; $03D153 | |
+   LDA #1.b                                                                    ; $03D155 | |
    STA r_battle_damage_hits.w                                                  ; $03D157 | |
    BRA @successful_hit                                                         ; $03D15A |/
@unsuccessful_hit:
    JSR _battle_unset_target                                                    ; $03D15C |\ If unsuccessful, unset this target and jump to the damage setting
    JMP @set_damage                                                             ; $03D15F |/ code.
@successful_hit:
    LDA <r_battle_command_target_slot                                           ; $03D162 |\
    BPL +                                                                       ; $03D164 | | If a monster is being targeted by something other than itself and
    CMP <r_battle_command_actor_slot                                            ; $03D166 | | if monsters are invincible, cancel the successful hit unless the
    BEQ +                                                                       ; $03D168 | | spell being used is specifically the Crystal.
    LDA r_monsters_invincible.w                                                 ; $03D16A | |
    BEQ +                                                                       ; $03D16D | |
    LDA r_battle_current_spell_item.w                                           ; $03D16F | |
    BEQ @unsuccessful_hit                                                       ; $03D172 | |
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D174 | |
    CMP #ITEM_CRYSTAL.b                                                         ; $03D177 | |
    BNE @unsuccessful_hit                                                       ; $03D179 |/
+   LDA r_battle_double_spell_power.w                                           ; $03D17B |\
    BEQ ++                                                                      ; $03D17E | | If double spell power is enabled (if this is a summon) and it's
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D180 | | not one of the Asura spells and the target is not a monster,
    CMP #SPELL_CALL_ASURA_CURE_WEAK.b                                           ; $03D183 | | branch to the zero hits code.
    BCC +                                                                       ; $03D185 | |
    CMP #SPELL_CALL_BAHAMUT.b                                                   ; $03D187 | |
    BCC ++                                                                      ; $03D189 | |
+   LDA <r_battle_command_target_slot                                           ; $03D18B | |
    BPL @zero_hits                                                              ; $03D18D |/
++  LDA r_current_spell_properties.data.effect.w                                ; $03D18F |\
    AND #%01111111.b                                                            ; $03D192 | | If the spell effect is either $7E or $7F, unset the targets and
    CMP #SPELL_EFFECT_NOTHING_SILENT.b                                          ; $03D194 | | jump to the next iteration of the loop. If the effect is $7F,
    BEQ +                                                                       ; $03D196 | | an alert is additionally set to display "Nothing happened."
    CMP #SPELL_EFFECT_NOTHING_HAPPENED.b                                        ; $03D198 | |
    BNE ++                                                                      ; $03D19A | |
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03D19C | |
    LDA #BATTLE_ALERT_NOTHING_HAPPENED.b                                        ; $03D19F | |
    STA r_battle_alert_queue.w                                                  ; $03D1A1 | |
+   STZ r_battle_command_actual_targets.w                                       ; $03D1A4 | |
    JMP @next                                                                   ; $03D1A7 |/
++  PHA                                                                         ; $03D1AA | Push the spell effect to the stack temporarily.
    LDA <r_battle_command_target_slot                                           ; $03D1AB |\
    CMP <r_battle_command_actor_slot                                            ; $03D1AD | | If the actor and target are the same, copy the actor's current
    BNE +                                                                       ; $03D1AF | | MP to the target stat record as well, to keep them in sync.
    LDA r_character_battle_current_actor.mp_lo.w                                ; $03D1B1 | |
    STA r_character_battle_current_target.mp_lo.w                               ; $03D1B4 | |
    LDA r_character_battle_current_actor.mp_hi.w                                ; $03D1B7 | |
    STA r_character_battle_current_target.mp_hi.w                               ; $03D1BA |/
+   PLA                                                                         ; $03D1BD |\ Restore the spell effect to the accumulator and dispatch to the
    JSR _battle_spell_effect_dispatch                                           ; $03D1BE |/ effect handler.
@set_damage:
    LDA r_battle_skip_character_battle_actor.w                                  ; $03D1C1 |\ Skip the actor damage if the flag is set.
    BNE @target_damage                                                          ; $03D1C4 |/
    LDA <r_battle_command_actor_slot                                            ; $03D1C6 |\
    JSR _battle_get_damage_offset                                               ; $03D1C8 | | If the slot doesn't already have any damage, branch ahead to code
    LDA r_battle_slot_damage.w + 0,X                                            ; $03D1CB | | that simply sets the damage.
    ORA r_battle_slot_damage.w + 1,X                                            ; $03D1CE | |
    BEQ ++                                                                      ; $03D1D1 |/
    LDA <r_battle_damage_actor_damage_hi                                        ; $03D1D3 |\
    AND #>BATTLE_DAMAGE_VALUE                                                   ; $03D1D5 | | Unset any flags in the new damage value.
    STA <r_battle_damage_actor_damage_hi                                        ; $03D1D7 |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D1D9 |\
    PHA                                                                         ; $03D1DC | | Preserve any existing restore bit in the actor's damage value.
    AND #>BATTLE_DAMAGE_RESTORE                                                 ; $03D1DD | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03D1DF |/
    PLA                                                                         ; $03D1E1 |\
    AND #>BATTLE_DAMAGE_VALUE                                                   ; $03D1E2 | | Unset any extra bits in the actor's damage value.
    STA r_battle_slot_damage.w + 1,X                                            ; $03D1E4 |/
    CLC                                                                         ; $03D1E7 |\
    LDA r_battle_slot_damage.w + 0,X                                            ; $03D1E8 | | Add the new damage to the existing damage value.
    ADC <r_battle_damage_actor_damage_lo                                        ; $03D1EB | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03D1ED | |
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D1F0 | |
    ADC <r_battle_damage_actor_damage_hi                                        ; $03D1F3 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03D1F5 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D1F8 |\
    LDA r_battle_slot_damage.w,X                                                ; $03D1FA | | If the value exceeds 9999, set it explicitly to 9999.
    CMP #9999.w                                                                 ; $03D1FD | |
    BCC +                                                                       ; $03D200 | |
    LDA #9999.w                                                                 ; $03D202 | |
    STA r_battle_slot_damage.w,X                                                ; $03D205 | |
+   TDC                                                                         ; $03D208 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D209 |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D20B |\
    ORA <r_battle_generic_tmp_1_lo                                              ; $03D20E | | Reset any pre-existing restore bit and branch to the target
    STA r_battle_slot_damage.w + 1,X                                            ; $03D210 | | damage section.
    BRA @target_damage                                                          ; $03D213 |/
++  LDA <r_battle_damage_actor_damage_lo                                        ; $03D215 |\
    STA r_battle_slot_damage.w + 0,X                                            ; $03D217 | | If there was no pre-existing damage, simply copy the new damage
    LDA <r_battle_damage_actor_damage_hi                                        ; $03D21A | | bytes into the damage value for this slot.
    STA r_battle_slot_damage.w + 1,X                                            ; $03D21C |/
@target_damage:
    LDA <r_battle_command_target_slot                                           ; $03D21F |\
    JSR _battle_get_damage_offset                                               ; $03D221 | | If the target slot doesn't already have pending damage, branch
    LDA r_battle_slot_damage.w + 0,X                                            ; $03D224 | | forward to code to handle that.
    ORA r_battle_slot_damage.w + 1,X                                            ; $03D227 | |
    BEQ ++                                                                      ; $03D22A |/
    LDA <r_battle_calculate_damage_result_hi                                    ; $03D22C |\
    AND #>BATTLE_DAMAGE_VALUE                                                   ; $03D22E | | Unset any flag bits in the new damage value.
    STA <r_battle_calculate_damage_result_hi                                    ; $03D230 |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D232 |\
    PHA                                                                         ; $03D235 | | Preserve any existing restore bit in the slot's damage value.
    AND #>BATTLE_DAMAGE_RESTORE                                                 ; $03D236 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03D238 | |
    PLA                                                                         ; $03D23A |/
    AND #>BATTLE_DAMAGE_VALUE                                                   ; $03D23B |\ Unset any flag bits in the slot's damage value.
    STA r_battle_slot_damage.w + 1,X                                            ; $03D23D |/
    CLC                                                                         ; $03D240 |\
    LDA r_battle_slot_damage.w + 0,X                                            ; $03D241 | | Add the new damage value to the existing damage value.
    ADC <r_battle_calculate_damage_result_lo                                    ; $03D244 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03D246 | |
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D249 | |
    ADC <r_battle_calculate_damage_result_hi                                    ; $03D24C | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03D24E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D251 |\
    LDA r_battle_slot_damage.w,X                                                ; $03D253 | | If the result is greater than 9999, set the damage explicitly to
    CMP #9999.w                                                                 ; $03D256 | | 9999.
    BCC +                                                                       ; $03D259 | |
    LDA #9999.w                                                                 ; $03D25B | |
    STA r_battle_slot_damage.w,X                                                ; $03D25E | |
+   TDC                                                                         ; $03D261 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D262 |/
    LDA r_battle_slot_damage.w + 1,X                                            ; $03D264 |\
    ORA <r_battle_generic_tmp_1_lo                                              ; $03D267 | | Set any preserved restore bit and branch ahead.
    STA r_battle_slot_damage.w + 1,X                                            ; $03D269 | |
    BRA +                                                                       ; $03D26C |/
++  LDA <r_battle_calculate_damage_result_lo                                    ; $03D26E |\
    STA r_battle_slot_damage.w + 0,X                                            ; $03D270 | | If there was no already existing damage, simply copy the new value
    LDA <r_battle_calculate_damage_result_hi                                    ; $03D273 | | into the damage value.
    STA r_battle_slot_damage.w + 1,X                                            ; $03D275 |/
+   LDA <r_battle_command_target_slot                                           ; $03D278 |\
    CMP <r_battle_command_actor_slot                                            ; $03D27A | | If the actor slot is the same as the target slot, ensure that the
    BNE +                                                                       ; $03D27C | | actor slot is skipped in the finalize function.
    INC r_battle_skip_character_battle_actor.w                                  ; $03D27E |/
+   JSR _battle_command_finalize_actor_target_stats                             ; $03D281 | Finalize the stats records of the actor and target.
@next:
    DEC r_battle_command_magic_target_count.w                                   ; $03D284 | Decrement the target count.
    LDA r_battle_command_magic_target_count.w                                   ; $03D287 |\
    BEQ +                                                                       ; $03D28A | | Loop until the count reaches zero.
    JMP @loop_start                                                             ; $03D28C |/
+   LDA <r_battle_command_actor_slot                                            ; $03D28F |\
    BPL +                                                                       ; $03D291 | | If the actor is a monster and the next command in the script is
    LDX r_battle_script_tmp_index.w                                             ; $03D293 | | not a display dialog command, skip processing pending damage.
    LDA r_battle_script_audiovisual.w,X                                         ; $03D296 | |
    CMP #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03D299 | |
    BNE @done                                                                   ; $03D29B |/
+   JSR _battle_apply_pending_damage                                            ; $03D29D | Otherwise, apply the pending damage.
@done:
    LDA r_battle_command_actual_targets.w                                       ; $03D2A0 |\ Set the action details target to the actual targets.
    STA r_battle_current_action_details.target.w                                ; $03D2A3 |/
    RTS                                                                         ; $03D2A6

; _battle_spell_effect_dispatch ($03:D2A7)
;
; Given a spell effect number in the accumulator, calls the handler for that
; spell effect.
_battle_spell_effect_dispatch:
    ASL A                                                                       ; $03D2A7 |\
    TAX                                                                         ; $03D2A8 | | Set the pointer by looking up the spell effect passed in the
    LDA battle_spell_effect_jump_data.l + 0,X                                   ; $03D2A9 | | accumulator.
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03D2AD | |
    LDA battle_spell_effect_jump_data.l + 1,X                                   ; $03D2AF | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03D2B3 | |
    LDA #:battle_spell_effect_jump_data.b                                       ; $03D2B5 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03D2B7 |/
    JML [r_generic_tmp_ptr.w]                                                   ; $03D2B9 | Jump to the loaded function.

; _battle_remove_unavailable_spell_targets_if_not_life ($03:D2BC)
;
; Given a single byte targeting value in the accumulator and a byte in $354E
; with the high bit set if a monster target or unset if a party target, adjusts
; the value to remove targets that are unavilable (if swoon, stone, jumping or
; hiding). Targets are not removed if there is only one target, and they are not
; removed if the current actor's subcommand indicates one of the spells that
; can restore a target.
_battle_remove_unavailable_spell_targets_if_not_life:
    STA <r_battle_generic_tmp_1_lo                                              ; $03D2BC | Store the initial target to a temporary variable.
    JSR _count_set_bits                                                         ; $03D2BE |\
    DEX                                                                         ; $03D2C1 | | Skip this function if exactly one target is set.
    BEQ @done                                                                   ; $03D2C2 |/
    LDA r_battle_action_can_hit_swoon.w                                         ; $03D2C4 |\ Skip this function if the action can hit swooned targets.
    BNE @done                                                                   ; $03D2C7 |/
    LDA r_battle_current_spell_item.w                                           ; $03D2C9 |\ Skip the following checks if the current spell is an item.
    BNE +                                                                       ; $03D2CC |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D2CE |\
    CMP #SPELL_LIFE1.b                                                          ; $03D2D1 | | Skip this function if the actor's subcommand is any of several
    BEQ @done                                                                   ; $03D2D3 | | spells that are designed to bring targets back to life.
    CMP #SPELL_LIFE2.b                                                          ; $03D2D5 | |
    BEQ @done                                                                   ; $03D2D7 | |
    CMP #SPELL_MONSTER_RECOVER.b                                                ; $03D2D9 | |
    BEQ @done                                                                   ; $03D2DB | |
    CMP #SPELL_MONSTER_REMEDY.b                                                 ; $03D2DD | |
    BEQ @done                                                                   ; $03D2DF | |
    CMP #SPELL_MONSTER_VANISH.b                                                 ; $03D2E1 | |
    BEQ @done                                                                   ; $03D2E3 | |
    CMP #SPELL_CALL_ASURA_LIFE1.b                                               ; $03D2E5 | |
    BEQ @done                                                                   ; $03D2E7 |/
+   LDX #5.w                                                                    ; $03D2E9 |\ Initially set the slot maximum to 5.
    STX <r_battle_generic_tmp_2                                                 ; $03D2EC |/
    TDC                                                                         ; $03D2EE |\
    TAX                                                                         ; $03D2EF | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03D2F0 |/
    LDA r_battle_command_current_target_type.w                                  ; $03D2F1 |\
    BPL @start                                                                  ; $03D2F4 | | If the target slot is a monster slot, initialize the X register
    LDX #5.w                                                                    ; $03D2F6 | | to five and set the maximum to 13.
    LDA #(5 + 8).b                                                              ; $03D2F9 | |
    STA <r_battle_generic_tmp_2_lo                                              ; $03D2FB |/
@start:
    LDA r_battle_slot_empty.w,X                                                 ; $03D2FD |\ Skip this slot if the slot is empty.
    BNE ++                                                                      ; $03D300 |/
    PHX                                                                         ; $03D302 |\
    TXA                                                                         ; $03D303 | | Set the Y register to the offset to this slot's stat record.
    STA <r_math_multiply_8bit_arg_1                                             ; $03D304 | |
    LDA #_sizeof_character_battle                                               ; $03D306 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03D308 | |
    JSR _math_multiply_8bit                                                     ; $03D30A | |
    PLX                                                                         ; $03D30D | |
    LDY <r_math_multiply_8bit_result                                            ; $03D30E |/
    LDA r_character_battle.1.status_1.w,Y                                       ; $03D310 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03D313 | | Skip this slot unless any of the following statuses is set: swoon,
    BNE +                                                                       ; $03D315 | | stone, jumping or hiding.
    LDA r_character_battle.1.status_3.w,Y                                       ; $03D317 | |
    AND #STATUS_3_JUMPING.b                                                     ; $03D31A | |
    BNE +                                                                       ; $03D31C | |
    LDA r_character_battle.1.status_4.w,Y                                       ; $03D31E | |
    BPL ++                                                                      ; $03D321 |/
+   PHX                                                                         ; $03D323 |\
    CPX #5.w                                                                    ; $03D324 | | Subtract five from the slot number if it's a monster slot to get
    BCC +                                                                       ; $03D327 | | the proper bit number of this target. If it's a character slot, no
    TXA                                                                         ; $03D329 | | need to subtract.
    SEC                                                                         ; $03D32A | |
    SBC #5.b                                                                    ; $03D32B | |
    TAX                                                                         ; $03D32D |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03D32E |\
    JSR _unset_bit_x                                                            ; $03D330 | | Remove this slot from the targeting value.
    STA <r_battle_generic_tmp_1_lo                                              ; $03D333 | |
    PLX                                                                         ; $03D335 |/
++  INX                                                                         ; $03D336 |\
    CPX <r_battle_generic_tmp_2                                                 ; $03D337 | | Loop until all of the relevant slots have been checked.
    BNE @start                                                                  ; $03D339 |/
@done:
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D33B | Load the new target value into the accumulator.
    RTS                                                                         ; $03D33D

; _battle_check_spell_display_name ($03:D33E)
;
; Given a spell ID in the accumulator, returns the spell ID if the spell's name
; should be displayed. Otherwise, returns a zero.
_battle_check_spell_display_name:
    PHA                                                                         ; $03D33E | Preserve the spell value.
    STZ <r_battle_generic_tmp_1_lo                                              ; $03D33F |\
    LSR A                                                                       ; $03D341 | | Set the X register to the upper five bits of the spell ID to
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D342 | | determine which byte to load.
    LSR A                                                                       ; $03D344 | |
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D345 | |
    LSR A                                                                       ; $03D347 | |
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D348 | |
    TAX                                                                         ; $03D34A |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D34B |\
    JSR _math_divide_by_32                                                      ; $03D34D | | Set the Y register to the lower three bits of the spell ID to
    STA <r_battle_generic_tmp_1_lo                                              ; $03D350 | | index the bits of the byte being loaded.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D352 | |
    TAY                                                                         ; $03D354 |/
    LDA bank13.battle_spell_disable_name_display_data.l,X                       ; $03D355 | Load the associated byte.
-   ASL A                                                                       ; $03D359 |\
    DEY                                                                         ; $03D35A | | Shift bits out of the byte until reaching the designated number.
    BPL -                                                                       ; $03D35B |/
    BCC +                                                                       ; $03D35D |\
    PLA                                                                         ; $03D35F | | If the bit was set, pull from the stack and then load zero to the
    TDC                                                                         ; $03D360 | | accumulator.
    RTS                                                                         ; $03D361 |/
+   PLA                                                                         ; $03D362 | Otherwise, simply load the spell value back.
    RTS                                                                         ; $03D363

; _battle_check_spell_suppress_flash ($03:D364)
;
; Given a spell ID in the accumulator, returns zero if the monster should flash
; as normal, and a non-zero value if the flash should be suppressed.
_battle_check_spell_suppress_flash:
    STZ <r_battle_generic_tmp_1_lo                                              ; $03D364 |\
    LSR A                                                                       ; $03D366 | | Set the X register to the upper five bits of the command ID to
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D367 | | determine which byte to load.
    LSR A                                                                       ; $03D369 | |
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D36A | |
    LSR A                                                                       ; $03D36C | |
    ROR <r_battle_generic_tmp_1_lo                                              ; $03D36D | |
    TAX                                                                         ; $03D36F |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D370 |\
    JSR _math_divide_by_32                                                      ; $03D372 | | Set the Y register to the lower three bits of the command ID to
    STA <r_battle_generic_tmp_1_lo                                              ; $03D375 | | index the bits of the byte being loaded.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D377 | |
    TAY                                                                         ; $03D379 |/
    LDA bank13.battle_spell_disable_monster_flash_data.l,X                      ; $03D37A | Load the associated byte.
-   ASL A                                                                       ; $03D37E |\
    DEY                                                                         ; $03D37F | | Shift bits out the byte until reaching the designated number.
    BPL -                                                                       ; $03D380 |/
    BCC +                                                                       ; $03D382 |\
    ROR A                                                                       ; $03D384 | | If the bit was set, rotate it right so the high bit is set.
    RTS                                                                         ; $03D385 |/
+   TDC                                                                         ; $03D386 | Otherwise, return zero.
    RTS                                                                         ; $03D387

; _battle_spell_effect_standard_attack ($03:D388)
;
; Handler for the standard attack spell effect, which applies damage based on
; element immunities, resistances, weaknesses, etc, and uses the standard
; damage calculation algorithm from _battle_calculate_damage.
;
; There is also an alternate entry point which goes straight to calculating
; damage based on the standard routine.
_battle_spell_effect_standard_attack:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03D388 | Set the element multiplier based on target's immunity or resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03D38B |\
    BPL +                                                                       ; $03D38E | | If the high bit was set, then the target will abosrb this spell's
    AND #ELEMENT_MULTIPLIER_ABSORB.b ~ $FF                                      ; $03D390 | | element, so unset the high bit on the multiplier and jump to a
    STA r_battle_damage_element_multiplier.w                                    ; $03D392 | | separate routine to handle the absorb.
    JMP _battle_spell_damage_standard_restore                                   ; $03D395 |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03D398 | Set the element multiplier based on weakness or strong weakness.
    LDA r_character_battle_current_target.status_2.w                            ; $03D39B |\
    AND #STATUS_2_FLOAT.b                                                       ; $03D39E | | If the target is floating and the spell is Quake, Titan or the
    BEQ ++                                                                      ; $03D3A0 | | monster Quake spell, return without calculating any damage, as the
    LDA r_battle_current_spell_item.w                                           ; $03D3A2 | | target is immune.
    BNE +                                                                       ; $03D3A5 | |
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D3A7 | |
    CMP #SPELL_QUAKE.b                                                          ; $03D3AA | |
    BEQ +++                                                                     ; $03D3AC | |
    CMP #SPELL_CALL_TITAN.b                                                     ; $03D3AE | |
    BEQ +++                                                                     ; $03D3B0 | |
    CMP #SPELL_MONSTER_QUAKE.b                                                  ; $03D3B2 | |
    BNE ++                                                                      ; $03D3B4 | |
    RTS                                                                         ; $03D3B6 |/
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03D3B7 |\
    CMP #ITEM_GAIADRUM.b                                                        ; $03D3BA | | Same if the target is floating and the spell is the GaiaDrum item.
    BEQ +++                                                                     ; $03D3BC |/
_battle_spell_effect_calculate_damage:
++  JSR _battle_calculate_damage                                                ; $03D3BE | Otherwise, calculate damage using the standard routine.
+++ RTS                                                                         ; $03D3C1

; _battle_spell_effect_attack_plus_sap ($03:D3C2)
;
; Handler for a standard attack spell effect which also adds the sap status to
; the target (unless the spell was White or the Crystal item and the target was
; not undead). Sets sap by falling through to the next function.
_battle_spell_effect_attack_plus_sap:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03D3C2 | Set the multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03D3C5 |\
    BPL +                                                                       ; $03D3C8 | | If the target absorbs any of the spell's elements, switch to
    AND #ELEMENT_MULTIPLIER_ABSORB.b ~ $FF                                      ; $03D3CA | | using an effect that restores the target unless it's undead.
    STA r_battle_damage_element_multiplier.w                                    ; $03D3CC | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03D3CF |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03D3D2 | Set the multiplier based on weakness if not already set.
    JSR _battle_calculate_damage                                                ; $03D3D5 | Calculate the damage.
    LDA r_battle_current_spell_item.w                                           ; $03D3D8 |\
    BNE +                                                                       ; $03D3DB | | Skip to the end of the function if the actor is using the White
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D3DD | | spell or the Crystal item against a non-undead target. All other
    CMP #SPELL_WHITE.b                                                          ; $03D3E0 | | combinations pass through to the following sap code.
    BNE _battle_spell_effect_helper_set_sap                                     ; $03D3E2 | |
    BEQ ++                                                                      ; $03D3E4 | |
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03D3E6 | |
    CMP #ITEM_CRYSTAL.b                                                         ; $03D3E9 | |
    BNE _battle_spell_effect_helper_set_sap                                     ; $03D3EB | |
++  LDA r_character_battle_current_target.monster_race.w                        ; $03D3ED | |
    AND #MONSTER_RACE_UNDEAD.b                                                  ; $03D3F0 | |
    BEQ _battle_spell_effect_helper_set_sap_done                                ; $03D3F2 |/

; _battle_spell_effect_helper_set_sap ($03:D3F4)
;
; Sets sap on the current target.
_battle_spell_effect_helper_set_sap:
    LDA r_character_battle_current_target.status_4.w                            ; $03D3F4 |\
    ORA #STATUS_4_SAP.b                                                         ; $03D3F7 | | Set the sap status on the target.
    STA r_character_battle_current_target.status_4.w                            ; $03D3F9 |/
    LDA #TIMER_MODE_SAP.b                                                       ; $03D3FC |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03D3FE | | Calculate the timer value using the sap timer calculation mode.
    LDA <r_battle_command_target_true_slot                                      ; $03D400 | |
    JSR _calculate_timer_value                                                  ; $03D402 |/
    LDA #TIMER_OFFSET_SAP.b                                                     ; $03D405 |\ Set the sap timer value.
    JSR _set_timer_value                                                        ; $03D407 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03D40A |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03D40C |/
    LDA <r_battle_command_target_true_slot                                      ; $03D40F |\
    ASL A                                                                       ; $03D411 | | Flag the sap timer for the target as being enabled.
    TAX                                                                         ; $03D412 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D413 | |
    ORA #(TIMER_ENABLED_SAP >> 8).b                                             ; $03D416 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D418 |/
_battle_spell_effect_helper_set_sap_done:
    RTS                                                                         ; $03D41B

; _battle_spell_effect_restore_if_not_undead ($03:D41C)
;
; Spell effect handler that will restore damage unless the target is undead. In
; that case, it will actually damage the target.
_battle_spell_effect_restore_if_not_undead:
    LDA r_character_battle_current_target.monster_race.w                        ; $03D41C |\
    AND #MONSTER_RACE_UNDEAD.b                                                  ; $03D41F | | If the monster is not undead, call the restoration damage routine.
    BEQ _battle_spell_damage_standard_restore                                   ; $03D421 |/
    JMP _battle_spell_effect_calculate_damage                                   ; $03D423 | Otherwise, call the standard damage calculation routine.

; _battle_spell_damage_standard_restore ($03:D426)
;
; Calculates the damage for spells that restore HP. Also used when a target
; absorbs a particular element.
_battle_spell_damage_standard_restore:
    LDA r_battle_current_spell_item.w                                           ; $03D426 |\
    BNE +                                                                       ; $03D429 | | If the current spell is specifically Cure4 and is being cast on a
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D42B | | single target, set the damage specifically to the amount needed to
    CMP #SPELL_CURE4.b                                                          ; $03D42E | | restore the target to full health.
    BNE +                                                                       ; $03D430 | |
    LDA r_battle_calculate_damage_arg_split.w                                   ; $03D432 | | BUG: If this amount is greater than 16383, the value is actually
    CMP #1.b                                                                    ; $03D435 | |      too large for the damage routines to deal with (as the upper
    BNE +                                                                       ; $03D437 | |      two bits are used as flags), leading to glitchy behavior. As
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D439 | |      the player is unlikely to use Cure4 on a monster, this
    SEC                                                                         ; $03D43B | |      largely is only relevant during the Asura fight.
    LDA r_character_battle_current_target.hp_max.w                              ; $03D43C | |
    SBC r_character_battle_current_target.hp.w                                  ; $03D43F | |
    STA <r_battle_calculate_damage_result                                       ; $03D442 | |
    TDC                                                                         ; $03D444 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D445 | |
    BRA ++                                                                      ; $03D447 |/
+   JSR _battle_calculate_damage                                                ; $03D449 | Otherwise, calculate the damage directly with the standard routine.
++  LDA <r_battle_calculate_damage_result_hi                                    ; $03D44C |\
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03D44E | | Set the uppermost bit to treat the value as healing.
    STA <r_battle_calculate_damage_result_hi                                    ; $03D450 |/
    RTS                                                                         ; $03D452

; _battle_spell_effect_weak ($03:D453)
;
; Handles the spell effect that reduces the target's HP to a random value
; between 1 and 9, inclusive. It will never increase the target's HP. If the
; random value is not less than their current HP, it will execute a TODO
; function instead.
_battle_spell_effect_weak:
    LDX #1.w                                                                    ; $03D453 |\
    LDA #9.b                                                                    ; $03D456 | | Get a random number from 1 to 9 and transfer it to a variable.
    JSR _get_battle_rng                                                         ; $03D458 | |
    TAX                                                                         ; $03D45B | |
    STX <r_battle_generic_tmp_1                                                 ; $03D45C |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D45E |\
    LDA r_character_battle_current_target.hp.w                                  ; $03D460 | | If the randomly generated value is less than the target's current
    CMP <r_battle_generic_tmp_1                                                 ; $03D463 | | HP, set their HP to the new value and return.
    BCC +                                                                       ; $03D465 | |
    LDA <r_battle_generic_tmp_1                                                 ; $03D467 | |
    STA r_character_battle_current_target.hp.w                                  ; $03D469 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D46C | |
    RTS                                                                         ; $03D46E |/
+   TDC                                                                         ; $03D46F |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D470 | | Otherwise, unset this target in the actual targets.
    JSR _battle_unset_target                                                    ; $03D472 |/
    RTS                                                                         ; $03D475

; _battle_spell_effect_drain ($03:D476)
;
; Handles the spell effect for the Drain spell. Calculates the standard damage
; value and restores it to the actor, unless the target is undead, in which case
; it restores the target (but damages the actor).
_battle_spell_effect_drain:
    LDA <r_battle_command_actor_slot                                            ; $03D476 |\
    CMP <r_battle_command_target_slot                                           ; $03D478 | | If the actor and target are the same, skip this function.
    BEQ ++                                                                      ; $03D47A |/
    JSR _battle_calculate_damage                                                ; $03D47C | Calculate the damage.
    LDX <r_battle_calculate_damage_result                                       ; $03D47F |\ Copy the damage value to the location for the actor's damage.
    STX <r_battle_damage_actor_damage                                           ; $03D481 |/
    LDA r_character_battle_current_target.monster_race.w                        ; $03D483 |\
    AND #MONSTER_RACE_UNDEAD.b                                                  ; $03D486 | | If the target is undead, set the flags to restore the target.
    BEQ +                                                                       ; $03D488 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03D48A | |
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03D48C | |
    STA <r_battle_calculate_damage_result_hi                                    ; $03D48E | |
    RTS                                                                         ; $03D490 |/
+   LDA <r_battle_damage_actor_damage_hi                                        ; $03D491 |\
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03D493 | | Otherwise, set the flags to restore the actor.
    STA <r_battle_damage_actor_damage_hi                                        ; $03D495 |/
++  RTS                                                                         ; $03D497

; _battle_spell_effect_psych ($03:D498)
;
; Handles the spell effect for the Psych spell. Calculates the standard damage
; value and restores it to the actor, unless the target is undead, in which case
; it restores the target (but damages the actor). Handles updating the MP values
; directly.
_battle_spell_effect_psych:
    LDA <r_battle_command_actor_slot                                            ; $03D498 |\
    CMP <r_battle_command_target_slot                                           ; $03D49A | | Skip this function if the actor and target are the same.
    BNE +                                                                       ; $03D49C | |
    RTS                                                                         ; $03D49E |/
+   JSR _battle_calculate_damage                                                ; $03D49F | Calculate the damage value using the standard routine.
    LDX <r_battle_calculate_damage_result                                       ; $03D4A2 |\ Copy the damage value into the actor damage variable.
    STX <r_battle_damage_actor_damage                                           ; $03D4A4 |/
    LDA r_character_battle_current_target.monster_race.w                        ; $03D4A6 |\
    AND #MONSTER_RACE_UNDEAD.b                                                  ; $03D4A9 | | If the target is undead, branch to code to handle that condition.
    BEQ +                                                                       ; $03D4AB | |
    BRA @undead                                                                 ; $03D4AD |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03D4AF |\
    SEC                                                                         ; $03D4B1 | | Subtract the damage value from the target's MP.
    LDA r_character_battle_current_target.mp.w                                  ; $03D4B2 | |
    SBC <r_battle_calculate_damage_result                                       ; $03D4B5 |/
    BCS +                                                                       ; $03D4B7 |\
    LDA r_character_battle_current_target.mp.w                                  ; $03D4B9 | | If the new value is less than zero, set the damage value for both
    STA <r_battle_calculate_damage_result                                       ; $03D4BC | | slots to the target's current MP and then set the target's MP to
    STA <r_battle_damage_actor_damage                                           ; $03D4BE | | zero.
    STZ r_character_battle_current_target.mp.w                                  ; $03D4C0 | |
    BRA ++                                                                      ; $03D4C3 |/
+   STA r_character_battle_current_target.mp.w                                  ; $03D4C5 | Otherwise, store the new MP value.
++  CLC                                                                         ; $03D4C8 |\
    LDA r_character_battle_current_actor.mp.w                                   ; $03D4C9 | | Add the damage value to the actor's current MP.
    ADC <r_battle_calculate_damage_result                                       ; $03D4CC | |
    STA r_character_battle_current_actor.mp.w                                   ; $03D4CE |/
    LDA r_character_battle_current_actor.mp_max.w                               ; $03D4D1 |\
    CMP r_character_battle_current_actor.mp.w                                   ; $03D4D4 | | If the value exceeded the actor's maximum MP, set it back to their
    BCS +                                                                       ; $03D4D7 | | maximum.
    STA r_character_battle_current_actor.mp.w                                   ; $03D4D9 |/
+   TDC                                                                         ; $03D4DC |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D4DD | | TODO: Set flags in the target's damage value.
    LDA <r_battle_calculate_damage_result_hi                                    ; $03D4DF | |
    ORA #(BATTLE_DAMAGE_UNKNOWN >> 8).b                                         ; $03D4E1 | |
    STA <r_battle_calculate_damage_result_hi                                    ; $03D4E3 |/
    LDA <r_battle_damage_actor_damage_hi                                        ; $03D4E5 |\
    ORA #((BATTLE_DAMAGE_RESTORE | BATTLE_DAMAGE_UNKNOWN) >> 8).b               ; $03D4E7 | | TODO: Set flags in the actor's damage value. One is restore.
    STA <r_battle_damage_actor_damage_hi                                        ; $03D4E9 | |
    RTS                                                                         ; $03D4EB |/
@undead:
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D4EC |\
    SEC                                                                         ; $03D4EE | | Subtract the damage value from the actor's MP.
    LDA r_character_battle_current_actor.mp.w                                   ; $03D4EF | |
    SBC <r_battle_calculate_damage_result                                       ; $03D4F2 |/
    BCS +                                                                       ; $03D4F4 |\
    LDA r_character_battle_current_actor.mp.w                                   ; $03D4F6 | | If the result was negative, set the damage result to the actor's
    STA <r_battle_calculate_damage_result                                       ; $03D4F9 | | current MP and set the actor's current MP to zero.
    STA <r_battle_damage_actor_damage                                           ; $03D4FB | |
    STZ r_character_battle_current_actor.mp.w                                   ; $03D4FD | |
    BRA ++                                                                      ; $03D500 |/
+   STA r_character_battle_current_actor.mp.w                                   ; $03D502 | Otherwise, update the actor's current MP with the new value.
++  TDC                                                                         ; $03D505 |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D506 | | TODO: Set flags in the actor's damage value.
    LDA <r_battle_damage_actor_damage_hi                                        ; $03D508 | |
    ORA #(BATTLE_DAMAGE_UNKNOWN >> 8).b                                         ; $03D50A | |
    STA <r_battle_damage_actor_damage_hi                                        ; $03D50C |/
    LDA <r_battle_calculate_damage_result_hi                                    ; $03D50E |\
    ORA #((BATTLE_DAMAGE_RESTORE | BATTLE_DAMAGE_UNKNOWN) >> 8).b               ; $03D510 | | TODO: Set flags in the target's damage value.
    STA <r_battle_calculate_damage_result_hi                                    ; $03D512 |/
    RTS                                                                         ; $03D514

; _battle_spell_effect_set_status ($03:D515)
;
; Handles the spell effect which sets statuses. There is an additional entry
; point that skips the swoon check against undead, spirits and machines.
_battle_spell_effect_set_status:
    LDA r_current_spell_properties.element_status.status_1.w                    ; $03D515 |\
    BPL +                                                                       ; $03D518 | | If the spell tries to set the swoon status and the target is
    LDA r_character_battle_current_target.monster_race.w                        ; $03D51A | | undead, a spirit, or a machine, jump to the failure code.
    AND #(MONSTER_RACE_UNDEAD | MONSTER_RACE_SPIRIT | MONSTER_RACE_MACHINE).b   ; $03D51D | |
    BEQ +                                                                       ; $03D51F | |
    JMP __battle_spell_effect_set_status_failure                                ; $03D521 |/
_battle_spell_effect_set_status_swoon_undead:
+   LDA r_character_battle_current_target.status_1.w                            ; $03D524 |\
    STA <r_battle_generic_tmp_2_hi                                              ; $03D527 | | Save the target's first status byte to two variables.
    STA <r_battle_generic_tmp_1_lo                                              ; $03D529 |/
    LDA r_character_battle_current_target.status_2.w                            ; $03D52B |\
    STA <r_battle_generic_tmp_1_hi                                              ; $03D52E | | Save the target's second status byte to one variable, and again
    AND #STATUS_2_FLOAT.b ~ $FF                                                 ; $03D530 | | with the float bit excluded to another.
    STA <r_battle_generic_tmp_2_lo                                              ; $03D532 |/
    LDA r_current_spell_properties.element_status.status_1.w                    ; $03D534 |\
    STA <r_battle_generic_tmp_3_hi                                              ; $03D537 | | Transfer the spell's status bytes to variables in reverse order,
    LDA r_current_spell_properties.element_status.status_2.w                    ; $03D539 | | like was done with the target's status bytes.
    STA <r_battle_generic_tmp_3_lo                                              ; $03D53C |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D53E |\
    LDA <r_battle_generic_tmp_2                                                 ; $03D540 | | If the target already has a status set with a higher bit position
    CMP <r_battle_generic_tmp_3                                                 ; $03D542 | | than the spell's status bytes (taking the two status bytes in
    BCC +                                                                       ; $03D544 | | reverse order as a single little endian word), jump to the failure
    TDC                                                                         ; $03D546 | | section.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D547 | |
    JMP __battle_spell_effect_set_status_failure                                ; $03D549 | | NOTE: This is the reverse byte order to the physical status code.
+   TDC                                                                         ; $03D54C | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D54D |/
    LDA r_character_battle_current_target.status_1_immunity.w                   ; $03D54F |\
    AND r_current_spell_properties.element_status.status_1.w                    ; $03D552 | | If the target is immune to any of the spell's status bits, jump to
    BNE +                                                                       ; $03D555 | | the failure code.
    LDA r_character_battle_current_target.status_2_immunity.w                   ; $03D557 | |
    AND r_current_spell_properties.element_status.status_2.w                    ; $03D55A | |
+   BNE __battle_spell_effect_set_status_failure                                ; $03D55D |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D55F |\
    ORA <r_battle_generic_tmp_3_hi                                              ; $03D562 | | Update the target's status bytes with the spell's status bytes.
    STA r_character_battle_current_target.status_1.w                            ; $03D564 | |
    LDA r_character_battle_current_target.status_2.w                            ; $03D567 | |
    ORA <r_battle_generic_tmp_3_lo                                              ; $03D56A | |
    STA r_character_battle_current_target.status_2.w                            ; $03D56C |/
    LDA r_current_spell_properties.element_status.status_2.w                    ; $03D56F |\
    AND #(STATUS_2_PARALYZE | STATUS_2_CHARM).b                                 ; $03D572 | | Skip the rest unless the spell set charm or paralyze.
    BEQ +                                                                       ; $03D574 |/
    LDA r_character_battle_current_target.status_2.w                            ; $03D576 |\
    AND #STATUS_2_BERSERK.b ~ $FF                                               ; $03D579 | | Unset the berserk status if set.
    STA r_character_battle_current_target.status_2.w                            ; $03D57B |/
    LDA <r_battle_command_target_true_slot                                      ; $03D57E |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03D580 | | Calculate the offset to the target's timers and save it to the
    LDA #_sizeof_character_timers.b                                             ; $03D582 | | timer offset variable.
    STA <r_math_multiply_8bit_arg_2                                             ; $03D584 | |
    JSR _math_multiply_8bit                                                     ; $03D586 | |
    LDX <r_math_multiply_8bit_result                                            ; $03D589 | |
    STX r_current_slot_offset_timer.w                                           ; $03D58B |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03D58E |\
    JSR _add_timer_offset.w                                                     ; $03D590 | | Calculate the offset to the target's action timer.
    LDX r_add_timer_offset_result.w                                             ; $03D593 |/
    LDA r_character_battle_current_target.status_2.w                            ; $03D596 |\
    AND #STATUS_2_PARALYZE.b                                                    ; $03D599 | | Skip to the end unless setting the paralyze status.
    BEQ +                                                                       ; $03D59B |/
    LDA r_character_battle_current_target.status_2.w                            ; $03D59D |\
    AND #STATUS_2_CHARM.b ~ $FF                                                 ; $03D5A0 | | Unset any charm status on the target.
    STA r_character_battle_current_target.status_2.w                            ; $03D5A2 |/
    LDA #1.b                                                                    ; $03D5A5 |\
    STA r_battle_timers.1.value_lo.w,X                                          ; $03D5A7 | | Set the target's action timer to 1, and unset any timer flags.
    STZ r_battle_timers.1.value_hi.w,X                                          ; $03D5AA | |
    STZ r_battle_timers.1.flags.w,X                                             ; $03D5AD |/
+   BRA ++                                                                      ; $03D5B0
__battle_spell_effect_set_status_failure:
    JSR _battle_unset_target                                                    ; $03D5B2 | If failure, unset this target.
++  RTS                                                                         ; $03D5B5

; _battle_spell_effect_set_paralyze_sleep ($03:D5B6)
;
; This spell effect handler is generally used to set sleep or paralyze on a
; target. Technically, it will set any set status bit within the second status
; byte, however. Additionally sets the action timer for the target using the
; timer calculation method used for sleep and paralyze.
;
; This handler suffers from a rather interesting bug involving a switch between
; 8-bit and 16-bit accumulator mode. A small block of code, seemingly intended
; to remove charm or berserk status from monster targets, does not execute
; properly. It tries to read $CE to determine if the target is a monster or not,
; but ends up reading $CE.CF instead, which will always be positive, resulting
; in the offending block never being executed. Even if it were, the instructions
; would be interpreted wrong. The switch back to 8-bit accumulator mode is
; immediately after the block, but it should be before.
_battle_spell_effect_set_paralyze_sleep:
    LDA #TIMER_MODE_PARALYZE_SLEEP_STONE.b                                      ; $03D5B6 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03D5B8 | | Calculate a timer value for the target using the paralyze/sleep
    LDA <r_battle_command_target_true_slot                                      ; $03D5BA | | timer calculation mode.
    JSR _calculate_timer_value                                                  ; $03D5BC |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03D5BF |\
    JSR _add_timer_offset                                                       ; $03D5C1 | | Calculate the offset to the target's action timer.
    LDX r_add_timer_offset_result.w                                             ; $03D5C4 |/
    LDA r_battle_timers.1.flags.w,X                                             ; $03D5C7 |\ Skip this target if the action timer has any flags set.
    BNE +                                                                       ; $03D5CA |/
    LDA r_character_battle_current_target.status_2_immunity.w                   ; $03D5CC |\
    AND r_current_spell_properties.element_status.status_2.w                    ; $03D5CF | | Skip this target if immune to any status in the second byte.
    BNE +                                                                       ; $03D5D2 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D5D4 |\
    STA <r_battle_generic_tmp_2_hi                                              ; $03D5D7 | | Skip this target if it already has a status with a higher bit
    LDA r_character_battle_current_target.status_2.w                            ; $03D5D9 | | value (taking the two status bytes in reverse order as a single
    AND #STATUS_2_FLOAT.b ~ $FF                                                 ; $03D5DC | | little endian word).
    STA <r_battle_generic_tmp_2_lo                                              ; $03D5DE | |
    LDA r_current_spell_properties.element_status.status_1.w                    ; $03D5E0 | |
    STA <r_battle_generic_tmp_3_hi                                              ; $03D5E3 | |
    LDA r_current_spell_properties.element_status.status_2.w                    ; $03D5E5 | |
    STA <r_battle_generic_tmp_3_lo                                              ; $03D5E8 | |
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D5EA | |
    LDA <r_battle_generic_tmp_2                                                 ; $03D5EC | |
    CMP <r_battle_generic_tmp_3                                                 ; $03D5EE | |
    BCC ++                                                                      ; $03D5F0 | |
    TDC                                                                         ; $03D5F2 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D5F3 | |
+   JMP _battle_unset_target                                                    ; $03D5F5 |/
++  LDA <r_battle_command_target_slot                                           ; $03D5F8 |\
    BPL +                                                                       ; $03D5FA | | If the target is a monster, unset any charm or berserk status it
    LDA r_character_battle_current_target.status_2.w                            ; $03D5FC | | might have.
    AND #(STATUS_2_CHARM | STATUS_2_BERSERK).b ~ $FF                            ; $03D5FF | |
    STA r_character_battle_current_target.status_2.w                            ; $03D601 | | BUG: This code is clearly intended for use with an 8-bit
+   TDC                                                                         ; $03D604 | |      accumulator, but clearly executes with a 16-bit one. The
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D605 |/       result is that this removal will never execute.
    LDA r_character_battle_current_target.status_2.w                            ; $03D607 |\
    ORA r_current_spell_properties.element_status.status_2.w                    ; $03D60A | | Set the statuses for this spell.
    STA r_character_battle_current_target.status_2.w                            ; $03D60D |/
    LDX r_add_timer_offset_result.w                                             ; $03D610 |\
    LDA <r_set_timer_value_arg_lo                                               ; $03D613 | | Set the target's action timer to the previously calculated value.
    STA r_battle_timers.1.value_lo.w,X                                          ; $03D615 | |
    LDA <r_set_timer_value_arg_hi                                               ; $03D618 | |
    STA r_battle_timers.1.value_hi.w,X                                          ; $03D61A |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03D61D |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03D61F |/
    RTS                                                                         ; $03D622

; _battle_spell_effect_set_image ($03:D623)
;
; This battle spell effect sets the image status on the target.
_battle_spell_effect_set_image:
    LDA r_character_battle_current_target.status_4.w                            ; $03D623 |\
    ORA #(STATUS_4_IMAGE_TWO_HITS | STATUS_4_IMAGE_ONE_HIT).b                   ; $03D626 | | Set the image status on the target.
    STA r_character_battle_current_target.status_4.w                            ; $03D628 |/
    RTS                                                                         ; $03D62B

; _battle_spell_effect_set_wall ($03:D62C)
;
; This battle spell effect is used for setting Wall status on the target. It
; works by reading the bits in the linked second status byte, and setting them
; in the FOURTH status byte, instead. It also sets the Wall timer for the
; target.
_battle_spell_effect_set_wall:
    LDA r_character_battle_current_target.status_4.w                            ; $03D62C |\
    ORA r_current_spell_properties.element_status.status_2.w                    ; $03D62F | | Set the appropriate bits in the fourth status byte.
    STA r_character_battle_current_target.status_4.w                            ; $03D632 |/
    LDA r_current_spell_properties.data.power.w                                 ; $03D635 |\
    STA r_calculate_timer_value_arg_index.w                                     ; $03D638 | | Calculate the timer value using the spell's power. The result is
    LDA #TIMER_MODE_WALL.b                                                      ; $03D63B | | double the power, plus 30.
    STA <r_calculate_timer_value_arg_mode                                       ; $03D63D | |
    LDA <r_battle_command_target_true_slot                                      ; $03D63F | |
    JSR _calculate_timer_value                                                  ; $03D641 |/
    LDA #TIMER_OFFSET_WALL.b                                                    ; $03D644 |\ Set the timer value for the Wall timer.
    JSR _set_timer_value                                                        ; $03D646 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03D649 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03D64B |/
    LDA <r_battle_command_target_true_slot                                      ; $03D64E |\
    ASL A                                                                       ; $03D650 | | Flag the target's wall timer as enabled.
    TAX                                                                         ; $03D651 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D652 | |
    ORA #(TIMER_ENABLED_WALL >> 8).b                                            ; $03D655 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D657 |/
    RTS                                                                         ; $03D65A

; _battle_spell_effect_life ($03:D65B)
;
; Handles the battle spell effect used for spells that revive targets from swoon
; status.
_battle_spell_effect_life:
    LDA #BATTLE_MONSTER_TRANSITION_LIFE.b                                       ; $03D65B |\ Set the special monster transition to life.
    STA r_battle_monster_special_transition.w                                   ; $03D65D |/
    LDA r_character_battle_current_target.monster_race.w                        ; $03D660 |\
    AND #MONSTER_RACE_UNDEAD.b                                                  ; $03D663 | | If the target is undead, set the spell's status bits to indicate
    BEQ +                                                                       ; $03D665 | | inflicting the swoon status and call the effect that sets general
    LDA #STATUS_1_SWOON.b                                                       ; $03D667 | | statuses, bypassing the check against swooning the undead.
    STA r_current_spell_properties.element_status.status_1.w                    ; $03D669 | |
    STZ r_current_spell_properties.element_status.status_2.w                    ; $03D66C | |
    JMP _battle_spell_effect_set_status_swoon_undead                            ; $03D66F |/
+   LDA r_character_battle_current_target.status_1.w                            ; $03D672 |\
    BMI +                                                                       ; $03D675 | | Otherwise, return unless the target has the swoon status.
    RTS                                                                         ; $03D677 |/
+   AND #(STATUS_1_SWOON | STATUS_1_POISON).b ~ $FF                             ; $03D678 |\ Unset the swoon and poison statuses from the target.
    STA r_character_battle_current_target.status_1.w                            ; $03D67A |/
    LDA r_character_battle_current_target.status_2.w                            ; $03D67D |\
    AND #(STATUS_2_CURSE | STATUS_2_FLOAT).b                                    ; $03D680 | | Unset statuses in byte 2 except curse and float.
    STA r_character_battle_current_target.status_2.w                            ; $03D682 |/
    LDA r_character_battle_current_target.status_3.w                            ; $03D685 |\
    AND #STATUS_3_EGG.b                                                         ; $03D688 | | Unset all byte 3 statuses except egg.
    STA r_character_battle_current_target.status_3.w                            ; $03D68A |/
    LDA r_character_battle_current_target.status_4.w                            ; $03D68D |\
    AND #STATUS_4_HIDING.b                                                      ; $03D690 | | Unset all byte 4 statuses except hiding.
    STA r_character_battle_current_target.status_4.w                            ; $03D692 |/
    STZ <r_calculate_timer_value_arg_mode                                       ; $03D695 |\
    LDA <r_battle_command_target_true_slot                                      ; $03D697 | | Set the target's action timer using the basic relative speed mode,
    JSR _calculate_timer_value                                                  ; $03D699 | | which sets the timer to their relative speed.
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03D69C | |
    JSR _set_timer_value                                                        ; $03D69E |/
    STZ r_battle_timers.1.flags.w,X                                             ; $03D6A1 | Unset any flags in the action timer.
    LDA r_calculate_offsets_slot.w                                              ; $03D6A4 |\
    ASL A                                                                       ; $03D6A7 | | Flag the action timer as enabled.
    TAX                                                                         ; $03D6A8 | |
    LDA #(TIMER_ENABLED_ACTION >> 8).b                                          ; $03D6A9 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D6AB |/
    LDA <r_battle_command_target_true_slot                                      ; $03D6AE |\
    CMP #5.b                                                                    ; $03D6B0 | | If the target is in a monster slot, set the slot to ID index map
    BCC +                                                                       ; $03D6B2 | | value back to the initial value, in case it was overwritten, and
    SEC                                                                         ; $03D6B4 | | increment the monster counts both for this type and for all
    SBC #5.b                                                                    ; $03D6B5 | | monsters.
    TAX                                                                         ; $03D6B7 | |
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $03D6B8 | |
    STA r_monster_slot_to_id_index.w,X                                          ; $03D6BB | |
    TAX                                                                         ; $03D6BE | |
    INC r_monsters_remaining.w,X                                                ; $03D6BF | |
    INC r_monsters_remaining_total.w                                            ; $03D6C2 |/
+   LDA r_battle_current_spell_item.w                                           ; $03D6C5 |\
    BNE +                                                                       ; $03D6C8 | | If the spell being used is either Life2 or the monster spells
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D6CA | | Recover and Remedy, branch ahead to later code.
    CMP #SPELL_LIFE2.b                                                          ; $03D6CD | |
    BEQ ++                                                                      ; $03D6CF | |
    CMP #SPELL_MONSTER_RECOVER.b                                                ; $03D6D1 | |
    BEQ ++                                                                      ; $03D6D3 | |
    CMP #SPELL_MONSTER_REMEDY.b                                                 ; $03D6D5 | |
    BEQ ++                                                                      ; $03D6D7 |/
+   LDA r_character_battle_current_target.vitality.w                            ; $03D6D9 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03D6DC | | Otherwise, set the target's current HP to their vitality times
    LDA #5.b                                                                    ; $03D6DE | | five.
    STA <r_math_multiply_8bit_arg_2                                             ; $03D6E0 | |
    JSR _math_multiply_8bit                                                     ; $03D6E2 | | BUG: Since monsters don't have base stats, this should really set
    LDX <r_math_multiply_8bit_result                                            ; $03D6E5 | |      monster HP in some other fashion. They probably didn't count
    STX r_character_battle_current_target.hp.w                                  ; $03D6E7 | |      on players attempting to revive monsters.
    RTS                                                                         ; $03D6EA |/
++  LDA r_character_battle_current_target.hp_max_lo.w                           ; $03D6EB |\
    STA r_character_battle_current_target.hp_lo.w                               ; $03D6EE | | If branching from above, instead set the current HP to the maximum
    LDA r_character_battle_current_target.hp_max_hi.w                           ; $03D6F1 | | HP.
    STA r_character_battle_current_target.hp_hi.w                               ; $03D6F4 |/
    RTS                                                                         ; $03D6F7

; _battle_spell_effect_heal ($03:D6F8)
;
; This spell effect handles the removal of status effect. Items that remove only
; some statuses remove the statuses not set in their spell status bytes. (In
; other words, the set bits define which status effects to keep.)
_battle_spell_effect_heal:
    LDA r_battle_current_spell_item.w                                           ; $03D6F8 |\
    BEQ +                                                                       ; $03D6FB | | If the current spell isn't Heal or the monster version of Heal, or
    LDA r_character_battle_current_actor.subcommand.w                           ; $03D6FD | | the Heal item, branch ahead to code that handles partial status
    CMP #ITEM_HEAL.b                                                            ; $03D700 | | healing.
    BEQ ++                                                                      ; $03D702 | |
    JMP @partial                                                                ; $03D704 | |
+   LDA r_character_battle_current_actor.subcommand.w                           ; $03D707 | |
    CMP #SPELL_HEAL.b                                                           ; $03D70A | |
    BEQ ++                                                                      ; $03D70C | |
    CMP #SPELL_MONSTER_HEAL.b                                                   ; $03D70E | |
    BEQ ++                                                                      ; $03D710 | |
    JMP @partial                                                                ; $03D712 |/
++  LDA <r_battle_command_target_slot                                           ; $03D715 |\
    BPL +                                                                       ; $03D717 | | Reset the the auto-action queued flag for this slot.
    CLC                                                                         ; $03D719 | |
    ADC #5.b                                                                    ; $03D71A | |
+   TAX                                                                         ; $03D71C | |
    STZ r_battle_slot_auto_action_queued.w,X                                    ; $03D71D |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D720 |\ Copy the target's initial first status byte to a temporary
    STA <r_battle_generic_tmp_1_lo                                              ; $03D723 |/ variable.
    AND #STATUS_1_SWOON.b                                                       ; $03D725 |\ Unset the stone, toad, small, pig, mute, darkness and poison
    STA r_character_battle_current_target.status_1.w                            ; $03D727 |/ statuses.
    LDA r_character_battle_current_target.status_2.w                            ; $03D72A |\ Copy the target's initial second status byte to a temporary
    STA <r_battle_generic_tmp_1_hi                                              ; $03D72D |/ variable.
    AND #(STATUS_2_FLOAT | STATUS_2_BERSERK).b                                  ; $03D72F |\ Unset the curse, paralyze, sleep, charm and partial stone statuses.
    STA r_character_battle_current_target.status_2.w                            ; $03D731 |/
    LDA #16.b                                                                   ; $03D734 |\ Reset the target's speed modifier to 16.
    STA r_character_battle_current_target.speed_modifier.w                      ; $03D736 |/
    LDA <r_battle_command_target_true_slot                                      ; $03D739 |\
    ASL A                                                                       ; $03D73B | | Disable the target's poison and stone timers.
    TAX                                                                         ; $03D73C | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D73D | |
    AND #((TIMER_ENABLED_POISON | TIMER_ENABLED_STONE) >> 8).b ~ $FE            ; $03D740 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D742 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D745 |\
    AND #STATUS_1_STONE.b                                                       ; $03D747 | | If the target had none of the stone, paralyze or sleep statuses,
    BNE +                                                                       ; $03D749 | | branch forward the furthest. Otherwise, branch forward depending
    LDA <r_battle_generic_tmp_1_hi                                              ; $03D74B | | on if they had stone or not.
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03D74D | |
    BEQ +++                                                                     ; $03D74F | |
    BRA ++                                                                      ; $03D751 |/
+   LDA <r_battle_command_target_true_slot                                      ; $03D753 |\
    ASL A                                                                       ; $03D755 | | If the target had the stone status, re-enable their action timer.
    TAX                                                                         ; $03D756 | |
    LDA #(TIMER_ENABLED_ACTION >> 8).b                                          ; $03D757 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D759 |/
++  STZ <r_calculate_timer_value_arg_mode                                       ; $03D75C |\
    LDA <r_battle_command_target_true_slot                                      ; $03D75E | | If the target had any of the stone, sleep or paralyze statuses,
    JSR _calculate_timer_value                                                  ; $03D760 | | calculate a new timer value based on their relative speed and set
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03D763 | | their action timer. Unset any flags for the timer.
    JSR _set_timer_value                                                        ; $03D765 | |
    STZ r_battle_timers.1.flags.w,X                                             ; $03D768 | |
    JMP @done                                                                   ; $03D76B |/
+++ LDA <r_battle_generic_tmp_1_lo                                              ; $03D76E |\
    AND #STATUS_1_PIG.b                                                         ; $03D770 | | If the target had the pig status, set their current command to
    BEQ +++                                                                     ; $03D772 | | the Wait command, to give them a new menu.
    LDA r_battle_command_target_slot.w                                          ; $03D774 | |
    BPL +                                                                       ; $03D777 | |
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03D779 | |
    BRA ++                                                                      ; $03D77B | |
+   LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03D77D | |
++  STA r_character_battle_current_target.command.w                             ; $03D77F |/
+++ RTS                                                                         ; $03D782
@partial:
    LDA r_character_battle_current_target.status_1.w                            ; $03D783 |\ Copy the initial first status byte to a temporary variable.
    STA <r_battle_spell_effect_heal_tmp_target_status_1                         ; $03D786 |/
    AND r_current_spell_properties.element_status.status_1.w                    ; $03D788 |\ Remove the selected statuses from the first status byte. (The
    STA r_character_battle_current_target.status_1.w                            ; $03D78B |/ status byte selects the statuses to keep.)
    LDA r_character_battle_current_target.status_2.w                            ; $03D78E |\ Copy the initial second status byte to a temporary variable.
    STA <r_battle_spell_effect_heal_tmp_target_status_2                         ; $03D791 |/
    AND r_current_spell_properties.element_status.status_2.w                    ; $03D793 |\ Remove the selected statuses from the second status byte.
    STA r_character_battle_current_target.status_2.w                            ; $03D796 |/
    LDA r_current_spell_properties.element_status.status_1.w                    ; $03D799 |\
    EOR #%11111111.b                                                            ; $03D79C | | Copy the statuses that are removed by this spell/item to two
    STA <r_battle_spell_effect_heal_tmp_removing_status_1                       ; $03D79E | | temporary bytes.
    LDA r_current_spell_properties.element_status.status_2.w                    ; $03D7A0 | |
    EOR #%11111111.b                                                            ; $03D7A3 | |
    STA <r_battle_spell_effect_heal_tmp_removing_status_2                       ; $03D7A5 |/
    LDA <r_battle_spell_effect_heal_tmp_target_status_1                         ; $03D7A7 |\
    AND #STATUS_1_POISON.b                                                      ; $03D7A9 | | If the target initially had the poison status and if the poison
    BEQ +                                                                       ; $03D7AB | | status was removed, disable the target's poison timer.
    LDA <r_battle_spell_effect_heal_tmp_removing_status_1                       ; $03D7AD | |
    AND #STATUS_1_POISON.b                                                      ; $03D7AF | |
    BEQ +                                                                       ; $03D7B1 | |
    LDA <r_battle_command_target_true_slot                                      ; $03D7B3 | |
    ASL A                                                                       ; $03D7B5 | |
    TAX                                                                         ; $03D7B6 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D7B7 | |
    AND #(TIMER_ENABLED_POISON >> 8).b ~ $FF                                    ; $03D7BA | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D7BC |/
+   LDA <r_battle_spell_effect_heal_tmp_target_status_1                         ; $03D7BF |\
    AND #STATUS_1_STONE.b                                                       ; $03D7C1 | | If the target initially had the stone status and the stone status
    BEQ +                                                                       ; $03D7C3 | | was removed, re-enable the target's action timer.
    LDA <r_battle_spell_effect_heal_tmp_removing_status_1                       ; $03D7C5 | |
    AND #STATUS_1_STONE.b                                                       ; $03D7C7 | |
    BEQ +                                                                       ; $03D7C9 | |
    LDA <r_battle_command_target_true_slot                                      ; $03D7CB | |
    ASL A                                                                       ; $03D7CD | |
    TAX                                                                         ; $03D7CE | |
    LDA #(TIMER_ENABLED_ACTION >> 8).b                                          ; $03D7CF | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D7D1 | |
    BRA ++                                                                      ; $03D7D4 |/
+   LDA <r_battle_spell_effect_heal_tmp_target_status_2                         ; $03D7D6 |\
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03D7D8 | | If the target initially had the stone, paralyze or sleep status
    BEQ +                                                                       ; $03D7DA | | and it was removed, set the action timer to a value based on the
    LDA <r_battle_spell_effect_heal_tmp_removing_status_2                       ; $03D7DC | | target's relative speed. Unset any flags for the timer.
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03D7DE | |
    BEQ +                                                                       ; $03D7E0 | |
++  STZ <r_calculate_timer_value_arg_mode                                       ; $03D7E2 | |
    LDA <r_battle_command_target_true_slot                                      ; $03D7E4 | |
    JSR _calculate_timer_value                                                  ; $03D7E6 | |
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03D7E9 | |
    JSR _set_timer_value                                                        ; $03D7EB | |
    STZ r_battle_timers.1.flags.w,X                                             ; $03D7EE |/
+   LDA <r_battle_spell_effect_heal_tmp_target_status_2                         ; $03D7F1 |\
    AND #STATUS_2_CHARM.b                                                       ; $03D7F3 | | If the target either didn't have the charm status or it wasn't
    BEQ ++                                                                      ; $03D7F5 | | removed, branch ahead past the next section.
    LDA <r_battle_spell_effect_heal_tmp_removing_status_2                       ; $03D7F7 | |
    AND #STATUS_2_CHARM.b                                                       ; $03D7F9 | |
    BEQ ++                                                                      ; $03D7FB |/
    LDA <r_battle_command_target_slot                                           ; $03D7FD |\
    BPL +                                                                       ; $03D7FF | | If the target's charm status was removed and was a monster, set
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03D801 | | their command to $E1.
    STA r_character_battle_current_target.command.w                             ; $03D803 | |
    BRA ++                                                                      ; $03D806 |/
+   TAX                                                                         ; $03D808 |\
    STZ r_battle_slot_auto_action_queued.w,X                                    ; $03D809 | | If they were a character, unset their auto-action queued flag and
    LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03D80C | | set their command to $21.
    STA r_character_battle_current_target.command.w                             ; $03D80E |/
++  LDA <r_battle_spell_effect_heal_tmp_target_status_2                         ; $03D811 |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $03D813 | | If the target either wasn't partially stoned or that status isn't
    BEQ @done                                                                   ; $03D815 | | being removed, branch to the end.
    LDA <r_battle_spell_effect_heal_tmp_removing_status_2                       ; $03D817 | |
    AND #STATUS_2_STONE_STATUS.b                                                ; $03D819 | |
    BEQ @done                                                                   ; $03D81B |/
    LDA <r_battle_command_target_true_slot                                      ; $03D81D |\
    ASL A                                                                       ; $03D81F | | Otherwise, disable the target's stone timer.
    TAX                                                                         ; $03D820 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D821 | |
    AND #(TIMER_ENABLED_STONE >> 8).b ~ $FF                                     ; $03D824 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D826 |/
@done:
    RTS                                                                         ; $03D829

; _battle_spell_effect_toggle_status_1 ($03:D82A)
;
; Spell effect which toggles status bits in the first status byte. Specifically
; used for spells that can either set or unset a status, depending on the status
; of the target.
_battle_spell_effect_toggle_status_1:
    LDA r_character_battle_current_target.status_1_immunity.w                   ; $03D82A |\
    AND r_current_spell_properties.element_status.status_1.w                    ; $03D82D | | Skip if the target is immune to any of the statuses being set.
    BNE +                                                                       ; $03D830 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D832 |\
    AND r_current_spell_properties.element_status.status_1.w                    ; $03D835 | | If the target already has the status in question, branch.
    BNE ++                                                                      ; $03D838 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03D83A |\
    CMP r_current_spell_properties.element_status.status_1.w                    ; $03D83D | | Branch if the target doesn't have a status with a higher bit.
    BCC ++                                                                      ; $03D840 |/
+   JMP _battle_unset_target                                                    ; $03D842 | If skipping this target, unset the target.
++  LDA r_character_battle_current_target.status_1.w                            ; $03D845 |\
    EOR r_current_spell_properties.element_status.status_1.w                    ; $03D848 | | Toggle the status bits in question.
    STA r_character_battle_current_target.status_1.w                            ; $03D84B |/
    RTS                                                                         ; $03D84E

; _battle_spell_effect_armor ($03:D84F)
;
; Spell effect for the Armor spell, which raises the target's physical defense
; directly by five.
;
; BUG/NOTE: Directly raising the physical defense is problematic because that
;           is a derived value that will be recalculated if the character
;           changes their equipment. This isn't necessarily a bug, but it is
;           definitely odd behavior if intended.
_battle_spell_effect_armor:
    LDA r_character_battle_current_target.physical_defense_base.w               ; $03D84F |\
    CMP #255.b                                                                  ; $03D852 | | If the target's physical defense is already at 255, unset the
    BNE +                                                                       ; $03D854 | | target and return.
    JMP _battle_unset_target                                                    ; $03D856 |/
+   LDA r_battle_formation_lo.w                                                 ; $03D859 |\
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL                                        ; $03D85C | | Skip doing anything if this is the final battle against Zeromus.
    BNE +                                                                       ; $03D85E | |
    LDA r_battle_formation_hi.w                                                 ; $03D860 | |
    BNE ++                                                                      ; $03D863 |/
+   CLC                                                                         ; $03D865 |\
    LDA r_character_battle_current_target.physical_defense_base.w               ; $03D866 | | Add five to the target's physical defense, setting the value
    ADC #5.b                                                                    ; $03D869 | | explicitly to 255 if it overflows.
    BCC +                                                                       ; $03D86B | |
    LDA #255.b                                                                  ; $03D86D | |
+   STA r_character_battle_current_target.physical_defense_base.w               ; $03D86F |/
++  RTS                                                                         ; $03D872

; _battle_spell_effect_shell ($03:D873)
;
; Spell effect for the Shell spell, which raices the target's magic defense
; directly by three.
;
; BUG/NOTE: Similar to the Armor effect, directly raising the magic defense
;           value is potentially problematic because it's a derived value that
;           it recalculated when a character changes equipment.
_battle_spell_effect_shell:
    LDA r_character_battle_current_target.magic_defense_base.w                  ; $03D873 |\
    CMP #255.b                                                                  ; $03D876 | | If the target's magic defense is already at 255, unset the target
    BNE +                                                                       ; $03D878 | | and return.
    JMP _battle_unset_target                                                    ; $03D87A |/
+   LDA r_battle_formation_lo.w                                                 ; $03D87D |\
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL                                        ; $03D880 | | SKip doing anything if this is the final battle against Zeromus.
    BNE +                                                                       ; $03D882 | |
    LDA r_battle_formation_hi.w                                                 ; $03D884 | |
    BNE ++                                                                      ; $03D887 |/
+   CLC                                                                         ; $03D889 |\
    LDA r_character_battle_current_target.magic_defense_base.w                  ; $03D88A | | Add three to the target's magic defense, setting the value
    ADC #3.b                                                                    ; $03D88D | | explicitly to 255 if it overflows.
    BCC +                                                                       ; $03D88F | |
    LDA #255.b                                                                  ; $03D891 | |
+   STA r_character_battle_current_target.magic_defense_base.w                  ; $03D893 |/
++  RTS                                                                         ; $03D896

; _battle_spell_effect_change_speed ($03:D897)
;
; Spell effect for spells and items that modify the speed modifier. The spell's
; power value is directly added to the target's speed modifier. The final value
; is adjusted to ensure it stays in a range from 12 to 32, inclusive.
_battle_spell_effect_change_speed:
    CLC                                                                         ; $03D897 |\
    LDA r_character_battle_current_target.speed_modifier.w                      ; $03D898 | | Add the spell's power value to the target's speed modifier.
    ADC r_current_spell_properties.data.power.w                                 ; $03D89B |/
    CMP #32.b                                                                   ; $03D89E |\
    BCS +                                                                       ; $03D8A0 | | Ensure the final value is between 12 and 32, inclusive.
    CMP #12.b                                                                   ; $03D8A2 | |
    BCS ++                                                                      ; $03D8A4 | |
    LDA #12.b                                                                   ; $03D8A6 | |
    BRA ++                                                                      ; $03D8A8 | |
+   LDA #32.b                                                                   ; $03D8AA |/
++  STA r_character_battle_current_target.speed_modifier.w                      ; $03D8AC | Store the new value to the stat record.
    RTS                                                                         ; $03D8AF

; _battle_spell_effect_dispel ($03:D8B0)
;
; Spell effect that causes a dispel-like effect. It removes berserk, sap, wall
; barrier, image and stop from the target. However, its implementation may not
; be complete and almost certainly has a bug involving monster slots. It
; disables the stop and sap timers, but it doesn't touch any of the others and
; that may be problematic.
;
; TODO: Is it problematic?
_battle_spell_effect_dispel:
    LDA <r_battle_command_target_slot                                           ; $03D8B0 |\
    BPL +                                                                       ; $03D8B2 | | TODO: Store a zero in an unknown variable for this slot.
    CLC                                                                         ; $03D8B4 | |
    ADC #5.b                                                                    ; $03D8B5 | | BUG: When calculating a slot for a monter, it adds five, but does
+   TAX                                                                         ; $03D8B7 | |      not unset the high bit, so it won't write to the expected
    STZ r_unknown_356d.w,X                                                      ; $03D8B8 |/       location.
    LDA r_character_battle_current_target.status_2.w                            ; $03D8BB |\ Copy the initial second status byte to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03D8BE |/
    AND #STATUS_2_BERSERK.b ~ %11111111                                         ; $03D8C0 |\ Unset the berserk status on the target.
    STA r_character_battle_current_target.status_2.w                            ; $03D8C2 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03D8C5 |\
    AND #STATUS_2_BERSERK.b                                                     ; $03D8C7 | | If berserk was removed from the target, set the target's command
    BEQ +++                                                                     ; $03D8C9 | | to $E1 if a monster or $21 if not.
    LDA r_battle_command_target_slot.w                                          ; $03D8CB | |
    BPL +                                                                       ; $03D8CE | |
    LDA #MONSTER_COMMAND_WAIT.b                                                 ; $03D8D0 | |
    BRA ++                                                                      ; $03D8D2 | |
+   LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03D8D4 | |
++  STA r_character_battle_current_target.command.w                             ; $03D8D6 |/
+++ LDA r_character_battle_current_target.status_4.w                            ; $03D8D9 |\
    AND #(STATUS_4_HIDING | STATUS_4_COVERED | STATUS_4_CRITICAL).b             ; $03D8DC | | Remove the sap, wall, barrier and image statuses.
    STA r_character_battle_current_target.status_4.w                            ; $03D8DE |/
    LDA <r_battle_command_target_true_slot                                      ; $03D8E1 |\
    ASL A                                                                       ; $03D8E3 | | Disable the stop and sap timers.
    TAX                                                                         ; $03D8E4 | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D8E5 | |
    AND #((TIMER_ENABLED_STOP | TIMER_ENABLED_SAP) >> 8).b ~ %11111111          ; $03D8E8 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D8EA |/
    RTS                                                                         ; $03D8ED

; _battle_spell_effect_stop ($03:D8EE)
;
; Spell effect for spells that set the stop status.
_battle_spell_effect_stop:
    LDA r_character_battle_current_target.status_3.w                            ; $03D8EE |\
    ORA #STATUS_3_STOP.b                                                        ; $03D8F1 | | Set the stop status on the target.
    STA r_character_battle_current_target.status_3.w                            ; $03D8F3 |/
    LDA r_current_spell_properties.data.power.w                                 ; $03D8F6 |\
    STA r_calculate_timer_value_arg_index.w                                     ; $03D8F9 | | Calculate a timer value using the stop timer calculation mode,
    LDA #TIMER_MODE_STOP.b                                                      ; $03D8FC | | which will multiply the spell power passed as a parameter by
    STA <r_calculate_timer_value_arg_mode                                       ; $03D8FE | | three.
    LDA <r_battle_command_target_true_slot                                      ; $03D900 | |
    JSR _calculate_timer_value                                                  ; $03D902 |/
    LDX r_current_slot_offset_timer.w                                           ; $03D905 |\
    LDA <r_set_timer_value_arg_lo                                               ; $03D908 | | Set the calculated value in the target's stop timer.
    STA r_battle_timers.1.stop.value_lo.w,X                                     ; $03D90A | |
    LDA <r_set_timer_value_arg_hi                                               ; $03D90D | |
    STA r_battle_timers.1.stop.value_hi.w,X                                     ; $03D90F |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03D912 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.stop.flags.w,X                                        ; $03D914 |/
.if FF4_VERSION != "USA_REV_1"
.if FF4_VERSION != "JAPAN_EASYTYPE"
    STZ r_battle_timers.1.action.flags.w,X                                      ; $03D917 | For any version except USA Rev 1 or Easytype, clear the action timer flags.
.endif
.endif
    LDA <r_battle_command_target_true_slot                                      ; $03D917 |\
    ASL A                                                                       ; $03D919 | | Flag the target's stop timer as enabled.
    TAX                                                                         ; $03D91A | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03D91B | |
    ORA #(TIMER_ENABLED_STOP >> 8).b                                            ; $03D91E | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03D920 |/
    RTS                                                                         ; $03D923

; _battle_spell_effect_peep ($03:D924)
;
; Spell effect to handle the Peep spell, which displays the monster's current
; and maximum HP, as well as any regular elemental weaknesses the monster has,
; as long as they don't also have a resistance that element. Additionally, the
; effect is hardcoded to not work in the final Zeromus battle.
_battle_spell_effect_peep:
    LDA r_battle_formation_lo.w                                                 ; $03D924 |\
    CMP #<BATTLE_FORMATION_ZEROMUS_FINAL                                        ; $03D927 | | If this is the final Zeromus battle, unset this target and
    BNE +                                                                       ; $03D929 | | return. Can't have the peons discovering that Zeromus only has
    LDA r_battle_formation_hi.w                                                 ; $03D92B | | 61000 HP and cheats.
    BEQ +                                                                       ; $03D92E | |
    JMP _battle_unset_target                                                    ; $03D930 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03D933 |\
    LDA r_character_battle_current_target.hp.w                                  ; $03D935 | | Copy the target's HP and maximum HP into the arguments used for
    STA r_battle_update_dialog_extra_arg_1.w                                    ; $03D938 | | the battle dialog system.
    LDA r_character_battle_current_target.hp_max.w                              ; $03D93B | |
    STA r_battle_update_dialog_extra_arg_2.w                                    ; $03D93E | |
    TDC                                                                         ; $03D941 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03D942 |/
    STZ r_battle_update_dialog_extra_arg_1_hi.w                                 ; $03D944 |\ Zero out the high byte of each argument. (Each argument is three
    STZ r_battle_update_dialog_extra_arg_2_hi.w                                 ; $03D947 |/ bytes).
    LDA r_character_battle_current_target.element_weakness.w                    ; $03D94A |\
    AND r_character_battle_current_target.element_resistance.w                  ; $03D94D | | Determine the set of elements that the target is weak to, but for
    EOR #%11111111.b                                                            ; $03D950 | | which it does not also have a resistance.
    AND r_character_battle_current_target.element_weakness.w                    ; $03D952 | |
    AND #(ELEMENT_IMMUNE | ELEMENT_ABSORB).b ~ %11111111                        ; $03D955 |/
    STA <r_battle_generic_tmp_1_lo                                              ; $03D957 |\
    BNE +                                                                       ; $03D959 | | If no such elements were found, set a battle alert to display that
    LDA #BATTLE_ALERT_NO_WEAK_POINTS_FOUND.b                                    ; $03D95B | | no weak points were found as the second alert.
    STA r_battle_alert_queue.w + 1                                              ; $03D95D | |
    BRA ++                                                                      ; $03D960 |/
+   TDC                                                                         ; $03D962 |\
    TAX                                                                         ; $03D963 | | Otherwise, loop through the bits starting from the lowest and add
    TAY                                                                         ; $03D964 | | associated alerts to the battle alert queue if the bit was set.
-   LSR <r_battle_generic_tmp_1_lo                                              ; $03D965 | |
    BCC +                                                                       ; $03D967 | |
    TYA                                                                         ; $03D969 | |
    CLC                                                                         ; $03D96A | |
    ADC #BATTLE_ALERT_WEAK_AGAINST_FIRE.b                                       ; $03D96B | |
    STA r_battle_alert_queue.w + 1,X                                            ; $03D96D | |
    INX                                                                         ; $03D970 | |
+   INY                                                                         ; $03D971 | |
    CPY #6.w                                                                    ; $03D972 | |
    BNE -                                                                       ; $03D975 |/
++  LDA #BATTLE_ALERT_HP_MAX_HP.b                                               ; $03D977 |\ Set the first alert to display the monster's HP and maximum HP.
    STA r_battle_alert_queue.w                                                  ; $03D979 |/
    JMP _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03D97C | Add the alert display codes to the audiovisual script.

; _battle_spell_effect_run ($03:D97F)
;
; Spell effect that handles spells that allow the party to run away from battle.
_battle_spell_effect_run:
    LDA r_formation_flags2.w                                                    ; $03D97F |\
    AND #FORMATION_FLAGS_2_DISABLE_RUNNING.b                                    ; $03D982 | | If running is not disabled, set the flag to bypass the run delay
    BNE +                                                                       ; $03D984 | | timer, set the running with spell flag, and set a TODO value.
    INC r_battle_bypass_run_timer.w                                             ; $03D986 | |
    INC A                                                                       ; $03D989 | |
    STA r_battle_running_with_spell.w                                           ; $03D98A | |
    STA r_unknown_35a3.w                                                        ; $03D98D | |
    RTS                                                                         ; $03D990 |/
+   STZ r_battle_command_actual_targets.w                                       ; $03D991 |\
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03D994 | | Otherwise, set the actual targets to zero and display the can't
    LDA #BATTLE_ALERT_CANT_RUN.b                                                ; $03D997 | | run alert.
    STA r_battle_alert_queue.w                                                  ; $03D999 |/
    RTS                                                                         ; $03D99C

; _battle_spell_effect_actor_hp ($03:D99D)
;
; Spell effect handler for spells that do damage based on the actor's HP.
_battle_spell_effect_actor_hp:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03D99D | Set the element multiplier based on immunities and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03D9A0 |\
    BPL +                                                                       ; $03D9A3 | | If the target absorbs the spell's attack element, set the
    AND #%01111111.b                                                            ; $03D9A5 | | multiplier to remove the high bit and then use the generic restore
    STA r_battle_damage_element_multiplier.w                                    ; $03D9A7 | | spell calculation.
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03D9AA |/
+   JSR _battle_spell_set_element_multiplier_weakness.w                         ; $03D9AD | Set the element multiplier based on weakness.
    LDA #1.b                                                                    ; $03D9B0 |\ Set the number of hits explicitly to one.
    STA r_battle_damage_hits.w                                                  ; $03D9B2 |/
    LDX r_character_battle_current_actor.hp.w                                   ; $03D9B5 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $03D9B8 | | Set the attack power explicitly to the actor's HP divided by the
    LDA r_current_spell_properties.data.power.w                                 ; $03D9BB | | spell's power.
    TAX                                                                         ; $03D9BE | |
    STX r_math_divide_16bit_arg_2.w                                             ; $03D9BF | |
    JSR _math_divide_16bit                                                      ; $03D9C2 | |
    LDX r_math_divide_16bit_result.w                                            ; $03D9C5 | |
    STX r_battle_damage_attack_power.w                                          ; $03D9C8 |/
    TDC                                                                         ; $03D9CB |\
    TAX                                                                         ; $03D9CC | | Set the target's defense power to zero.
    STX r_battle_damage_defense_power.w                                         ; $03D9CD |/
    JSR _battle_calculate_damage                                                ; $03D9D0 | Calculate the damage with the given parameters.
    LDA r_current_spell_properties.element_status.status_1.w                    ; $03D9D3 |\
    AND #STATUS_1_POISON.b ~ %11111111                                          ; $03D9D6 | | If the spell is setting a first byte status other than poison or
    BNE +                                                                       ; $03D9D8 | | not setting curse, float, charm or berserk, switch to using the
    LDA r_current_spell_properties.element_status.status_2.w                    ; $03D9DA | | generic status effect.
    AND #STATUS_2_CURSE.b | STATUS_2_FLOAT | STATUS_2_CHARM | STATUS_2_BERSERK  ; $03D9DD | |
    BEQ ++                                                                      ; $03D9DF | |
+   JMP _battle_spell_effect_set_status                                         ; $03D9E1 |/
++  LDA r_current_spell_properties.element_status.status_1.w                    ; $03D9E4 |\
    AND #STATUS_1_POISON.b                                                      ; $03D9E7 | | If the poison status should be set, jump to a handler specific to
    BEQ +                                                                       ; $03D9E9 | | the poison status.
    JMP _battle_command_helper_set_poison                                       ; $03D9EB |/
+   LDA r_current_spell_properties.element_status.status_2.w                    ; $03D9EE |\
    AND #(STATUS_2_PARALYZE | STATUS_2_SLEEP).b                                 ; $03D9F1 | | If the paralyze or sleep statuses should be set, jump to the
    BEQ +                                                                       ; $03D9F3 | | paralyze and sleep handler.
    JMP _battle_spell_effect_set_paralyze_sleep                                 ; $03D9F5 | |
+   RTS                                                                         ; $03D9F8 |/

; _battle_spell_effect_restore_mp ($03:D9F9)
;
; Spell effect that handles spells or items that restore MP.
_battle_spell_effect_restore_mp:
    JSR _battle_calculate_damage                                                ; $03D9F9 | Calculate the damage value using the standard algorithm.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03D9FC |\
    CLC                                                                         ; $03D9FE | | Set the target's MP to their current MP plus the calculated value.
    LDA <r_battle_calculate_damage_result                                       ; $03D9FF | | If this new value exceeds their maximum, set their current MP to
    ADC r_character_battle_current_target.mp.w                                  ; $03DA01 | | their maximum MP.
    CMP r_character_battle_current_target.mp_max.w                              ; $03DA04 | |
    BCC +                                                                       ; $03DA07 | |
    LDA r_character_battle_current_target.mp_max.w                              ; $03DA09 | |
+   STA r_character_battle_current_target.mp.w                                  ; $03DA0C | |
    TDC                                                                         ; $03DA0F | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03DA10 |/
    LDA <r_battle_calculate_damage_result_hi                                    ; $03DA12 |\
    ORA #((BATTLE_DAMAGE_RESTORE | BATTLE_DAMAGE_UNKNOWN) >> 8).b               ; $03DA14 | | Set flags in the damage result to flag it as restoration.
    STA <r_battle_calculate_damage_result_hi                                    ; $03DA16 |/
    RTS                                                                         ; $03DA18

; _battle_spell_effect_restore_full_hp_mp ($03:DA19)
;
; Spell effect to handle items or spells that restore the target's HP and MP
; both to their maximum values.
_battle_spell_effect_restore_full_hp_mp:
    REP #FLAG_P_ACCUMULATOR                                                     ; $03DA19 |\
    LDA r_character_battle_current_target.hp_max.w                              ; $03DA1B | | Set the target's current HP to their maximum HP.
    STA r_character_battle_current_target.hp.w                                  ; $03DA1E |/
    LDA r_character_battle_current_target.mp_max.w                              ; $03DA21 |\
    STA r_character_battle_current_target.mp.w                                  ; $03DA24 | | Set the target's current MP to their maximum MP.
    TDC                                                                         ; $03DA27 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03DA28 |/
    RTS                                                                         ; $03DA2A

; _battle_spell_effect_damage_and_poison ($03:DA2B)
;
; Spell effect for a spell that uses the standard damage algorithm for spells
; and then also poisons the target. Falls through to the next routine, which
; actually handles setting the poison status.
_battle_spell_effect_damage_and_poison:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DA2B | Set the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DA2E |\
    BPL +                                                                       ; $03DA31 | | If the target absorbs any of the attack elements, switch to using
    AND #%01111111.b                                                            ; $03DA33 | | a handler that will restore the target (unless they're undead).
    STA r_battle_damage_element_multiplier.w                                    ; $03DA35 | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DA38 |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03DA3B | Set the element multiplier based on weakness.
    JSR _battle_calculate_damage                                                ; $03DA3E | Calculate the damage and fall through to set poison.

; _battle_command_helper_set_poison ($03:DA41)
;
; Sets the poison status effect on the current target, including setting the
; appropriate timers and the poison interval.
_battle_command_helper_set_poison:
    LDA r_character_battle_current_target.status_1.w                            ; $03DA41 |\
    ORA #STATUS_1_POISON.b                                                      ; $03DA44 | | Set the poison status on the target.
    STA r_character_battle_current_target.status_1.w                            ; $03DA46 |/
    LDA #TIMER_MODE_POISON.b                                                    ; $03DA49 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03DA4B | | Calculate and set the value for the poison timer.
    LDA <r_battle_command_target_true_slot                                      ; $03DA4D | |
    JSR _calculate_timer_value                                                  ; $03DA4F | |
    LDA #TIMER_OFFSET_POISON.b                                                  ; $03DA52 | |
    JSR _set_timer_value                                                        ; $03DA54 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03DA57 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03DA59 |/
    LDA <r_battle_command_target_true_slot                                      ; $03DA5C |\
    ASL A                                                                       ; $03DA5E | | Flag the poison timer as being enabled.
    TAX                                                                         ; $03DA5F | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03DA60 | |
    ORA #(TIMER_ENABLED_POISON >> 8).b                                          ; $03DA63 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03DA65 |/
    LDA <r_set_timer_value_arg_lo                                               ; $03DA68 |\
    STA r_battle_poison_interval.w + 0,X                                        ; $03DA6A | | Save the calculated poison interval for future use.
    LDA <r_set_timer_value_arg_hi                                               ; $03DA6D | |
    STA r_battle_poison_interval.w + 1,X                                        ; $03DA6F |/
    RTS                                                                         ; $03DA72

; _battle_spell_effect_damage_and_set_status ($03:DA73)
;
; Spell effect for a spell that damages and sets a status.
_battle_spell_effect_damage_and_set_status:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DA73 | Set the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DA76 |\
    BPL +                                                                       ; $03DA79 | | If the target absorbs any of the attack elements, switch to using
    AND #%01111111.b                                                            ; $03DA7B | | the routine which will restore the target (unless they're undead).
    STA r_battle_damage_element_multiplier.w                                    ; $03DA7D | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DA80 |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03DA83 | Set the element multiplier based on weakness.
    JSR _battle_calculate_damage                                                ; $03DA86 | Calculate damage.
    JMP _battle_spell_effect_set_status                                         ; $03DA89 | Set any status effects.

; _battle_spell_effect_damage_and_set_paralyze_sleep ($03:DA8C)
;
; Spell effect for a spell that damages the target and sets one of the paralyze
; or sleep statuses.
_battle_spell_effect_damage_and_set_paralyze_sleep:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DA8C | Set the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DA8F |\
    BPL +                                                                       ; $03DA92 | | If the target absorbs any of the attack elements, switch to using
    AND #%01111111.b                                                            ; $03DA94 | | the routine which will restore the target (unless they're undead).
    STA r_battle_damage_element_multiplier.w                                    ; $03DA96 | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DA99 |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03DA9C | Set the element multiplier based on weakness.
    JSR _battle_calculate_damage                                                ; $03DA9F | Calculate damage.
    LDA r_battle_command_actual_targets.w                                       ; $03DAA2 |\ Preserve the actual targets value, as the next routine may change
    PHA                                                                         ; $03DAA5 |/ it.
    JSR _battle_spell_effect_set_paralyze_sleep                                 ; $03DAA6 | Set the paralyze or sleep status effects.
    PLA                                                                         ; $03DAA9 |\ Restore the actual targets value, as the status effect doesn't
    STA r_battle_command_actual_targets.w                                       ; $03DAAA |/ change whether the spell hit or not.
    RTS                                                                         ; $03DAAD

; _battle_spell_effect_sylph ($03:DAAE)
;
; Spell effect that calculates a damage value using the normal algorithm and
; then splits that damage value among the party as HP restoration.
;
; NOTE: It's strange that they try to manipulate the MP within this function at
;       all. As far as I can tell, all they needed to do was not suppress the
;       actor copy back and let the MP be handled as normal. Perhaps they were
;       confused and thought that that would override the restoration value, but
;       the pending damage isn't processed until after the stats are copied back
;       anyway, so there's no conflict.
_battle_spell_effect_sylph:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DAAE | Set the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DAB1 |\
    BPL +                                                                       ; $03DAB4 | | If the target absorbs any of the attack elements, switch to a
    AND #%01111111.b                                                            ; $03DAB6 | | routine that will heal the target.
    STA r_battle_damage_element_multiplier.w                                    ; $03DAB8 | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DABB |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03DABE | Set the element multiplier based on weakness.
    JSR _battle_calculate_damage                                                ; $03DAC1 | Calculate the damage.
    LDA r_battle_calculate_damage_arg_split.w                                   ; $03DAC4 |\
    CMP r_battle_command_magic_target_count.w                                   ; $03DAC7 | | Skip the rest of the function if the split argument doesn't match
    BEQ +                                                                       ; $03DACA | | the target count. TODO: When would this happen?
    RTS                                                                         ; $03DACC |/
+   INC r_battle_skip_character_battle_actor.w                                  ; $03DACD | Skip copying the actor stats back to the main array.
    LDX <r_battle_calculate_damage_result                                       ; $03DAD0 |\ Preserve the initial value of the damage calculation result.
    PHX                                                                         ; $03DAD2 |/
    TDC                                                                         ; $03DAD3 |\ Initialize the X register to zero.
    TAX                                                                         ; $03DAD4 |/
    STX <r_battle_generic_tmp_1                                                 ; $03DAD5 | Initialize the current slot number to zero.
    STX <r_battle_generic_tmp_2                                                 ; $03DAD7 | Initialize the target count to zero.
    STX r_battle_spell_effect_sylph_character_targets.w + 0                     ; $03DAD9 |\
    STX r_battle_spell_effect_sylph_character_targets.w + 2                     ; $03DADC | | Initialize the character target flags to zero.
    STX r_battle_spell_effect_sylph_character_targets.w + 4                     ; $03DADF |/
-   LDX <r_battle_generic_tmp_1                                                 ; $03DAE2 | Load the current slot into the X register.
.if FF4_EASYTYPE != 1                                                           ;         |\
    LDA r_battle_slot_empty.w                                                   ; $03DAD7 | | Skip this slot if empty.
.else                                                                           ;         | |
    LDA r_battle_slot_empty.w,X                                                 ; $03DAE4 | | BUG: In the Japanese version, they didn't index this by X, so it
.endif                                                                          ;         | |      always checks slot zero. It was fixed for Easytype.
    BNE +                                                                       ; $03DAE7 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DAE9 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03DAEB | | Set the X register to the slot number times 128, or the offset
    LDA #_sizeof_character_battle.b                                             ; $03DAED | | into that slot's stat record.
    STA <r_math_multiply_8bit_arg_2                                             ; $03DAEF | |
    JSR _math_multiply_8bit                                                     ; $03DAF1 | |
    LDX <r_math_multiply_8bit_result                                            ; $03DAF4 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03DAF6 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03DAF9 | | Skip this slot if swooned or stoned.
    BNE +                                                                       ; $03DAFB |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03DAFD |\
    AND #STATUS_3_JUMPING.b                                                     ; $03DB00 | | Skip this slot if jumping.
    BNE +                                                                       ; $03DB02 |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03DB04 |\ Skip this slot if hiding.
    BMI +                                                                       ; $03DB07 |/
    INC <r_battle_generic_tmp_2_lo                                              ; $03DB09 | Otherwise, increment the target count.
    LDX <r_battle_generic_tmp_1                                                 ; $03DB0B |\ Set the flag that indicates this slot is a valid target.
    INC r_battle_spell_effect_sylph_character_targets.w,X                       ; $03DB0D |/
+   INC <r_battle_generic_tmp_1_lo                                              ; $03DB10 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DB12 | | Increment to the next slot and loop until all character slots have
    CMP #5.b                                                                    ; $03DB14 | | been examined.
    BNE -                                                                       ; $03DB16 |/
    LDX <r_battle_calculate_damage_result                                       ; $03DB18 |\
    STX r_math_divide_16bit_arg_1.w                                             ; $03DB1A | | Determine the amount to restore per character by taking the
    LDX <r_battle_generic_tmp_2                                                 ; $03DB1D | | initial damage calculation result and dividing by the number of
    STX r_math_divide_16bit_arg_2.w                                             ; $03DB1F | | valid targets as determined above.
    JSR _math_divide_16bit                                                      ; $03DB22 | |
    LDX r_math_divide_16bit_result.w                                            ; $03DB25 | |
    STX <r_battle_calculate_damage_result                                       ; $03DB28 |/
    TDC                                                                         ; $03DB2A |\ Initialize the X register to zero.
    TAX                                                                         ; $03DB2B |/
    STX <r_battle_generic_tmp_1                                                 ; $03DB2C | Initialize the current slot to zero.
-   LDX <r_battle_generic_tmp_1                                                 ; $03DB2E | Load the current slot into the X register.
    LDA r_battle_spell_effect_sylph_character_targets.w,X                       ; $03DB30 |\ Skip this slot if it wasn't flagged as a valid target.
    BEQ ++                                                                      ; $03DB33 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DB35 |\
    STA <r_math_multiply_8bit_arg_1.b                                           ; $03DB37 | | Calculate the offset to this slot's character battle record.
    LDA #_sizeof_character_battle.b                                             ; $03DB39 | | copy the actor's MP value back to the main record if it's Rydia.
    STA <r_math_multiply_8bit_arg_2.b                                           ; $03DB3B | |
    JSR _math_multiply_8bit                                                     ; $03DB3D |/
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
    REP #FLAG_P_ACCUMULATOR                                                     ; $03DB33 |\
    LDX <r_math_multiply_8bit_result                                            ; $03DB35 | | In the Japanese version, directly update each character's HP with
    CLC                                                                         ; $03DB37 | | the calculated restoration.
    LDA r_character_battle.1.hp.w,X                                             ; $03DB38 | |
    ADC <r_battle_calculate_damage_result                                       ; $03DB3B | | BUG: This code just ends up adding the restoration value twice.
    CMP r_character_battle.1.hp_max.w,X                                         ; $03DB3D | |      (Once here, and once through the regular code.)
    BCC +                                                                       ; $03DB40 | |
    LDA r_character_battle.1.hp_max.w,X                                         ; $03DB42 | | BUG: By removing this code in the USA release, they accidentally
+   STA r_character_battle.1.hp.w,X                                             ; $03DB45 | |      leave the X register without the character record offset,
    TDC                                                                         ; $03DB48 | |      leading the following function call to always check slot 0,
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03DB49 |/       as the multiply routine sets it to zero as a side effect.
.endif
.endif
    JSR _battle_command_helper_copy_rydia_mp                                    ; $03DB40 | Attempt to copy Rydia's MP back to the main record.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DB43 |\
    ASL A                                                                       ; $03DB45 | | Set the damage values for this slot and set the bit that flags
    TAX                                                                         ; $03DB46 | | them as restoration.
    LDA <r_battle_calculate_damage_result_lo                                    ; $03DB47 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03DB49 | |
    LDA <r_battle_calculate_damage_result_hi                                    ; $03DB4C | |
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03DB4E | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03DB50 |/
++  INC <r_battle_generic_tmp_1_lo                                              ; $03DB53 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DB55 | | Increment the slot and loop until all character slots have been
    CMP #5.b                                                                    ; $03DB57 | | handled.
    BNE -                                                                       ; $03DB59 |/
    PLX                                                                         ; $03DB5B
    STX <r_battle_calculate_damage_result                                       ; $03DB5C
    RTS                                                                         ; $03DB5E

; _battle_spell_effect_odin ($03:DB5F)
;
; Spell effect for the Odin Call spell. Has a 50% chance of killing all
; monsters.
_battle_spell_effect_odin:
    LDA #1.b                                                                    ; $03DB5F |\ Set the target count to 1, so this routine will not process again.
    STA r_battle_command_magic_target_count.w                                   ; $03DB61 |/ (This is the counter variable used by the magic processing.)
    JSR _get_battle_rng_0_98                                                    ; $03DB64 |\
    CMP #50.b                                                                   ; $03DB67 | | If a random number from 0 to 98 inclusive is less than 50, branch.
    BCC +                                                                       ; $03DB69 |/
    TDC                                                                         ; $03DB6B |\ Set the actual targets variable to reflect no hits.
    STA r_battle_command_actual_targets.w                                       ; $03DB6C |/
    TAX                                                                         ; $03DB6F |\ Initialize the slot offset and slot to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03DB70 |/
-   JSR _battle_command_helper_copy_rydia_mp                                    ; $03DB72 | Update the MP of the current slot if it's Rydia. NOTE: Pointless.
    JSR _increment_x_by_128                                                     ; $03DB75 |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03DB78 | | Increment the indexes and loop until all five slots have been
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DB7A | | checked.
    CMP #5.b                                                                    ; $03DB7C | |
    BNE -                                                                       ; $03DB7E |/
    RTS                                                                         ; $03DB80 |
+   LDA r_character_battle_current_target.status_1.w                            ; $03DB81 |\
    ORA #STATUS_1_SWOON.b                                                       ; $03DB84 | | Set the swoon status on the target.
    STA r_character_battle_current_target.status_1.w                            ; $03DB86 |/
    STZ <r_battle_generic_tmp_2_lo                                              ; $03DB89 | Initialize the monster number to zero.
    LDA r_battle_command_available_targets.w                                    ; $03DB8B |\ Copy the available target value to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03DB8E |/
-   ASL <r_battle_generic_tmp_1_lo                                              ; $03DB90 |\ If the next bit in the targeting value is not set, skip this
    BCC +                                                                       ; $03DB92 |/ monster.
    CLC                                                                         ; $03DB94 |\
    LDA <r_battle_generic_tmp_2_lo                                              ; $03DB95 | | Add five to the monster slot and multiply by 128 to determine the
    ADC #5.b                                                                    ; $03DB97 | | offset into the stat record.
    STA <r_math_multiply_8bit_arg_1                                             ; $03DB99 | |
    LDA #_sizeof_character_battle.b                                             ; $03DB9B | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03DB9D | |
    JSR _math_multiply_8bit                                                     ; $03DB9F | |
    LDX <r_math_multiply_8bit_result                                            ; $03DBA2 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03DBA4 |\
    ORA #STATUS_1_SWOON.b                                                       ; $03DBA7 | | Set the swoon status on the monster.
    STA r_character_battle.1.status_1.w,X                                       ; $03DBA9 |/
+   INC <r_battle_generic_tmp_2                                                 ; $03DBAC |\
    LDA <r_battle_generic_tmp_2                                                 ; $03DBAE | | Increment the slot and loop until all monsters have been checked.
    CMP #8.b                                                                    ; $03DBB0 | |
    BNE -                                                                       ; $03DBB2 |/
    RTS                                                                         ; $03DBB4

; _battle_spell_effect_count ($03:DBB5)
;
; Spell effect for spells that set the count status effect. Sets the count timer
; directly to the spell's power.
_battle_spell_effect_count:
    LDA r_character_battle_current_target.status_3.w                            ; $03DBB5 |\
    ORA #STATUS_3_COUNT.b                                                       ; $03DBB8 | | Set the count status on the target.
    STA r_character_battle_current_target.status_3.w                            ; $03DBBA |/
    LDA <r_battle_command_target_true_slot                                      ; $03DBBD |\
    JSR _calculate_offsets                                                      ; $03DBBF | | Set the timer value to the spell power.
    LDA #TIMER_OFFSET_COUNT.b                                                   ; $03DBC2 | |
    JSR _add_timer_offset                                                       ; $03DBC4 | |
    LDX r_add_timer_offset_result.w                                             ; $03DBC7 | |
    LDA r_current_spell_properties.data.power.w                                 ; $03DBCA | |
    STA r_battle_timers.1.value_lo.w,X                                          ; $03DBCD | |
    STZ r_battle_timers.1.value_hi.w,X                                          ; $03DBD0 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03DBD3 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03DBD5 |/
    LDA <r_battle_command_target_true_slot                                      ; $03DBD8 |\
    ASL A                                                                       ; $03DBDA | | Flag this slot's count timer as enabled.
    TAX                                                                         ; $03DBDB | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03DBDC | |
    ORA #(TIMER_ENABLED_COUNT >> 8).b                                           ; $03DBDF | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03DBE1 |/
    RTS                                                                         ; $03DBE4

; _battle_spell_effect_target_hp ($03:DBE5)
;
; Handles spells that calculate damage as a percentage of the target's HP. The
; spell's power specifies the divisor the maximum HP is divided by. If the
; target is weak to the spell's element, the divisor is divided by two. If the
; target resists or is immune, the divisor is set to 10.
_battle_spell_effect_target_hp:
    LDA r_current_spell_properties.data.power.w                                 ; $03DBE5 |\ Copy the spell's power to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03DBE8 |/
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DBEA | Calculate the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DBED |\
    BPL +                                                                       ; $03DBF0 | | If the target absorbs one of the spell's elements, switch to using
    AND #%01111111.b                                                            ; $03DBF2 | | a routine that restores instead.
    STA r_battle_damage_element_multiplier.w                                    ; $03DBF4 | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DBF7 |/
+   JSR _battle_spell_set_element_multiplier_weakness                           ; $03DBFA | Set the element multiplier based on weakness.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DBFD |\
    CMP #2.b                                                                    ; $03DC00 | | Set the divisor. The initial value is the spell's power. If the
    BCS +                                                                       ; $03DC02 | | target is immune to or resists an attacking element, the divisor
    LDA #10.b                                                                   ; $03DC04 | | is set to a fixed value of 10. If the target is weak or strongly
    STA <r_battle_generic_tmp_1_lo                                              ; $03DC06 | | weak to the element, the spell's power is divided by two.
    BRA ++                                                                      ; $03DC08 | |
+   CMP #4.b                                                                    ; $03DC0A | |
    BCC ++                                                                      ; $03DC0C | |
    LSR <r_battle_generic_tmp_1_lo                                              ; $03DC0E |/
++  LDA <r_battle_generic_tmp_1_lo                                              ; $03DC10 |\
    TAX                                                                         ; $03DC12 | | Calculate the actual damage by dividing the target's maximum HP
    STX r_math_divide_16bit_arg_2.w                                             ; $03DC13 | | by the calculated divisor. In summary, the default value is the
    LDA r_character_battle_current_target.hp_max_lo.w                           ; $03DC16 | | maximum HP divided by the spell power. If the target is weak, the
    STA r_math_divide_16bit_arg_1_lo.w                                          ; $03DC19 | | value is the maximum HP divided by half the spell power. If the
    LDA r_character_battle_current_target.hp_max_hi.w                           ; $03DC1C | | target is immune or resistant, the value is the maximum HP divided
    STA r_math_divide_16bit_arg_1_hi.w                                          ; $03DC1F | | by 10.
    JSR _math_divide_16bit                                                      ; $03DC22 | |
    LDX r_math_divide_16bit_result.w                                            ; $03DC25 | |
    STX <r_battle_calculate_damage_result                                       ; $03DC28 |/
    RTS                                                                         ; $03DC2A

; _battle_spell_effect_set_partial_stone ($03:DC2B)
;
; Spell effect for spells that set the partial stone status. Increments the
; stone status bits and sets the stone status timer. Also sets full stone if the
; stone status reaches maximum.
_battle_spell_effect_set_partial_stone:
    JSR _battle_spell_set_element_multiplier_immune_resistance                  ; $03DC2B | Set the element multiplier based on immunity and resistance.
    LDA r_battle_damage_element_multiplier.w                                    ; $03DC2E |\
    BPL +                                                                       ; $03DC31 | | If the target absorbs an attack element, switch to using a routine
    AND #%01111111.b                                                            ; $03DC33 | | that restores HP.
    STA r_battle_damage_element_multiplier.w                                    ; $03DC35 | |
    JMP _battle_spell_effect_restore_if_not_undead                              ; $03DC38 |/
+   LDA r_character_battle_current_target.status_2_immunity.w                   ; $03DC3B |\
    AND r_current_spell_properties.element_status.status_2.w                    ; $03DC3E | | If the target is immune to the attack status, unset the target and
    BEQ +                                                                       ; $03DC41 | | return.
    JMP _battle_unset_target                                                    ; $03DC43 |/
+   LDA r_character_battle_current_target.status_2.w                            ; $03DC46 |\
    AND #STATUS_2_STONE_STATUS.b ~ %11111111                                    ; $03DC49 | | Save the target's second byte statuses other than stone.
    STA <r_battle_generic_tmp_1_hi                                              ; $03DC4B |/
    LDA r_character_battle_current_target.status_2.w                            ; $03DC4D |\
    AND #STATUS_2_STONE_STATUS.b                                                ; $03DC50 | | Mask out the target's current stone status and add one.
    CLC                                                                         ; $03DC52 | |
    ADC #1.b                                                                    ; $03DC53 |/
    CMP #4.b                                                                    ; $03DC55 |\
    BCC +                                                                       ; $03DC57 | | If the value reaches four, set the stone status to zero and
    LDA <r_battle_generic_tmp_1_hi                                              ; $03DC59 | | switch to a routine that will explicitly set the full stone
    STA r_character_battle_current_target.status_2.w                            ; $03DC5B | | status.
    JMP _battle_spell_effect_set_status                                         ; $03DC5E |/
+   ORA <r_battle_generic_tmp_1_hi                                              ; $03DC61 |\ Otherwise, add in the non-stone status bits, and save back to the
    STA r_character_battle_current_target.status_2.w                            ; $03DC63 |/ stat record.
    LDA #TIMER_MODE_STONE.b                                                     ; $03DC66 |\
    STA <r_calculate_timer_value_arg_mode                                       ; $03DC68 | | Calculate the stone timer value.
    LDA <r_battle_command_target_true_slot                                      ; $03DC6A | |
    JSR _calculate_timer_value                                                  ; $03DC6C |/
    LDA #TIMER_OFFSET_STONE.b                                                   ; $03DC6F |\ Set the timer value.
    JSR _set_timer_value                                                        ; $03DC71 |/
    LDA #TIMER_FLAG_STATUS.b                                                    ; $03DC74 |\ Flag the timer as being status-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03DC76 |/
    LDA <r_battle_command_target_true_slot                                      ; $03DC79 |\
    ASL A                                                                       ; $03DC7B | | Flag the stone timer as being enabled.
    TAX                                                                         ; $03DC7C | |
    LDA r_battle_enabled_timers.1.hi.w,X                                        ; $03DC7D | |
    ORA #(TIMER_ENABLED_STONE >> 8).b                                           ; $03DC80 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03DC82 |/
    LDA <r_set_timer_value_arg_lo                                               ; $03DC85 |\
    STA r_battle_stone_interval.w + 0,X                                         ; $03DC87 | | Save the stone duration to memory to use when refreshing the
    LDA <r_set_timer_value_arg_hi                                               ; $03DC8A | | timer.
    STA r_battle_stone_interval.w + 1,X                                         ; $03DC8C |/
    RTS                                                                         ; $03DC8F

; _battle_spell_effect_gaze ($03:DC90)
;
; Spell effect for the Gaze monster spell, which sets a random status of either
; paralyze, sleep or confuse.
_battle_spell_effect_gaze:
    LDX #3.w                                                                    ; $03DC90 |\
    LDA #5.b                                                                    ; $03DC93 | | Set the Y register to a random number between 3 and 5.
    JSR _get_battle_rng                                                         ; $03DC95 | |
    TAY                                                                         ; $03DC98 |/
    STA r_battle_generic_tmp_1_lo.w                                             ; $03DC99 | Save the random value to a variable.
    SEC                                                                         ; $03DC9C |\
-   ROR r_current_spell_properties.element_status.status_2.w                    ; $03DC9D | | Rotate the bit into the second status byte the number of times
    DEY                                                                         ; $03DCA0 | | specified in the Y register.
    BNE -                                                                       ; $03DCA1 |/
    LDA r_battle_generic_tmp_1_lo.w                                             ; $03DCA3 |\
    CMP #5.b                                                                    ; $03DCA6 | | If the chosen status was either paralyze or sleep, call the
    BEQ +                                                                       ; $03DCA8 | | paralyze/sleep handler.
    JMP _battle_spell_effect_set_paralyze_sleep                                 ; $03DCAA |/
+   JMP _battle_spell_effect_set_status_swoon_undead                            ; $03DCAD | Otherwise, call the generic status handler.

; _battle_spell_effect_bluster ($03:DCB0)
;
; Spell effect for the Bluster spell, which has a 50% chance of causing swoon,
; and a 50% chance of causing paralyze.
_battle_spell_effect_bluster:
    LDX #0.w                                                                    ; $03DCB0 |\
    LDA #1.b                                                                    ; $03DCB3 | | Set the X register to a random number from 0 to 1.
    JSR _get_battle_rng                                                         ; $03DCB5 | |
    TAX                                                                         ; $03DCB8 |/
    BNE +                                                                       ; $03DCB9 |\
    LDA #STATUS_1_SWOON.b                                                       ; $03DCBB | | If the result was zero, call a routine to set the swoon status on
    STA r_current_spell_properties.element_status.status_1.w                    ; $03DCBD | | the target.
    JMP _battle_spell_effect_set_status_swoon_undead.w                          ; $03DCC0 |/
+   LDA #STATUS_2_PARALYZE.b                                                    ; $03DCC3 |\
    STA r_current_spell_properties.element_status.status_2.w                    ; $03DCC5 | | Otherwise, set the paralyze status.
    JMP _battle_spell_effect_set_paralyze_sleep                                 ; $03DCC8 |/

; _battle_spell_effect_slap ($03:DCCB)
;
; Spell effect for the Slap spell, which sets either paralyze, mute or curse
; with an equal probability of each.
_battle_spell_effect_slap:
    LDX #0.w                                                                    ; $03DCCB |\
    LDA #2.b                                                                    ; $03DCCE | | Select a random number from 0 to 2, inclusive.
    JSR _get_battle_rng                                                         ; $03DCD0 | |
    TAX                                                                         ; $03DCD3 |/
    BNE +                                                                       ; $03DCD4 |\
    LDA #STATUS_2_PARALYZE.b                                                    ; $03DCD6 | | If the selected value was zero, set the paralyze status on the
    STA r_current_spell_properties.element_status.status_2.w                    ; $03DCD8 | | target.
    JMP _battle_spell_effect_set_paralyze_sleep                                 ; $03DCDB |/
+   DEC A                                                                       ; $03DCDE |\
    BNE +                                                                       ; $03DCDF | | If the value was one, set the mute status.
    LDA #STATUS_1_MUTE.b                                                        ; $03DCE1 | |
    STA r_current_spell_properties.element_status.status_1.w                    ; $03DCE3 | |
    BRA ++                                                                      ; $03DCE6 |/
+   LDA #STATUS_2_CURSE.b                                                       ; $03DCE8 |\
    STA r_current_spell_properties.element_status.status_2.w                    ; $03DCEA | | Otherwise, set the curse status.
++  JMP _battle_spell_effect_set_status_swoon_undead                            ; $03DCED |/

; _battle_spell_effect_blast ($03:DCF0)
;
; Spell effect for the Blast spell, which sets paralyze and sap on the target.
_battle_spell_effect_blast:
    LDA #STATUS_2_PARALYZE.b                                                    ; $03DCF0 |\
    STA r_current_spell_properties.element_status.status_2.w                    ; $03DCF2 | | Set the paralyze status on the target.
    JSR _battle_spell_effect_set_paralyze_sleep                                 ; $03DCF5 |/
    JMP _battle_spell_effect_helper_set_sap                                     ; $03DCF8 | Set the sap status on the target.

; _battle_spell_effect_hug ($03:DCFB)
;
; Spell effect for the Hug spell, which fully cures the target and then sets the
; stone status.
_battle_spell_effect_hug:
    REP #FLAG_P_ACCUMULATOR                                                     ; $03DCFB |\
    SEC                                                                         ; $03DCFD | | Set the damage value to the difference between the target's
    LDA r_character_battle_current_target.hp_max.w                              ; $03DCFE | | maximum HP and their current HP.
    SBC r_character_battle_current_target.hp.w                                  ; $03DD01 | |
    STA <r_battle_calculate_damage_result                                       ; $03DD04 | |
    TDC                                                                         ; $03DD06 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03DD07 |/
    LDA <r_battle_calculate_damage_result_hi                                    ; $03DD09 |\
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03DD0B | | Set the restore bit on the damage so it's treated as healing.
    STA <r_battle_calculate_damage_result_hi                                    ; $03DD0D |/
    JMP _battle_spell_effect_set_status                                         ; $03DD0F | Set any statuses set in this spell's status bits.

; _battle_spell_effect_explode ($03:DD12)
;
; Spell effect for Explode and similar spells, that cause damage equal to the
; actor's current HP and kill the actor.
_battle_spell_effect_explode:
    LDA #BATTLE_MONSTER_TRANSITION_EXPLODE.b                                    ; $03DD12 |\ Set the special transition to explode.
    STA r_battle_monster_special_transition.w                                   ; $03DD14 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03DD17 |\
    LDA r_character_battle_current_actor.hp.w                                   ; $03DD19 | | Set the damage to the actor's current HP.
.if FF4_VERSION != "JAPAN"                                                      ;         | |
.if FF4_VERSION != "JAPAN_REV_1"                                                ;         | | For USA Rev 1 and Easytype, if the actor's HP is greater than
.if FF4_VERSION != "USA"                                                        ;         | | 9999, reset the damage to 9999.
    CMP #9999.w                                                                 ; $03DD1C | |
    BCC +                                                                       ; $03DD1F | |
    LDA #9999.w                                                                 ; $03DD21 | |
.endif                                                                          ;         | |
.endif                                                                          ;         | |
.endif                                                                          ;         | |
+   STA <r_battle_calculate_damage_result                                       ; $03DD24 | |
    TDC                                                                         ; $03DD26 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03DD27 |/
    LDA #STATUS_1_SWOON.b                                                       ; $03DD29 |\ Set swoon status on the actor.
    STA r_character_battle_current_actor.status_1.w                             ; $03DD2B |/
    RTS                                                                         ; $03DD2E

; _battle_spell_effect_reaction ($03:DD2F)
;
; Spell effect for the Reaction monster spell, which kills both the actor and
; all monsters.
_battle_spell_effect_reaction:
    LDA #BATTLE_MONSTER_TRANSITION_EXPLODE.b                                    ; $03DD2F |\ TODO: Set an unknown variable to 5.
    STA r_battle_monster_special_transition.w                                   ; $03DD31 |/
    LDA #STATUS_1_SWOON.b                                                       ; $03DD34 |\ Set the swoon status on the actor.
    STA r_character_battle_current_actor.status_1.w                             ; $03DD36 |/
    STA r_character_battle_current_target.status_1.w                            ; $03DD39 | Set the swoon status on the target.
    LDX #_sizeof_character_battle.w * 5                                         ; $03DD3C | Initialize the X register to the offset to the first monster slot.
    LDY #8.w                                                                    ; $03DD3F | Set the Y register to eight.
-   LDA #STATUS_1_SWOON.b                                                       ; $03DD42 |\ Set the swoon status on the current monster.
    STA r_character_battle.1.status_1.w,X                                       ; $03DD44 |/
    JSR _increment_x_by_128                                                     ; $03DD47 |\
    DEY                                                                         ; $03DD4A | | Increment the X register and loop until all monsters are done.
    BNE -                                                                       ; $03DD4B |/
    RTS                                                                         ; $03DD4D

; _battle_spell_effect_* ($03:DD4E)
;
; A series of two spell effects that restore the target based on either its
; maximum or current HP. Specifically, the remedy version restores the target
; by its maximum HP divided by ten. The absorb version restores the target by
; one-third of its current HP.
_battle_spell_effect_remedy:
    LDA r_character_battle_current_target.hp_max_lo.w                           ; $03DD4E |\
    STA r_math_divide_16bit_arg_1_lo.w                                          ; $03DD51 | | Load the arguments to divide the target's maximum HP by 10 and
    LDA r_character_battle_current_target.hp_max_hi.w                           ; $03DD54 | | branch to the main function.
    STA r_math_divide_16bit_arg_1_hi.w                                          ; $03DD57 | |
    LDX #10.w                                                                   ; $03DD5A | |
    STX r_math_divide_16bit_arg_2.w                                             ; $03DD5D | |
    BRA _battle_spell_effect_target_hp_restore                                  ; $03DD60 |/
_battle_spell_effect_absorb:
    LDA r_character_battle_current_target.hp_lo.w                               ; $03DD62 |\
    STA r_math_divide_16bit_arg_1_lo.w                                          ; $03DD65 | | Load the arguments to divide the target's current HP by 3 and
    LDA r_character_battle_current_target.hp_hi.w                               ; $03DD68 | | fall through to the main function.
    STA r_math_divide_16bit_arg_1_hi.w                                          ; $03DD6B | |
    LDX #3.w                                                                    ; $03DD6E | |
    STX r_math_divide_16bit_arg_2.w                                             ; $03DD71 |/
_battle_spell_effect_target_hp_restore:
+   JSR _math_divide_16bit                                                      ; $03DD74 | Execute the division.
    LDX r_math_divide_16bit_result.w                                            ; $03DD77 |\
    CPX #9999.w                                                                 ; $03DD7A | | If the result is greater than 9999, set the result explicitly to
    BCC +                                                                       ; $03DD7D | | 9999.
    LDX #9999.w                                                                 ; $03DD7F | |
    STX r_math_divide_16bit_result.w                                            ; $03DD82 |/
+   LDA r_math_divide_16bit_result_lo.w                                         ; $03DD85 |\
    STA <r_battle_calculate_damage_result_lo                                    ; $03DD88 | | Store the value in the calculated damage value and set the bit
    LDA r_math_divide_16bit_result_hi.w                                         ; $03DD8A | | that flags it as restoration.
    ORA #(BATTLE_DAMAGE_RESTORE >> 8).b                                         ; $03DD8D | |
    STA <r_battle_calculate_damage_result_hi                                    ; $03DD8F |/
    RTS                                                                         ; $03DD91

; _battle_spell_effect_damage_and_set_status_swoon_undead ($03:DD92)
;
; This spell effect executes a standard spell attack and then sets any set
; status bits, including skipping the check that prevents the undead from being
; swooned.
_battle_spell_effect_damage_and_set_status_swoon_undead:
    JSR _battle_spell_effect_standard_attack                                    ; $03DD92 | Process the spell as a normal attack.
    JMP _battle_spell_effect_set_status_swoon_undead                            ; $03DD95 | Set any statuses, including swooning the undead.

; _battle_spell_effect_alert ($03:DD98)
;
; This spell effect searches for the first empty monster slot and calls a
; routine to revive the monster in that slot using the type index of 1.
_battle_spell_effect_alert:
    INC r_battle_monster_special_transition.w                                   ; $03DD98 | Set the special transition to alert.
    TDC                                                                         ; $03DD9B |\ Initialize the X register to zero.
    TAX                                                                         ; $03DD9C |/
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03DD9D |\
    CMP #$FF.b                                                                  ; $03DDA0 | | If this slot is empty, branch ahead to the revive code.
    BEQ +                                                                       ; $03DDA2 |/
    INX                                                                         ; $03DDA4 |\ Loop checking the next slot.
    BRA -                                                                       ; $03DDA5 |/
+   STX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DDA7 |\
    LDA #1.b                                                                    ; $03DDA9 | | Revive the monster in the found slot with type index 1.
    JMP _battle_helper_revive_monster                                           ; $03DDAB |/

; _battle_spell_effect_zeromus_disrupt ($03:DDAE)
;
; This spell effect removes the float, berserk, wall, barrier and image statuses
; from the target and reset's the target's speed modifier back to the default
; value of 16.
_battle_spell_effect_zeromus_disrupt:
    LDA r_character_battle_current_target.status_2.w                            ; $03DDAE |\ Copy the target's second status byte to another variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03DDB1 |/ TODO: Why?
    AND #(STATUS_2_FLOAT | STATUS_2_BERSERK).b ~ %11111111                      ; $03DDB3 |\ Remove the float and berserk statuses and save the result back.
    STA r_character_battle_current_target.status_2.w                            ; $03DDB5 |/
    LDA r_character_battle_current_target.status_4.w                            ; $03DDB8 |\
    AND #(STATUS_4_WALL | STATUS_4_BARRIER | STATUS_4_IMAGE).b ~ %11111111      ; $03DDBB | | Remove the wall, barrier and image statuses.
    STA r_character_battle_current_target.status_4.w                            ; $03DDBD |/
    LDA #16.b                                                                   ; $03DDC0 |\ Reset the speed modifier back to the default value of 16.
    STA r_character_battle_current_target.speed_modifier.w                      ; $03DDC2 |/
    RTS                                                                         ; $03DDC5

; _battle_spell_effect_needle ($03:DDC6)
;
; This spell effect essentially does a standard non-elemental spell, using
; double the actor's physical attack base as the attack power per hit.
_battle_spell_effect_needle:
    LDA r_character_battle_current_actor.physical_attack_base.w                 ; $03DDC6 |\
    TAX                                                                         ; $03DDC9 | | Transfer the actor's physical attack power to the attack power.
    STX r_battle_damage_attack_power.w                                          ; $03DDCA |/
    ASL r_battle_damage_attack_power_lo.w                                       ; $03DDCD |\ Multiply the attack power by two.
    ROL r_battle_damage_attack_power_hi.w                                       ; $03DDD0 |/
    JMP _battle_calculate_damage                                                ; $03DDD3 | Calculate damage using the standard damage algorithm.

; _battle_spell_effect_increment_monsters_invincible ($03:DDD6)
;
; This spell effect increments the monster invincibility flag. It falls through
; to the next effect, which does nothing but return.
_battle_spell_effect_increment_monsters_invincible:
    INC r_monsters_invincible.w                                                 ; $03DDD6 | Increment the monster invincibility flag.

; _battle_spell_effect_do_nothing ($03:DDD9)
;
; This spell effect does nothing as far as damage calculation.
_battle_spell_effect_do_nothing:
    RTS                                                                         ; $03DDD9 | Return, doing nothing.

; _battle_spell_effect_decrement_monsters_invincible ($03:DDDA)
;
; This spell effect decrements the monster invincibility flag.
_battle_spell_effect_decrement_monsters_invincible:
    DEC r_monsters_invincible.w                                                 ; $03DDDA | Decrement the monster invincibility flag.
    RTS                                                                         ; $03DDDD

; _battle_spell_effect_recover ($03:DDDE)
;
; This spell effect fully recovers the target's HP. If the target is swooned,
; it will be revived and all status effects removed.
_battle_spell_effect_recover:
    LDA #BATTLE_MONSTER_TRANSITION_LIFE.b                                       ; $03DDDE |\ Set the special transition to life.
    STA r_battle_monster_special_transition.w                                   ; $03DDE0 |/
    LDA r_character_battle_current_target.status_1.w                            ; $03DDE3 |\ If the target doesn't have the swoon status, branch ahead to the
    BPL +                                                                       ; $03DDE6 |/ next section.
    STZ r_character_battle_current_target.status_1.w                            ; $03DDE8 |\
    STZ r_character_battle_current_target.status_2.w                            ; $03DDEB | | Unset all status effects from the target.
    STZ r_character_battle_current_target.status_3.w                            ; $03DDEE | |
    STZ r_character_battle_current_target.status_4.w                            ; $03DDF1 |/
    STZ <r_calculate_timer_value_arg_mode                                       ; $03DDF4 |\
    LDA <r_battle_command_target_true_slot                                      ; $03DDF6 | | Calculate the value for the target's action timer using its
    JSR _calculate_timer_value                                                  ; $03DDF8 | | relative speed and use that value to set the target's action
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03DDFB | | timer.
    JSR _set_timer_value                                                        ; $03DDFD |/
    STZ r_battle_timers.1.flags.w,X                                             ; $03DE00 | Unset any flags for the timer.
    LDA r_calculate_offsets_slot.w                                              ; $03DE03 |\
    ASL A                                                                       ; $03DE06 | | Flag the action timer as being enabled.
    TAX                                                                         ; $03DE07 | |
    LDA #(TIMER_ENABLED_ACTION >> 8).b                                          ; $03DE08 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03DE0A |/
    LDA <r_battle_command_target_true_slot                                      ; $03DE0D |\
    CMP #5.b                                                                    ; $03DE0F | | If the target is a monster, update the slot to type index map and
    BCC +                                                                       ; $03DE11 | | increment the monsters remaining count.
    SEC                                                                         ; $03DE13 | |
    SBC #5.b                                                                    ; $03DE14 | |
    TAX                                                                         ; $03DE16 | |
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $03DE17 | |
    STA r_monster_slot_to_id_index.w,X                                          ; $03DE1A | |
    TAX                                                                         ; $03DE1D | |
    INC r_monsters_remaining.w,X                                                ; $03DE1E | |
    INC r_monsters_remaining_total.w                                            ; $03DE21 |/
+   LDA r_character_battle_current_target.hp_max_lo.w                           ; $03DE24 |\
    STA r_character_battle_current_target.hp_lo.w                               ; $03DE27 | | Set the target's current HP to the value of their maximum HP.
    LDA r_character_battle_current_target.hp_max_hi.w                           ; $03DE2A | |
    STA r_character_battle_current_target.hp_hi.w                               ; $03DE2D |/
    RTS                                                                         ; $03DE30

; _battle_spell_effect_transition ($03:DE31)
;
; This spell effect transitions between two monsters or sets of monsters. It
; has two primary modes of operation.
;
; If any of the monsters starts out dead, it then checks to see if a monster of
; the first type is alive. If so, it kills any monsters of the first type and
; revives any monsters of the second and third types. Otherwise, it will kill
; any monsters of the second and third types and revive any monsters of the
; first type.
;
; If none of the monsters starts out dead, it will check to see if a monster of
; the third type is alive. If so, it kills all monsters of the third type and
; revives all monsters of the first and second types. Otherwise, it kills all
; monsters of the first and second types and revives all monsters of the third
; type.
_battle_spell_effect_transition:
    LDA #BATTLE_MONSTER_TRANSITION_SWAP.b                                       ; $03DE31 |\ Set the special transition type to swap.
    STA r_battle_monster_special_transition.w                                   ; $03DE33 |/
    INC r_battle_monster_suppress_death_count.w                                 ; $03DE36 | Set the flag to prevent the death count from being incremented.
    LDA r_character_battle_current_actor.status_1.w                             ; $03DE39 |\
    ORA #STATUS_1_SWOON.b                                                       ; $03DE3C | | Set the swoon status on the actor.
    STA r_character_battle_current_actor.status_1.w                             ; $03DE3E |/
    LDA r_character_battle_current_target.status_1.w                            ; $03DE41 |\
    ORA #STATUS_1_SWOON.b                                                       ; $03DE44 | | Set the swoon status on the target.
    STA r_character_battle_current_target.status_1.w                            ; $03DE46 |/
    LDA r_formation_properties.monster_counts.w                                 ; $03DE49 |\ Load the formation's monster counts byte and save it to a local
    STA <r_battle_generic_tmp_1_lo                                              ; $03DE4C |/ variable.
    AND #%00000011.b                                                            ; $03DE4E |\
    CMP #%00000011.b                                                            ; $03DE50 | | If none of the monsters starts out dead, switch to the code to
    BNE +                                                                       ; $03DE52 | | handle that.
    JMP @all_alive                                                              ; $03DE54 |/
+   TDC                                                                         ; $03DE57 |\
    TAX                                                                         ; $03DE58 | | Initialize the count to zero.
    STX <r_battle_generic_tmp_2                                                 ; $03DE59 |/
    CLC                                                                         ; $03DE5B |\
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03DE5C | | Add the type indexes of all living monsters and leave the result
    BMI +                                                                       ; $03DE5F | | in $AB. (If only one monster is ever alive at the same time,
    ADC <r_battle_generic_tmp_2_lo                                              ; $03DE61 | | however, this will store the type index of the living monster.)
    STA <r_battle_generic_tmp_2_lo                                              ; $03DE63 | |
+   INX                                                                         ; $03DE65 | |
    CPX #8.w                                                                    ; $03DE66 | |
    BNE -                                                                       ; $03DE69 |/
    LDA <r_battle_generic_tmp_2_lo                                              ; $03DE6B |\ If any monster other than the first type is alive, branch to other
    BNE @non_first_alive                                                        ; $03DE6D |/ code.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DE6F |\
    AND #%11000000.b                                                            ; $03DE71 | | Set the slot parameter to the first slot used for the second type
    JSR _math_divide_by_64                                                      ; $03DE73 | | (by using the count of monsters for the first type).
    TAX                                                                         ; $03DE76 | |
    STX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DE77 |/
    STZ <r_battle_helper_set_monster_type_swoon_arg_type_1                      ; $03DE79 |\
    STZ <r_battle_helper_set_monster_type_swoon_arg_type_2                      ; $03DE7B | | Kill all monsters of the first type.
    JSR _battle_helper_set_monster_type_swoon                                   ; $03DE7D |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DE80 |\
    AND #%00110000.b                                                            ; $03DE82 | | Initialize the counter to the number of monsters of the second
    JSR _math_divide_by_16                                                      ; $03DE84 | | type.
    TAX                                                                         ; $03DE87 | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DE88 |/
    BEQ +                                                                       ; $03DE8A |\
-   LDA #1.b                                                                    ; $03DE8C | | If the count is greater than zero, revive all monsters of the
    JSR _battle_helper_revive_monster                                           ; $03DE8E | | second type.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DE91 | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DE93 | |
    BNE -                                                                       ; $03DE95 |/
+   LDA r_formation_properties.monster_counts.w                                  ; $03DE97 |\
    AND #%00001100.b                                                            ; $03DE9A | | Set the counter to the number of monsters of the third type.
    JSR _math_divide_by_4                                                       ; $03DE9C | |
    TAX                                                                         ; $03DE9F | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DEA0 |/
    BEQ +                                                                       ; $03DEA2 |\
-   LDA #2.b                                                                    ; $03DEA4 | | If the count is greater than zero, revive all monsters of the
    JSR _battle_helper_revive_monster                                           ; $03DEA6 | | third type.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DEA9 | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DEAB | |
    BNE -                                                                       ; $03DEAD |/
+   JMP @done                                                                   ; $03DEAF | Branch to the end.
@non_first_alive:
    LDA #1.b                                                                    ; $03DEB2 |\
    STA <r_battle_helper_set_monster_type_swoon_arg_type_1                      ; $03DEB4 | | Kill all monsters of the second and third types.
    INC A                                                                       ; $03DEB6 | |
    STA <r_battle_helper_set_monster_type_swoon_arg_type_2                      ; $03DEB7 | |
    JSR _battle_helper_set_monster_type_swoon                                   ; $03DEB9 |/
    TDC                                                                         ; $03DEBC |\
    TAX                                                                         ; $03DEBD | | Set the first revival slot to the first slot.
    STX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DEBE |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DEC0 |\
    AND #%11000000.b                                                            ; $03DEC2 | | Initialize the counter to the number of first type monsters.
    JSR _math_divide_by_64                                                      ; $03DEC4 | |
    TAX                                                                         ; $03DEC7 | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DEC8 |/
-   LDA #0.b                                                                    ; $03DECA |\
    JSR _battle_helper_revive_monster                                           ; $03DECC | | Revive all monsters of the first type.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DECF | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DED1 | |
    BNE -                                                                       ; $03DED3 |/
    JMP @done                                                                   ; $03DED5 | Branch to the end.
@all_alive:
    TDC                                                                         ; $03DED8 |\ Initialize the X register to zero.
    TAX                                                                         ; $03DED9 |/
    CLC                                                                         ; $03DEDA |\
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03DEDB | | Search the living monsters for a monster of the third type in the
    CMP #2.b                                                                    ; $03DEDE | | battle. If found, branch to another section later in the routine.
    BNE +                                                                       ; $03DEE0 | | Otherwise, continue.
    BRA @living_third_type                                                      ; $03DEE2 | |
+   INX                                                                         ; $03DEE4 | |
    CPX #8.w                                                                    ; $03DEE5 | |
    BNE -                                                                       ; $03DEE8 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DEEA |\
    AND #%11000000.b                                                            ; $03DEEC | | Extract the original count of monsters of the first type and save
    JSR _math_divide_by_64                                                      ; $03DEEE | | it to another variable.
    STA r_battle_generic_tmp_2_lo.w                                             ; $03DEF1 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DEF4 |\
    AND #%00110000.b                                                            ; $03DEF6 | | Add in the original count of monsters of the second type and add
    JSR _math_divide_by_16                                                      ; $03DEF8 | | it to the previous count. Save the result to the argument for the
    CLC                                                                         ; $03DEFB | | monster revival routine (to revive the monster in the first slot
    ADC r_battle_generic_tmp_2_lo.w                                             ; $03DEFC | | of the third type).
    TAX                                                                         ; $03DEFF | |
    STX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DF00 |/
    LDA #0.b                                                                    ; $03DF02 |\
    STA <r_battle_helper_set_monster_type_swoon_arg_type_1                      ; $03DF04 | | Set any monsters of the first and second types to the swoon
    INC A                                                                       ; $03DF06 | | status.
    STA <r_battle_helper_set_monster_type_swoon_arg_type_2                      ; $03DF07 | |
    JSR _battle_helper_set_monster_type_swoon                                   ; $03DF09 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DF0C |\
    AND #%00001100.b                                                            ; $03DF0E | | Initialize the index to the number of monsters of the third type.
    JSR _math_divide_by_4                                                       ; $03DF10 | |
    TAX                                                                         ; $03DF13 | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DF14 |/
-   LDA #2.b                                                                    ; $03DF16 |\
    JSR _battle_helper_revive_monster                                           ; $03DF18 | | Revive monsters until all monsters of the third type are revived.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF1B | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF1D | |
    BNE -                                                                       ; $03DF1F |/
    BRA @done                                                                   ; $03DF21
@living_third_type:
    TDC                                                                         ; $03DF23 |\
    TAX                                                                         ; $03DF24 | | Initialize the revival slot number to zero.
    STX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DF25 |/
    LDA #2.b                                                                    ; $03DF27 |\
    STA <r_battle_helper_set_monster_type_swoon_arg_type_1                      ; $03DF29 | | Kill off all monsters of the third type.
    STA <r_battle_helper_set_monster_type_swoon_arg_type_2                      ; $03DF2B | |
    JSR _battle_helper_set_monster_type_swoon                                   ; $03DF2D |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03DF30 |\
    AND #%11000000.b                                                            ; $03DF32 | | Initialize the count variable to the number of monsters of the
    JSR _math_divide_by_64                                                      ; $03DF34 | | first type.
    TAX                                                                         ; $03DF37 | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DF38 |/
-   LDA #0.b                                                                    ; $03DF3A |\
    JSR _battle_helper_revive_monster                                           ; $03DF3C | | Revive all monsters of the first type.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF3F | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF41 | |
    BNE -                                                                       ; $03DF43 |/
    LDA r_formation_properties.monster_counts.w                                 ; $03DF45 |\
    AND #%00110000.b                                                            ; $03DF48 | | Set the counter to the number of monsters of the second type.
    JSR _math_divide_by_16                                                      ; $03DF4A | |
    TAX                                                                         ; $03DF4D | |
    STX <r_battle_spell_effect_transition_tmp_count                             ; $03DF4E |/
-   LDA #1.b                                                                    ; $03DF50 |\
    JSR _battle_helper_revive_monster                                           ; $03DF52 | | Revive all monsters of the second type.
    DEC <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF55 | |
    LDA <r_battle_spell_effect_transition_tmp_count_lo                          ; $03DF57 | |
    BNE -                                                                       ; $03DF59 |/
@done:
    RTS                                                                         ; $03DF5B

; _battle_helper_revive_monster ($03:DF5C)
;
; Revives the monster in the 16-bit monster slot number passed in $8A with the
; type index (0-2) passed in the accumulator. The slot argument is automatically
; incremented at the end to allow for repeated calls.
_battle_helper_revive_monster:
    LDX <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DF5C |\ Set the type index of this slot to the given type index.
    STA r_monster_slot_to_id_index.w,X                                          ; $03DF5E |/
    TAX                                                                         ; $03DF61 |\
    INC r_monsters_remaining.w,X                                                ; $03DF62 | | Increment the monster counts.
    INC r_monsters_remaining_total.w                                            ; $03DF65 |/
    CLC                                                                         ; $03DF68 |\
    LDA <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DF69 | | Add five to the monster slot to determine the true slot.
    ADC #5.b                                                                    ; $03DF6B | |
    STA <r_battle_helper_revive_monster_tmp_slot                                ; $03DF6D |/
    STA <r_math_multiply_8bit_arg_1                                             ; $03DF6F |\
    LDA #_sizeof_character_battle.b                                             ; $03DF71 | | Multiply the true slot number the size of a stat record to get the
    STA <r_math_multiply_8bit_arg_2                                             ; $03DF73 | | offset to that slot's record.
    JSR _math_multiply_8bit                                                     ; $03DF75 | |
    LDX <r_math_multiply_8bit_result                                            ; $03DF78 |/
    STZ r_character_battle.1.status_1.w,X                                       ; $03DF7A |\
    STZ r_character_battle.1.status_2.w,X                                       ; $03DF7D | | Reset all the status bits to zero.
    STZ r_character_battle.1.status_3.w,X                                       ; $03DF80 | |
    STZ r_character_battle.1.status_4.w,X                                       ; $03DF83 |/
    LDA r_character_battle.1.hp_max_lo.w,X                                      ; $03DF86 |\
    STA r_character_battle.1.hp_lo.w,X                                          ; $03DF89 |  | Set the current HP to the value of the maximum HP.
    LDA r_character_battle.1.hp_max_hi.w,X                                      ; $03DF8C | |
    STA r_character_battle.1.hp_hi.w,X                                          ; $03DF8F |/
    STZ <r_calculate_timer_value_arg_mode                                       ; $03DF92 |\
    LDA <r_battle_helper_revive_monster_tmp_slot                                ; $03DF94 | | Set the monster's action timer based on its relative speed.
    JSR _calculate_timer_value                                                  ; $03DF96 | |
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03DF99 | |
    JSR _set_timer_value                                                        ; $03DF9B |/
    STZ r_battle_timers.1.flags.w,X                                             ; $03DF9E | Unset any timer flags.
    LDA <r_battle_helper_revive_monster_tmp_slot                                ; $03DFA1 |\
    ASL A                                                                       ; $03DFA3 | | Flag the action timer as being enabled.
    TAX                                                                         ; $03DFA4 | |
    LDA #(TIMER_ENABLED_ACTION >> 8).b                                          ; $03DFA5 | |
    STA r_battle_enabled_timers.1.hi.w,X                                        ; $03DFA7 |/
    INC <r_battle_helper_revive_monster_arg_monster_slot                        ; $03DFAA | Increment the argument slot to allow repeated calls.
    RTS                                                                         ; $03DFAC

; _battle_helper_set_monster_type_swoon ($03:DFAD)
;
; Given two monster type indexes in $B1 and $B2, sets the swoon status on any
; monster slots matching that type index.
_battle_helper_set_monster_type_swoon:
    LDX #_sizeof_character_battle.w * 5                                         ; $03DFAD | Initialize the X register to the offset to the first monster record.
    TDC                                                                         ; $03DFB0 |\ Initialize the Y register (slot number) to zero.
    TAY                                                                         ; $03DFB1 |/
-   LDA r_monster_slot_to_id_index.w,Y                                          ; $03DFB2 |\
    CMP <r_battle_helper_set_monster_type_swoon_arg_type_1                      ; $03DFB5 | | If the type index of the slot matches one of the two parameters,
    BEQ +                                                                       ; $03DFB7 | | set the swoon status on the monster.
    CMP <r_battle_helper_set_monster_type_swoon_arg_type_2                      ; $03DFB9 | |
    BNE ++                                                                      ; $03DFBB | |
+   LDA r_character_battle.1.status_1.w,X                                       ; $03DFBD | |
    ORA #STATUS_1_SWOON.b                                                       ; $03DFC0 | |
    STA r_character_battle.1.status_1.w,X                                       ; $03DFC2 |/
++  JSR _increment_x_by_128                                                     ; $03DFC5 |\
    INY                                                                         ; $03DFC8 | | Increment the indexes and loop until all eight monster slots have
    CPY #8.w                                                                    ; $03DFC9 | | been checked.
    BNE -                                                                       ; $03DFCC |/
    RTS                                                                         ; $03DFCE

; _battle_spell_effect_end_battle ($03:DFCF)
;
; This spell effect ends the current battle by setting the battle status to
; stalemate, in which nobody dies and no spoils are given.
_battle_spell_effect_end_battle:
    LDA #BATTLE_STATUS_STALEMATE.b                                              ; $03DFCF |\ Set the battle status to stalemate.
    STA r_battle_status.w                                                       ; $03DFD1 |/
    RTS                                                                         ; $03DFD4

; _battle_spell_effect_set_next_target ($03:DFD5)
;
; This spell effect, given a target, sets a variable to override the monster's
; next target. This effect only makes sense with a monster actor and party
; target. Any other combination will not work as expected.
_battle_spell_effect_set_next_target:
    LDA <r_battle_command_target_slot                                           ; $03DFD5 |\ Set the Y register to the target slot.
    TAY                                                                         ; $03DFD7 |/
    LDA <r_battle_command_actor_slot                                            ; $03DFD8 |\
    AND #%01111111.b                                                            ; $03DFDA | | Set the X register to the actor slot, relative to the base slot.
    TAX                                                                         ; $03DFDC |/
    LDA #0.b                                                                    ; $03DFDD |\
    SEC                                                                         ; $03DFDF | | Shift a bit right until it matches the target slot number.
-   ROR A                                                                       ; $03DFE0 | |
    DEY                                                                         ; $03DFE1 | |
    BPL -                                                                       ; $03DFE2 |/
    STA r_monster_next_party_target.w,X                                         ; $03DFE4 | Store this value as this monster's next target.
    RTS                                                                         ; $03DFE7

; _battle_spell_effect_hatch ($03:DFE8)
;
; This spell effect unsets the egg status from the target.
_battle_spell_effect_hatch:
    LDA r_character_battle_current_target.status_3.w                            ; $03DFE8 |\
    AND #STATUS_3_EGG.b ~ %11111111                                             ; $03DFEB | | Remove the egg status from the target.
    STA r_character_battle_current_target.status_3.w                            ; $03DFED |/
    LDA <r_battle_command_actor_slot                                            ; $03DFF0 |\
    AND #%01111111.b                                                            ; $03DFF2 | | Unset the flag for this monster type as being an egg.
    TAX                                                                         ; $03DFF4 | |
    LDA r_monster_slot_to_id_index.w,X                                          ; $03DFF5 | |
    TAX                                                                         ; $03DFF8 | |
    STZ r_monster_type_egg.w,X                                                  ; $03DFF9 |/
    RTS                                                                         ; $03DFFC

; _battle_spell_effect_activate_rydia ($03:DFFD)
;
; This spell effect activates adult Rydia by setting her action timer to 10.
_battle_spell_effect_activate_rydia:
    TDC                                                                         ; $03DFFD |\
    TAX                                                                         ; $03DFFE | | Initialize the slot and slot offset to zero.
    STX <r_battle_generic_tmp_1                                                 ; $03DFFF |/
-   LDA r_character_battle.1.id.w,X                                             ; $03E001 |\
    AND #%00011111.b                                                            ; $03E004 | | If this slot has adult Rydia, branch ahead to the next section.
    CMP #CHARACTER_RYDIA_2.b                                                    ; $03E006 | |
    BEQ +                                                                       ; $03E008 |/
    JSR _increment_x_by_128.w                                                   ; $03E00A |\
    INC <r_battle_generic_tmp_1_lo                                              ; $03E00D | | Increment the index and offset and loop.
    BRA -                                                                       ; $03E00F |/
+   LDA <r_battle_generic_tmp_1_lo                                              ; $03E011 |\ Calculate offsets for Rydia's slot.
    JSR _calculate_offsets                                                      ; $03E013 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E016 |\
    JSR _add_timer_offset                                                       ; $03E018 | | Set Rydia's action timer to ten.
    LDX r_add_timer_offset_result.w                                             ; $03E01B | |
    LDA #10.b                                                                   ; $03E01E | |
    STA r_battle_timers.1.value_lo.w,X                                          ; $03E020 | |
    STZ r_battle_timers.1.value_hi.w,X                                          ; $03E023 |/
    STZ r_battle_timers.1.flags.w,X                                             ; $03E026 | Unset any flags for this timer.
    INC r_battle_skip_victim_history_update.w                                   ; $03E029 | Prevent the victim history from being updated.
    RTS                                                                         ; $03E02C

; _battle_unset_target ($03:E02D)
;
; Given a relative target slot in $CE, unsets that target in either $3550 if no
; wall is active ($3554 is zero), or in $3523 if a wall is active.
_battle_unset_target:
    LDA r_battle_command_wall_active.w                                          ; $03E02D |\ If a wall is active, branch to the wall portion of the code.
    BNE +                                                                       ; $03E030 |/
    LDA <r_battle_command_target_slot                                           ; $03E032 |\
    AND #%01111111.b                                                            ; $03E034 | | Unset the target in the actual targets variable.
    TAX                                                                         ; $03E036 | |
    LDA r_battle_command_actual_targets.w                                       ; $03E037 | |
    JSR _unset_bit_x                                                            ; $03E03A | |
    STA r_battle_command_actual_targets.w                                       ; $03E03D | |
    RTS                                                                         ; $03E040 |/
+   LDA <r_battle_command_target_slot                                           ; $03E041 |\
    AND #%01111111.b                                                            ; $03E043 | | If a wall is active, unset the target instead in the wall targets
    TAX                                                                         ; $03E045 | | variable.
    LDA r_battle_command_wall_targets.w                                         ; $03E046 | |
    JSR _unset_bit_x                                                            ; $03E049 | |
    STA r_battle_command_wall_targets.w                                         ; $03E04C |/
    RTS                                                                         ; $03E04F

; _battle_command_helper_update_call ($03:E050)
;
; Given a spell value in the accumulator, updates the current actor's subcommand
; to reflect the actual Call spell associated with the proxy being passed.
; Selects a random Asura variant if Asura is selected.
_battle_command_helper_update_call:
    CMP #SPELL_ASURA.b                                                          ; $03E050 |\ If the spell is before Asura in the list, branch ahead to the main
    BCC ++                                                                      ; $03E052 |/ translation.
    CMP #SPELL_BAHAM.b                                                          ; $03E054 |\
    BNE +                                                                       ; $03E056 | | If the spell is Baham, set the value explicitly to the Bahamut
    LDA #SPELL_CALL_BAHAMUT.b                                                   ; $03E058 | | Call value and branch to near the end.
    BRA +++                                                                     ; $03E05A |/
+   LDX #0.w                                                                    ; $03E05C |\
    LDA #2.b                                                                    ; $03E05F | | If the spell is Asura, select a random number from 0 to 2 to
    JSR _get_battle_rng                                                         ; $03E061 | | select the Asura variant, set the party target to all party
    PHA                                                                         ; $03E064 | | members, and then add the offset to the first Asura spell so it
    LDA #BATTLE_TARGET_PARTY_ALL.b                                              ; $03E065 | | will have the right relative value.
    STA r_character_battle_current_actor.targets.party.w                        ; $03E067 | |
    PLA                                                                         ; $03E06A | |
    CLC                                                                         ; $03E06B | |
    ADC #SPELL_ASURA.b                                                          ; $03E06C |/
++  SEC                                                                         ; $03E06E |\
    SBC #SPELL_FIRST_CALL_PROXY.b                                               ; $03E06F | | Except for Baham, which was explicitly set, subtract the base
    CLC                                                                         ; $03E071 | | proxy spell value and add the base call spell value.
    ADC #SPELL_FIRST_CALL.b                                                     ; $03E072 |/
+++ STA r_character_battle_current_actor.subcommand.w                           ; $03E074 | Set the calculated spell as the actor's subcommand.
    INC r_battle_double_spell_power.w                                           ; $03E077 | Set the double spell power flag. TODO: Should this just be summon?
    RTS                                                                         ; $03E07A

; _battle_command_helper_copy_rydia_mp ($03:E07B)
;
; Given the offset to a character battle stat record in the X register, checks
; if that character is adult Rydia, and if so, transfers the current MP value
; from the current actor stat record at $2680 to the base record.
_battle_command_helper_copy_rydia_mp:
    LDA r_character_battle.1.id.w,X                                             ; $03E07B |\
    AND #%00011111.b                                                            ; $03E07E | | If the character in the passed slot is specifically the second
    CMP #CHARACTER_RYDIA_2.b                                                    ; $03E080 | | Rydia, transfer the current MP from the current actor data to
    BNE +                                                                       ; $03E082 | | the base stat location.
    LDA r_character_battle_current_actor.mp_lo.w                                ; $03E084 | |
    STA r_character_battle.1.mp_lo.w,X                                          ; $03E087 | |
    LDA r_character_battle_current_actor.mp_hi.w                                ; $03E08A | |
    STA r_character_battle.1.mp_hi.w,X                                          ; $03E08D |/
+   RTS                                                                         ; $03E090

; battle_spell_effect_jump_data ($03:E091)
;
; For each spell effect, contains the pointer within bank $03 to the handler for
; that spell effect.
battle_spell_effect_jump_data:
    .addr _battle_spell_effect_standard_attack                                  ; $03E091.E092 | $00: Various attack spells
    .addr _battle_spell_effect_attack_plus_sap                                  ; $03E093.E094 | $01: White, Virus, Big Bang, Vampire, Digest, Pollen
    .addr _battle_spell_effect_restore_if_not_undead                            ; $03E095.E096 | $02: Various cure spells
    .addr _battle_spell_effect_weak                                             ; $03E097.E098 | $03: Weak, Storm
    .addr _battle_spell_effect_drain                                            ; $03E099.E09A | $04: Drain, Vampire (item)
    .addr _battle_spell_effect_psych                                            ; $03E09B.E09C | $05: Psych, Succubus (item)
    .addr _battle_spell_effect_set_status                                       ; $03E09D.E09E | $06: Various status effect spells
    .addr _battle_spell_effect_set_paralyze_sleep                               ; $03E09F.E0A0 | $07: Hold, Sleep, Pin, Tongue, Entangle, Gas
    .addr _battle_spell_effect_set_image                                        ; $03E0A1.E0A2 | $08: Blink, Image, Illusion (item)
    .addr _battle_spell_effect_set_wall                                         ; $03E0A3.E0A4 | $09: Wall, StarVeil (item), MoonVeil (item)
    .addr _battle_spell_effect_life                                             ; $03E0A5.E0A6 | $0A: Life1, Life2, Asura, Life (item)
    .addr _battle_spell_effect_heal                                             ; $03E0A7.E0A8 | $0B: Heal, Silver Staff, Staff, Crystal (item), various items
    .addr _battle_spell_effect_toggle_status_1                                  ; $03E0A9.E0AA | $0C: Size, Toad, Piggy, Whisper
    .addr _battle_spell_effect_armor                                            ; $03E0AB.E0AC | $0D: Armor
    .addr _battle_spell_effect_shell                                            ; $03E0AD.E0AE | $0E: Shell
    .addr _battle_spell_effect_change_speed                                     ; $03E0AF.E0B0 | $0F: Slow, Fast, DullSong, $BD, Hermes (item), SilkWeb (item)
    .addr _battle_spell_effect_dispel                                           ; $03E0B1.E0B2 | $10: Dummy ($0C)
    .addr _battle_spell_effect_stop                                             ; $03E0B3.E0B4 | $11: Stop, Magnet, Hourglass (items)
    .addr _battle_spell_effect_peep                                             ; $03E0B5.E0B6 | $12: Peep, Bestiary (item)
    .addr _battle_spell_effect_run                                              ; $03E0B7.E0B8 | $13: Exit, Smoke
    .addr _battle_spell_effect_actor_hp                                         ; $03E0B9.E0BA | $14: Bomb, Mist, Blizzard, Wave, Tornado, Laser, HP-based items
    .addr _battle_spell_effect_restore_mp                                       ; $03E0BB.E0BC | $15: Ether1 (item), Ether2 (item)
    .addr _battle_spell_effect_restore_full_hp_mp                               ; $03E0BD.E0BE | $16: $BE, Elixir (item)
    .addr _battle_spell_effect_damage_and_poison                                ; $03E0BF.E0C0 | $17: Venom, Poison
    .addr _battle_spell_effect_damage_and_set_status                            ; $03E0C1.E0C2 | $18: Cocktric
    .addr _battle_spell_effect_damage_and_set_paralyze_sleep                    ; $03E0C3.E0C4 | $19: Mage
    .addr _battle_spell_effect_sylph                                            ; $03E0C5.E0C6 | $1A: Sylph
    .addr _battle_spell_effect_odin                                             ; $03E0C7.E0C8 | $1B: Odin
    .addr _battle_spell_effect_count                                            ; $03E0C9.E0CA | $1C: <unused>
    .addr _battle_spell_effect_count                                            ; $03E0CB.E0CC | $1D: Count
    .addr _battle_spell_effect_target_hp                                        ; $03E0CD.E0CE | $1E: Maser, Beam, Fire, Blaze, Blitz, Thunder, D.Breath, Big Wave
    .addr _battle_spell_effect_set_partial_stone                                ; $03E0CF.E0D0 | $1F: Ray, Petrify
    .addr _battle_spell_effect_gaze                                             ; $03E0D1.E0D2 | $20: Gaze
    .addr _battle_spell_effect_bluster                                          ; $03E0D3.E0D4 | $21: Bluster
    .addr _battle_spell_effect_slap                                             ; $03E0D5.E0D6 | $22: Slap
    .addr _battle_spell_effect_blast                                            ; $03E0D7.E0D8 | $23: Blast
    .addr _battle_spell_effect_hug                                              ; $03E0D9.E0DA | $24: Hug
    .addr _battle_spell_effect_explode                                          ; $03E0DB.E0DC | $25: Fission, Explode, Kamikaze (item)
    .addr _battle_spell_effect_reaction                                         ; $03E0DD.E0DE | $26: Reaction
    .addr _battle_spell_effect_remedy                                           ; $03E0DF.E0E0 | $27: Remedy ($84)
    .addr _battle_spell_effect_damage_and_set_status_swoon_undead               ; $03E0E1.E0E2 | $28: <unused>
    .addr _battle_spell_effect_alert                                            ; $03E0E3.E0E4 | $29: Alert, Call
    .addr _battle_spell_effect_zeromus_disrupt                                  ; $03E0E5.E0E6 | $2A: Disrupt, Blk.Hole
    .addr _battle_spell_effect_needle                                           ; $03E0E7.E0E8 | $2B: Needle, Counter
    .addr _battle_spell_effect_absorb                                           ; $03E0E9.E0EA | $2C: Absorb
    .addr _battle_spell_effect_do_nothing                                       ; $03E0EB.E0EC | $2D: Dummy
    .addr _battle_spell_effect_increment_monsters_invincible                    ; $03E0ED.E0EE | $2E: Dummy
    .addr _battle_spell_effect_decrement_monsters_invincible                    ; $03E0EF.E0F0 | $2F: Dummy
    .addr _battle_spell_effect_recover                                          ; $03E0F1.E0F2 | $30: Vanish, Recover, Remedy
    .addr _battle_spell_effect_transition                                       ; $03E0F3.E0F4 | $31: Dummy
    .addr _battle_spell_effect_end_battle                                       ; $03E0F5.E0F6 | $32: Dummy
    .addr _battle_spell_effect_set_next_target                                  ; $03E0F7.E0F8 | $33: Search
    .addr _battle_spell_effect_hatch                                            ; $03E0F9.E0FA | $34: Hatch
    .addr _battle_spell_effect_activate_rydia                                   ; $03E0FB.E0FC | $35: y ($B0)

; _battle_spell_set_element_multiplier_immune_resistance ($03:E0FD)
;
; Used as part of the damage calculation routines, sets the element multiplier
; at $38FE based on the target stat record at $2700 and the current spell
; properties at $289C. This routine checks for and sets the multiplier based on
; immunity, resistance and absorption.
_battle_spell_set_element_multiplier_immune_resistance:
    LDA r_character_battle_current_target.element_immunity.w                    ; $03E0FD |\
    AND r_current_spell_properties.element_status.element.w                     ; $03E100 | | If the target has immunity to any of the spell's elements, set the
    BEQ +                                                                       ; $03E103 | | multiplier to zero. If the absorb bit is also set in the immunity
    TDC                                                                         ; $03E105 | | data, set the multiplier to $84, which will result in a double
    STA r_battle_damage_element_multiplier.w                                    ; $03E106 | | absorption effect.
    LDA r_character_battle_current_target.element_immunity.w                    ; $03E109 | |
    AND #ELEMENT_ABSORB.b                                                       ; $03E10C | |
    BEQ ++                                                                      ; $03E10E | |
    LDA #4.b | ELEMENT_MULTIPLIER_ABSORB                                        ; $03E110 | |
    STA r_battle_damage_element_multiplier.w                                    ; $03E112 | |
    RTS                                                                         ; $03E115 |/
+   LDA r_character_battle_current_target.element_resistance.w                  ; $03E116 |\
    AND r_current_spell_properties.element_status.element.w                     ; $03E119 | | Otherwise, if the target has resistance to any of the spell's
    BEQ ++                                                                      ; $03E11C | | elements, set the multiplier to one. If the absorb bit is set in
    LDA #1.b                                                                    ; $03E11E | | their resistances, change the multiplier to $82, which will
    STA r_battle_damage_element_multiplier.w                                    ; $03E120 | | result in a standard absorb effect.
    LDA r_character_battle_current_target.element_resistance.w                  ; $03E123 | |
    AND #ELEMENT_ABSORB.b                                                       ; $03E126 | |
    BEQ ++                                                                      ; $03E128 | |
    LDA #2.b | ELEMENT_MULTIPLIER_ABSORB                                        ; $03E12A | |
    STA r_battle_damage_element_multiplier.w                                    ; $03E12C |/
++  RTS                                                                         ; $03E12F

; _battle_spell_set_element_multiplier_weakness ($03:E130)
;
; Used as part fo the damage calculation routines, sets the element multiplier
; at $38FE based on the target stat record at $2700 and the current spell
; properties at $289C. This routine checks for and sets the multiplier based on
; weakness and strong weakness. Notably, it will not change the multiplier if
; it is already set to something other than the default of two.
_battle_spell_set_element_multiplier_weakness:
    LDA r_battle_damage_element_multiplier.w                                    ; $03E130 |\
    CMP #2.b                                                                    ; $03E133 | | Skip this function if the multiplier is no longer set to 2.
    BNE ++                                                                      ; $03E135 |/
    LDA r_character_battle_current_target.element_weakness_strong.w             ; $03E137 |\
    AND r_current_spell_properties.element_status.element.w                     ; $03E13A | | If the target has a strong weakness to one of the spell's
    BEQ +                                                                       ; $03E13D | | elements, set the multiplier to 8.
    LDA #8.b                                                                    ; $03E13F | |
    STA r_battle_damage_element_multiplier.w                                    ; $03E141 | |
    RTS                                                                         ; $03E144 |/
+   LDA r_character_battle_current_target.element_weakness.w                    ; $03E145 |\
    AND r_current_spell_properties.element_status.element.w                     ; $03E148 | | Otherwise, if the target has a regular weakness to one of the
    BEQ ++                                                                      ; $03E14B | | elements, set the multiplier to 4.
    LDA #4.b                                                                    ; $03E14D | |
    STA r_battle_damage_element_multiplier.w                                    ; $03E14F |/
++  RTS                                                                         ; $03E152

; _battle_command_execute_peep ($03:E153)
;
; Handles the Peep command.
_battle_command_execute_peep:
    LDA r_character_battle_current_target.monster_level_boss.w                  ; $03E153 |\
    BPL +                                                                       ; $03E156 | | Return doing nothing if the monster has the boss bit.
    JMP @done                                                                   ; $03E158 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03E15B |\
    LDA r_character_battle_current_target.hp.w                                  ; $03E15D | | Copy the target's current HP and maximum HP into the dialog extra
    STA r_battle_update_dialog_extra_arg_1.w                                    ; $03E160 | | arguments.
    LDA r_character_battle_current_target.hp_max.w                              ; $03E163 | |
    STA r_battle_update_dialog_extra_arg_2.w                                    ; $03E166 | |
    TDC                                                                         ; $03E169 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03E16A |/
    STZ r_battle_update_dialog_extra_arg_1_hi.w                                 ; $03E16C |\ Each of those values is 24-bit, so set the high bytes to zeroes.
    STZ r_battle_update_dialog_extra_arg_2_hi.w                                 ; $03E16F |/
    LDA r_character_battle_current_target.element_weakness.w                    ; $03E172 |\
    AND r_character_battle_current_target.element_resistance.w                  ; $03E175 | | Get the list of elements the target is weak to, but is not also
    EOR #%11111111.b                                                            ; $03E178 | | resistant too.
    AND r_character_battle_current_target.element_weakness.w                    ; $03E17A | |
    AND #(ELEMENT_IMMUNE | ELEMENT_ABSORB).b ~ %11111111                        ; $03E17D | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03E17F |/
    BNE +                                                                       ; $03E181 |\
    LDA #BATTLE_ALERT_NO_WEAK_POINTS_FOUND.b                                    ; $03E183 | | If there are none, set the second byte in the alert queue to the
    STA r_battle_alert_queue.w + 1                                              ; $03E185 | | "no weak points" alert.
    BRA ++                                                                      ; $03E188 |/
+   TDC                                                                         ; $03E18A |\
    TAX                                                                         ; $03E18B | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03E18C |/
-   LSR <r_battle_generic_tmp_1_lo                                              ; $03E18D |\
    BCC +                                                                       ; $03E18F | | Loop through the weak elements, adding an alert to the queue for
    TYA                                                                         ; $03E191 | | each.
    CLC                                                                         ; $03E192 | |
    ADC #BATTLE_ALERT_WEAK_AGAINST_FIRE.b                                       ; $03E193 | |
    STA r_battle_alert_queue.w + 1,X                                            ; $03E195 | |
    INX                                                                         ; $03E198 | |
+   INY                                                                         ; $03E199 | |
    CPY #6.w                                                                    ; $03E19A | |
    BNE -                                                                       ; $03E19D |/
++  JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E19F | Set the codes to show the alerts.
    LDA #BATTLE_ALERT_HP_MAX_HP.b                                               ; $03E1A2 |\ Set the first alert to display the target's current and maximum HP.
    STA r_battle_alert_queue.w + 0                                              ; $03E1A4 |/
    LDA #BATTLE_COMMAND_PEEP.b                                                  ; $03E1A7 |\
    STA r_battle_current_action_details.action.w                                ; $03E1A9 | | Set the current action to the Peep command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E1AC | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E1AE |/
@done:
    RTS                                                                         ; $03E1B1

; _battle_command_execute_flee ($03:E1B2)
;
; Handler for the Flee command, which sets the swoon status on the user and
; displays a "Ran Away" alert. It is intended to be used by monsters and makes
; no sense for characters.
_battle_command_execute_flee:
    LDA #BATTLE_MONSTER_TRANSITION_RETREAT.b                                    ; $03E1B2 |\ Set the special transition to retreat.
    STA r_battle_monster_special_transition.w                                   ; $03E1B4 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E1B7 |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03E1B9 | | Set the swoon status on the actor.
    ORA #STATUS_1_SWOON.b                                                       ; $03E1BC | |
    STA r_character_battle.1.status_1.w,X                                       ; $03E1BE |/
    LDA #BATTLE_ALERT_RAN_AWAY.b                                                ; $03E1C1 |\ Add the "Ran away" alert to the queue.
    STA r_battle_alert_queue.w                                                  ; $03E1C3 |/
    INC r_battle_action_skip_action_timer_update.w                              ; $03E1C6 | Skip the action timer update, since the monster fled.
    JMP _battle_script_audiovisual_set_display_dialog_alert_0                   ; $03E1C9 | Add audiovisual code to display battle alerts.

; _battle_command_execute_sneak ($03:E1CC)
;
; Handles the Sneak command.
_battle_command_execute_sneak:
    LDA #BATTLE_COMMAND_SNEAK.b                                                 ; $03E1CC |\
    STA r_battle_current_action_details.action.w                                ; $03E1CE | | Set the current action to the Sneak command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E1D1 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E1D3 |/
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03E1D6 |\
    STA r_battle_script_audiovisual.w + 4                                       ; $03E1D8 | | Add the commands to display damage to the audiovisual script.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03E1DB | |
    STA r_battle_script_audiovisual.w + 5                                       ; $03E1DD |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03E1E0 | Add the display of battle alerts to the audiovisual script.
    LDA <r_battle_command_target_slot                                           ; $03E1E3 |\
    BMI +                                                                       ; $03E1E5 | | Fail if attempting to sneak from a party member.
    JMP @failed                                                                 ; $03E1E7 |/
+   JSR _get_battle_rng_0_98                                                    ; $03E1EA |\ Select a random value from 0 to 98, inclusive.
    STA <r_battle_generic_tmp_1_lo                                              ; $03E1ED |/
    CLC                                                                         ; $03E1EF |\
    LDA #50.b                                                                   ; $03E1F0 | | Add 50 to the actor's level, and then subtract the target's $2F
    ADC r_character_battle_current_actor.level.w                                ; $03E1F2 | | stat.
    SEC                                                                         ; $03E1F5 | |
    SBC r_character_battle_current_target.unknown2F.w                           ; $03E1F6 |/
    BCS +                                                                       ; $03E1F9 |\
    LDA #1.b                                                                    ; $03E1FB | | If the result was negative, set the result to 1.
    BRA ++                                                                      ; $03E1FD |/
+   CMP #99.b                                                                   ; $03E1FF |\
    BCC ++                                                                      ; $03E201 | | If the result was greater than 99, set the result to 99.
    LDA #99.b                                                                   ; $03E203 |/
++  CMP <r_battle_generic_tmp_1_lo                                              ; $03E205 |\ If that result was greater than or equal to the random number,
    BCS ++                                                                      ; $03E207 |/ branch ahead to the next section.
    JSR _get_battle_rng_0_98                                                    ; $03E209 | Select a random number from 0 to 98, inclusive.
    CMP r_character_battle_current_target.unknown2F.w                           ; $03E20C |\ If that random number is less than the target's $2F stat, jump
    BCC @failed                                                                 ; $03E20F |/ to the basic failure mode.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03E211 |\
    LDA r_character_battle_current_actor.hp_max.w                               ; $03E213 | | Divide the actor's maximum HP by 16.
    JSR _math_divide_by_16                                                      ; $03E216 | |
    STA <r_battle_generic_tmp_1                                                 ; $03E219 | |
    LDA #0.w                                                                    ; $03E21B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03E21E |/
    LDA <r_battle_command_actor_slot                                            ; $03E220 |\
    JSR _battle_get_damage_offset                                               ; $03E222 | | Set the pending damage for the actor to that value.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E225 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03E227 | | BUG: _battle_get_damage_offset clobbers the low byte of $A9, so
    LDA <r_battle_generic_tmp_1_hi                                              ; $03E22A | |      actual damage value will have its low byte replaced with the
    STA r_battle_slot_damage.w + 1,X                                            ; $03E22C |/       actor's slot.
    JSR _battle_apply_pending_damage.w                                          ; $03E22F | Apply the pending damage.
    LDA #BATTLE_ALERT_FAILED_1C.b                                               ; $03E232 |\
    STA r_battle_alert_queue.w                                                  ; $03E234 | | Display a failed battle alert and return.
    BRA +                                                                       ; $03E237 |/
@failed:
    LDA #BATTLE_ALERT_FAILED_1B.b                                               ; $03E239 |\
    STA r_battle_alert_queue.w                                                  ; $03E23B | | Display a failed battle alert and return (different from above).
+   RTS                                                                         ; $03E23E |/
++  LDA r_character_battle_current_target.monster_item_index.w                  ; $03E23F |\
    AND #MONSTER_ITEM_INDEX_DROP_RATE.b                                         ; $03E242 | | If the monster always drops an item, return.
    CMP #MONSTER_ITEM_INDEX_DROP_RATE_ALWAYS.b                                  ; $03E244 | |
    BNE +                                                                       ; $03E246 | |
    RTS                                                                         ; $03E248 |/
+   TDC                                                                         ; $03E249 |\
    INC A                                                                       ; $03E24A | | Set the count of items to 1.
    STA <r_battle_generic_tmp_1_hi                                              ; $03E24B |/
    LDA r_character_battle_current_target.monster_item_index.w                  ; $03E24D |\
    AND #MONSTER_ITEM_INDEX_VALUE.b                                             ; $03E250 | | Load the item ID in the first slot of the monster's drop table.
    JSR _math_multiply_by_4                                                     ; $03E252 | |
    TAX                                                                         ; $03E255 | |
    LDA bank0E.monster_item_drop_data.l,X                                       ; $03E256 |/
    BEQ @failed                                                                 ; $03E25A | If the result was no item, branch to the basic failure method.
    STA <r_battle_generic_tmp_1_lo                                              ; $03E25C |\
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03E25E | | If the item being sneaked is an arrow, set the count to 10.
    BCS +                                                                       ; $03E260 | |
    CMP #ITEM_FIRST_ARROW.b                                                     ; $03E262 | |
    BCC +                                                                       ; $03E264 | |
    LDA #10.b                                                                   ; $03E266 | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03E268 |/
+   TDC                                                                         ; $03E26A |\
    TAX                                                                         ; $03E26B | | Initialize the X and Y registers to zero.
    TXY                                                                         ; $03E26C |/
-   LDA r_battle_inventory.1.id.w,X                                             ; $03E26D |\
    CMP <r_battle_generic_tmp_1_lo                                              ; $03E270 | | If the next item is the item being stolen, branch ahead.
    BEQ +                                                                       ; $03E272 |/
@start:
    INX                                                                         ; $03E274 |\
    INX                                                                         ; $03E275 | | Increment indexes and loop until the entire inventory has been
    INX                                                                         ; $03E276 | | scanned.
    INX                                                                         ; $03E277 | |
    INY                                                                         ; $03E278 | |
    CPY #48.w                                                                   ; $03E279 | |
    BNE -                                                                       ; $03E27C |/
    LDA r_battle_inventory_first_empty.w                                        ; $03E27E |\
    CMP #$FF.b                                                                  ; $03E281 | | If there is no empty slot in the inventory, branch to failure.
    BEQ @failed                                                                 ; $03E283 |/
    TAY                                                                         ; $03E285 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $03E286 | | Calculate the offset to the empty inventory slot's entry in the
    ASL A                                                                       ; $03E288 | | battle inventory.
    ASL A                                                                       ; $03E289 | |
    TAX                                                                         ; $03E28A | |
    TDC                                                                         ; $03E28B | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03E28C |/
    LDA <r_battle_generic_tmp_1_hi                                              ; $03E28E |\ Set the item's count to the stolen count.
    STA r_battle_inventory.1.count.w,X                                          ; $03E290 |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E293 |\ Set the item's ID.
    STA r_battle_inventory.1.id.w,X                                             ; $03E295 |/
    STX <r_battle_generic_tmp_2                                                 ; $03E298 |\
    PHY                                                                         ; $03E29A | | Update the flags and effect for the inventory entry and branch
    JSR _battle_command_helper_update_inventory_entry                           ; $03E29B | | ahead.
    PLY                                                                         ; $03E29E | |
    BRA ++                                                                      ; $03E29F |/
+   CLC                                                                         ; $03E2A1 |\
    LDA r_battle_inventory.1.count.w,X                                          ; $03E2A2 | | Add the new count to the existing count in this slot.
    ADC <r_battle_generic_tmp_1_hi                                              ; $03E2A5 |/
    CMP #100.b                                                                  ; $03E2A7 |\ If the updated count is less than 100, branch ahead.
    BCC +                                                                       ; $03E2A9 |/
    PHA                                                                         ; $03E2AB |\
    LDA #99.b                                                                   ; $03E2AC | | Otherwise, set it to 99 and update that dialog entry.
    STA r_battle_inventory.1.count.w,X                                          ; $03E2AE | |
    JSR _battle_command_helper_update_inventory_entry_dialog                    ; $03E2B1 | |
    PLA                                                                         ; $03E2B4 |/
    SEC                                                                         ; $03E2B5 |\
    SBC #99.b                                                                   ; $03E2B6 | | Subtract 99 from the total, and set that as the new amount to
    BEQ ++                                                                      ; $03E2B8 | | place in the inventory. Afterward, branch back to the start to
    STA <r_battle_generic_tmp_1_hi                                              ; $03E2BA | | find the next inventory entry.
    BRA @start                                                                  ; $03E2BC |/
+   STA r_battle_inventory.1.count.w,X                                          ; $03E2BE | Store the updated count.
++  JSR _battle_command_helper_update_inventory_entry_dialog                    ; $03E2C1 | Update the dialog for this inventory entry.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E2C4 |\ Set the item ID as the extra argument for the battle alert.
    STA r_battle_update_dialog_extra_arg_1.w                                    ; $03E2C6 |/
    LDA #BATTLE_ALERT_FOUND.b                                                   ; $03E2C9 |\ Add the "Found" battle alert to the queue.
    STA r_battle_alert_queue.w                                                  ; $03E2CB |/
    RTS                                                                         ; $03E2CE

; _battle_command_helper_update_inventory_entry_dialog ($03:E2CF)
;
; Updates the battle inventory entry passed in the Y register.
_battle_command_helper_update_inventory_entry_dialog:
    PHX                                                                         ; $03E2CF |\ Preserve the X and Y registers.
    PHY                                                                         ; $03E2D0 |/
    TYA                                                                         ; $03E2D1 |\ Set the Y register as the argument to the update function.
    STA <r_battle_update_arg_index                                              ; $03E2D2 |/
    LDA #BATTLE_UPDATE_MODE_INVENTORY_ENTRY.b                                   ; $03E2D4 |\ Update the inventory entry with the index that was in the Y
    JSR _battle_update                                                          ; $03E2D6 |/ register.
    PLY                                                                         ; $03E2D9 |\ Restore the X and Y registers.
    PLX                                                                         ; $03E2DA |/
    RTS                                                                         ; $03E2DB

; _battle_command_execute_heal ($03:E2DC)
;
; Handles the Heal command, which is a multi-target use of a Cure1 potion.
_battle_command_execute_heal:
    LDA #MONSTER_COMMAND_ITEM.b                                                 ; $03E2DC |\ Set the next byte in the audiovisual script to use the Item
    STA r_battle_script_audiovisual.w + 2                                       ; $03E2DE |/ command.
    TDC                                                                         ; $03E2E1 |\
    TAX                                                                         ; $03E2E2 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03E2E3 |/
-   LDA r_battle_inventory.1.id.w,X                                             ; $03E2E4 |\
    CMP #ITEM_CURE1.b                                                           ; $03E2E7 | | Search through the inventory for a Cure1 item. If one is found,
    BEQ +                                                                       ; $03E2E9 | | branch ahead to later code.
    INY                                                                         ; $03E2EB | |
    INX                                                                         ; $03E2EC | |
    INX                                                                         ; $03E2ED | |
    INX                                                                         ; $03E2EE | |
    INX                                                                         ; $03E2EF | |
    CPX #_sizeof_r_battle_inventory.w                                           ; $03E2F0 | |
    BNE -                                                                       ; $03E2F3 |/
-   JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E2F5 |\
    LDA #BATTLE_ALERT_DUMMY_F.b                                                 ; $03E2F8 | | If one wasn't found, configure an alert display and branch to the
    STA r_battle_alert_queue.w                                                  ; $03E2FA | | end of the function.
    BRA @done                                                                   ; $03E2FD |/
+   LDA r_battle_inventory.1.flags.w,X                                          ; $03E2FF |\
    AND #BATTLE_INVENTORY_FLAG_DISABLED.b ~ %11111111                           ; $03E302 | | Remove any disabled flags from the item.
    STA r_battle_inventory.1.flags.w,X                                          ; $03E304 |/
    LDA r_battle_inventory.1.count.w,X                                          ; $03E307 |\
    CMP #1.b                                                                    ; $03E30A | | If there is fewer than 1 of the item, branch to the failure code.
    BCC -                                                                       ; $03E30C |/
    SEC                                                                         ; $03E30E |\
    LDA r_battle_inventory.1.count.w,X                                          ; $03E30F | | Subtract 1 from the count and save the updated value.
    SBC #1.b                                                                    ; $03E312 | | TODO: What about the other place that messed with the count?
    STA r_battle_inventory.1.count.w,X                                          ; $03E314 |/
    BNE +                                                                       ; $03E317 |\
    STZ r_battle_inventory.1.count.w,X                                          ; $03E319 | | If the new count is zero, set the count to zero, zero out the ID
    STZ r_battle_inventory.1.id.w,X                                             ; $03E31C | | byte, and set the flags to disable the item.
    LDA #BATTLE_INVENTORY_FLAG_DISABLED.b                                       ; $03E31F | |
    STA r_battle_inventory.1.flags.w,X                                          ; $03E321 |/
+   TYA                                                                         ; $03E324 |\
    STA <r_battle_update_arg_index                                              ; $03E325 | | Update the inventory entry that was just modified.
    LDA #BATTLE_UPDATE_MODE_INVENTORY_ENTRY.b                                   ; $03E327 | |
    JSR _battle_update                                                          ; $03E329 |/
    LDA #BATTLE_TARGET_PARTY_ALL.b                                              ; $03E32C |\ Set the target to the entire party.
    STA r_character_battle_current_actor.targets.party.w                        ; $03E32E |/
    LDA #ITEM_CURE1.b                                                           ; $03E331 |\ Set the subcommand to the Cure1 item.
    STA r_character_battle_current_actor.subcommand.w                           ; $03E333 |/
    INC r_battle_current_spell_item.w                                           ; $03E336 | Set the flag that indicates the current spell is an item.
    JSR _battle_calculate_magic_damage                                          ; $03E339 | Calculate the damage.
    LDA #ITEM_CURE1.b                                                           ; $03E33C |\ Set the Cure1 item in the audiovisual script.
    STA r_battle_script_audiovisual.w + 3                                       ; $03E33E |/
@done:
    LDA #BATTLE_COMMAND_HEAL.b                                                  ; $03E341 |\
    STA r_battle_current_action_details.action.w                                ; $03E343 | | Indicate that the current action is the Heal command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E346 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E348 |/
    RTS                                                                         ; $03E34B

; _battle_command_execute_dart ($03:E34C)
;
; Handles the Dart command.
_battle_command_execute_dart:
    LDA #BATTLE_COMMAND_DART.b                                                  ; $03E34C |\
    STA r_battle_current_action_details.action.w                                ; $03E34E | | Set the current action as the Dart command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E351 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E353 |/
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03E356 |\
    STA r_battle_script_audiovisual.w + 4                                       ; $03E358 | | Set commands in the audiovisual script to display damage after the
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03E35B | | command.
    STA r_battle_script_audiovisual.w + 5                                       ; $03E35D |/
    LDA <r_battle_command_target_slot                                           ; $03E360 |\
    BMI +                                                                       ; $03E362 | | If the target is a party member, change the script to the Cover
-   LDA #MONSTER_COMMAND_COVER.b                                                ; $03E364 | | command (for animation purposes), show the nothing happened alert,
    STA r_battle_script_audiovisual.w + 2                                       ; $03E366 | | and then return without doing anything.
    JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E369 | |
    LDA #BATTLE_ALERT_NOTHING_HAPPENED.b                                        ; $03E36C | |
    STA r_battle_alert_queue.w                                                  ; $03E36E | |
    JMP @done                                                                   ; $03E371 |/
+   LDA r_monsters_invincible.w                                                 ; $03E374 |\ If monsters are invincible, branch back to the failure code.
    BNE -                                                                       ; $03E377 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03E379 |\ Save the ID for the weapon so the animation code will know which
    STA r_battle_effect_dart_weapon.w                                           ; $03E37C |/ sword to draw.
    TAX                                                                         ; $03E37F |\
    STX r_copy_from_array_arg_index.b                                           ; $03E380 | | Load the data for the piece of equipment being thrown.
    LDX #bank0F.equipment_property_data.w                                       ; $03E382 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03E385 | |
    LDA #:bank0F.equipment_property_data.b                                      ; $03E387 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03E389 | |
    LDA #_sizeof_equipment.b                                                    ; $03E38B | |
    JSR _copy_from_array.w                                                      ; $03E38D |/
    LDA r_copy_from_array_result.w + equipment.power                            ; $03E390 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03E393 | | Initially set the damage to the equipment power times the actor's
    LDA r_character_battle_current_actor.level.w                                ; $03E395 | | level.
    STA <r_math_multiply_8bit_arg_2                                             ; $03E398 | |
    JSR _math_multiply_8bit                                                     ; $03E39A | |
    LDX <r_math_multiply_8bit_result                                            ; $03E39D | |
    STX r_copy_from_array_result.w                                              ; $03E39F |/
    JSR _get_battle_rng_0_98                                                    ; $03E3A2 | Get a random value from 0 to 98, inclusive.
    CLC                                                                         ; $03E3A5 |\
    ADC r_copy_from_array_result.w + 0                                          ; $03E3A6 | | Add that value to the previously calculated value.
    STA <r_math_multiply_8bit_result_lo                                         ; $03E3A9 | |
    LDA #0.b                                                                    ; $03E3AB | |
    ADC r_copy_from_array_result.w + 1                                          ; $03E3AD | |
    STA <r_math_multiply_8bit_result_hi                                         ; $03E3B0 |/
    LDX <r_math_multiply_8bit_result                                            ; $03E3B2 |\
    CPX #9999.w                                                                 ; $03E3B4 | | If the result is greater than 9999, set it explicitly to 9999.
    BCC +                                                                       ; $03E3B7 | |
    LDX #9999.w                                                                 ; $03E3B9 | |
    STX <r_math_multiply_8bit_result                                            ; $03E3BC |/
+   LDA <r_battle_command_target_slot                                           ; $03E3BE |\ Get the damage offset for the target slot.
    JSR _battle_get_damage_offset                                               ; $03E3C0 |/
    LDA <r_math_multiply_8bit_result_lo                                         ; $03E3C3 |\
    STA r_battle_slot_damage.w + 0,X                                            ; $03E3C5 | | Store the damage value for that slot.
    LDA <r_math_multiply_8bit_result_hi                                         ; $03E3C8 | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03E3CA |/
    JSR _battle_apply_pending_damage                                            ; $03E3CD | Apply the pending damage.
@done:
    RTS                                                                         ; $03E3D0

; _battle_command_execute_change ($03:E3D1)
;
; Handles the Change command.
_battle_command_execute_change:
    TDC                                                                         ; $03E3D1 |\
    TAX                                                                         ; $03E3D2 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03E3D3 |/
-   LDA r_character_battle.1.sprite_class.w,X                                   ; $03E3D4 |\
    STA <r_battle_generic_tmp_1_lo                                              ; $03E3D7 | | Flip the back row bit on the character in this slot.
    AND #SPRITE_CLASS_BACK_ROW.b                                                ; $03E3D9 | |
    EOR #SPRITE_CLASS_BACK_ROW.b                                                ; $03E3DB | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03E3DD |/
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E3DF |\
    AND #SPRITE_CLASS_BACK_ROW.b ~ %11111111                                    ; $03E3E1 | | Combine that value with the other bits in the byte and save it
    ORA <r_battle_generic_tmp_1_hi                                              ; $03E3E3 | | back to the stat record.
    STA r_character_battle.1.sprite_class.w,X                                   ; $03E3E5 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03E3E8 |\
    TXA                                                                         ; $03E3EA | | Increment the indexes and loop until all five slots have been
    CLC                                                                         ; $03E3EB | | updated.
    ADC #_sizeof_character_battle                                               ; $03E3EC | |
    TAX                                                                         ; $03E3EF | |
    TDC                                                                         ; $03E3F0 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03E3F1 | |
    INY                                                                         ; $03E3F3 | |
    CPY #5.w                                                                    ; $03E3F4 | |
    BNE -                                                                       ; $03E3F7 |/
    RTS                                                                         ; $03E3F9

; _battle_command_execute_bless ($03:E3FA)
;
; Handles the Bless command.
_battle_command_execute_bless:
    STZ r_battle_fusoya_bless_counter.w                                         ; $03E3FA | Zero out the bless counter.
    LDX #10.w                                                                   ; $03E3FD |\ Set the bless value to 10.
    STX r_battle_fusoya_bless_value.w                                           ; $03E400 |/
    INC r_battle_action_skip_action_timer_update.w                              ; $03E403 | Skip the action timer update for the actor.
    LDA #BATTLE_COMMAND_BLESS.b                                                 ; $03E406 |\
    STA r_battle_current_action_details.action.w                                ; $03E408 | | Set the current action as the Bless command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E40B | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E40D |/
    LDA #BATTLE_COMMAND_BLESS_OFF.b                                             ; $03E410 |\
    STA r_calculate_timer_value_arg_index.w                                     ; $03E412 | | Set the actor's action timer using a value calculated for the
    LDA #TIMER_MODE_COMMAND.b                                                   ; $03E415 | | command that turns Bless off.
    STA <r_calculate_timer_value_arg_mode                                       ; $03E417 | |
    LDA <r_battle_command_actor_slot                                            ; $03E419 | |
    JSR _calculate_timer_value                                                  ; $03E41B | |
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E41E | |
    JSR _set_timer_value                                                        ; $03E420 |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03E423 |\ Flag the timer as being command related.
    STA r_battle_timers.1.flags.w,X                                             ; $03E425 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E428 |\
    LDA #BATTLE_COMMAND_BLESS_OFF.b                                             ; $03E42A | | Set the actor's command to the command that disables Bless.
    STA r_character_battle.1.command.w,X                                        ; $03E42C |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E42F |\
    LDA #BATTLE_ALERT_DUMMY_36.b                                                ; $03E432 | | Display a dummied alert.
    STA r_battle_alert_queue.w                                                  ; $03E434 |/
    RTS                                                                         ; $03E437

; _battle_command_execute_bless_off ($03:E438)
;
; Handles the command that disables Bless.
_battle_command_execute_bless_off:
    LDA #$FF.b                                                                  ; $03E438 |\ Set the bless counter to $FF to disable bless.
    STA r_battle_fusoya_bless_counter.w                                         ; $03E43A |/
    RTS                                                                         ; $03E43D

; _battle_command_execute_twin ($03:E43E)
;
; Handles the Twin command, which sets up the twin casting status and sets
; timers until the completion happens.
_battle_command_execute_twin:
    LDX #1.w                                                                    ; $03E43E |\
    LDA <r_battle_command_actor_slot                                            ; $03E441 | | Load the slot number of the other twin and calculate the offsets
    CMP r_battle_twin_slots.w                                                   ; $03E443 | | for that slot.
    BEQ +                                                                       ; $03E446 | |
    DEX                                                                         ; $03E448 | |
+   LDA r_battle_twin_slots.w,X                                                 ; $03E449 | |
    JSR _calculate_offsets                                                      ; $03E44C |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E44F |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03E451 | | Jump to the failure code if the other twin is swooned or stoned.
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03E454 | |
    BEQ +                                                                       ; $03E456 | |
    JMP _battle_command_execute_twin_failed                                     ; $03E458 |/
+   LDA r_character_battle.1.status_2.w,X                                       ; $03E45B |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03E45E | | Jump to the failure code if the other twin has any of the
    BEQ +                                                                       ; $03E460 | | paralyze, sleep, charm or berserk statuses.
    JMP _battle_command_execute_twin_failed                                     ; $03E462 | |
+   LDA r_character_battle.1.status_3.w,X                                       ; $03E465 |/
    AND #STATUS_3_STOP.b                                                        ; $03E468 |\
    BEQ +                                                                       ; $03E46A | | Jump to the failure code if the other twin has the stop status.
    JMP _battle_command_execute_twin_failed                                     ; $03E46C |/
+   LDA r_character_battle.1.status_3.w,X                                       ; $03E46F |\
    ORA #STATUS_3_TWIN_CASTING.b                                                ; $03E472 | | Set the twin casting status on the other twin.
    STA r_character_battle.1.status_3.w,X                                       ; $03E474 |/
    LDA r_character_battle_current_actor.action_flags.w                         ; $03E477 |\ Transfer the action flags from the current slot to the other slot.
    STA r_character_battle.1.action_flags.w,X                                   ; $03E47A |/
    LDA r_character_battle_current_actor.targets.monster.w                      ; $03E47D |\ Transfer the targeting data from the acting slot to the other slot.
    STA r_character_battle.1.targets.monster.w,X                                ; $03E480 |/
    LDA #BATTLE_COMMAND_TWIN_CAST.b                                             ; $03E483 |\ Set the other twin's command to the second part of the Twin
    STA r_character_battle.1.command.w,X                                        ; $03E485 |/ command.
    LDX r_current_slot_offset_timer.w                                           ; $03E488 |\ Transfer the timer offset for the other twin into a separate
    STX <r_battle_command_execute_twin_tmp_timer_offset                         ; $03E48B |/ variable.
    LDA #BATTLE_COMMAND_TWIN_CAST.b                                             ; $03E48D |\
    STA r_calculate_timer_value_arg_index.w                                     ; $03E48F | | Calculate a timer value based on the actor's slot, using the
    LDA #TIMER_MODE_COMMAND.b                                                   ; $03E492 | | command mode with the second part of the Twin command.
    STA <r_calculate_timer_value_arg_mode                                       ; $03E494 | |
    LDA <r_battle_command_actor_slot                                            ; $03E496 | |
    JSR _calculate_timer_value                                                  ; $03E498 |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E49B |\ Set the timer value on the actor's action timer.
    JSR _set_timer_value                                                        ; $03E49D |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03E4A0 |\ Flag the timer as being a command.
    STA r_battle_timers.1.flags.w,X                                             ; $03E4A2 |/
    CLC                                                                         ; $03E4A5 |\
    LDA <r_battle_command_execute_twin_tmp_timer_offset_lo                      ; $03E4A6 | | Calculate the offset for the other twin's action timer, and load
    ADC #TIMER_OFFSET_ACTION.b                                                  ; $03E4A8 | | it into the X register.
    STA <r_battle_command_execute_twin_tmp_timer_offset_lo                      ; $03E4AA | |
    LDA <r_battle_command_execute_twin_tmp_timer_offset_hi                      ; $03E4AC | |
    ADC #0.b                                                                    ; $03E4AE | |
    STA <r_battle_command_execute_twin_tmp_timer_offset_hi                      ; $03E4B0 | |
    LDX <r_battle_command_execute_twin_tmp_timer_offset                         ; $03E4B2 |/
    LDA <r_set_timer_value_arg_lo                                               ; $03E4B4 |\
    STA r_battle_timers.1.value_lo.w,X                                          ; $03E4B6 | | Set the same timer value in the other twin's action timer.
    LDA <r_set_timer_value_arg_hi                                               ; $03E4B9 | |
    STA r_battle_timers.1.value_hi.w,X                                          ; $03E4BB |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03E4BE |\ Flag the other twin's action timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03E4C0 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E4C3 |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E4C5 | | Set the twin casting status on the actor.
    ORA #STATUS_3_TWIN_CASTING.b                                                ; $03E4C8 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E4CA |/
    LDA #BATTLE_COMMAND_TWIN_CAST.b                                             ; $03E4CD |\ Set the actor's command to the second part of Twin.
    STA r_character_battle.1.command.w,X                                        ; $03E4CF |/
    INC r_battle_action_skip_action_timer_update.w                              ; $03E4D2 | Skip the action timer update for the actor.
    RTS                                                                         ; $03E4D5
_battle_command_execute_twin_failed:
    LDA #$FF.b                                                                  ; $03E4D6 |\ Set the other twin slot to $FF.
    STA r_battle_twin_other_slot.w                                              ; $03E4D8 |/
    LDA #BATTLE_ALERT_FAILED.b                                                  ; $03E4DB |\
    STA r_battle_alert_queue.w                                                  ; $03E4DD | | Display an alert that shows the Twin command failed.
    JMP _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E4E0 |/

; _battle_command_execute_twin_cast ($03:E4E3)
;
; Handles the second half of the Twin command, which is the actual casting.
_battle_command_execute_twin_cast:
    LDA #$FF.b                                                                  ; $03E4E3 |\ Set the other twin slot to $FF.
    STA r_battle_twin_other_slot.w                                              ; $03E4E5 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E4E8 |\ Save the offset for the actor's stat record.
    STX <r_battle_command_execute_twin_tmp_actor_offset                         ; $03E4EA |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03E4EC |\
    AND #STATUS_3_TWIN_CASTING.b ~ %11111111                                    ; $03E4EF | | Remove the twin casting status from the actor, both in their true
    STA r_character_battle.1.status_3.w,X                                       ; $03E4F1 | | record and in the copy of the record.
    LDA r_character_battle_current_actor.status_3.w                             ; $03E4F4 | |
    AND #STATUS_3_TWIN_CASTING.b ~ %11111111                                    ; $03E4F7 | |
    STA r_character_battle_current_actor.status_3.w                             ; $03E4F9 |/
    LDX #1.w                                                                    ; $03E4FC |\
    LDA <r_battle_command_actor_slot                                            ; $03E4FF | | Set the X register to the twin index number for the other twin.
    CMP r_battle_twin_slots.w                                                   ; $03E501 | |
    BEQ +                                                                       ; $03E504 | |
    DEX                                                                         ; $03E506 |/
+   STZ <r_calculate_timer_value_arg_mode                                       ; $03E507 |\
    LDA r_battle_twin_slots.w,X                                                 ; $03E509 | | Calculate a timer value for that slot based on relative speed.
    JSR _calculate_timer_value                                                  ; $03E50C |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E50F |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E511 | | Remove the twin casting status from the other twin.
    AND #STATUS_3_TWIN_CASTING.b ~ %11111111                                    ; $03E514 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E516 |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03E519 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03E51C | | If the other twin is swoon or stone, branch to the failure code.
    BNE @failed                                                                 ; $03E51E |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03E520 |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03E523 | | Fail if the other twin has paralyze, sleep, charm or berserk.
    BEQ ++                                                                      ; $03E525 |/
@failed:
    LDA #BATTLE_COMMAND_WAIT.b                                                  ; $03E527 |\ Set the other twin's command to Wait.
    STA r_character_battle.1.command.w,X                                        ; $03E529 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03E52C |\
    TXA                                                                         ; $03E52E | | Determine which slot the other twin is in and save that to a
    JSR _math_divide_by_64                                                      ; $03E52F | | temporary variable.
    LSR A                                                                       ; $03E532 | |
    STA <r_battle_generic_tmp_1                                                 ; $03E533 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03E535 | |
    TDC                                                                         ; $03E537 |/
    TAX                                                                         ; $03E538 |\
-   LDA r_battle_twin_slots.w,X                                                 ; $03E539 | | Find which of the entries in the twin slots array is the other
    CMP <r_battle_generic_tmp_1_lo                                              ; $03E53C | | twin.
    BEQ +                                                                       ; $03E53E | |
    INX                                                                         ; $03E540 | |
    BRA -                                                                       ; $03E541 |/
+   ORA #%10000000.b                                                            ; $03E543 |\ Set the high bit on that slot in the array.
    STA r_battle_twin_slots.w,X                                                 ; $03E545 |/ TODO: Why?
    JMP _battle_command_execute_twin_failed                                     ; $03E548 | Jump to the Twin failure code.
++  LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E54B |\ Set the timer on the other twin's action timer.
    JSR _set_timer_value                                                        ; $03E54D |/
    STZ r_battle_timers.1.flags.w,X                                             ; $03E550 | Unset any flags for the other twin's action timer.
    LDX <r_current_slot_offset_character_battle                                 ; $03E553 |\ Save the offset for the other twin's stat record to a temporary
    STX <r_battle_command_execute_twin_tmp_other_offset                         ; $03E555 |/ variable.
    LDA r_character_battle.1.status_3.w,X                                       ; $03E557 |\
    AND #STATUS_3_STOP.b                                                        ; $03E55A | | If the other twin is stopped, branch to the failure code.
    BNE @failed                                                                 ; $03E55C |/
    LDX <r_battle_command_execute_twin_tmp_actor_offset                         ; $03E55E |\
    LDA r_character_battle.1.status_1.w,X                                       ; $03E560 | | If the acting twin is swoon or stone, branch to the failure code.
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03E563 | |
    BNE @failed                                                                 ; $03E565 |/
    LDA r_character_battle.1.status_2.w,X                                       ; $03E567 |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03E56A | | Fail if the acting twin has paralyze, sleep, charm or berserk.
    BNE @failed                                                                 ; $03E56C |/
    LDA r_character_battle.1.id.w,X                                             ; $03E56E |\
    AND #%00011111.b                                                            ; $03E571 | | If the acting twin is either FuSoYa or Golbez, set the spell to
    CMP #CHARACTER_FUSOYA.b                                                     ; $03E573 | | W.Meteo.
    BEQ +                                                                       ; $03E575 | |
    CMP #CHARACTER_GOLBEZ.b                                                     ; $03E577 | |
    BNE ++                                                                      ; $03E579 | |
+   LDA #SPELL_TWIN_W_METEO.b                                                   ; $03E57B | |
    BRA +++                                                                     ; $03E57D |/
++  JSR _get_battle_rng_0_255                                                   ; $03E57F | Generate a random number from 0 to 255.
    CMP #255.b                                                                  ; $03E582 |\
    BCC +                                                                       ; $03E584 | | If the value is 255, display a failed alert and return.
    LDA #BATTLE_ALERT_FAILED.b                                                  ; $03E586 | |
    STA r_battle_alert_queue.w                                                  ; $03E588 | |
    JMP _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E58B |/
+   CMP #64.b                                                                   ; $03E58E |\
    BCC +                                                                       ; $03E590 | | If the value is 64-254, set the spell to Flare.
    LDA #SPELL_TWIN_FLARE.b                                                     ; $03E592 | |
    BRA +++                                                                     ; $03E594 |/
+   LDA #SPELL_TWIN_COMET.b                                                     ; $03E596 | Otherwise, set it to Comet.
+++ STA <r_battle_command_execute_twin_tmp_spell                                ; $03E598 | Save the spell to a temporary variable.
    TAX                                                                         ; $03E59A |\
    STX <r_copy_from_array_arg_index                                            ; $03E59B | | Load the spell property data.
    LDX #bank0F.spell_property_data.w                                           ; $03E59D | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03E5A0 | |
    LDA #:bank0F.spell_property_data.b                                          ; $03E5A2 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03E5A4 | |
    LDA #_sizeof_spell.b                                                        ; $03E5A6 | |
    JSR _copy_from_array                                                        ; $03E5A8 |/
    LDA r_current_spell_properties.data.element_status_index.w                  ; $03E5AB |\
    AND #SPELL_ELEMENT_STATUS_INDEX.b                                           ; $03E5AE | | Calculcate the offset to this spell's element status bytes.
    STA <r_math_multiply_8bit_arg_1                                             ; $03E5B0 | |
    LDA #_sizeof_element_status.b                                               ; $03E5B2 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03E5B4 | |
    JSR _math_multiply_8bit                                                     ; $03E5B6 | |
    LDX <r_math_multiply_8bit_result                                            ; $03E5B9 |/
    TDC                                                                         ; $03E5BB |\
    TAY                                                                         ; $03E5BC | | Load the element status bytes from ROM.
-   LDA bank0F.equipment_element_status_data.l,X                                ; $03E5BD | |
    STA r_current_spell_properties.element_status.w,Y                           ; $03E5C1 | |
    INY                                                                         ; $03E5C4 | |
    INX                                                                         ; $03E5C5 | |
    CPY #_sizeof_element_status.w                                               ; $03E5C6 | |
    BNE -                                                                       ; $03E5C9 |/
    LDA r_character_battle_current_actor.mp_lo.w                                ; $03E5CB |\
    STA <r_battle_generic_tmp_1_lo                                              ; $03E5CE | | Transfer the actor's current MP into a temporary variable. If
    LDA r_character_battle_current_actor.mp_hi.w                                ; $03E5D0 | | greater than 255, simply assume 255.
    BEQ +                                                                       ; $03E5D3 | |
    LDA #255.b                                                                  ; $03E5D5 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03E5D7 |/
+   LDA r_current_spell_properties.data.wall_mp.w                               ; $03E5D9 |\
    AND #SPELL_WALL_MP_MP.b                                                     ; $03E5DC | | Copy the required MP for this spell to a temporary variable.
    STA <r_battle_generic_tmp_2_lo                                              ; $03E5DE |/
    CMP <r_battle_generic_tmp_1_lo                                              ; $03E5E0 |\
    BEQ +                                                                       ; $03E5E2 | | If the twin doesn't have enough MP, skip to the end.
    BCS ++                                                                      ; $03E5E4 |/
+   LDX <r_battle_command_execute_twin_tmp_other_offset                         ; $03E5E6 |\
    SEC                                                                         ; $03E5E8 | | Subtract the required MP from the other twin's current MP.
    LDA r_character_battle.1.mp_lo.w,X                                          ; $03E5E9 | |
    SBC <r_battle_generic_tmp_2_lo                                              ; $03E5EC | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03E5EE | |
    LDA r_character_battle.1.mp_hi.w,X                                          ; $03E5F0 | |
    SBC #0.b                                                                    ; $03E5F3 | |
    STA <r_battle_generic_tmp_1_hi                                              ; $03E5F5 |/
    BCC ++                                                                      ; $03E5F7 | If the other twin didn't have enough, branch to the end.
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E5F9 |\
    STA r_character_battle.1.mp_lo.w,X                                          ; $03E5FB | | Store the other twin's new MP.
    LDA <r_battle_generic_tmp_1_hi                                              ; $03E5FE | |
    STA r_character_battle.1.mp_hi.w,X                                          ; $03E600 |/
    LDA <r_battle_command_execute_twin_tmp_spell                                ; $03E603 |\ Set the spell as the actor's subcommand.
    STA r_character_battle_current_actor.subcommand.w                           ; $03E605 |/
    INC r_battle_current_action_uses_mp.w                                       ; $03E608 | Flag this action as requiring MP.
    JSR _battle_calculate_magic_damage                                          ; $03E60B | Calculate damage using the magic calculation algorithm.
++  RTS                                                                         ; $03E60E

; _battle_command_execute_cover ($03:E60F)
;
; Handles the Cover command.
_battle_command_execute_cover:
    LDA <r_battle_command_target_slot                                           ; $03E60F |\ Store the covered slot in a variable.
    STA r_battle_cover_slot.w                                                   ; $03E611 |/
    JSR _calculate_offsets                                                      ; $03E614 |\
    LDX <r_current_slot_offset_character_battle                                 ; $03E617 | | Set the covered status on the target.
    LDA r_character_battle.1.status_4.w,X                                       ; $03E619 | |
    ORA #STATUS_4_COVERED.b                                                     ; $03E61C | |
    STA r_character_battle.1.status_4.w,X                                       ; $03E61E |/
    LDA <r_battle_command_actor_slot                                            ; $03E621 |\
    JSR _calculate_offsets                                                      ; $03E623 | | Set the X register to the offset to the actor's command list.
    LDX r_current_slot_offset_command_list.w                                    ; $03E626 |/
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03E629 |\
    CMP #BATTLE_COMMAND_COVER.b                                                 ; $03E62C | | Loop through the command list looking for the Cover command.
    BEQ +                                                                       ; $03E62E | |
    INX                                                                         ; $03E630 | |
    INX                                                                         ; $03E631 | |
    INX                                                                         ; $03E632 | |
    INX                                                                         ; $03E633 | |
    BRA -                                                                       ; $03E634 |/
+   LDA #BATTLE_COMMAND_OFF.b                                                   ; $03E636 |\ Set the command to the Off command instead.
    STA r_battle_commands.1.commands.1.id.w,X                                   ; $03E638 |/
    TDC                                                                         ; $03E63B |\ Ensure the command is enabled, set it to self targeting, and unset
    STA r_battle_commands.1.commands.1.flags.w,X                                ; $03E63C |/ a TODO flag ($08).
    LDA <r_battle_command_actor_slot                                            ; $03E63F |\
    STA <r_battle_update_arg_slot                                               ; $03E641 | | Update the actor's command menu entries.
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_ENTRIES.b                              ; $03E643 | |
    JSR _battle_update                                                          ; $03E645 |/
    LDA #BATTLE_COMMAND_COVER.b                                                 ; $03E648 |\
    STA r_battle_current_action_details.action.w                                ; $03E64A | | Set the current action as the Cover command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E64D | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E64F |/
    RTS                                                                         ; $03E652

; _battle_command_execute_off ($03:E653)
;
; Handles the Off command.
_battle_command_execute_off:
    LDA #BATTLE_COMMAND_OFF.b                                                   ; $03E653 |\
    STA r_battle_current_action_details.action.w                                ; $03E655 | | Set the current action as the Off command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E658 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E65A |/
    LDA r_battle_cover_slot.w                                                   ; $03E65D |\
    JSR _calculate_offsets                                                      ; $03E660 | | Remove the covered status from the previously selected cover
    LDX <r_current_slot_offset_character_battle                                 ; $03E663 | | target.
    LDA r_character_battle.1.status_4.w,X                                       ; $03E665 | |
    AND #STATUS_4_COVERED.b ~ %11111111                                         ; $03E668 | |
    STA r_character_battle.1.status_4.w,X                                       ; $03E66A |/
    LDA <r_battle_command_actor_slot                                            ; $03E66D |\ Recalculate the offsets for the actor's slot.
    JSR _calculate_offsets                                                      ; $03E66F |/
    LDX r_current_slot_offset_command_list.w                                    ; $03E672 |\
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03E675 | | Loop through the actor's command entries searching for the Off
    CMP #BATTLE_COMMAND_OFF.b                                                   ; $03E678 | | command.
    BEQ +                                                                       ; $03E67A | |
    INX                                                                         ; $03E67C | |
    INX                                                                         ; $03E67D | |
    INX                                                                         ; $03E67E | |
    INX                                                                         ; $03E67F | |
    BRA -                                                                       ; $03E680 |/
+   LDA #BATTLE_COMMAND_COVER.b                                                 ; $03E682 |\ Replace it with the Cover command.
    STA r_battle_commands.1.commands.1.id.w,X                                     ; $03E684 |/
    LDA #BATTLE_COMMAND_FLAG_TARGETING_SINGLE.b | BATTLE_COMMAND_FLAG_UNKNOWN_3 ; $03E687 |\ Set the targeting to single and set a TODO flag.
    STA r_battle_commands.1.commands.1.flags.w,X                                  ; $03E689 |/
    LDA <r_battle_command_actor_slot                                            ; $03E68C |\
    STA <r_battle_update_arg_slot                                               ; $03E68E | | Update the command menu entries for this slot.
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_ENTRIES.b                              ; $03E690 | |
    JSR _battle_update                                                          ; $03E692 |/
    RTS                                                                         ; $03E695

; _battle_command_execute_endure ($03:E696)
;
; Handles the Endure command, which casts Armor on the user.
_battle_command_execute_endure:
    LDA #SPELL_ARMOR.b                                                          ; $03E696 |\
    STA r_character_battle_current_actor.subcommand.w                           ; $03E698 | | Cast the Armor spell on the target.
    STZ r_battle_script_audiovisual.w + 2                                       ; $03E69B | |
    JSR _battle_calculate_magic_damage                                          ; $03E69E |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03E6A1 |\
    LDA #BATTLE_ALERT_DUMMY_3A.b                                                ; $03E6A4 | | Display an alert regarding the cast.
    STA r_battle_alert_queue.w                                                  ; $03E6A6 |/
    LDA #BATTLE_COMMAND_ENDURE.b                                                ; $03E6A9 |\
    STA r_battle_current_action_details.action.w                                ; $03E6AB | | Set the action details to indicate the Endure command is being
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E6AE | | used.
    STA r_battle_current_action_details.action_flags.w                          ; $03E6B0 |/
    RTS                                                                         ; $03E6B3

; _battle_command_execute_kick ($03:E6B4)
;
; Handles the Kick command.
_battle_command_execute_kick:
    STZ <r_battle_calculate_kick_dark_wave_damage_arg_dark_wave                 ; $03E6B4 |\ Calculate the damage for the Kick command.
    JMP _battle_calculate_kick_dark_wave_damage                                 ; $03E6B6 |/

; _battle_calculate_kick_dark_wave_damage ($03:E6B9)
;
; This routine calcultes damage for both the Kick and Dark Wave commands. There
; is some specific code for both. Dark Wave is signaled by passing 1 in $C1.
_battle_calculate_kick_dark_wave_damage:
    LDA <r_battle_command_actor_slot                                            ; $03E6B9 |\ If the actor is not a monster, branch ahead to the party code.
    BPL @party                                                                  ; $03E6BB |/
    STA r_battle_current_action_details.action_flags.w                          ; $03E6BD | NOTE: This makes no sense, but will effectively set the physical bit.
    LDA #BATTLE_TARGET_PARTY_ALL.b                                              ; $03E6C0 |\ Set the target to the entire party.
    STA r_battle_current_action_details.target.w                                ; $03E6C2 |/
    TDC                                                                         ; $03E6C5 |\
    TAX                                                                         ; $03E6C6 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03E6C7 |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03E6C8 |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03E6CB | | Copy the audiovisual script to a temporary area until encountering
    CMP #MONSTER_COMMAND_KICK.b                                                 ; $03E6CE | | either a kick or dark wave command.
    BEQ ++                                                                      ; $03E6D0 | |
    CMP #MONSTER_COMMAND_DARK_WAVE.b                                            ; $03E6D2 | |
    BEQ ++                                                                      ; $03E6D4 | |
    INX                                                                         ; $03E6D6 | |
    INY                                                                         ; $03E6D7 | |
    BRA -                                                                       ; $03E6D8 |/
++  INY                                                                         ; $03E6DA |\
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03E6DB | | Set the next two bytes in the script to the damage display codes.
    STA r_battle_script_tmp_copy.w,Y                                            ; $03E6DD | |
    INY                                                                         ; $03E6E0 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03E6E1 | |
    STA r_battle_script_tmp_copy.w,Y                                            ; $03E6E3 | |
    INY                                                                         ; $03E6E6 | |
    INX                                                                         ; $03E6E7 |/
-   LDA r_battle_script_audiovisual.w,X                                         ; $03E6E8 |\
    STA r_battle_script_tmp_copy.w,Y                                            ; $03E6EB | | Copy the remainder of the script until the end command to the
    CMP #MONSTER_COMMAND_END.b                                                  ; $03E6EE | | temporary area.
    BEQ +                                                                       ; $03E6F0 | |
    INX                                                                         ; $03E6F2 | |
    INY                                                                         ; $03E6F3 | |
    BRA -                                                                       ; $03E6F4 |/
+   TDC                                                                         ; $03E6F6 |\
    TAX                                                                         ; $03E6F7 | | Copy the entire script from the temporary area back to the main
-   LDA r_battle_script_tmp_copy.w,X                                            ; $03E6F8 | | script location.
    STA r_battle_script_audiovisual.w,X                                         ; $03E6FB | |
    CMP #MONSTER_COMMAND_END.b                                                  ; $03E6FE | |
    BEQ +                                                                       ; $03E700 | |
    INX                                                                         ; $03E702 | |
    BRA -                                                                       ; $03E703 |/
+   BRA ++                                                                      ; $03E705 | Branch ahead past the party-specific code.
@party:
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03E707 |\
    STA r_battle_script_audiovisual.w + 4                                       ; $03E709 | | For the party, just set the dialog display codes directly in the
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03E70C | | script at the next location.
    STA r_battle_script_audiovisual.w + 5                                       ; $03E70E |/
++  LDA r_monsters_invincible.w                                                 ; $03E711 |\
    BEQ +                                                                       ; $03E714 | | If monsters are invincible, jump to the end.
    JMP @done                                                                   ; $03E716 |/
+   LDX <r_current_slot_offset_character_battle                                 ; $03E719 |\
    LDA r_character_battle.1.physical_attack_multiplier.w,X                     ; $03E71B | | Set the first argument to the physical attack multiplier.
    STA <r_math_multiply_8bit_arg_1                                             ; $03E71E |/
    LDA <r_battle_calculate_kick_dark_wave_damage_arg_dark_wave                 ; $03E720 |\
    BNE +                                                                       ; $03E722 | | If this is kick, divide the multiplier by two. If the result is
    LSR <r_math_multiply_8bit_arg_1                                             ; $03E724 | | zero, add one.
    LDA <r_math_multiply_8bit_arg_1                                             ; $03E726 | |
    BNE +                                                                       ; $03E728 | |
    INC <r_math_multiply_8bit_arg_1                                             ; $03E72A |/
+   LDA <r_math_multiply_8bit_arg_1                                             ; $03E72C |\ Save the calculated multiplier for later use.
    STA <r_battle_calculate_kick_dark_wave_damage_multiplier                    ; $03E72E |/
    LDA r_character_battle.1.physical_attack_base.w,X                           ; $03E730 |\ Copy the actor's physical attack base to a local variable.
    STA <r_battle_calculate_kick_dark_wave_damage_attack_base                   ; $03E733 |/
    STA <r_math_multiply_8bit_arg_2                                             ; $03E735 |\
    JSR _math_multiply_8bit                                                     ; $03E737 | | Multiply the multiplier by the base value, and then divide by two.
    LSR <r_math_multiply_8bit_result_hi                                         ; $03E73A | | Save the result to another variable as the base damage.
    ROR <r_math_multiply_8bit_result_lo                                         ; $03E73C | |
    LDX <r_math_multiply_8bit_result_lo                                         ; $03E73E | |
    STX <r_battle_calculate_kick_dark_wave_damage_base_damage                   ; $03E740 |/
    LDA <r_battle_command_actor_slot                                            ; $03E742 |\
    BMI +                                                                       ; $03E744 | | If the actor is a party member, set the initial slot to 5 and the
    LDX #5.w                                                                    ; $03E746 | | maximum slot to 13 (to explore the monster range from 5 to 12).
    STX <r_battle_calculate_kick_dark_wave_damage_tmp_slot                      ; $03E749 | |
    LDX #(5 + 8).w                                                              ; $03E74B | |
    STX <r_battle_calculate_kick_dark_wave_damage_slot_max                      ; $03E74E | |
    BRA @start                                                                  ; $03E750 |/
+   TDC                                                                         ; $03E752 |\
    TAX                                                                         ; $03E753 | | Otherwise, set the initial slot to 0 and the maximum slot to 5.
    STX <r_battle_calculate_kick_dark_wave_damage_tmp_slot                      ; $03E754 | |
    LDX #5.w                                                                    ; $03E756 | |
    STX <r_battle_calculate_kick_dark_wave_damage_slot_max                      ; $03E759 |/
@start:
    TDC                                                                         ; $03E75B |\
    TAX                                                                         ; $03E75C | | Choose a random number from 0 to the physical attack base and save
    LDA <r_battle_calculate_kick_dark_wave_damage_attack_base                   ; $03E75D | | it initially to the damage value.
    JSR _get_battle_rng                                                         ; $03E75F | |
    STA <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E762 |/
    CLC                                                                         ; $03E764 |\
    LDA <r_battle_calculate_kick_dark_wave_damage_base_damage_lo                ; $03E765 | | Add that to the base damage value calculated above.
    ADC <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E767 | |
    STA <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E769 | |
    LDA <r_battle_calculate_kick_dark_wave_damage_base_damage_hi                ; $03E76B | |
    ADC #0.b                                                                    ; $03E76D | |
    STA <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E76F |/
    LDA <r_battle_calculate_kick_dark_wave_damage_tmp_slot_lo                   ; $03E771 |
    TAX                                                                         ; $03E773 |\
    LDA r_battle_slot_empty.w,X                                                 ; $03E774 | | If the current slot is empty, skip to the next slot.
    BNE @next                                                                   ; $03E777 |/
    LDA <r_battle_calculate_kick_dark_wave_damage_tmp_slot_lo                   ; $03E779 |\
    JSR _calculate_offsets                                                      ; $03E77B | | Skip this slot if it has either of the swoon or stone statuses.
    LDX <r_current_slot_offset_character_battle                                 ; $03E77E | |
    LDA r_character_battle.1.status_1.w,X                                       ; $03E780 | |
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03E783 | |
    BNE @next                                                                   ; $03E785 |/
    LDA r_character_battle.1.status_3.w,X                                       ; $03E787 |\
    AND #STATUS_3_JUMPING.b                                                     ; $03E78A | | Skip this slot if it's jumping.
    BNE @next                                                                   ; $03E78C |/
    LDA r_character_battle.1.status_4.w,X                                       ; $03E78E |\ Skip this slot if it's hiding.
    BMI @next                                                                   ; $03E791 |/
    LDA r_character_battle.1.monster_race.w,X                                   ; $03E793 |\
    AND #MONSTER_RACE_FLAN.b                                                    ; $03E796 | | Skip this slot if it's a flan-type monster.
    BNE @next                                                                   ; $03E798 |/
    LDA <r_battle_calculate_kick_dark_wave_damage_arg_dark_wave                 ; $03E79A |\
    BEQ +                                                                       ; $03E79C | | If the parameter is non-zero and the monster is undead, divide the
    LDA r_character_battle.1.monster_race.w,X                                   ; $03E79E | | calculated damage by 4.
    BPL +                                                                       ; $03E7A1 | |
    LSR <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E7A3 | |
    ROR <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E7A5 | |
    LSR <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E7A7 | |
    ROR <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E7A9 |/
+   LDA <r_battle_calculate_kick_dark_wave_damage_arg_dark_wave                 ; $03E7AB |\ If the command is dark wave, branch past this next block.
    BNE +                                                                       ; $03E7AD |/
    LDA <r_battle_calculate_kick_dark_wave_damage_multiplier                    ; $03E7AF |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03E7B1 | | Multiply the previously calculated multiplier by the target's
    LDA r_character_battle.1.physical_defense_base.w,X                          ; $03E7B3 | | physical defense base.
    STA <r_math_multiply_8bit_arg_2                                             ; $03E7B6 | |
    JSR _math_multiply_8bit                                                     ; $03E7B8 |/
    SEC                                                                         ; $03E7BB |\
    LDA <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E7BC | | Subtract that from the previously calculated damage.
    SBC <r_math_multiply_8bit_result_lo                                         ; $03E7BE | |
    STA <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E7C0 | |
    LDA <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E7C2 | |
    SBC <r_math_multiply_8bit_result_hi                                         ; $03E7C4 | |
    STA <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E7C6 |/
    BCS +                                                                       ; $03E7C8 |\
-   LDX #BATTLE_DAMAGE_MISS.w                                                   ; $03E7CA | | If it fell below zero, set the damage result to a miss.
    STX <r_battle_calculate_kick_dark_wave_damage_damage                        ; $03E7CD |/
+   LDX <r_battle_calculate_kick_dark_wave_damage_damage                        ; $03E7CF |\ If the result was exactly zero, branch to make it a miss instead.
    BEQ -                                                                       ; $03E7D1 |/
    LDA <r_battle_calculate_kick_dark_wave_damage_tmp_slot_lo                   ; $03E7D3 |\
    ASL A                                                                       ; $03E7D5 | | Store the calculated damage for this slot.
    TAX                                                                         ; $03E7D6 | |
    LDA <r_battle_calculate_kick_dark_wave_damage_damage_lo                     ; $03E7D7 | |
    STA r_battle_slot_damage.w + 0,X                                            ; $03E7D9 | |
    LDA <r_battle_calculate_kick_dark_wave_damage_damage_hi                     ; $03E7DC | |
    STA r_battle_slot_damage.w + 1,X                                            ; $03E7DE |/
@next:
    INC <r_battle_calculate_kick_dark_wave_damage_tmp_slot_lo                   ; $03E7E1 |\
    LDA <r_battle_calculate_kick_dark_wave_damage_tmp_slot_lo                   ; $03E7E3 | | Increment the slot and loop until all slots have been considered.
    CMP <r_battle_calculate_kick_dark_wave_damage_slot_max_lo                   ; $03E7E5 | |
    BEQ +                                                                       ; $03E7E7 | |
    JMP @start                                                                  ; $03E7E9 |/
+   JSR _battle_apply_pending_damage                                            ; $03E7EC | Apply the pending damage.
@done:
    RTS                                                                         ; $03E7EF

; _battle_command_execute_build_up ($03:E7F0)
;
; Handles the Build Up command.
_battle_command_execute_build_up:
    INC r_battle_action_skip_action_timer_update.w                              ; $03E7F0 | Skip the action timer update for the actor.
    LDA #BATTLE_COMMAND_RELEASE.b                                               ; $03E7F3 |\
    STA r_calculate_timer_value_arg_index.w                                     ; $03E7F5 | | Calculate the timer value for the finishing command.
    LDA #TIMER_MODE_COMMAND.b                                                   ; $03E7F8 | |
    STA <r_calculate_timer_value_arg_mode                                       ; $03E7FA | |
    LDA <r_battle_command_actor_slot                                            ; $03E7FC | |
    JSR _calculate_timer_value                                                  ; $03E7FE |/
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E801 |\ Set that value in the actor's action timer.
    JSR _set_timer_value                                                        ; $03E803 |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03E806 |\ Flag the action timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03E808 |/
    LDX <r_current_slot_offset_character_battle.b                               ; $03E80B |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E80D | | Set the charging status on the actor.
    ORA #STATUS_3_CHARGING.b                                                    ; $03E810 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E812 |/
    LDA #BATTLE_COMMAND_RELEASE.b                                               ; $03E815 |\ Set the actor's command to the finishing command.
    STA r_character_battle.1.command.w,X                                        ; $03E817 |/
    JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E81A |\
    LDA #BATTLE_ALERT_DUMMY_39.b                                                ; $03E81D | | Display an alert message (dummied in this version).
    STA r_battle_alert_queue.w                                                  ; $03E81F |/
    RTS                                                                         ; $03E822

; _battle_command_execute_release ($03:E823)
;
; Handles the unnamed release command, which finishes the Build Up command.
_battle_command_execute_release:
    JSR _battle_command_execute_fight.w                                         ; $03E823 | Calculate the damage using the Fight command handler.
    LDA <r_battle_command_actor_slot                                            ; $03E826 |\
    JSR _calculate_offsets                                                      ; $03E828 | | Remove the charging status from the actor.
    LDX <r_current_slot_offset_character_battle                                 ; $03E82B | |
    LDA r_character_battle.1.status_3.w,X                                       ; $03E82D | |
    AND #STATUS_3_CHARGING.b ~ %11111111                                        ; $03E830 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E832 |/
    RTS                                                                         ; $03E835

; _battle_command_execute_aim ($03:E836)
;
; Handles the Aim command.
_battle_command_execute_aim:
    LDA r_character_battle_current_actor.physical_attack_accuracy.w             ; $03E836 |\ Preserve the actor's physical attack accuracy.
    PHA                                                                         ; $03E839 |/
    LDA r_character_battle_current_target.physical_defense_evade.w              ; $03E83A |\ Preserve the target's physical evade.
    PHA                                                                         ; $03E83D |/
    TDC                                                                         ; $03E83E |\ Set the target's evade explicitly to zero.
    STA r_character_battle_current_target.physical_defense_evade.w              ; $03E83F |/
    DEC A                                                                       ; $03E842 |\ Set the actor's accuracy to 255.
    STA r_character_battle_current_actor.physical_attack_accuracy.w             ; $03E843 |/
    JSR _battle_command_execute_fight                                           ; $03E846 | Execute the Fight command logic.
    PLA                                                                         ; $03E849 |\ Restore the target's original evade.
    STA r_character_battle_current_target.physical_defense_evade.w              ; $03E84A |/
    PLA                                                                         ; $03E84D |\ Restore the actor's original accuracy.
    STA r_character_battle_current_actor.physical_attack_accuracy.w             ; $03E84E |/
    RTS                                                                         ; $03E851

; _battle_command_execute_pray ($03:E852)
;
; Handles the Pray command, which has a 50% chance of casting Cure1 and a 50%
; chance of failure.
_battle_command_execute_pray:
    JSR _get_battle_rng_0_255                                                   ; $03E852 | Get a random value from 0 to 255.
    CMP #128.b                                                                  ; $03E855 |\
    BCC +                                                                       ; $03E857 | | If the value was 128 to 255, add the codes to display an alert
    JSR _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E859 | | and branch to the end.
    LDA #BATTLE_ALERT_DUMMY_10.b                                                ; $03E85C | |
    STA r_battle_alert_queue.w                                                  ; $03E85E | |
    BRA ++                                                                      ; $03E861 |/
+   LDA #SPELL_CURE1.b                                                          ; $03E863 |\
    STA r_character_battle_current_actor.subcommand.w                           ; $03E865 | | Otherwise, cast Cure1 on the party.
    JSR _battle_calculate_magic_damage                                          ; $03E868 |/
++  LDA #BATTLE_COMMAND_PRAY.b                                                  ; $03E86B |\
    STA r_battle_current_action_details.action.w                                ; $03E86D | | Set the action details to reflect the Pray command being used.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E870 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E872 |/
    RTS                                                                         ; $03E875

; _battle_command_execute_hide ($03:E876)
;
; Handles the Hide command.
_battle_command_execute_hide:
    LDX <r_current_slot_offset_character_battle                                 ; $03E876 |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03E878 | | Set the hiding status on the actor.
    ORA #STATUS_4_HIDING.b                                                      ; $03E87B | |
    STA r_character_battle.1.status_4.w,X                                       ; $03E87D |/
    LDX r_current_slot_offset_command_list.w                                    ; $03E880 | Load the offset to the command list into the X register.
    STZ <r_battle_generic_tmp_1_lo                                              ; $03E883 | Initialize the command index to zero.
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03E885 |\
    CMP #BATTLE_COMMAND_HIDE.b                                                  ; $03E888 | | If the current command is the Hide command, change it to Show.
    BNE +                                                                       ; $03E88A | |
    LDA #BATTLE_COMMAND_SHOW.b                                                  ; $03E88C | |
    STA r_battle_commands.1.commands.1.id.w,X                                   ; $03E88E | |
    BRA ++                                                                      ; $03E891 |/
+   LDA r_battle_commands.1.commands.1.flags.w,X                                ; $03E893 |\
    ORA #BATTLE_COMMAND_FLAG_DISABLED.b                                         ; $03E896 | | Otherwise, set a flag to disable the command.
    STA r_battle_commands.1.commands.1.flags.w,X                                ; $03E898 |/
++  INX                                                                         ; $03E89B |\
    INX                                                                         ; $03E89C | | Increment the indexes and loop until all five commands have been
    INX                                                                         ; $03E89D | | updated as appropriate.
    INX                                                                         ; $03E89E | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03E89F | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E8A1 | |
    CMP #5.b                                                                    ; $03E8A3 | |
    BNE -                                                                       ; $03E8A5 |/
    LDA <r_battle_command_actor_slot                                            ; $03E8A7 |\
    STA <r_battle_update_arg_slot                                               ; $03E8A9 | | Update this slot's command menu entries.
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_ENTRIES.b                              ; $03E8AB | |
    JSR _battle_update                                                          ; $03E8AD |/
    LDA #BATTLE_COMMAND_HIDE.b                                                  ; $03E8B0 |\
    STA r_battle_current_action_details.action.w                                ; $03E8B2 | | Set the action details to indicate the Hide command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E8B5 | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E8B7 |/
    RTS                                                                         ; $03E8BA

; _battle_command_execute_show ($03:E8BB)
;
; Handles the Show command.
_battle_command_execute_show:
    LDX <r_current_slot_offset_character_battle                                 ; $03E8BB |\
    LDA r_character_battle.1.status_4.w,X                                       ; $03E8BD | | Remove the hiding status from the actor.
    AND #STATUS_4_HIDING.b ~ %11111111                                          ; $03E8C0 | |
    STA r_character_battle.1.status_4.w,X                                       ; $03E8C2 |/
    LDX r_current_slot_offset_command_list.w                                    ; $03E8C5 | Initialize the X register to the command list offset.
    STZ <r_battle_generic_tmp_1_lo                                              ; $03E8C8 | Initialize the counter to zero.
-   LDA r_battle_commands.1.commands.1.id.w,X                                   ; $03E8CA |\
    CMP #BATTLE_COMMAND_SHOW.b                                                  ; $03E8CD | | If the next command in the list is Show, replace it with Hide.
    BNE +                                                                       ; $03E8CF | | Otherwise, remove the disabled bit to re-enable the command.
    LDA #BATTLE_COMMAND_HIDE.b                                                  ; $03E8D1 | |
    STA r_battle_commands.1.commands.1.id.w,X                                   ; $03E8D3 | | BUG: This also enables any nonexistent commands in the list,
    BRA ++                                                                      ; $03E8D6 | |      which allows the player to select an invalid command that
+   LDA r_battle_commands.1.commands.1.flags.w,X                                ; $03E8D8 | |      will lock up the game.
    AND #BATTLE_COMMAND_FLAG_DISABLED.b ~ %11111111                             ; $03E8DB | |
    STA r_battle_commands.1.commands.1.flags.w,X                                ; $03E8DD |/
++  INX                                                                         ; $03E8E0 |\
    INX                                                                         ; $03E8E1 | | Increment the indexes and loop until all five command entries have
    INX                                                                         ; $03E8E2 | | been checked.
    INX                                                                         ; $03E8E3 | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03E8E4 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03E8E6 | |
    CMP #5.b                                                                    ; $03E8E8 | |
    BNE -                                                                       ; $03E8EA |/
    LDA <r_battle_command_actor_slot                                            ; $03E8EC |\
    STA <r_battle_update_arg_slot                                               ; $03E8EE | | Update the command menu entries for this slot.
    LDA #BATTLE_UPDATE_MODE_COMMAND_MENU_ENTRIES.b                              ; $03E8F0 | |
    JSR _battle_update                                                          ; $03E8F2 |/
    LDA #BATTLE_COMMAND_SHOW.b                                                  ; $03E8F5 |\
    STA r_battle_current_action_details.action.w                                ; $03E8F7 | | Set the current command as the Show command.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E8FA | |
    STA r_battle_current_action_details.action_flags.w                          ; $03E8FC |/
    RTS                                                                         ; $03E8FF

; _battle_command_execute_sing ($03:E900)
;
; Handler for the Sing command, which effectively casts a random spell among
; Charm, Sleep or Silence. If the actor is a toad, it will instead cast Toad.
; If not casting Toad, there is a 25% chance of failure.
_battle_command_execute_sing:
    LDA r_character_battle_current_actor.status_1.w                             ; $03E900 |\
    AND #STATUS_1_TOAD.b                                                        ; $03E903 | | If the actor is currently a toad, add the "Song of Toad" alert to
    BEQ +                                                                       ; $03E905 | | the queue, load the value for the toad spell, and branch to the
    LDA #BATTLE_ALERT_SONG_OF_TOAD.b                                            ; $03E907 | | execution.
    STA r_battle_alert_queue.w                                                  ; $03E909 | |
    LDA #SPELL_TOAD.b                                                           ; $03E90C | |
    BRA @execute                                                                ; $03E90E |/
+   JSR _get_battle_rng_0_255                                                   ; $03E910 | Get a random value from 0 to 255, inclusive.
    CMP #192.b                                                                  ; $03E913 |\
    BCC +                                                                       ; $03E915 | | If the value is from 192 to 255, display the "Nothing happened"
    LDA #BATTLE_ALERT_NOTHING_HAPPENED.b                                        ; $03E917 | | alert and load the value for no spell.
    STA r_battle_alert_queue.w                                                  ; $03E919 | |
    LDA #SPELL_NONE.b                                                           ; $03E91C | |
    BRA @execute                                                                ; $03E91E |/
+   CMP #128.b                                                                  ; $03E920 |\
    BCC +                                                                       ; $03E922 | | If the value is from 128 to 191, display the "Song of Silence"
    LDA #BATTLE_ALERT_SONG_OF_SILENCE.b                                         ; $03E924 | | alert and load the value for the Mute spell.
    STA r_battle_alert_queue.w                                                  ; $03E926 | |
    LDA #SPELL_MUTE.b                                                           ; $03E929 | |
    BRA @execute                                                                ; $03E92B |/
+   CMP #64.b                                                                   ; $03E92D |\
    BCC +                                                                       ; $03E92F | | If the value is from 64 to 127, display the "Song of Charm" alert
    LDA #BATTLE_ALERT_SONG_OF_CHARM.b                                           ; $03E931 | | and load the value for the Charm spell.
    STA r_battle_alert_queue.w                                                  ; $03E933 | |
    LDA #SPELL_CHARM.b                                                          ; $03E936 | |
    BRA @execute                                                                ; $03E938 |/
+   LDA #BATTLE_ALERT_LULLABY.b                                                 ; $03E93A |\
    STA r_battle_alert_queue.w                                                  ; $03E93C | | Otherwise, display the "Lullaby" alert and load the Sleep spell.
    LDA #SPELL_SLEEP.b                                                          ; $03E93F |/
@execute:
    STA r_character_battle_current_actor.subcommand.w                           ; $03E941 | Set the spell as the actor's subcommand.
    JSR _battle_calculate_magic_damage                                          ; $03E944 | Apply the statuses if appropriate.
    LDA #BATTLE_COMMAND_SING.b                                                  ; $03E947 |\ Set Sing as the current action's action.
    STA r_battle_current_action_details.action.w                                ; $03E949 |/
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03E94C |\ Set the action flags to signify that this action is a command.
    STA r_battle_current_action_details.action_flags.w                          ; $03E94E |/
    JMP _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03E951 | Set the codes to display the battle alerts.

; _battle_command_execute_jump ($03:E954)
;
; Handles the Jump command, which produces no damage, and only changes the
; status of the actor to jumping.
_battle_command_execute_jump:
    LDA <r_battle_command_actor_slot                                            ; $03E954 |\
    BMI +                                                                       ; $03E956 | | If both the actor and target are parpty members, change the
    LDA <r_battle_command_target_slot                                           ; $03E958 | | command to Cover (for animation purposes only), and set an alert
    BMI +                                                                       ; $03E95A | | to display the "Nothing happened." message.
    LDA #MONSTER_COMMAND_COVER.b                                                ; $03E95C | |
    STA r_battle_script_audiovisual.w + 2                                       ; $03E95E | |
    LDA #BATTLE_ALERT_NOTHING_HAPPENED.b                                        ; $03E961 | |
    STA r_battle_alert_queue.w                                                  ; $03E963 | |
    JMP _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03E966 |/
+   INC r_battle_action_skip_action_timer_update.w                              ; $03E969 | TODO: Increment an unknown variable.
    LDX #4.w                                                                    ; $03E96C |\
    STX <r_set_timer_value_arg                                                  ; $03E96F | | Set the actor's action timer to four.
    LDA #TIMER_OFFSET_ACTION.b                                                  ; $03E971 | |
    JSR _set_timer_value                                                        ; $03E973 |/
    LDA #TIMER_FLAG_COMMAND.b                                                   ; $03E976 |\ Flag the timer as being command-related.
    STA r_battle_timers.1.flags.w,X                                             ; $03E978 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E97B |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E97D | | Set the actor's status to jumping.
    ORA #STATUS_3_JUMPING.b                                                     ; $03E980 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E982 |/
    LDA <r_battle_command_actor_slot                                            ; $03E985 |\
    BPL +                                                                       ; $03E987 | | Set the actor's command to the appropriate land command.
    LDA #MONSTER_COMMAND_LAND.b                                                 ; $03E989 | |
    BRA ++                                                                      ; $03E98B | | TODO: Is that command actually land?
+   LDA #BATTLE_COMMAND_LAND.b                                                  ; $03E98D | |
++  STA r_character_battle.1.command.w,X                                        ; $03E98F |/
    LDA <r_battle_command_actor_slot                                            ; $03E992 |\
    ASL A                                                                       ; $03E994 | | Set the X register to the enabled timers offset.
    TAX                                                                         ; $03E995 |/
    LDA r_battle_enabled_timers.1.lo.w,X                                        ; $03E996 |\ Preserve the current value of the low enabled timers byte.
    STA r_battle_jump_timers_lo_backup.w                                        ; $03E999 |/
    LDA #TIMER_ENABLED_UNKNOWN6.b                                               ; $03E99C |\ TODO: Set an unknown timer enabled bit. (All known timers use the
    STA r_battle_enabled_timers.1.lo.w,X                                        ; $03E99E |/       high byte. Does the low byte actually serve an entirely different
    RTS                                                                         ; $03E9A1          purpose?

; _battle_command_execute_land ($03:E9A2)
;
; Handles the unnamed land command, which finishes the Jump command.
_battle_command_execute_land:
    JSR _battle_command_execute_fight                                           ; $03E9A2 | Calculate damage using the code for the Fight command.
    LDA <r_battle_command_actor_slot                                            ; $03E9A5 |\
    BPL +                                                                       ; $03E9A7 | | Calculate the offsets for the actor slot.
    AND #%01111111.b                                                            ; $03E9A9 | |
    CLC                                                                         ; $03E9AB | |
    ADC #5.b                                                                    ; $03E9AC | |
+   JSR _calculate_offsets                                                      ; $03E9AE |/
    LDX <r_current_slot_offset_character_battle                                 ; $03E9B1 |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E9B3 | | Remove the jumping status from the actor.
    AND #STATUS_3_JUMPING.b ~ %11111111                                         ; $03E9B6 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E9B8 |/
    LDA <r_battle_command_actor_slot                                            ; $03E9BB |\
    ASL A                                                                       ; $03E9BD | | Restore the original value of the low enabled timers byte.
    TAX                                                                         ; $03E9BE | |
    LDA r_battle_jump_timers_lo_backup.w                                        ; $03E9BF | |
    STA r_battle_enabled_timers.1.lo.w,X                                        ; $03E9C2 |/
    LDA <r_battle_command_actor_slot                                            ; $03E9C5 |\
    BPL +                                                                       ; $03E9C7 | | If the actor is a monster, add the codes to the audiovisual script
    LDA #MONSTER_COMMAND_LAND.b                                                 ; $03E9C9 | | to display the landing and the damage display. For character
    STA r_battle_script_audiovisual.w + 0                                       ; $03E9CB | | actors, this is added directly by the Fight command.
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG.b                                       ; $03E9CE | |
    STA r_battle_script_audiovisual.w + 1                                       ; $03E9D0 | |
    LDA #MONSTER_COMMAND_DISPLAY_DIALOG_DAMAGE.b                                ; $03E9D3 | |
    STA r_battle_script_audiovisual.w + 2                                       ; $03E9D5 | |
    LDA #MONSTER_COMMAND_END.b                                                  ; $03E9D8 | |
    STA r_battle_script_audiovisual.w + 3                                       ; $03E9DA |/
+   RTS                                                                         ; $03E9DD

; _battle_command_execute_parry ($03:E9DE)
;
; Handles the Parry command.
_battle_command_execute_parry:
    LDX <r_current_slot_offset_character_battle                                 ; $03E9DE |\
    LDA r_character_battle.1.status_3.w,X                                       ; $03E9E0 | | Set the defending status on the actor.
    ORA #STATUS_3_DEFENDING.b                                                   ; $03E9E3 | |
    STA r_character_battle.1.status_3.w,X                                       ; $03E9E5 |/
    RTS                                                                         ; $03E9E8

; _battle_command_execute_dark_wave ($03:E9E9)
;
; This handles the damage calculation for the Dark Wave command.
_battle_command_execute_dark_wave:
    LDA <r_battle_command_actor_slot                                            ; $03E9E9 |\ If the actor is a monster, skip the HP adjustment.
    BMI ++                                                                      ; $03E9EB |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03E9ED |\
    LDX <r_current_slot_offset_character_battle                                 ; $03E9EF | | Divide the actor's maximum HP by eight.
    LDA r_character_battle.1.hp_max.w,X                                         ; $03E9F1 | |
    JSR _math_divide_by_8                                                       ; $03E9F4 | |
    STA <r_battle_generic_tmp_1                                                 ; $03E9F7 |/
    SEC                                                                         ; $03E9F9 |\
    LDA r_character_battle.1.hp.w,X                                             ; $03E9FA | | Subtract that value from their current HP.
    SBC <r_battle_generic_tmp_1                                                 ; $03E9FD | |
    STA r_character_battle.1.hp.w,X                                             ; $03E9FF |/
    BCS +                                                                       ; $03EA02 |\
    LDA #0.w                                                                    ; $03EA04 | | If the result was negative, explicitly set the HP to zero and set
    STA r_character_battle.1.hp.w,X                                             ; $03EA07 | | the swoon status.
    LDA #STATUS_1_SWOON.w                                                       ; $03EA0A | |
    STA r_character_battle.1.status_1.w,X                                       ; $03EA0D | |
+   TDC                                                                         ; $03EA10 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03EA11 |/
++  LDA #1.b                                                                    ; $03EA13 |\
    STA <r_battle_calculate_kick_dark_wave_damage_arg_dark_wave                 ; $03EA15 | | Calculate the damage for the attack.
    JMP _battle_calculate_kick_dark_wave_damage                                 ; $03EA17 |/

; _battle_command_execute_recall ($03:EA1A)
;
; Handles the Recall command, which selects a random spell from a small set of
; spells.
_battle_command_execute_recall:
    TDC                                                                         ; $03EA1A |\
    TAX                                                                         ; $03EA1B | | Select a random number from 0 to 160.
    LDA #160.b                                                                  ; $03EA1C |/
    JSR _get_battle_rng                                                         ; $03EA1E |\
    CMP #8.b                                                                    ; $03EA21 | | If the value is between 0 and 7, cast the Stone spell.
    BCS +                                                                       ; $03EA23 | |
    LDA #SPELL_STONE.b                                                          ; $03EA25 | |
    BRA @cast                                                                   ; $03EA27 |/
+   CMP #16.b                                                                   ; $03EA29 |\
    BCS +                                                                       ; $03EA2B | | If the value is between 8 and 15, cast the Virus spell.
    LDA #SPELL_VIRUS.b                                                          ; $03EA2D | |
    BRA @cast                                                                   ; $03EA2F |/
+   CMP #24.b                                                                   ; $03EA31 |\
    BCS +                                                                       ; $03EA33 | | If the value is between 16 and 23, cast the Weak spell.
    LDA #SPELL_WEAK.b                                                           ; $03EA35 | |
    BRA @cast                                                                   ; $03EA37 |/
+   CMP #32.b                                                                   ; $03EA39 |\
    BCS +                                                                       ; $03EA3B | | If the value is between 24 and 31, cast the Fatal spell.
    LDA #SPELL_FATAL.b                                                          ; $03EA3D | |
    BRA @cast                                                                   ; $03EA3F |/
+   CMP #56.b                                                                   ; $03EA41 |\
    BCS +                                                                       ; $03EA43 | | If the value is between 32 and 55, cast the Fire1 spell.
    LDA #SPELL_FIRE1.b                                                          ; $03EA45 | |
    BRA @cast                                                                   ; $03EA47 |/
+   CMP #80.b                                                                   ; $03EA49 |\
    BCS +                                                                       ; $03EA4B | | If the value is between 56 and 79, cast the Ice-1 spell.
    LDA #SPELL_ICE_1.b                                                          ; $03EA4D | |
    BRA @cast                                                                   ; $03EA4F |/
+   CMP #104.b                                                                  ; $03EA51 |\
    BCS +                                                                       ; $03EA53 | | If the value is between 80 and 103, cast the Lit-1 spell.
    LDA #SPELL_LIT_1.b                                                          ; $03EA55 | |
    BRA @cast                                                                   ; $03EA57 |/
+   CMP #128.b                                                                  ; $03EA59 |\
    BCS +                                                                       ; $03EA5B | | If the value is between 104 and 127, cast the Toad spell.
    LDA #SPELL_TOAD.b                                                           ; $03EA5D | |
    BRA @cast                                                                   ; $03EA5F |/
+   LDA #BATTLE_ALERT_DUMMY_9.b                                                 ; $03EA61 |\
    STA r_battle_alert_queue.w                                                  ; $03EA63 | | Otherwise, display a failure message.
    JMP _battle_script_audiovisual_set_display_dialog_alert_6                   ; $03EA66 |/  BUG: This writes the dialog codes to the wrong bytes.
@cast:
    PHA                                                                         ; $03EA69 | Preserve the spell value being cast.
    TAX                                                                         ; $03EA6A |\
    STX r_copy_from_array_arg_index.b                                           ; $03EA6B | | Load the properties of the spell.
    LDX #bank0F.spell_property_data.w                                           ; $03EA6D | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03EA70 | |
    LDA #:bank0F.spell_property_data.b                                          ; $03EA72 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03EA74 | |
    LDA #_sizeof_spell.b                                                        ; $03EA76 | |
    JSR _copy_from_array                                                        ; $03EA78 |/
    LDA r_current_spell_properties.data.element_status_index.w                  ; $03EA7B |\
    AND #SPELL_ELEMENT_STATUS_INDEX.b                                           ; $03EA7E | | Load the element and status bytes for the spell.
    STA <r_math_multiply_8bit_arg_1                                             ; $03EA80 | |
    LDA #_sizeof_element_status.b                                               ; $03EA82 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03EA84 | |
    JSR _math_multiply_8bit                                                     ; $03EA86 | |
    LDX <r_math_multiply_8bit_result                                            ; $03EA89 | |
    TDC                                                                         ; $03EA8B | |
    TAY                                                                         ; $03EA8C | |
-   LDA bank0F.equipment_element_status_data.l,X                                ; $03EA8D | |
    STA r_current_spell_properties.element_status.w,Y                           ; $03EA91 | |
    INY                                                                         ; $03EA94 | |
    INX                                                                         ; $03EA95 | |
    CPY #_sizeof_element_status.w                                               ; $03EA96 | |
    BNE -                                                                       ; $03EA99 |/
    LDA r_character_battle_current_actor.mp_lo.w                                ; $03EA9B |\
    STA <r_battle_generic_tmp_1_lo                                              ; $03EA9E | | Copy the actor's current MP into a temporary variable. For the
    LDA r_character_battle_current_actor.mp_hi.w                                ; $03EAA0 | | purposes here, anything greater than 255 is assumed to be 255.
    BEQ +                                                                       ; $03EAA3 | |
    LDA #255.b                                                                  ; $03EAA5 | |
    STA <r_battle_generic_tmp_1_lo                                              ; $03EAA7 |/
+   LDA r_current_spell_properties.data.wall_mp.w                               ; $03EAA9 |\
    AND #SPELL_WALL_MP_MP.b                                                     ; $03EAAC | | If the actor has enough MP to cast the spell, jump to casting the
    CMP <r_battle_generic_tmp_1_lo                                              ; $03EAAE | | spell. Otherwise, jump to the end of the function without casting
    BEQ +                                                                       ; $03EAB0 | | the spell.
    BCC +                                                                       ; $03EAB2 | |
    PLA                                                                         ; $03EAB4 | |
    JMP ++                                                                      ; $03EAB5 | |
+   PLA                                                                         ; $03EAB8 |/
    STA r_character_battle_current_actor.subcommand.w                           ; $03EAB9 | Set the spell as the actor's subcommand.
    INC r_battle_current_action_uses_mp.w                                       ; $03EABC | Set the flag that indicates this action uses MP.
    JSR _battle_command_execute_magic                                           ; $03EABF | Execute the spell as if it were magic.
++  RTS                                                                         ; $03EAC2

; _battle_command_execute_bluff ($03:EAC3)
;
; Handles the Bluff command, which raises the user's wisdom stat by 16.
_battle_command_execute_bluff:
    LDA #BATTLE_COMMAND_BLUFF.b                                                 ; $03EAC3 |\
    STA r_battle_current_action_details.action.w                                ; $03EAC5 | | Set the action details to say the current action is the Bluff
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03EAC8 | | command.
    STA r_battle_current_action_details.action_flags.w                          ; $03EACA |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EACD |\
    CLC                                                                         ; $03EACF | | Add 16 to the character's current wisdom. If the value exceeds 99,
    LDA r_character_battle.1.wisdom.w,X                                         ; $03EAD0 | | set it explicitly back to 99.
    ADC #16.b                                                                   ; $03EAD3 | |
    CMP #99.b                                                                   ; $03EAD5 | | BUG: Modifying wisdom directly means that if the equipment is
    BCC +                                                                       ; $03EAD7 | |      changed, the buff will be lost. That may or may not be
    LDA #99.b                                                                   ; $03EAD9 | |      considered a bug.
+   STA r_character_battle.1.wisdom.w,X                                         ; $03EADB |/
    LDA #BATTLE_ALERT_DUMMY_12.b                                                ; $03EADE |\
    STA r_battle_alert_queue.w                                                  ; $03EAE0 | | Display a dummied alert.
    JMP _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03EAE3 |/

; _battle_command_execute_cry ($03:EAE6)
;
; Handles the Cry command.
_battle_command_execute_cry:
    LDA #BATTLE_COMMAND_CRY.b                                                   ; $03EAE6 |\
    STA r_battle_current_action_details.action.w                                ; $03EAE8 | | Set the current action details to show the Cry command being used.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_COMMAND.b                            ; $03EAEB | |
    STA r_battle_current_action_details.action_flags.w                          ; $03EAED |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EAF0 |\
    LDA r_character_battle.1.unknown2F.w,X                                      ; $03EAF2 | | TODO: Load the actor's $2F stat, divide it by two, and save that
    LSR A                                                                       ; $03EAF5 | |       to a temporary variable.
    STA <r_battle_generic_tmp_1_lo                                              ; $03EAF6 |/
    LDX #5.w                                                                    ; $03EAF8 |\ Initialize the slot number to 5.
    STX <r_battle_generic_tmp_2                                                 ; $03EAFB |/
-   LDX <r_battle_generic_tmp_2                                                 ; $03EAFD | Set the X register to the current slot number.
    LDA r_battle_slot_empty.w,X                                                 ; $03EAFF |\ Skip this slot if it's empty.
    BNE +++                                                                     ; $03EB02 |/
    TXA                                                                         ; $03EB04 |\ Calculate the offsets for this slot.
    JSR _calculate_offsets                                                      ; $03EB05 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EB08 |\
    SEC                                                                         ; $03EB0A | | TODO: Subtract the previously calculated value from the target's
    LDA r_character_battle.1.unknown2F.w,X                                      ; $03EB0B | |       $2F stat.
    SBC <r_battle_generic_tmp_1_lo.b                                            ; $03EB0E |/
    BEQ +                                                                       ; $03EB10 |\
    BCS ++                                                                      ; $03EB12 | | If the result was zero or less, set the result to 1.
+   LDA #1.b                                                                    ; $03EB14 |/
++  STA r_character_battle.1.unknown2F.w,X                                      ; $03EB16 | Save the result as the target's new $2F stat.
+++ INC <r_battle_generic_tmp_2                                                 ; $03EB19 |\
    LDA <r_battle_generic_tmp_2                                                 ; $03EB1B | | Increment the slot and loop until all monster slots have been
    CMP #(5 + 8).b                                                              ; $03EB1D | | updated.
    BNE -                                                                       ; $03EB1F |/
    LDA #BATTLE_ALERT_DUMMY_13.b                                                ; $03EB21 |\
    STA r_battle_alert_queue.w                                                  ; $03EB23 | | Display an alert.
    JMP _battle_script_audiovisual_set_display_dialog_alert_4                   ; $03EB26 |/

; _battle_command_helper_update_inventory_entry ($03:EB29)
;
; Given an item ID in the accumulator and the offset to a battle inventory entry
; in $AB, updates that item's flags and spell effect. Note that this routine is
; somewhat buggy.
;
; BUG: This routine doesn't bother to check anything regarding whether a weapon
;      or shield should be usable, so it enables their use, which allows them
;      to be equipped by characters who ordinarily would not be able to, as long
;      as they do so before the next update. In addition, the spell effect is
;      loaded incorrectly for weapons, leading to unusual effects when used as
;      an item.
_battle_command_helper_update_inventory_entry:
    BEQ @done                                                                   ; $03EB29 | Branch immediately to the end if no item.
    CMP #ITEM_FIRST_NON_BATTLE_ITEM.b                                           ; $03EB2B |\ If the item is a non-battle item, branch to the end.
    BCS @done                                                                   ; $03EB2D |/
    CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03EB2F |\ If the item is a battle item, branch to that code.
    BCS @battle                                                                 ; $03EB31 |/
    CMP #ITEM_FIRST_HELM.b                                                      ; $03EB33 |\ If the item is armor (other than shields), branch to the end.
    BCS @done                                                                   ; $03EB35 |/
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03EB37 |\ If the item is a weapon, branch to weapon-specific code.
    BCC @weapon                                                                 ; $03EB39 |/
    LDA #0.b                                                                    ; $03EB3B |\ Finally, if a shield, load a value to unset the disabled bit and
    BEQ @shield                                                                 ; $03EB3D |/ branch ahead.
@weapon:
    TAX                                                                         ; $03EB3F |\
    STX <r_copy_from_array_arg_index                                            ; $03EB40 | | Load the data regarding this weapon.
    LDX #bank0F.equipment_property_data.w                                       ; $03EB42 | |
    STX <r_generic_tmp_ptr_addr                                                 ; $03EB45 | |
    LDA #:bank0F.equipment_property_data.b                                      ; $03EB47 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03EB49 | |
    LDA #_sizeof_equipment.b                                                    ; $03EB4B | |
    JSR _copy_from_array                                                        ; $03EB4D |/
    PHA                                                                         ; $03EB50 |\
    LDA r_copy_from_array_result.w + equipment.unknown00                        ; $03EB51 | | TODO: Extract the probable dartable bit from the equipment and
    JSR _math_divide_by_8                                                       ; $03EB54 | |       save it to a temporary variable. This variable is only used
    AND #%00001000.b                                                            ; $03EB57 | |       in the Japanese version.
    STA <r_init_battle_data_tmp_1_lo                                            ; $03EB59 | |
    PLA                                                                         ; $03EB5B |/
    TAX                                                                         ; $03EB5C |\
    STX <r_copy_from_array_arg_index                                            ; $03EB5D | | BUG: Now, the real fun begins. This code attempts to load the
    LDX #bank0F.spell_property_data.w                                           ; $03EB5F | |      spell effect for the weapon to store in the inventory bytes.
    STX <r_generic_tmp_ptr_addr                                                 ; $03EB62 | |      The first problem is that they never set A to anything useful
    LDA #:bank0F.spell_property_data.b                                          ; $03EB64 | |      and it ends up retaining whatever was set in _copy_from_array
    STA <r_generic_tmp_ptr_bank                                                 ; $03EB66 | |      (the last byte of the equipment data). Second, the effect for
    LDA #_sizeof_spell.b                                                        ; $03EB68 | |      weapons is supposed to be the actual spell number, but they
    JSR _copy_from_array                                                        ; $03EB6A | |      load the spell and store its effect value instead. This
    LDX <r_battle_generic_tmp_2                                                 ; $03EB6D | |      leads to most weapons that are stolen casting Disrupt
    LDA r_copy_from_array_result.w + spell.effect                               ; $03EB6F | |      if used as items in that battle.
    STA r_battle_inventory.1.effect.w,X                                         ; $03EB72 | |
    BRA +                                                                       ; $03EB75 |/
@battle:
    SEC                                                                         ; $03EB77 |\
    SBC #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03EB78 | | Set the argument to the item ID minus the base ID for battle
    TAX                                                                         ; $03EB7A | | items.
    STX <r_copy_from_array_arg_index                                            ; $03EB7B |/
    LDX #bank0F.battle_item_property_data.w                                     ; $03EB7D |\
    STX <r_generic_tmp_ptr_addr                                                 ; $03EB80 | | Load the item data from ROM.
    LDA #:bank0F.battle_item_property_data.b                                    ; $03EB82 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03EB84 | |
    LDA #_sizeof_spell.b                                                        ; $03EB86 | |
    JSR _copy_from_array                                                        ; $03EB88 |/
    LDX <r_battle_generic_tmp_2                                                 ; $03EB8B |\
    LDA r_copy_from_array_result.w + spell.effect                               ; $03EB8D | | Load the spell effect for this item and store it as the effect.
    STA r_battle_inventory.1.effect.w,X                                         ; $03EB90 |/
+   LDA r_copy_from_array_result.w + spell.time_targeting.w                     ; $03EB93 |\ Load the targeting data for the spell.
    AND #SPELL_TIME_TARGETING_TARGETING.b                                       ; $03EB96 |/
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE != 1
    ORA <r_init_battle_data_tmp_1_lo                                            ; $03EB9B | For the Japanese version, add in the dartable bit.
.endif
.endif
    LSR A                                                                       ; $03EB98 | Shift the result to put the bits in the correct location.
@shield:
    STA r_battle_inventory.1.flags.w,X                                          ; $03EB99 | Save the laoded byte into the flags variable.
@done:
    RTS                                                                         ; $03EB9C

; _battle_command_execute_item ($03:EB9D)
;
; Calculates the effects of the use of an item in battle.
_battle_command_execute_item:
    LDA r_character_battle_current_actor.status_1.w                             ; $03EB9D |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03EBA0 | | Check the actor for various statuses that would preclude their use
    BNE @done                                                                   ; $03EBA2 | | of an item. In particular, return doing nothing if the actor has
    LDA r_character_battle_current_actor.status_2.w                             ; $03EBA4 | | any of the following statuses: swoon, stone, paralyze, sleep,
    AND #%00111100.b                                                            ; $03EBA7 | | charm, berserk, magnetized, stop, twin casting or jumping.
    BNE @done                                                                   ; $03EBA9 | |
    LDA r_character_battle_current_actor.status_3.w                             ; $03EBAB | |
    AND #%11000110.b                                                            ; $03EBAE | |
    BNE @done                                                                   ; $03EBB0 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03EBB2 |\ Push the item ID to the stack.
    PHA                                                                         ; $03EBB5 |/
    LDA r_character_battle_current_actor.subcommand.w                           ; $03EBB6 |\
    CMP #ITEM_GRIMOIRE.b                                                        ; $03EBB9 | | If the item being used is a Grimoire, call the Grimoire-specific
    BNE +                                                                       ; $03EBBB | | preparation function and then branch to the next part of the
    JSR _battle_item_execute_grimoire                                           ; $03EBBD | | routine.
    BRA @next                                                                   ; $03EBC0 |/
+   CMP #ITEM_FIRST_BATTLE_ITEM.b                                               ; $03EBC2 |\
    BCC +                                                                       ; $03EBC4 | | If the item being used is in the battle item range and if the
    LDA r_character_battle_current_actor.action_flags.w                         ; $03EBC6 | | actor's action flags do not signal a weapon being used as an item,
    AND #BATTLE_ACTION_FLAG_WEAPON.b                                            ; $03EBC9 | | branch ahead to battle item code.
    BEQ +++                                                                     ; $03EBCB |/
+   LDX r_character_battle_current_actor.command_offset.w                       ; $03EBCD |\ If using a weapon as an item, copy the offset to that weapon's
    STX <r_generic_tmp_ptr_addr                                                 ; $03EBD0 |/ entry to a temporary variable.
    LDA r_character_battle_current_actor.subcommand.w                           ; $03EBD2 |\
    CMP #ITEM_FIRST_SHIELD.b                                                    ; $03EBD5 | | If the weapon being used is a shield, load a zero into the
    BCC +                                                                       ; $03EBD7 | | accumulator to replace as the subcommand, since shields can't be
    LDA #0.b                                                                    ; $03EBD9 | | used.
    BRA ++                                                                      ; $03EBDB |/
+   TAX                                                                         ; $03EBDD |\
    LDA bank0F.battle_weapon_spell_hits_data.l,X                                ; $03EBDE | | Otherwise, load this weapon's number of spell hits.
    STA r_battle_current_spell_weapon_hits.w                                    ; $03EBE2 |/
    INC r_battle_current_spell_weapon.w                                         ; $03EBE5 | Set the flag that this spell is a weapon.
    LDY #battle_inventory_entry.effect.w                                        ; $03EBE8 |\ Load the spell ID associated with this weapon into the
    LDA (<r_generic_tmp_ptr_addr),Y                                             ; $03EBEB |/ accumulator.
++  STA r_character_battle_current_actor.subcommand.w                           ; $03EBED |\ Save the loaded value as the actor's subcommand.
    BRA @next                                                                   ; $03EBF0 |/
+++ INC r_battle_current_spell_item.w                                           ; $03EBF2 | If using a battle item, set the battle item flag.
@next:
    JSR _battle_calculate_magic_damage                                          ; $03EBF5 | Calculate the damage for this item or weapon.
    LDA r_battle_current_spell_grimoire.w                                       ; $03EBF8 |\
    BEQ +                                                                       ; $03EBFB | | If the item was a Grimoire, restore the item ID from the stack.
    PLA                                                                         ; $03EBFD | |
    BRA ++                                                                      ; $03EBFE |/
+   PLA                                                                         ; $03EC00 |\ If it wasn't, restore the value and then save it to the audiovisual
    STA r_battle_script_audiovisual.w + 3                                       ; $03EC01 |/ script.
++  STA r_battle_current_action_details.action.w                                ; $03EC04 | Save the item ID to the current action details action.
    LDA #BATTLE_ACTION_DETAILS_ACTION_FLAG_ITEM.b                               ; $03EC07 |\ Set the flag that indicates this action was an item use.
    STA r_battle_current_action_details.action_flags.w                          ; $03EC09 |/
@done:
    RTS                                                                         ; $03EC0C

; _battle_item_execute_grimoire ($03:EC0D)
;
; Handles the Grimoire item. Selects a random Call spell from the set that is
; enabled for this item (via a table in ROM) and adjusts the audiovisual script
; to display that spell.
_battle_item_execute_grimoire:
    LDA #MONSTER_COMMAND_VANISH_PARTY.b                                         ; $03EC0D |\ Set the next byte of the audiovisual script to run the command that
    STA r_battle_script_audiovisual.w + 2                                       ; $03EC0F |/ makes the party invisible.
    INC r_battle_current_spell_grimoire.w                                       ; $03EC12 | Indicate that the current spell is the result of a Grimoire.
    INC r_battle_double_spell_power.w                                           ; $03EC15 | Set the double spell power flag.
    TDC                                                                         ; $03EC18 |\
    TAX                                                                         ; $03EC19 | | Load a random value from the table of allowed Call spells.
    LDA #9.b                                                                    ; $03EC1A | |
    JSR _get_battle_rng                                                         ; $03EC1C | |
    TAX                                                                         ; $03EC1F | |
    LDA bank13.battle_grimoire_call_data.l,X                                    ; $03EC20 |/
    PHA                                                                         ; $03EC24 |\
    AND #%01111111.b                                                            ; $03EC25 | | Save the spell number as the actor's subcommand and in the
    STA r_character_battle_current_actor.subcommand.w                           ; $03EC27 | | audiovisual script.
    STA r_battle_script_audiovisual.w + 3                                       ; $03EC2A |/
    PLA                                                                         ; $03EC2D |\ If the spell is flagged as being a multi-target spell, branch ahead
    BPL +                                                                       ; $03EC2E |/ to that code.
-   LDX #5.w                                                                    ; $03EC30 |\
    LDA #(5 + 8 - 1).b                                                          ; $03EC33 | | Select a random monster slot.
    JSR _get_battle_rng                                                         ; $03EC35 | |
    TAY                                                                         ; $03EC38 | |
    STY <r_battle_generic_tmp_1                                                 ; $03EC39 |/
    LDA r_battle_slot_empty.w,Y                                                 ; $03EC3B |\ Loop until the randomly chosen slot is not empty.
    BNE -                                                                       ; $03EC3E |/
    TYA                                                                         ; $03EC40 |\
    STA <r_math_multiply_8bit_arg_1                                             ; $03EC41 | | Calculate the offset to that slot's stat record.
    LDA #_sizeof_character_battle.b                                             ; $03EC43 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03EC45 | |
    JSR _math_multiply_8bit                                                     ; $03EC47 | |
    LDX <r_math_multiply_8bit_result                                            ; $03EC4A |/
    LDA r_character_battle.1.status_1.w,X                                       ; $03EC4C |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03EC4F | | Loop until the randomly chosen slot is not swooned or stoned.
    BNE -                                                                       ; $03EC51 |/
    SEC                                                                         ; $03EC53 |\
    LDA <r_battle_generic_tmp_1                                                 ; $03EC54 | | Set the current target slot to the randomly chosen target.
    SBC #5.b                                                                    ; $03EC56 | |
    TAX                                                                         ; $03EC58 | |
    ORA #%10000000.b                                                            ; $03EC59 | |
    STA <r_battle_command_target_slot                                           ; $03EC5B |/
    TDC                                                                         ; $03EC5D |\
    JSR _set_bit_x                                                              ; $03EC5E | | Load the target mask into the accumulator and branch.
    BRA ++                                                                      ; $03EC61 |/
+   LDA #%10000000.b                                                            ; $03EC63 |\ For multi-target spells, set the target to monster slot zero.
    STA <r_battle_command_target_slot                                           ; $03EC65 |/
    LDA #BATTLE_TARGET_MONSTER_ALL.b                                            ; $03EC67 | Load the target value for all monsters into the accumulator.
++  STA r_character_battle_current_actor.targets.monster.w                      ; $03EC69 | Save the loaded value to the actor's monster target value.
    RTS                                                                         ; $03EC6C

; _battle_spoils ($03:EC6D)
;
; Handles the spoils at the end of battle, including experience, GP, item drops
; and level ups. Additionally updates the character battle records.
_battle_spoils:
    TDC                                                                         ; $03EC6D |\ Initialize the X register to zero.
    TAX                                                                         ; $03EC6E |/
    STX r_battle_spoils_exp_lo.w                                                ; $03EC6F |\ Zero out all three bytes of the experience variable.
    STX r_battle_spoils_exp_hi.w                                                ; $03EC72 |/
    STX r_battle_spoils_gp_lo.w                                                 ; $03EC75 |\ Zero out all three bytes of the GP variable.
    STX r_battle_spoils_gp_md.w                                                 ; $03EC78 |/
    STX <r_battle_spoils_tmp_drop_count                                         ; $03EC7B
    STX <r_battle_spoils_tmp_type_index                                         ; $03EC7D | Initialize the type index to zero.
@type_loop_start:
    LDX <r_battle_spoils_tmp_type_index                                         ; $03EC7F | Set the X register to the current type index.
    LDA r_monster_type_deaths.w,X                                               ; $03EC81 |\ Copy the number of deaths of this monster type to a temporary
    STA <r_battle_spoils_tmp_monster_count                                      ; $03EC84 |/ variable.
    BNE @monster_loop_start                                                     ; $03EC86 |\ If there were zero deaths, branch to the next iteration of the
    JMP @next_type                                                              ; $03EC88 |/ loop.
@monster_loop_start:
    LDX <r_battle_spoils_tmp_type_index                                         ; $03EC8B |\
    LDA r_monster_ids_initial_exp.w,X                                           ; $03EC8D | | Load the offset to the current monster's EXP value in ROM.
    STA <r_battle_generic_tmp_4_lo                                              ; $03EC90 | |
    STZ <r_battle_generic_tmp_4_hi                                              ; $03EC92 | |
    ASL <r_battle_generic_tmp_4_lo                                              ; $03EC94 | |
    ROL <r_battle_generic_tmp_4_hi                                              ; $03EC96 | |
    LDX <r_battle_generic_tmp_4                                                 ; $03EC98 |/
    CLC                                                                         ; $03EC9A |\
    LDA bank0E.monster_exp_data.l + 0,X                                         ; $03EC9B | | Load the monster's EXP value and add it to the current total of
    ADC r_battle_spoils_exp_lo.w                                                ; $03EC9F | | EXP.
    STA r_battle_spoils_exp_lo.w                                                ; $03ECA2 | |
    LDA bank0E.monster_exp_data.l + 1,X                                         ; $03ECA5 | |
    ADC r_battle_spoils_exp_md.w                                                ; $03ECA9 | |
    STA r_battle_spoils_exp_md.w                                                ; $03ECAC | |
    LDA r_battle_spoils_exp_hi.w                                                ; $03ECAF | |
    ADC #0.b                                                                    ; $03ECB2 | |
    STA r_battle_spoils_exp_hi.w                                                ; $03ECB4 |/
    LDX <r_battle_spoils_tmp_type_index                                         ; $03ECB7 |\
    LDA r_monster_ids_initial_gp.w,X                                            ; $03ECB9 | | Calculate the offset to the current monster's GP value.
    STA <r_battle_generic_tmp_4_lo                                              ; $03ECBC | |
    STZ <r_battle_generic_tmp_4_hi                                              ; $03ECBE | |
    ASL <r_battle_generic_tmp_4_lo                                              ; $03ECC0 | |
    ROL <r_battle_generic_tmp_4_hi                                              ; $03ECC2 | |
    LDX <r_battle_generic_tmp_4                                                 ; $03ECC4 |/
    CLC                                                                         ; $03ECC6 |\
    LDA bank0E.monster_gp_data.l + 0,X                                          ; $03ECC7 | | Load the monster's GP value and add it to the current total.
    ADC r_battle_spoils_gp_lo.w                                                 ; $03ECCB | |
    STA r_battle_spoils_gp_lo.w                                                 ; $03ECCE | |
    LDA bank0E.monster_gp_data.l + 1,X                                          ; $03ECD1 | |
    ADC r_battle_spoils_gp_md.w                                                 ; $03ECD5 | |
    STA r_battle_spoils_gp_md.w                                                 ; $03ECD8 | |
    LDA r_battle_spoils_gp_hi.w                                                 ; $03ECDB | |
    ADC #0.b                                                                    ; $03ECDE | |
    STA r_battle_spoils_gp_hi.w                                                 ; $03ECE0 |/
    LDX <r_battle_spoils_tmp_type_index                                         ; $03ECE3 |\
    LDA r_monster_items.w,X                                                     ; $03ECE5 | | Load the monster's item index and save it to a temporary variable.
    STA <r_battle_spoils_tmp_item_index                                         ; $03ECE8 |/
    LDA r_monster_items.w,X                                                     ; $03ECEA |\
    AND #MONSTER_ITEM_INDEX_DROP_RATE.b                                         ; $03ECED | | If the monster always drop an item, skip the RNG check.
    CMP #MONSTER_ITEM_INDEX_DROP_RATE_ALWAYS.b                                  ; $03ECEF | |
    BEQ +++                                                                     ; $03ECF1 |/
    CMP #MONSTER_ITEM_INDEX_DROP_RATE_NORMAL.b                                  ; $03ECF3 |\
    BNE +                                                                       ; $03ECF5 | | If the monster drops items at the normal rate, load 5 into the
    LDA #5.b                                                                    ; $03ECF7 | | accumulator.
    BRA ++                                                                      ; $03ECF9 |/
+   CMP #MONSTER_ITEM_INDEX_DROP_RATE_FREQUENT.b                                ; $03ECFB |\ If the monster never drops items, skip to the next monster.
    BNE @next_monster                                                           ; $03ECFD |/
    LDA #25.b                                                                   ; $03ECFF | Load 25 into the accumulator.
++  STA <r_battle_spoils_tmp_drop_rate                                          ; $03ED01 | Store the drop rate into a temporary variable.
    JSR _get_battle_rng_0_98                                                    ; $03ED03 |\
    CMP <r_battle_spoils_tmp_drop_rate                                          ; $03ED06 | | If RND(0, 98) is less than the drop rate, continue.
    BCS @next_monster                                                           ; $03ED08 |/
+++ ASL <r_battle_spoils_tmp_item_index                                         ; $03ED0A |\
    ASL <r_battle_spoils_tmp_item_index                                         ; $03ED0C | | Multiply the item index by four (which automatically discards the
    LDA <r_battle_spoils_tmp_item_index                                         ; $03ED0E | | drop rate bits) and transfer it to the X register.
    TAX                                                                         ; $03ED10 |/
    TDC                                                                         ; $03ED11 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03ED12 |/
    STY <r_battle_generic_tmp_1                                                 ; $03ED13 |\
-   LDA bank0E.monster_item_drop_data.l,X                                       ; $03ED15 | | Copy the four possible items for this monster to a temporary
    STA r_battle_generic_tmp_block.w,Y                                          ; $03ED19 | | location in the memory.
    INX                                                                         ; $03ED1C | |
    INY                                                                         ; $03ED1D | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03ED1E | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03ED20 | |
    CMP #4.b                                                                    ; $03ED22 | |
    BNE -                                                                       ; $03ED24 |/
    LDA r_game_time.frames.w                                                    ; $03ED26 |\
    ADC <r_battle_rng_index                                                     ; $03ED29 | | Add the current game time frame value to the RNG index.
    STA <r_battle_rng_index                                                     ; $03ED2B |/
    JSR _get_battle_rng_0_255                                                   ; $03ED2D | Get a random number from 0 to 255.
    CMP #128.b                                                                  ; $03ED30 |\
    BCS +                                                                       ; $03ED32 | | If the number is less than 128, select the first item.
    LDA #0.b                                                                    ; $03ED34 | |
    BRA ++                                                                      ; $03ED36 |/
+   CMP #208.b                                                                  ; $03ED38 |\
    BCS +                                                                       ; $03ED3A | | If the number is from 128 to 207, select the second item.
    LDA #1.b                                                                    ; $03ED3C | |
    BRA ++                                                                      ; $03ED3E |/
+   CMP #252.b                                                                  ; $03ED40 |\
    BCS +                                                                       ; $03ED42 | | If the number is from 208 to 251, select the third item.
    LDA #2.b                                                                    ; $03ED44 | |
    BRA ++                                                                      ; $03ED46 |/
+   LDA #3.b                                                                    ; $03ED48 | Otherwise, select the fourth.
++  TAX                                                                         ; $03ED4A |\ Load the associated item ID.
    LDA r_battle_generic_tmp_block.w,X                                          ; $03ED4B |/
    LDX <r_battle_spoils_tmp_drop_count                                         ; $03ED4E |\
    CPX #8.w                                                                    ; $03ED50 | | If there hasn't yet been eight drops, add the item ID to the list
    BEQ @next_monster                                                           ; $03ED53 | | and increment the counter.
    STA r_battle_drops.w,X                                                      ; $03ED55 | |
    INC <r_battle_spoils_tmp_drop_count_lo                                      ; $03ED58 |/
@next_monster:
    DEC <r_battle_spoils_tmp_monster_count                                      ; $03ED5A |\
    LDA <r_battle_spoils_tmp_monster_count                                      ; $03ED5C | | Loop until all monsters of this type have been considered.
    BEQ @next_type                                                              ; $03ED5E | |
    JMP @monster_loop_start                                                     ; $03ED60 |/
@next_type:
    INC <r_battle_spoils_tmp_type_index                                         ; $03ED63 |\
    LDA <r_battle_spoils_tmp_type_index                                         ; $03ED65 | | Loop until all three types of monsters have been considered.
    CMP #3.b                                                                    ; $03ED67 | |
    BEQ +                                                                       ; $03ED69 | |
    JMP @type_loop_start                                                        ; $03ED6B |/
+   CLC                                                                         ; $03ED6E |\
    LDA r_party_gp.lo.w                                                         ; $03ED6F | | Add the calculated GP to the party's GP.
    ADC r_battle_spoils_gp_lo.w                                                 ; $03ED72 | |
    STA r_party_gp.lo.w                                                         ; $03ED75 | |
    LDA r_party_gp.md.w                                                         ; $03ED78 | |
    ADC r_battle_spoils_gp_md.w                                                 ; $03ED7B | |
    STA r_party_gp.md.w                                                         ; $03ED7E | |
    LDA r_party_gp.hi.w                                                         ; $03ED81 | |
    ADC r_battle_spoils_gp_hi.w                                                 ; $03ED84 | |
    STA r_party_gp.hi.w                                                         ; $03ED87 |/
    SEC                                                                         ; $03ED8A |\
    LDA r_party_gp.lo.w                                                         ; $03ED8B | | If the new total is greater than 9,999,999 ($98967F), set the
    SBC #$7F.b                                                                  ; $03ED8E | | party's GP explicitly to 9,999,999.
    LDA r_party_gp.md.w                                                         ; $03ED90 | |
    SBC #$96.b                                                                  ; $03ED93 | |
    LDA r_party_gp.hi.w                                                         ; $03ED95 | |
    SBC #$98.b                                                                  ; $03ED98 | |
    BCC +                                                                       ; $03ED9A | |
    LDA #$7F.b                                                                  ; $03ED9C | |
    STA r_party_gp.lo.w                                                         ; $03ED9E | |
    LDA #$96.b                                                                  ; $03EDA1 | |
    STA r_party_gp.md.w                                                         ; $03EDA3 | |
    LDA #$98.b                                                                  ; $03EDA6 | |
    STA r_party_gp.hi.w                                                         ; $03EDA8 |/
+   TDC                                                                         ; $03EDAB |\ Initialize the X register to zero.
    TAX                                                                         ; $03EDAC |/
    STX <r_battle_generic_tmp_1                                                 ; $03EDAD | Initialize the slot number to zero.
    STX <r_battle_generic_tmp_2                                                 ; $03EDAF | Initialize the experience divisor to zero.
    STX <r_battle_generic_tmp_3                                                 ; $03EDB1 | Initialize the stat record offset to zero.
    STX r_monster_actions.w + 0                                                 ; $03EDB3 |\
    STX r_monster_actions.w + 2                                                 ; $03EDB6 | | Initialize ten bytes of the monster action data to zero (as it's
    STX r_monster_actions.w + 4                                                 ; $03EDB9 | | no longer needed).
    STX r_monster_actions.w + 6                                                 ; $03EDBC | |
    STX r_monster_actions.w + 8                                                 ; $03EDBF |/
-   LDX <r_battle_generic_tmp_1                                                 ; $03EDC2 |\
    CPX #5.w                                                                    ; $03EDC4 | | If this slot is part of the actual party, make sure it's not
    BCS +                                                                       ; $03EDC7 | | empty. Skip this check for the shadow party.
    LDA r_battle_slot_empty.w,X                                                 ; $03EDC9 | |
    BNE ++                                                                      ; $03EDCC |/
+   LDX <r_battle_generic_tmp_3                                                 ; $03EDCE |\
    LDA r_character_field.1.id.w,X                                              ; $03EDD0 | | Skip this slot if it's empty (checking another way).
    AND #%00011111.b                                                            ; $03EDD3 | |
    BEQ ++                                                                      ; $03EDD5 |/
    LDA r_character_field.1.status_1.w,X                                        ; $03EDD7 |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03EDDA | | Skip this slot if swooned or stoned.
    BNE ++                                                                      ; $03EDDC |/
    LDX <r_battle_generic_tmp_1                                                 ; $03EDDE |\ Increment the flag for this slot.
    INC r_monster_actions.w,X                                                   ; $03EDE0 |/
    CPX #5.w                                                                    ; $03EDE3 |\
    BCS ++                                                                      ; $03EDE6 | | If this slot is not in the shadow party, increment a counter.
    INC <r_battle_generic_tmp_2_lo                                              ; $03EDE8 |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $03EDEA |\
    CLC                                                                         ; $03EDEC | | Increment the offset to move to the next record.
    LDA <r_battle_generic_tmp_3                                                 ; $03EDED | |
    ADC #_sizeof_character_field.w                                              ; $03EDEF | |
    STA <r_battle_generic_tmp_3                                                 ; $03EDF2 | |
    TDC                                                                         ; $03EDF4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03EDF5 |/
    INC <r_battle_generic_tmp_1_lo                                              ; $03EDF7 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03EDF9 | | Increment the slot number and loop until all normal slots and all
    CMP #10.b                                                                   ; $03EDFB | | shadow slots have been considered.
    BNE -                                                                       ; $03EDFD |/
    LDA r_battle_spoils_exp_lo.w                                                ; $03EDFF |\
    ORA r_battle_spoils_exp_md.w                                                ; $03EE02 | | Skip this next block if no EXP is being earned.
    ORA r_battle_spoils_exp_hi.w                                                ; $03EE05 | |
    BEQ +++                                                                     ; $03EE08 |/
    TDC                                                                         ; $03EE0A |\
    TAX                                                                         ; $03EE0B | | Zero out the X register, and the location of the divided EXP.
    STX <r_battle_generic_tmp_3                                                 ; $03EE0C | |
    STX <r_battle_generic_tmp_4                                                 ; $03EE0E |/
    LDA r_battle_spoils_exp_lo.w                                                ; $03EE10 |\
    ORA r_battle_spoils_exp_md.w                                                ; $03EE13 | | If there is no EXP being earned, set the result explicitly to zero
    ORA r_battle_spoils_exp_hi.w                                                ; $03EE16 | | and branch past the division code.
    BNE +                                                                       ; $03EE19 | |
    STZ <r_battle_generic_tmp_3_lo                                              ; $03EE1B | | NOTE: Unless there's another entry point, it seems impossible for
    STZ <r_battle_generic_tmp_3_hi                                              ; $03EE1D | |       this condition to be true.
    STZ <r_battle_generic_tmp_4_lo                                              ; $03EE1F | |
    BRA ++                                                                      ; $03EE21 |/
+   JSL bank13.battle_divide_exp                                                ; $03EE23 | Divide the experience by the divisor.
++  LDA <r_battle_generic_tmp_3_lo                                              ; $03EE27 |\
    ORA <r_battle_generic_tmp_3_hi                                              ; $03EE29 | | If the divided amount was zero, set it to one.
    ORA <r_battle_generic_tmp_4_lo                                              ; $03EE2B | |
    BNE +                                                                       ; $03EE2D | |
    INC <r_battle_generic_tmp_3_lo                                              ; $03EE2F |/
+   LDX <r_battle_generic_tmp_3                                                 ; $03EE31 |\
    STX r_battle_spoils_exp_lo.w                                                ; $03EE33 | | Copy the divided value into the main experience location.
    LDA <r_battle_generic_tmp_4                                                 ; $03EE36 | |
    STA r_battle_spoils_exp_hi.w                                                ; $03EE38 |/
+++ JSR _battle_initialize_action_audiovisual                                   ; $03EE3B | Initialize the audiovisual system.
    JSR _battle_script_audiovisual_set_display_dialog_alert_0                   ; $03EE3E | Write the script to display battle alerts.
    LDA r_battle_spoils_gp_lo.w                                                 ; $03EE41 |\
    STA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $03EE44 | | Set the earned GP as one of the extra arguments for battle alerts.
    LDA r_battle_spoils_gp_md.w                                                 ; $03EE47 | |
    STA r_battle_update_dialog_extra_arg_1_md.w                                 ; $03EE4A | |
    LDA r_battle_spoils_gp_hi.w                                                 ; $03EE4D | |
    STA r_battle_update_dialog_extra_arg_1_hi.w                                 ; $03EE50 |/
    LDA r_battle_spoils_exp_lo.w                                                ; $03EE53 |\
    STA r_battle_update_dialog_extra_arg_2_lo.w                                 ; $03EE56 | | Set the earned EXP as another extra argument for the battle
    LDA r_battle_spoils_exp_md.w                                                ; $03EE59 | | alerts.
    STA r_battle_update_dialog_extra_arg_2_md.w                                 ; $03EE5C | |
    LDA r_battle_spoils_exp_hi.w                                                ; $03EE5F | |
    STA r_battle_update_dialog_extra_arg_2_hi.w                                 ; $03EE62 |/
    TDC                                                                         ; $03EE65 |\ Initialize the X register to zero.
    TAX                                                                         ; $03EE66 |/
    LDA r_battle_spoils_gp_lo.w                                                 ; $03EE67 |\
    ORA r_battle_spoils_gp_md.w                                                 ; $03EE6A | | If the two low bytes of the GP value is non-zero, display the
    BEQ +                                                                       ; $03EE6D | | received GP alert.
    LDA #BATTLE_ALERT_RECEIVED_GP.b                                             ; $03EE6F | |
    STA r_battle_alert_queue.w                                                  ; $03EE71 | | BUG: The alert won't display if the GP is a multiple of 65536.
    INX                                                                         ; $03EE74 |/
+   LDA r_battle_spoils_exp_lo.w                                                ; $03EE75 |\
    ORA r_battle_spoils_exp_md.w                                                ; $03EE78 | | If the two low bytes of the EXP value is non-zero, display the
    BEQ +                                                                       ; $03EE7B | | received EXP alert.
    LDA #BATTLE_ALERT_RECEIVED_EXP.b                                            ; $03EE7D | |
    STA r_battle_alert_queue.w,X                                                ; $03EE7F | | BUG: The alert won't display if the EXP is a multiple of 65536.
    INX                                                                         ; $03EE82 |/
+   TXA                                                                         ; $03EE83 |\
    BEQ +                                                                       ; $03EE84 | | If either of the alerts was programmed, call the code to display
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03EE86 | | the alerts.
    JSR _battle_update                                                          ; $03EE88 |/
+   LDA #$FF.b                                                                  ; $03EE8B |\ Unset the second byte of the battle alert queue.
    STA r_battle_alert_queue.w + 1                                              ; $03EE8D |/
    TDC                                                                         ; $03EE90 |\ Initialize the X register to zero.
    TAX                                                                         ; $03EE91 |/
    STX <r_battle_generic_tmp_1                                                 ; $03EE92 | Initialize the slot to zero.
    STX <r_battle_generic_tmp_2                                                 ; $03EE94 | Initialize the offset to zero.
-   LDX <r_battle_generic_tmp_1                                                 ; $03EE96 |\
    LDA r_monster_actions.w,X                                                   ; $03EE98 | | Skip this slot if this slot isn't receiving experience.
    BEQ +                                                                       ; $03EE9B |/
    LDX <r_battle_generic_tmp_2                                                 ; $03EE9D |\
    CLC                                                                         ; $03EE9F | | Add the experience to the character's experience.
    LDA r_character_field.1.experience_lo.w,X                                   ; $03EEA0 | |
    ADC r_battle_spoils_exp_lo.w                                                ; $03EEA3 | |
    STA r_character_field.1.experience_lo.w,X                                   ; $03EEA6 | |
    LDA r_character_field.1.experience_md.w,X                                   ; $03EEA9 | |
    ADC r_battle_spoils_exp_md.w                                                ; $03EEAC | |
    STA r_character_field.1.experience_md.w,X                                   ; $03EEAF | |
    LDA r_character_field.1.experience_hi.w,X                                   ; $03EEB2 | |
    ADC r_battle_spoils_exp_hi.w                                                ; $03EEB5 | |
    STA r_character_field.1.experience_hi.w,X                                   ; $03EEB8 |/
    SEC                                                                         ; $03EEBB |\
    LDA r_character_field.1.experience_lo.w,X                                   ; $03EEBC | | Ensure the character's total experience does not exceed 9999999.
    SBC #$7F.b                                                                  ; $03EEBF | | If it does, explicitly set it to 9999999.
    LDA r_character_field.1.experience_md.w,X                                   ; $03EEC1 | |
    SBC #$96.b                                                                  ; $03EEC4 | |
    LDA r_character_field.1.experience_hi.w,X                                   ; $03EEC6 | |
    SBC #$98.b                                                                  ; $03EEC9 | |
    BCC +                                                                       ; $03EECB | |
    LDA #$7F.b                                                                  ; $03EECD | |
    STA r_character_field.1.experience_lo.w,X                                   ; $03EECF | |
    LDA #$96.b                                                                  ; $03EED2 | |
    STA r_character_field.1.experience_md.w,X                                   ; $03EED4 | |
    LDA #$98.b                                                                  ; $03EED7 | |
    STA r_character_field.1.experience_hi.w,X                                   ; $03EED9 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03EEDC |\
    CLC                                                                         ; $03EEDE | | Increment the stat record offset to move to the next character.
    LDA <r_battle_generic_tmp_2                                                 ; $03EEDF | |
    ADC #_sizeof_character_field.w                                              ; $03EEE1 | |
    STA <r_battle_generic_tmp_2                                                 ; $03EEE4 | |
    TDC                                                                         ; $03EEE6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03EEE7 |/
    INC <r_battle_generic_tmp_1_lo                                              ; $03EEE9 |\
    LDA <r_battle_generic_tmp_1_lo                                              ; $03EEEB | | Increment the slot and loop until all slots have been updated.
    CMP #10.b                                                                   ; $03EEED | |
    BNE -                                                                       ; $03EEEF |/
    TDC                                                                         ; $03EEF1 |\ Initialize the X register to zero.
    TAX                                                                         ; $03EEF2 |/
    STX <r_battle_spoils_tmp_slot                                               ; $03EEF3 | Initialize the slot to zero.
    STX <r_current_slot_offset_character_battle                                 ; $03EEF5 | Initialize the offset to zero.
@slot_start:
    LDX <r_battle_spoils_tmp_slot                                               ; $03EEF7 |\
    LDA r_monster_actions.w,X                                                   ; $03EEF9 | | Skip this slot if it wasn't receiving experience.
    BNE @check_level_up                                                         ; $03EEFC | |
    JMP @no_level_up                                                            ; $03EEFE |/
@check_level_up:
    LDX <r_current_slot_offset_character_battle                                 ; $03EF01 |\
    LDA r_character_field.1.id.w,X                                              ; $03EF03 | | Load the pointer to this character's level up data.
    AND #%00011111.b                                                            ; $03EF06 | |
    DEC A                                                                       ; $03EF08 | |
    ASL A                                                                       ; $03EF09 | |
    TAX                                                                         ; $03EF0A | |
    LDA bank0F.level_up_pointer_data.l + 0,X                                    ; $03EF0B | |
    STA <r_generic_tmp_ptr_addr_lo                                              ; $03EF0F | |
    LDA bank0F.level_up_pointer_data.l + 1,X                                    ; $03EF11 | |
    STA <r_generic_tmp_ptr_addr_hi                                              ; $03EF15 | |
    LDA #:bank0F.level_up_pointer_data.b                                        ; $03EF17 | |
    STA <r_generic_tmp_ptr_bank                                                 ; $03EF19 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EF1B |\
    LDA r_character_field.1.level.w,X                                           ; $03EF1D | | Set the Y register to the character's current level minus one
    CMP #70.b                                                                   ; $03EF20 | | times five. If the level is 70 or greater, assume level 69
    BCC +                                                                       ; $03EF22 | | instead.
    LDA #69.b                                                                   ; $03EF24 | |
+   DEC A                                                                       ; $03EF26 | |
    STA <r_math_multiply_8bit_arg_1                                             ; $03EF27 | |
    LDA #5.b                                                                    ; $03EF29 | |
    STA <r_math_multiply_8bit_arg_2                                             ; $03EF2B | |
    JSR _math_multiply_8bit                                                     ; $03EF2D | |
    LDY <r_math_multiply_8bit_result                                            ; $03EF30 |/
    TDC                                                                         ; $03EF32 |\ Initialize the X register to zero.
    TAX                                                                         ; $03EF33 |/
-   LDA [<r_generic_tmp_ptr],Y                                                  ; $03EF34 |\
    STA r_battle_spoils_level_up.w,X                                            ; $03EF36 | | Copy the level up data to a temporary area in memory.
    INY                                                                         ; $03EF39 | |
    INX                                                                         ; $03EF3A | |
    CPX #_sizeof_level_up.w                                                     ; $03EF3B | |
    BNE -                                                                       ; $03EF3E |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EF40 |\
    LDA r_character_field.1.level.w,X                                           ; $03EF42 | | If the character's current level is less than 70, skip the next
    CMP #70.b                                                                   ; $03EF45 | | block of code.
    BCC +                                                                       ; $03EF47 |/
    PHY                                                                         ; $03EF49 | Preserve the value in the Y register.
    LDX #0.w                                                                    ; $03EF4A |\
    LDA #7.b                                                                    ; $03EF4D | | Select a random number from 0 to 7 and transfer it to a location
    JSR _get_battle_rng                                                         ; $03EF4F | | in memory.
    TAX                                                                         ; $03EF52 | |
    STX <r_battle_generic_tmp_3                                                 ; $03EF53 |/
    PLY                                                                         ; $03EF55 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $03EF56 | | Restore the Y register and increment its value by the randomly
    TYA                                                                         ; $03EF58 | | chosen value.
    CLC                                                                         ; $03EF59 | |
    ADC <r_battle_generic_tmp_3                                                 ; $03EF5A | |
    TAY                                                                         ; $03EF5C | |
    TDC                                                                         ; $03EF5D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03EF5E |/
    LDA [<r_generic_tmp_ptr],Y                                                  ; $03EF60 |\ Update the stat gains byte by the read value.
    STA r_battle_spoils_level_up.stats.w                                        ; $03EF62 |/
+   LDA r_battle_spoils_level_up.exp_lo.w                                       ; $03EF65 |\
    STA <r_battle_generic_tmp_3_lo                                              ; $03EF68 | | Copy the experience needed for this level to temporary variables.
    LDA r_battle_spoils_level_up.exp_md.w                                       ; $03EF6A | |
    STA <r_battle_generic_tmp_3_hi                                              ; $03EF6D | |
    LDA r_battle_spoils_level_up.mp_exp_hi.w                                    ; $03EF6F | |
    JSR _math_divide_by_32                                                      ; $03EF72 | |
    STA <r_battle_generic_tmp_4_lo                                              ; $03EF75 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03EF77 |\
    CLC                                                                         ; $03EF79 | | Add the experience needed for this level to the character's
    LDA r_character_field.1.experience_needed.lo.w,X                            ; $03EF7A | | existing needed experience to determine the total experience
    ADC <r_battle_generic_tmp_3_lo                                              ; $03EF7D | | needed for this level up.
    STA <r_battle_generic_tmp_3_lo                                              ; $03EF7F | |
    LDA r_character_field.1.experience_needed.md.w,X                            ; $03EF81 | |
    ADC <r_battle_generic_tmp_3_hi                                              ; $03EF84 | |
    STA <r_battle_generic_tmp_3_hi                                              ; $03EF86 | |
    LDA r_character_field.1.experience_needed.hi.w,X                            ; $03EF88 | |
    ADC <r_battle_generic_tmp_4_lo                                              ; $03EF8B | |
    STA <r_battle_generic_tmp_4_lo                                              ; $03EF8D |/
    SEC                                                                         ; $03EF8F |\
    LDA r_character_field.1.experience_lo.w,X                                   ; $03EF90 | | Subtract the total needed experience from the character's current
    SBC <r_battle_generic_tmp_3_lo                                              ; $03EF93 | | experience.
    LDA r_character_field.1.experience_md.w,X                                   ; $03EF95 | |
    SBC <r_battle_generic_tmp_3_hi                                              ; $03EF98 | |
    LDA r_character_field.1.experience_hi.w,X                                   ; $03EF9A | |
    SBC <r_battle_generic_tmp_4_lo                                              ; $03EF9D |/
    BCC @no_level_up                                                            ; $03EF9F | Skip the level up if there was not enough experience.
    LDA <r_battle_generic_tmp_3_lo                                              ; $03EFA1 |\
    STA r_character_field.1.experience_needed.lo.w,X                            ; $03EFA3 | | Copy the new needed experience value to the character record.
    LDA <r_battle_generic_tmp_3_hi                                              ; $03EFA6 | |
    STA r_character_field.1.experience_needed.md.w,X                            ; $03EFA8 | |
    LDA <r_battle_generic_tmp_4_lo                                              ; $03EFAB | |
    STA r_character_field.1.experience_needed.hi.w,X                            ; $03EFAD |/
    LDA r_character_field.1.level.w,X                                           ; $03EFB0 |\
    CMP #99.b                                                                   ; $03EFB3 | | Skip the level up if the character is already level 99.
    BCS @no_level_up                                                            ; $03EFB5 |/
    INC r_character_field.1.level.w,X                                           ; $03EFB7 | Increment the character's level.
    JSR _battle_update_character_stats_spells                                   ; $03EFBA | Update the character's stats and learn any new spells.
    LDA <r_battle_spoils_tmp_slot                                               ; $03EFBD |\
    CMP #5.b                                                                    ; $03EFBF | | Skip this next block if the character is in the shadow party.
    BCS +                                                                       ; $03EFC1 |/
    STA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $03EFC3 |\
    LDA #BATTLE_ALERT_GAINED_A_LEVEL.b                                          ; $03EFC6 | | Display a battle alert that says the character gained a level.
    STA r_battle_alert_queue.w                                                  ; $03EFC8 | |
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03EFCB | |
    JSR _battle_update                                                          ; $03EFCD |/
    LDA #BATTLE_ALERT_LEARNED.b                                                 ; $03EFD0 |\ Add the code for the Learned battle alert to the queue.
    STA r_battle_alert_queue.w                                                  ; $03EFD2 |/
    TDC                                                                         ; $03EFD5 |\
    TAX                                                                         ; $03EFD6 | | Initialize the learned index to zero.
    STX <r_battle_generic_tmp_4                                                 ; $03EFD7 |/
-   LDX <r_battle_generic_tmp_4                                                 ; $03EFD9 |\ Load the next learned spell.
    LDA r_battle_generic_tmp_block.w + 128,X                                    ; $03EFDB |/
    CMP #$FF.b                                                                  ; $03EFDE |\ If there are no more spells, skip past this code.
    BEQ +                                                                       ; $03EFE0 |/
    STA r_battle_update_dialog_extra_arg_1_lo.w                                 ; $03EFE2 |\
    LDA #BATTLE_UPDATE_MODE_ANIMATE_AUDIOVISUAL.b                               ; $03EFE5 | | Display a battle alert to show the learned spell.
    JSR _battle_update                                                          ; $03EFE7 |/
    INC <r_battle_generic_tmp_4_lo                                              ; $03EFEA |\ Increment the index and loop to the next spell.
    BRA -                                                                       ; $03EFEC |/
+   JMP @check_level_up                                                         ; $03EFEE | Jump to check if the character can level up again.
@no_level_up:
    REP #FLAG_P_ACCUMULATOR                                                     ; $03EFF1 |\
    CLC                                                                         ; $03EFF3 | | Increment the offset to move to the next character.
    LDA <r_current_slot_offset_character_battle                                 ; $03EFF4 | |
    ADC #_sizeof_character_field.w                                              ; $03EFF6 | |
    STA <r_current_slot_offset_character_battle                                 ; $03EFF9 | |
    TDC                                                                         ; $03EFFB | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03EFFC |/
    INC <r_battle_spoils_tmp_slot                                               ; $03EFFE |\ Increment the slot number.
    LDA <r_battle_spoils_tmp_slot                                               ; $03F000 |/
    CMP #10.b                                                                   ; $03F002 |\
    BEQ +                                                                       ; $03F004 | | Loop until all ten slots have been checked.
    JMP @slot_start                                                             ; $03F006 |/
+   JSR _init_character_battle                                                  ; $03F009 | Initializes the in-battle character records.
    JSR _update_equipment_data                                                  ; $03F00C | Update the equipment data.
    STZ r_battle_generic_arg_slot.w                                             ; $03F00F |\
-   LDA r_battle_generic_arg_slot.w                                             ; $03F012 | | For each non-empty slot, update the in-battle character record.
    TAX                                                                         ; $03F015 | |
    LDA r_battle_slot_empty.w,X                                                 ; $03F016 | |
    BNE +                                                                       ; $03F019 | |
    JSR _calculate_character_battle                                             ; $03F01B | |
+   INC r_battle_generic_arg_slot.w                                             ; $03F01E | |
    LDA r_battle_generic_arg_slot.w                                             ; $03F021 | |
    CMP #5.b                                                                    ; $03F024 | |
    BNE -                                                                       ; $03F026 |/
    RTS                                                                         ; $03F028

; _battle_update_character_stats_spells ($03:F029)
;
; Given the current offset to the character record in $A6 and the data about the
; current level up in $289C, updates the character's stats according to the
; level up data and learns any spells the character should learn.
_battle_update_character_stats_spells:
    LDA r_battle_spoils_level_up.stats.w                                        ; $03F029 |\
    AND #LEVEL_UP_STATS_VALUE.b                                                 ; $03F02C | | Extract the stat update value and save it to a variable.
    STA <r_battle_generic_tmp_4_lo                                              ; $03F02E |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F030 |\
    LDA <r_current_slot_offset_character_battle                                 ; $03F032 | | Set the X register to the offset to this character's base strength
    ADC #character_field.strength_base.w                                        ; $03F034 | | stat.
    TAX                                                                         ; $03F037 | |
    TDC                                                                         ; $03F038 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F039 |/
    LDY #5.w                                                                    ; $03F03B | Initialize the Y register to five.
-   ASL r_battle_spoils_level_up.stats.w                                        ; $03F03E | Shift out the next stat bit.
    BCC +++                                                                     ; $03F041 | If it's not set, skip to the next stat.
    LDA <r_battle_generic_tmp_4_lo                                              ; $03F043 |\
    CMP #7.b                                                                    ; $03F045 | | If the value is not seven, branch to other code.
    BNE +                                                                       ; $03F047 |/
    SEC                                                                         ; $03F049 |\
    LDA r_character_field.w,X                                                   ; $03F04A | | If the value was specifically seven, subtract one from the stat
    SBC #1.b                                                                    ; $03F04D | | in question. Make sure the final value is at least one.
    CMP #1.b                                                                    ; $03F04F | |
    BCS ++                                                                      ; $03F051 | |
    LDA #1.b                                                                    ; $03F053 | |
    BRA ++                                                                      ; $03F055 |/
+   CLC                                                                         ; $03F057 |\
    LDA r_character_field.w,X                                                   ; $03F058 | | Otherwise, add the given value directly to the stat. Ensure the
    ADC <r_battle_generic_tmp_4_lo                                              ; $03F05B | | final value is no greater than 99.
    CMP #99.b                                                                   ; $03F05D | |
    BCC ++                                                                      ; $03F05F | |
    LDA #99.b                                                                   ; $03F061 |/
++  STA r_character_field.w,X                                                   ; $03F063 | Store the updated value back to the stat.
+++ INX                                                                         ; $03F066 |\
    DEY                                                                         ; $03F067 | | Loop until all five stats have been potentially updated.
    BNE -                                                                       ; $03F068 |/
    LDA r_battle_spoils_level_up.hp.w                                           ; $03F06A |\
    STA <r_battle_update_character_max_arg_base                                 ; $03F06D | | Update the character's maximum HP by adding a random number
    LDX #9999.w                                                                 ; $03F06F | | between the value and 9/8 * the value. Ensure the final value is
    STX <r_battle_update_character_max_arg_max                                  ; $03F072 | | no greater than 9999.
    LDA #character_field.hp_max.b                                               ; $03F074 | |
    JSR _battle_update_character_max                                            ; $03F076 |/
    LDA r_battle_spoils_level_up.mp_exp_hi.w                                    ; $03F079 |\
    AND #LEVEL_UP_MP_EXP_MP.b                                                   ; $03F07C | | Update the character's maximum MP by adding a random number
    STA <r_battle_update_character_max_arg_base                                 ; $03F07E | | between the value and 9/8 * the value. Ensure the final value is
    LDX #999.w                                                                  ; $03F080 | | no greater than 999.
    STX <r_battle_update_character_max_arg_max                                  ; $03F083 | |
    LDA #character_field.mp_max.b                                               ; $03F085 | |
    JSR _battle_update_character_max                                            ; $03F087 |/
    LDX #127.w                                                                  ; $03F08A |\
    LDA #$FF.b                                                                  ; $03F08D | | Set the temporary array used for storing learned spells to all
-   STA r_battle_generic_tmp_block.w + 128,X                                    ; $03F08F | | $FF.
    DEX                                                                         ; $03F092 | |
    BPL -                                                                       ; $03F093 |/
    LDX <r_current_slot_offset_character_battle                                 ; $03F095 | Load the offset to this character's stat record to the X register.
    LDA r_character_field.1.level.w,X                                           ; $03F097 |\ Copy the character's level into the spell list update argument.
    STA <r_battle_update_spell_list_level_up_arg_level                          ; $03F09A |/
    LDA r_character_field.1.sprite_class.w,X                                    ; $03F09C |\
    AND #%00001111.b                                                            ; $03F09F | | Calculate the character's class times three to determine the
    STA <r_battle_generic_tmp_4                                                 ; $03F0A1 | | index into the class spell list data.
    ASL A                                                                       ; $03F0A3 | |
    CLC                                                                         ; $03F0A4 | |
    ADC <r_battle_generic_tmp_4                                                 ; $03F0A5 | |
    TAX                                                                         ; $03F0A7 | |
    STX <r_battle_spoils_tmp_spell_list_offset                                  ; $03F0A8 |/
    STZ <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F0AA | Initialize the list index to zero.
    STZ <r_battle_update_spell_list_level_up_arg_index_lo                       ; $03F0AC |\ Initialize the result index to zero.
    STZ <r_battle_update_spell_list_level_up_arg_index_hi                       ; $03F0AE |/
-   LDX <r_battle_spoils_tmp_spell_list_offset                                  ; $03F0B0 |\
    LDA bank13.class_spell_list_data.l,X                                        ; $03F0B2 | | If the character has a spell list in this slot, learn any spells
    CMP #$FF.b                                                                  ; $03F0B6 | | for this level.
    BEQ +                                                                       ; $03F0B8 | |
    JSR _battle_update_spell_list_level_up                                      ; $03F0BA |/
+   INC <r_battle_spoils_tmp_spell_list_offset_lo                               ; $03F0BD |\
    INC <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F0BF | | Increment the indexes and loop until all three spell lists have
    LDA <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F0C1 | | been updated.
    CMP #3.b                                                                    ; $03F0C3 | |
    BNE -                                                                       ; $03F0C5 |/
    RTS                                                                         ; $03F0C7

; _battle_update_character_max ($03:F0C8)
;
; Given an 8-bit base update value in $B1, a 16-bit maximum value in $B3, and
; the offset within the character stat record to update in the accumulator,
; updates that value as follows: The existing value is added to the base value
; plus a random number from 0 to 1/8th the base value. the final value stored
; will be no larger than the provided maximum. It is assumed that the target
; is a 16-bit value.
_battle_update_character_max:
    STA <r_battle_update_character_max_tmp_offset_lo                            ; $03F0C8 |\ Initialize the offset to the value passed in the accumulator.
    STZ <r_battle_update_character_max_tmp_offset_hi                            ; $03F0CA |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F0CC |\
    CLC                                                                         ; $03F0CE | | Add the base offset for the current character.
    LDA <r_current_slot_offset_character_battle                                 ; $03F0CF | |
    ADC <r_battle_update_character_max_tmp_offset                               ; $03F0D1 | |
    STA <r_battle_update_character_max_tmp_offset                               ; $03F0D3 | |
    TDC                                                                         ; $03F0D5 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F0D6 |/
    TDC                                                                         ; $03F0D8 |\
    TAX                                                                         ; $03F0D9 | | Get a random number from 0 to the base value divided by eight.
    LDA <r_battle_update_character_max_arg_base                                 ; $03F0DA | |
    JSR _math_divide_by_8                                                       ; $03F0DC | |
    JSR _get_battle_rng                                                         ; $03F0DF |/
    CLC                                                                         ; $03F0E2 |\
    ADC <r_battle_update_character_max_arg_base                                 ; $03F0E3 | | Add that value to the base value and save it to another variable.
    STA <r_battle_generic_tmp_4_lo                                              ; $03F0E5 | |
    LDA #0.b                                                                    ; $03F0E7 | |
    ADC #0.b                                                                    ; $03F0E9 | |
    STA <r_battle_generic_tmp_4_hi                                              ; $03F0EB |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F0ED |\
    LDX <r_battle_update_character_max_tmp_offset                               ; $03F0EF | | Add the character's existing maximum to the calculated value.
    LDA r_character_field.w,X                                                   ; $03F0F1 | |
    ADC <r_battle_generic_tmp_4                                                 ; $03F0F4 |/
    CMP <r_battle_update_character_max_arg_max                                  ; $03F0F6 |\
    BCC +                                                                       ; $03F0F8 | | If greater than the provided maximum, replace it with the maximum.
    LDA <r_battle_update_character_max_arg_max                                  ; $03F0FA |/
+   STA r_character_field.w,X                                                   ; $03F0FC |\
    TDC                                                                         ; $03F0FF | | Save the updated value back to the character.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F100 |/
    RTS                                                                         ; $03F102

; _battle_update_spell_list_level_up ($03:F103)
;
; Given a spell list in the accumulator, the character's spell list index in
; $B3, the character's level in $B5, and an index of learned spells in $9A (pass
; 0 on the first call and don't mess with it for any subsequent calls),
; determines which spells should be learned and transfers them to the spell
; list. All learned spells are placed in an array at $291C. ($9A is the current
; index in that array.)
;
; BUG: As written, this routine has issues. If a character is slated to learn
;      spells from multiple spell lists on the same level, only the first list
;      will work correctly. The code that filters spells by lists branches to
;      the wrong location, and does not increment the Y register. As a result,
;      as soon as a spell on the wrong list is encountered, it will stop
;      incrementing and no further spells will be processed. The list
;      restrictions are unnecessary, and are only useful because the code starts
;      from the beginning of the "learned spells" list every time, including
;      spells from previous lists. A proper fix would simply save the initial
;      value of $9A and use that as the starting index for the final scan. At
;      that point, all the list restriction code can be entirely removed, as
;      spells are already associated with the list they are supposed to be
;      learned on.
_battle_update_spell_list_level_up:
    PHA                                                                         ; $03F103 | Save the spell list number to the stack.
    STA <r_find_nth_entry_arg_n                                                 ; $03F104 |\
    LDY #bank0F.spell_list_level_up_data.w                                      ; $03F106 | | Find the offset to that spell list's data within the spell list
    LDA #:bank0F.spell_list_level_up_data.b                                     ; $03F109 | | level up data.
    JSR _find_nth_entry                                                         ; $03F10B |/
    TYX                                                                         ; $03F10E | Transfer the offset to the X register.
    TDC                                                                         ; $03F10F |\ Initialize the Y register to zero.
    TAY                                                                         ; $03F110 |/
-   LDA bank0F.spell_list_level_up_data.l,X                                     ; $03F111 |\
    STA r_battle_generic_tmp_block.w,Y                                          ; $03F115 | | Copy the level up data for this spell list to a temporary area.
    INX                                                                         ; $03F118 | |
    INY                                                                         ; $03F119 | |
    CMP #$FF.b                                                                  ; $03F11A | |
    BNE -                                                                       ; $03F11C |/
    TDC                                                                         ; $03F11E |\ Initialize the X register to zero.
    TAX                                                                         ; $03F11F |/
-   LDA r_battle_generic_tmp_block.w,X                                          ; $03F120 | Read the next spell level.
    CMP #$FF.b                                                                  ; $03F123 |\ If $FF, we've reached the end of the list, so branch past this
    BEQ ++                                                                      ; $03F125 |/ code.
    CMP <r_battle_update_spell_list_level_up_arg_level                          ; $03F127 |\
    BNE +                                                                       ; $03F129 | | If the level matches the level argument, copy the spell ID to the
    LDY <r_battle_update_spell_list_level_up_arg_index                          ; $03F12B | | array of spells to learn, and increment the index.
    LDA r_battle_generic_tmp_block.w + 1,X                                      ; $03F12D | |
    STA r_battle_generic_tmp_block.w + 128,Y                                    ; $03F130 | |
    INC <r_battle_update_spell_list_level_up_arg_index_lo                       ; $03F133 |/
+   INX                                                                         ; $03F135 |\
    INX                                                                         ; $03F136 | | Increment the X register to move to the next spell and loop.
    BRA -                                                                       ; $03F137 |/
++  PLA                                                                         ; $03F139 | Load the spell list number into the accumulator.
    STA <r_math_multiply_8bit_arg_1                                             ; $03F13A |\
    LDA #24.b                                                                   ; $03F13C | | Multiply the spell list by 24 (the number of spells in a list) and
    STA <r_math_multiply_8bit_arg_2                                             ; $03F13E | | transfer the result into the X register.
    JSR _math_multiply_8bit                                                     ; $03F140 | |
    LDX <r_math_multiply_8bit_result                                            ; $03F143 |/
    TDC                                                                         ; $03F145 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03F146 |/
    STY <r_battle_update_spell_list_level_up_tmp_spell_index                    ; $03F147 | Initialize the spell index to zero.
@start:
    LDA r_spell_lists.w,X                                                       ; $03F149 | Read the spell in the current index.
    BNE @next                                                                   ; $03F14C | If a spell is already in this index, skip to the next index.
    LDA r_battle_generic_tmp_block.w + 128.w,Y                                  ; $03F14E |\ Copy the current spell ID to be learned to a temporary variable.
    STA <r_battle_update_spell_list_level_up_tmp_spell                          ; $03F151 |/
    CMP #$FF.b                                                                  ; $03F153 |\ If there are no more spells to be learned, branch to the end.
    BEQ @done                                                                   ; $03F155 |/
    CMP #SPELL_FIRST_BLACK.b                                                    ; $03F157 |\
    BCS +                                                                       ; $03F159 | | If the spell is in the white magic spell range and this is not the
    LDA <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F15B | | character's first list, skip to the next spell.
    BNE @next                                                                   ; $03F15D | |
    BRA ++                                                                      ; $03F15F |/
+   CMP #SPELL_FIRST_CALL_PROXY.b                                               ; $03F161 |\
    BCS +                                                                       ; $03F163 | | If the spell is in the black magic range and this is not the
-   LDA <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F165 | | second list, skip this spell. This code is also invoked for spells
    DEC A                                                                       ; $03F167 | | in the ninja range.
    BNE @next                                                                   ; $03F168 | |
    BRA ++                                                                      ; $03F16A |/
+   CMP #SPELL_FIRST_NINJA.b                                                    ; $03F16C |\ If the spell is in the ninja range, branch back to the black magic
    BCS -                                                                       ; $03F16E |/ code.
    LDA <r_battle_update_spell_list_level_up_arg_list_index                     ; $03F170 |\
    CMP #2.b                                                                    ; $03F172 | | If the spell is in the call range, ensure the list is the third.
    BNE @next                                                                   ; $03F174 |/
++  LDA <r_battle_update_spell_list_level_up_tmp_spell                          ; $03F176 |\ Transfer the spell ID into the empty spot in the spell list.
    STA r_spell_lists.w,X                                                       ; $03F178 |/
    INY                                                                         ; $03F17B | Increment the Y register.
@next:
    INX                                                                         ; $03F17C |\
    INC <r_battle_update_spell_list_level_up_tmp_spell_index                    ; $03F17D | | Increment the indexes and loop until all entries of the spell list
    LDA <r_battle_update_spell_list_level_up_tmp_spell_index                    ; $03F17F | | have been checked.
    CMP #24.b                                                                   ; $03F181 | |
    BNE @start                                                                  ; $03F183 |/
@done:
    RTS                                                                         ; $03F185

; _battle_end_copy_battle_to_field ($03:F186)
;
; Restores the status bytes from the backup, and then copies the in-battle stat
; records to the field records. Copies the battle inventory back to the field
; inventory.
;
; TODO: After all this is done, it also calls a routine to update the back row
;       status of characters, but this updates the in-battle record. Is this a
;       bug, or is there more code somewhere else to fix it?
_battle_end_copy_battle_to_field:
    TDC                                                                         ; $03F186 |\
    TAX                                                                         ; $03F187 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03F188 |/
-   LDA r_character_battle.1.base_critical_rate.w,X                             ; $03F189 |\
    STA r_character_battle.1.critical_rate.w,X                                  ; $03F18C | | Copy the base critical rate and bonus back to the main part of the
    LDA r_character_battle.1.base_critical_bonus.w,X                            ; $03F18F | | record.
    STA r_character_battle.1.critical_bonus.w,X                                 ; $03F192 |/
    LDA r_battle_status_backup.1.status_1.w,Y                                   ; $03F195 |\
    STA r_character_battle.1.status_1.w,X                                       ; $03F198 | | Restore the status bytes from the backup.
    LDA r_battle_status_backup.1.status_2.w,Y                                   ; $03F19B | |
    STA r_character_battle.1.status_2.w,X                                       ; $03F19E | |
    LDA r_battle_status_backup.1.status_4.w,Y                                   ; $03F1A1 | |
    STA r_character_battle.1.status_4.w,X                                       ; $03F1A4 |/
    JSR _increment_x_by_128                                                     ; $03F1A7 |\
    INY                                                                         ; $03F1AA | | Increment the indexes and loop until all five characters have been
    INY                                                                         ; $03F1AB | | processed.
    INY                                                                         ; $03F1AC | |
    CPY #_sizeof_r_battle_status_backup.w                                       ; $03F1AD | |
    BNE -                                                                       ; $03F1B0 |/
    TDC                                                                         ; $03F1B2 |\
    TAX                                                                         ; $03F1B3 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03F1B4 |/
    STZ <r_battle_generic_tmp_1_lo                                              ; $03F1B5 | Initialize the current slot to zero.
--  STZ <r_battle_generic_tmp_2_lo                                              ; $03F1B7 | Initialize the byte counter to zero.
-   LDA r_character_battle.w,X                                                  ; $03F1B9 |\ Copy the in-battle record back to the field record.
    STA r_character_field.w,Y                                                   ; $03F1BC |/
    INX                                                                         ; $03F1BF |\
    INY                                                                         ; $03F1C0 | | Increment the byte counter and loop until the entire field record
    INC <r_battle_generic_tmp_2_lo                                              ; $03F1C1 | | has been transferred from the battle record.
    LDA <r_battle_generic_tmp_2_lo                                              ; $03F1C3 | |
    CMP #_sizeof_character_field.b                                              ; $03F1C5 | |
    BNE -                                                                       ; $03F1C7 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F1C9 |\
    TXA                                                                         ; $03F1CB | | Loop until all five characters have been handled.
    CLC                                                                         ; $03F1CC | |
    ADC #_sizeof_character_field.w                                              ; $03F1CD | |
    TAX                                                                         ; $03F1D0 | |
    TDC                                                                         ; $03F1D1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F1D2 | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03F1D4 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03F1D6 | |
    CMP #5.b                                                                    ; $03F1D8 | |
    BNE --                                                                      ; $03F1DA |/
    TDC                                                                         ; $03F1DC |\
    TAX                                                                         ; $03F1DD | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03F1DE |/
    STX <r_battle_generic_tmp_1                                                 ; $03F1DF | Initialize the index to zero.
-   LDA r_battle_inventory.1.id.w,X                                             ; $03F1E1 |\ Copy the item ID for this inventory slot to the field inventory.
    STA r_inventory.1.id.w,Y                                                    ; $03F1E4 |/
    BEQ +                                                                       ; $03F1E7 |\
    CMP #ITEM_NAKED.b                                                           ; $03F1E9 | | If the item ID was $00 or $60, replace the ID with $00.
    BNE ++                                                                      ; $03F1EB | |
+   TDC                                                                         ; $03F1ED | |
    STA r_inventory.1.id.w,Y                                                    ; $03F1EE | |
    BRA +                                                                       ; $03F1F1 |/
++  LDA r_battle_inventory.1.count.w,X                                          ; $03F1F3 | If the item ID wasn't $00 or $60, load the count.
+   STA r_inventory.1.count.w,Y                                                 ; $03F1F6 | Save the count to the field inventory.
    BNE +                                                                       ; $03F1F9 |\
    TDC                                                                         ; $03F1FB | | If the count is zero, zero out the item ID.
    STA r_inventory.1.id.w,Y                                                    ; $03F1FC |/
+   INX                                                                         ; $03F1FF |\
    INX                                                                         ; $03F200 | | Increment the indexes and loop until the entire inventory has been
    INX                                                                         ; $03F201 | | transferred back to the field inventory.
    INX                                                                         ; $03F202 | |
    INY                                                                         ; $03F203 | |
    INY                                                                         ; $03F204 | |
    INC <r_battle_generic_tmp_1_lo                                              ; $03F205 | |
    LDA <r_battle_generic_tmp_1_lo                                              ; $03F207 | |
    CMP #48.b                                                                   ; $03F209 | |
    BNE -                                                                       ; $03F20B |/
    JMP _set_back_row_characters                                                ; $03F20D | Pointlessly update the back row status on the in-battle stats.

UNUSED_03F210:
.if FF4_REGION == "JAPAN"
.if FF4_EASYTYPE == 1
    .dsb $0076 $FF                                                              ; $03F215.F27F
.else
    .dsb $006B $FF                                                              ; $03F215.F27F
.endif
.else
.if FF4_VERSION == "USA"
    .dsb $0085 $FF                                                              ; $03F210.F27F
.else
    .dsb $0070 $FF                                                              ; $03F210.F27F
.endif
.endif

; binary_to_decimal_data ($03:F280)
;
; Contains the powers of 10 starting from the 7th power to the second power,
; which correspond to the numbers needed to calculate the places for up to an
; eight digit decimal number.
binary_to_decimal_data:
    .ddw 10000000                                                               ; $03F280.F283 | $00
    .ddw 1000000                                                                ; $03F284.F287 | $01
    .ddw 100000                                                                 ; $03F288.F28B | $02
    .ddw 10000                                                                  ; $03F28C.F28F | $03
    .ddw 1000                                                                   ; $03F290.F293 | $04
    .ddw 100                                                                    ; $03F294.F297 | $05
    .ddw 10                                                                     ; $03F298.F29B | $06

; battle_format_number_long ($03:F29C)
;
; Given a 24-bit number in $00, converts the number into decimal format and
; stores the correct tile numbers to draw that number on BG3 in $F4AD. Supports
; numbers with up to eight digits.
battle_format_number_long:
    TDC                                                                         ; $03F29C |\ Initialize the X register and accumulator to zero.
    TAX                                                                         ; $03F29D |/
-   STZ r_battle_format_number_long_result.w,X                                  ; $03F29E |\
    INX                                                                         ; $03F2A1 | | Zero out the destination array.
    CPX #_sizeof_r_battle_format_number_long_result.w                           ; $03F2A2 | |
    BNE -                                                                       ; $03F2A5 |/
    LDX #0.w                                                                    ; $03F2A7 | Initialize the X register to zero again.
-   PHX                                                                         ; $03F2AA | Preserve the value of the X register for later.
    TXA                                                                         ; $03F2AB |\
    ASL A                                                                       ; $03F2AC | | Multiply the X register value by four.
    ASL A                                                                       ; $03F2AD | |
    TAX                                                                         ; $03F2AE |/
    LDA binary_to_decimal_data.l,X                                              ; $03F2AF |\
    STA <r_battle_format_number_long_tmp_divisor_lo                             ; $03F2B3 | | Load the number corresponding to the current decimal place into a
    LDA binary_to_decimal_data.l + 1,X                                          ; $03F2B5 | | temporary variable.
    STA <r_battle_format_number_long_tmp_divisor_md                             ; $03F2B9 | |
    LDA binary_to_decimal_data.l + 2,X                                          ; $03F2BB | |
    STA <r_battle_format_number_long_tmp_divisor_hi                             ; $03F2BF |/
    JSR _battle_format_number_long_divide                                       ; $03F2C1 | Divide the argument by the divisor to determine the current place.
    PLX                                                                         ; $03F2C4 | Restore the X register to current place fvalue.
    LDA <r_battle_format_number_long_tmp_count                                  ; $03F2C5 |\
    CLC                                                                         ; $03F2C7 | | Set the tile value by adding $80, which will produce the correct
    ADC #$80.b                                                                  ; $03F2C8 | | number.
    STA r_battle_format_number_long_result.w,X                                  ; $03F2CA |/
    INX                                                                         ; $03F2CD |\
    CPX #7.w                                                                    ; $03F2CE | | Loop until the first seven digits have been calculated.
    BNE -                                                                       ; $03F2D1 |/
    LDA <r_battle_format_number_long_arg_lo                                     ; $03F2D3 |\
    CLC                                                                         ; $03F2D5 | | Set the value of the ones digit based on the final remainder.
    ADC #$80.b                                                                  ; $03F2D6 | |
    STA r_battle_format_number_long_result.w + 7.w                              ; $03F2D8 |/
    RTL                                                                         ; $03F2DB

; _battle_format_number_long_divide ($03:F2DC)
;
; Essentially a general purpose division function that takes a 24-bit number in
; $00 and a 24-bit divisor in $04 and returns the 8-bit quotient in $08 and the
; 24-bit remainder in $00. Used by the battle number formatting routine to
; convert a number into decimal.
_battle_format_number_long_divide:
    STZ <r_battle_format_number_long_tmp_count                                  ; $03F2DC | Initialize the count to zero.
-   LDA <r_battle_format_number_long_arg_lo                                     ; $03F2DE |\
    SEC                                                                         ; $03F2E0 | | Repeatedly subtract the divisor from the argument until a borrow
    SBC <r_battle_format_number_long_tmp_divisor_lo                             ; $03F2E1 | | is required, adding one to the count each time.
    STA <r_battle_format_number_long_arg_lo                                     ; $03F2E3 | |
    LDA <r_battle_format_number_long_arg_md                                     ; $03F2E5 | |
    SBC <r_battle_format_number_long_tmp_divisor_md                             ; $03F2E7 | |
    STA <r_battle_format_number_long_arg_md                                     ; $03F2E9 | |
    LDA <r_battle_format_number_long_arg_hi                                     ; $03F2EB | |
    SBC <r_battle_format_number_long_tmp_divisor_hi                             ; $03F2ED | |
    STA <r_battle_format_number_long_arg_hi                                     ; $03F2EF | |
    INC <r_battle_format_number_long_tmp_count                                  ; $03F2F1 | |
    BCS -                                                                       ; $03F2F3 |/
    DEC <r_battle_format_number_long_tmp_count                                  ; $03F2F5 |\
    LDA <r_battle_format_number_long_arg_lo                                     ; $03F2F7 | | Subtract one from the count and add the divisor once back into the
    CLC                                                                         ; $03F2F9 | | argument. The result is that the argument has effectively been
    ADC <r_battle_format_number_long_tmp_divisor_lo                             ; $03F2FA | | divided by the divisor with the quotient in $08 and the remainder
    STA <r_battle_format_number_long_arg_lo                                     ; $03F2FC | | remaining in the argument.
    LDA <r_battle_format_number_long_arg_md                                     ; $03F2FE | |
    ADC <r_battle_format_number_long_tmp_divisor_md                             ; $03F300 | |
    STA <r_battle_format_number_long_arg_md                                     ; $03F302 | |
    LDA <r_battle_format_number_long_arg_hi                                     ; $03F304 | |
    ADC <r_battle_format_number_long_tmp_divisor_hi                             ; $03F306 | |
    STA <r_battle_format_number_long_arg_hi                                     ; $03F308 |/
    RTS                                                                         ; $03F30A

; battle_check_equipment_compatibility ($03:F30B)
;
; Given a provisional item ID for the right hand in $2894, one for the left hand
; in $2895 and the last active character slot in $1822, determines if those
; represent a valid combination of equipment in the hands.
;
; BUG: This actually allows two-handed weapons to be equipped in the wrong
;      hand, as its handedness checks are not complete.
battle_check_equipment_compatibility:
    PHX                                                                         ; $03F30B | Preserve the value in the X register.
    LDA r_battle_check_equipment_compatibility_args.right.w                     ; $03F30C | Load the item ID for the right hand to be tested.
    BNE +                                                                       ; $03F30F |\
    LDA #EQUIPMENT_TYPE_EMPTY.b                                                 ; $03F311 | | If empty, set the equipment type to empty.
    BRA ++                                                                      ; $03F313 |/
+   CMP #ITEM_FIRST_HARP.b                                                      ; $03F315 |\
    BCS +                                                                       ; $03F317 | | If the item is in the one handed range, set the equipment type to
    LDA #EQUIPMENT_TYPE_ONE_HANDED.b                                            ; $03F319 | | one handed.
    BRA ++                                                                      ; $03F31B |/
+   CMP #ITEM_FIRST_BOW.b                                                       ; $03F31D |\
    BCS +                                                                       ; $03F31F | | If the item is in the two handed range, set the equipment type to
    LDA #EQUIPMENT_TYPE_TWO_HANDED.b                                            ; $03F321 | | two handed.
    BRA ++                                                                      ; $03F323 |/
+   CMP #ITEM_FIRST_ARROW.b                                                     ; $03F325 |\
    BCS +                                                                       ; $03F327 | | If in the bow range, set the equipment type to bow.
    LDA #EQUIPMENT_TYPE_BOW.b                                                   ; $03F329 | |
    BRA ++                                                                      ; $03F32B |/
+   CMP #ITEM_FIRST_SHIELD.b                                                    ; $03F32D |\
    BCS +                                                                       ; $03F32F | | If in the arrow range, set the equipment type to arrow.
    LDA #EQUIPMENT_TYPE_ARROW.b                                                 ; $03F331 | | NOTE: This includes the "naked" armor value of $60.
    BRA ++                                                                      ; $03F333 |/
+   CMP #ITEM_FIRST_HELM.b                                                      ; $03F335 |\
    BCS +                                                                       ; $03F337 | | If in the shield range, set the equipment type to shield.
    LDA #EQUIPMENT_TYPE_SHIELD.b                                                ; $03F339 | |
    BRA ++                                                                      ; $03F33B |/
+   JMP @failure                                                                ; $03F33D | Jump to the failure code if it was none of these.
++  STA <r_battle_check_equipment_compatibility_types.right                     ; $03F340 | Save the loaded equipment type to a temporary variable.
    LDA r_battle_check_equipment_compatibility_args.left.w                      ; $03F342 | Load the item ID for the left hand to be tested.
    BNE +                                                                       ; $03F345 |\
    LDA #EQUIPMENT_TYPE_EMPTY.b                                                 ; $03F347 | | If empty, set the equipment type to empty.
    BRA ++                                                                      ; $03F349 |/
+   CMP #ITEM_FIRST_HARP.b                                                      ; $03F34B |\
    BCS +                                                                       ; $03F34D | | If in the one handed range, set the equipment type to one handed.
    LDA #EQUIPMENT_TYPE_ONE_HANDED.b                                            ; $03F34F | |
    BRA ++                                                                      ; $03F351 |/
+   CMP #ITEM_FIRST_BOW.b                                                       ; $03F353 |\
    BCS +                                                                       ; $03F355 | | If in the two handed range, set the equipment type to two handed.
    LDA #EQUIPMENT_TYPE_TWO_HANDED.b                                            ; $03F357 | |
    BRA ++                                                                      ; $03F359 |/
+   CMP #ITEM_FIRST_ARROW.b                                                     ; $03F35B |\
    BCS +                                                                       ; $03F35D | | If in the bow range, set the equipment type to bow.
    LDA #EQUIPMENT_TYPE_BOW.b                                                   ; $03F35F | |
    BRA ++                                                                      ; $03F361 |/
+   CMP #ITEM_FIRST_SHIELD.b                                                    ; $03F363 |\
    BCS +                                                                       ; $03F365 | | If in the arrow range, set the equipment type to arrow.
    LDA #EQUIPMENT_TYPE_ARROW.b                                                 ; $03F367 | |
    BRA ++                                                                      ; $03F369 |/
+   CMP #ITEM_FIRST_HELM.b                                                      ; $03F36B |\
    BCS +                                                                       ; $03F36D | | If in the shield range, set the equipment type to shield.
    LDA #EQUIPMENT_TYPE_SHIELD.b                                                ; $03F36F | |
    BRA ++                                                                      ; $03F371 |/
+   JMP @failure                                                                ; $03F373 | Jump to the failure code if it was none of these.
++  STA <r_battle_check_equipment_compatibility_types.left                      ; $03F376 | Save the loaded equipment type to a temporary variable.
    LDA r_battle_last_active_character_slot.w                                   ; $03F378 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F37B | | Set the X register to the offset for the current slot's
    ASL A                                                                       ; $03F37D | | in-battle character record.
    ASL A                                                                       ; $03F37E | |
    ASL A                                                                       ; $03F37F | |
    ASL A                                                                       ; $03F380 | |
    ASL A                                                                       ; $03F381 | |
    ASL A                                                                       ; $03F382 | |
    ASL A                                                                       ; $03F383 | |
    TAX                                                                         ; $03F384 | |
    TDC                                                                         ; $03F385 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F386 |/
    LDA r_character_battle.1.id.w,X                                             ; $03F388 |\ Save the character's ID byte to a temporary variable.
    STA <r_battle_check_equipment_compatibility_tmp_2                           ; $03F38B |/
    AND #%11000000.b                                                            ; $03F38D |\
    CMP #%11000000.b                                                            ; $03F38F | | Based on the handedness of the character, branch to the correct
    BEQ ++                                                                      ; $03F391 | | section of code.
    LDA <r_battle_check_equipment_compatibility_tmp_2                           ; $03F393 | |
    BMI +                                                                       ; $03F395 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F397 |\
    LDA <r_battle_check_equipment_compatibility_types                           ; $03F399 | | If the character is left handed, and has any combination of a
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_ONE_HANDED).w            ; $03F39B | | shield in the right hand and a one-handed weapon in the left
    BEQ @success                                                                ; $03F39E | | hand, branch to the success code. Otherwise, continue to the
    CMP #((EQUIPMENT_TYPE_SHIELD << 8) + EQUIPMENT_TYPE_ONE_HANDED).w           ; $03F3A0 | | common checks.
    BEQ @success                                                                ; $03F3A3 | |
    CMP #((EQUIPMENT_TYPE_SHIELD << 8) + EQUIPMENT_TYPE_EMPTY).w                ; $03F3A5 | |
    BEQ @success                                                                ; $03F3A8 | |
    BRA @common                                                                 ; $03F3AA |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03F3AC |\
    LDA <r_battle_check_equipment_compatibility_types                           ; $03F3AE | | If the character is right handed, and has any combination of a
    CMP #((EQUIPMENT_TYPE_ONE_HANDED << 8) + EQUIPMENT_TYPE_EMPTY).w            ; $03F3B0 | | shield in the left hand and a one-handed weapon in the right hand,
    BEQ @success                                                                ; $03F3B3 | | branch to the success code. Otherwise, continue to the common
    CMP #((EQUIPMENT_TYPE_ONE_HANDED << 8) + EQUIPMENT_TYPE_SHIELD).w           ; $03F3B5 | | checks.
    BEQ @success                                                                ; $03F3B8 | |
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_SHIELD).w                ; $03F3BA | |
    BEQ @success                                                                ; $03F3BD | |
    BRA @common                                                                 ; $03F3BF |/
++  REP #FLAG_P_ACCUMULATOR                                                     ; $03F3C1 |\
    LDA <r_battle_check_equipment_compatibility_types                           ; $03F3C3 | | If the character is ambidextrous and has a one handed weapon in
    CMP #((EQUIPMENT_TYPE_ONE_HANDED << 8) + EQUIPMENT_TYPE_ONE_HANDED).w       ; $03F3C5 | | either hand or both hands, branch to the success code. Otherwise,
    BEQ @success                                                                ; $03F3C8 | | fall through to the common checks.
    CMP #((EQUIPMENT_TYPE_ONE_HANDED << 8) + EQUIPMENT_TYPE_EMPTY).w            ; $03F3CA | |
    BEQ @success                                                                ; $03F3CD | |
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_ONE_HANDED).w            ; $03F3CF | |
    BEQ @success                                                                ; $03F3D2 |/
@common:
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_EMPTY).w                 ; $03F3D4 |\ Branch to success if both slots are empty.
    BEQ @success                                                                ; $03F3D7 |/
    CMP #((EQUIPMENT_TYPE_ARROW << 8) + EQUIPMENT_TYPE_BOW).w                   ; $03F3D9 |\ Branch to success with an arrow in the right hand and a bow in the
    BEQ @success                                                                ; $03F3DC |/ left.
    CMP #((EQUIPMENT_TYPE_BOW << 8) + EQUIPMENT_TYPE_ARROW).w                   ; $03F3DE |\ Branch to success with an arrow in the left hand and a bow in the
    BEQ @success                                                                ; $03F3E1 |/ right.
    CMP #((EQUIPMENT_TYPE_TWO_HANDED << 8) + EQUIPMENT_TYPE_EMPTY).w            ; $03F3E3 |\
    BEQ @success                                                                ; $03F3E6 | | Branch to success with a two handed weapon in one hand and the
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_TWO_HANDED).w            ; $03F3E8 | | other hand empty.
    BEQ @success                                                                ; $03F3EB |/
    CMP #((EQUIPMENT_TYPE_BOW << 8) + EQUIPMENT_TYPE_EMPTY).w                   ; $03F3ED |\
    BEQ @success                                                                ; $03F3F0 | | Branch to success with either a bow or an arrow in either hand and
    CMP #((EQUIPMENT_TYPE_ARROW << 8) + EQUIPMENT_TYPE_EMPTY).w                 ; $03F3F2 | | the other hand empty.
    BEQ @success                                                                ; $03F3F5 | |
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_ARROW).w                 ; $03F3F7 | |
    BEQ @success                                                                ; $03F3FA | |
    CMP #((EQUIPMENT_TYPE_EMPTY << 8) + EQUIPMENT_TYPE_BOW).w                   ; $03F3FC | |
    BEQ @success                                                                ; $03F3FF |/
    TDC                                                                         ; $03F401 |\ Switch back to 8-bit accumulator mode and fall through to failure.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F402 |/
@failure:
    LDA #1.b                                                                    ; $03F404 |\
    STA r_battle_check_equipment_compatibility_result.w                         ; $03F406 | | If failure, set the result variable to one, restore the X
    PLX                                                                         ; $03F409 | | register, and return.
    RTL                                                                         ; $03F40A |/
@success:
    TDC                                                                         ; $03F40B |\ If success, switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F40C |/
    LDA #1.b                                                                    ; $03F40E |\ Set the flag that will recalculate battle stats.
    STA r_battle_stats_recalculation_pending.w                                  ; $03F410 |/
    STZ r_battle_check_equipment_compatibility_result.w                         ; $03F413 | Set the result variable to zero to indicate success.
    PLX                                                                         ; $03F416 | Restore the X register.
    RTL                                                                         ; $03F417

; battle_monster_slow_dissolve ($03:F418)
;
; Animates the slow dissolve effect for the on-screen monster. Due to the way
; this works, it's only possible to use in situations where the monster is the
; only monster on screen, as it works on the screen as a whole rather than on
; a single monster.
battle_monster_slow_dissolve:
    LDA #AUDIO_EFFECT_DISINTEGRATE.b                                            ; $03F418 |\ Play the disintegration sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $03F41A |/
    TDC                                                                         ; $03F41E |\
    TAX                                                                         ; $03F41F | | Initialize the horizontal and vertical BG1 scroll arguments to
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F420 | | zero.
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F423 |/
    STX r_battle_effect_sine_index_2.w                                          ; $03F426 | Initialize the second sine index to zero.
    LDX #16.w                                                                   ; $03F429 |\ Wait for 16 frames.
    JSR _battle_wait_x_frames                                                   ; $03F42C |/
    TDC                                                                         ; $03F42F |\
    TAX                                                                         ; $03F430 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03F431 |/
    STX r_battle_monster_slow_dissolve_tmp_current_line.w                       ; $03F432 | Initialize the current line to zero.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F435 |\
-   LDA battle_monster_slow_dissolve_data.l,X                                   ; $03F437 | | Copy the line toggle data from ROM to RAM. The data in ROM gives a
    ASL A                                                                       ; $03F43B | | simple $80 for lines that should toggle and $00 or lines that
    AND #$0100.w                                                                ; $03F43C | | should not. Here, we expand it to two bytes per entry by shifting
    STA r_battle_monster_slow_dissolve_tmp_lines.w,Y                            ; $03F43F | | it left one bit. This allows us to toggle the bit that will add
    INX                                                                         ; $03F442 | | 256 to (or subtract from) the coordinate.
    INY                                                                         ; $03F443 | |
    INY                                                                         ; $03F444 | |
    CPY #64.w                                                                   ; $03F445 | |
    BNE -                                                                       ; $03F448 | |
    TDC                                                                         ; $03F44A | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F44B |/
-   JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F44D | Wait for the next frame.
    INC r_battle_monster_slow_dissolve_frame_counter.w                          ; $03F451 | Increment the frame counter.
    LDA r_battle_monster_slow_dissolve_frame_counter.w                          ; $03F454 |\
    AND #%00000111.b                                                            ; $03F457 | | Set the current scroll value based on the current frame counter.
    TAX                                                                         ; $03F459 | | This part produces a shaking effect.
    LDA bank0D.battle_shake_scroll_data.l,X                                     ; $03F45A | |
    TAY                                                                         ; $03F45E | |
    STY r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F45F |/
    JSR _battle_monster_slow_dissolve_set_hdma                                  ; $03F462 | Set the HDMA for this frame.
    LDA r_battle_monster_slow_dissolve_frame_counter.w                          ; $03F465 |\
    AND #%00000011.b                                                            ; $03F468 | | Repeat the current situation until the frame counter mod 4 is 0.
    BNE -                                                                       ; $03F46A |/
    LDX r_battle_monster_slow_dissolve_tmp_current_line.w                       ; $03F46C |\
    INX                                                                         ; $03F46F | | Increment the current line.
    STX r_battle_monster_slow_dissolve_tmp_current_line.w                       ; $03F470 |/
    CPX #128.w                                                                  ; $03F473 |\ Loop until the current line reaches 128.
    BNE -                                                                       ; $03F476 |/
    RTL                                                                         ; $03F478

; battle_monster_slow_dissolve_data ($03:F479)
;
; For the slow dissolve monster effect, determines the patterns of lines that
; exist below the threshold line, as far as which are visible and which are not.
battle_monster_slow_dissolve_data:
    .db $80, $00, $80, $00, $80, $00, $80, $00, $80, $00, $80                   ; $03F479.F483
    .db $00, $80, $00, $00, $80, $00, $00, $80, $00, $00, $00                   ; $03F484.F48E
    .db $80, $00, $00, $00, $00, $80, $00, $00, $00, $00, $00                   ; $03F48F.F499

; _battle_monster_slow_dissolve_set_hdma ($03:F49A)
;
; Sets the current BG1 HDMA values for the slow monster dissolve effect. The
; current line for the start of the effect (where the monster starts to be
; visible) should be passed in $F4A2 (16-bits), but note that the routine is
; inded to be called as a subroutine of the slow dissolve routine and relies on
; certain data set by that routine.
_battle_monster_slow_dissolve_set_hdma:
    PHX                                                                         ; $03F49A | Preserve the value in the X register.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F49B | Switch to 16-bit accumulator mode.
    LDA r_battle_monster_slow_dissolve_tmp_current_line.w                       ; $03F49D |\ Transfer the current line number to a temporary variable.
    STA <r_battle_generic_tmp_index_2                                           ; $03F4A0 |/
    LDA #$0100.w                                                                ; $03F4A2 |\ Initialize the current HDMA value to show the right side of BG1
    STA <r_battle_generic_tmp_index                                             ; $03F4A5 |/ (where the monster is erased).
    TDC                                                                         ; $03F4A7 |\
    TAY                                                                         ; $03F4A8 | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $03F4A9 |/
-   LDA <r_battle_generic_tmp_index                                             ; $03F4AA |\ Set the scroll value of the current line to the current value.
    STA r_battle_bg1_hdma_data.1.horizontal.w,Y                                 ; $03F4AC |/
    DEC <r_battle_generic_tmp_index_2                                           ; $03F4AF |\ If the current line hasn't been reached yet, skip this next block.
    BPL +                                                                       ; $03F4B1 |/
    LDA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F4B3 |\ Transfer the current desired scroll value to a temporary variable.
    STA <r_battle_generic_tmp_index                                             ; $03F4B6 |/
    CPX #64.w                                                                   ; $03F4B8 |\ If 64 lines have passed since starting the line effect, skip this
    BEQ +                                                                       ; $03F4BB |/ next section, as the effect is done.
    LDA r_battle_monster_slow_dissolve_tmp_lines.w,X                            ; $03F4BD |\
    STA <r_battle_generic_tmp_index_3                                           ; $03F4C0 | | Otherwise, exclusive OR the current scroll value with the value
    LDA <r_battle_generic_tmp_index                                             ; $03F4C2 | | loaded from the current line effect index, to potentially toggle
    EOR <r_battle_generic_tmp_index_3                                           ; $03F4C4 | | which side is visible.
    STA <r_battle_generic_tmp_index                                             ; $03F4C6 |/
    INX                                                                         ; $03F4C8 |\ Increment the X register twice to move to the next line.
    INX                                                                         ; $03F4C9 |/
+   INY                                                                         ; $03F4CA |\
    INY                                                                         ; $03F4CB | | Increment the Y register four times to move to the next line of
    INY                                                                         ; $03F4CC | | HDMA data.
    INY                                                                         ; $03F4CD |/
    CPY #(140 * _sizeof_scroll_hdma_data_entry).w                               ; $03F4CE |\ Loop until 140 lines in total have been processed.
    BNE -                                                                       ; $03F4D1 |/
    TDC                                                                         ; $03F4D3 |\ Switch back to 8-bit accumulator mode.
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F4D4 |/
    PLX                                                                         ; $03F4D6 | Restore the value in the X register.
    RTS                                                                         ; $03F4D7

; battle_effect_spell_set_oam_entry ($03:F4D8)
;
; Sets the next tile in the battle effect OAM based on the value passed in the
; accumulator. The low five bits determine the actual tile number to insert in
; the current location (with $1F being a blank tile). The next two bits are
; the vertical and horizontal flip bits. The last bit is not used in this
; routine. The current desired index within the effect OAM data should be set in
; the Y register.
battle_effect_spell_set_oam_entry:
    PHA                                                                         ; $03F4D8 |\
    AND #%00011111.b                                                            ; $03F4D9 | | Skip to updating the indexes if the tile number is $1F, which
    CMP #$1F.b                                                                  ; $03F4DB | | corresponds to a blank tile.
    BNE +                                                                       ; $03F4DD | |
    PLA                                                                         ; $03F4DF | |
    JMP @next                                                                   ; $03F4E0 |/
+   TAX                                                                         ; $03F4E3 |\
    LDA bank16.battle_effect_spell_tile_number_data.l,X                         ; $03F4E4 | | Set the actual tile number by loading it from ROM.
    STA r_battle_effect_oam.1.tile.w,Y                                          ; $03F4E8 |/
    LDA <r_battle_effect_spell_current_coordinates.x                            ; $03F4EB |\
    STA r_battle_effect_oam.1.x.w,Y                                             ; $03F4ED | | Set the tile's X and Y coordinates to the current X and Y
    LDA <r_battle_effect_spell_current_coordinates.y                            ; $03F4F0 | | coordinates.
    STA r_battle_effect_oam.1.y.w,Y                                             ; $03F4F2 |/
    PLA                                                                         ; $03F4F5 |\
    ASL A                                                                       ; $03F4F6 | | Set the tile flags by masking out the flip bits from the argument,
    AND #%11000000.b                                                            ; $03F4F7 | | adding the bits to use palette 15 and use the high tile numbers,
    ORA #%00001111.b                                                            ; $03F4F9 | | and then add the priority argument.
    ORA <r_battle_effect_spell_tile_priority                                    ; $03F4FB | |
    STA r_battle_effect_oam.1.flags.w,Y                                         ; $03F4FD |/
    LDA r_battle_effect_spell_mirror.w                                          ; $03F500 |\
    BEQ +                                                                       ; $03F503 | | If the mirror flag is enabled, toggle the horizontal flip bit on
    LDA r_battle_effect_oam.1.flags.w,Y                                         ; $03F505 | | the flags byte, and recalculate the X coordinate to mirror to
    EOR #%01000000.b                                                            ; $03F508 | | flip the overall location as well (relative to its center point).
    STA r_battle_effect_oam.1.flags.w,Y                                         ; $03F50A | |
    LDA <r_battle_effect_spell_tiles_remaining.x                                ; $03F50D | |
    DEC A                                                                       ; $03F50F | |
    ASL A                                                                       ; $03F510 | |
    ASL A                                                                       ; $03F511 | |
    ASL A                                                                       ; $03F512 | |
    ASL A                                                                       ; $03F513 | |
    CLC                                                                         ; $03F514 | |
    ADC <r_battle_effect_spell_starting_coordinates.x                           ; $03F515 | |
    STA r_battle_effect_oam.1.x.w,Y                                             ; $03F517 |/
+   INY                                                                         ; $03F51A |\
    INY                                                                         ; $03F51B | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $03F51C | |
    INY                                                                         ; $03F51D |/
@next:
    LDA <r_battle_effect_spell_current_coordinates.x                            ; $03F51E |\
    CLC                                                                         ; $03F520 | | Add sixteen to the X coordinate to move to the next tile.
    ADC #16.b                                                                   ; $03F521 | |
    STA <r_battle_effect_spell_current_coordinates.x                            ; $03F523 |/
    DEC <r_battle_effect_spell_tiles_remaining.x                                ; $03F525 |\ Decrement the number of horizontal tiles remaining, and unless it
    BNE +                                                                       ; $03F527 |/ reaches zero, branch to the end.
    LDA <r_battle_effect_spell_starting_coordinates.x                           ; $03F529 |\ Reset the X coordinate to the starting X coordinate.
    STA <r_battle_effect_spell_current_coordinates.x                            ; $03F52B |/
    LDA <r_battle_effect_spell_current_coordinates.y                            ; $03F52D |\
    CLC                                                                         ; $03F52F | |
    ADC #16.b                                                                   ; $03F530 | |
    STA <r_battle_effect_spell_current_coordinates.y                            ; $03F532 |/
    LDA r_battle_effect_spell_size.width.w                                      ; $03F534 |\ Set the number of horizontal remaining tiles to the width.
    STA <r_battle_effect_spell_tiles_remaining.x                                ; $03F537 |/
    DEC <r_battle_effect_spell_tiles_remaining.y                                ; $03F539 | Decrement the remaining count of vertical tiles.
    BNE +                                                                       ; $03F53B |\
    CLC                                                                         ; $03F53D | | If none remain, clear the carry flag and return.
    RTL                                                                         ; $03F53E |/
+   SEC                                                                         ; $03F53F | Otherwise, set the carry flag.
    RTL                                                                         ; $03F540

; battle_load_monster_death_palette ($03:F541)
;
; Loads the monster death palette from ROM to the CG-RAM mirror in RAM,
; specifically to the eighth palette.
battle_load_monster_death_palette:
    STZ <r_battle_monster_effect_counter                                        ; $03F541 | Zero out the monster effect counter.
    TDC                                                                         ; $03F543 |\
    TAX                                                                         ; $03F544 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03F545 |/
-   LDA bank0E.battle_palette_data.l + BATTLE_PALETTE_OFFSET_MONSTER_DEATH,X    ; $03F546 |\ Copy the next byte from ROM to RAM.
    STA r_battle_cgram_data.8.w,Y                                               ; $03F54A |/
    INX                                                                         ; $03F54D |\
    INY                                                                         ; $03F54E | | Increment the indexes and loop until the entire palette has been
    CPY #_sizeof_palette.w                                                      ; $03F54F | | copied.
    BNE -                                                                       ; $03F552 |/
    RTL                                                                         ; $03F554

; battle_monster_slot_map_enable_pre_action ($03:F555)
;
; Swaps the monster slot to type index map to the pre-action copy, backing up
; the existing value.
battle_monster_slot_map_enable_pre_action:
    TDC                                                                         ; $03F555 |\ Initialize the X register to zero.
    TAX                                                                         ; $03F556 |/
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03F557 |\ Copy the byte to the backup array.
    STA r_monster_slot_to_id_index_backup.w,X                                   ; $03F55A |/
    LDA r_monster_slot_to_id_index_pre_action.w,X                               ; $03F55D |\ Copy the pre-action data to the main array.
    STA r_monster_slot_to_id_index.w,X                                          ; $03F560 |/
    INX                                                                         ; $03F563 |\
    CPX #8.w                                                                    ; $03F564 | | Loop until all eight monster slots are copied.
    BNE -                                                                       ; $03F567 |/
    RTL                                                                         ; $03F569

; battle_monster_slot_map_disable_pre_action ($03:F56A)
;
; Swaps the monster slot to type index map back to the main array, restoring
; from a backup made by the enable version of this routine.
battle_monster_slot_map_disable_pre_action:
    TDC                                                                         ; $03F56A |\ Initialize the X register to zero.
    TAX                                                                         ; $03F56B |/
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03F56C |\ Copy the pre-action data back to the pre-action array.
    STA r_monster_slot_to_id_index_pre_action.w,X                               ; $03F56F |/
    LDA r_monster_slot_to_id_index_backup.w,X                                   ; $03F572 |\ Copy the backed up data back to the main array.
    STA r_monster_slot_to_id_index.w,X                                          ; $03F575 |/
    INX                                                                         ; $03F578 |\
    CPX #8.w                                                                    ; $03F579 | | Loop until all eight monster slots are copied.
    BNE -                                                                       ; $03F57C |/
    RTL                                                                         ; $03F57E

; battle_zeromus_death_sound_effect_data ($03:F57F)
;
; Sound effects used during the Zeromus death scene (but due to a bug, only one
; is used).
;
; TODO: Is this only used by Zeromus, or are there other users that possibly
;       explain the bug away as intentional?
battle_zeromus_death_sound_effect_data:
    .db AUDIO_EFFECT_LIT                                                        ; $03F57F
    .db AUDIO_EFFECT_SHORT_EXPLOSION                                            ; $03F580
    .db AUDIO_EFFECT_FIRE3                                                      ; $03F581
    .db AUDIO_EFFECT_MAGNET                                                     ; $03F582

; _battle_zeromus_death_play_sound_effect ($03:F583)
;
; Plays a sound effect for the Zeromus death animation. TODO: Other users?
;
; BUG: Assuming the Zeromus death animation is the only consumer, there is a
;      likely bug or curiosity in this routine. The routine reads a value from
;      $13 and then takes it mod 4 to determine the index into the sound effect
;      data. Unfortunately, $13 is not set by any of the calling routines, and
;      at least during the Zeromus death animation, the last routine to set the
;      value is using it as storage for coordinates. In fact, the routine ends
;      up being called with the same value in $13 every time, so only one sound
;      effect is ever played. It's hard to gauge what the original intent was
;      here, but changing the routine to read the frame counter at $97 produces
;      a more interesting death sound effect sequence.
_battle_zeromus_death_play_sound_effect:
    LDA <r_battle_generic_tmp_coordinates.y                                     ; $03F583 |\
    AND #%00000011.b                                                            ; $03F585 | | Set the X register to either 0, 1, 2 or 3 depending on the value
    TAX                                                                         ; $03F587 |/  of a variable often used for coordinates.
    LDA battle_zeromus_death_sound_effect_data.l,X                              ; $03F588 | Load the sound effect associated with this value.
    JSL bank02.battle_play_sound_effect                                         ; $03F58C | Play the sound effect.
    RTS                                                                         ; $03F590

; battle_zeromus_death_animation ($03:F591)
;
; Animates the Zeromus death animation, including both audio and visual effects.
battle_zeromus_death_animation:
    LDA #AUDIO_TRACK_RUMBLING.b                                                 ; $03F591 |\
    STA r_battle_song_change_track.w                                            ; $03F593 | | Change the music to the rumbling sound.
    INC r_battle_song_change_pending.w                                          ; $03F596 |/
    JSR _battle_zeromus_death_play_sound_effect                                 ; $03F599 | Play a sound effect.
    JSR _battle_zeromus_flash                                                   ; $03F59C | Do a graphical flash effect.
    LDX #64.w                                                                   ; $03F59F |\ Wait for 64 frames.
    JSR _battle_wait_x_frames                                                   ; $03F5A2 |/
    JSR _battle_zeromus_death_play_sound_effect                                 ; $03F5A5 | Play another sound effect.
    JSL bank01.set_battle_flash_continuous_yellow                               ; $03F5A8 |\
    LDX #32.w                                                                   ; $03F5AC | | Flash continuously with a yellow color for 32 frames.
    JSR _battle_wait_x_frames                                                   ; $03F5AF |/
    JSR _battle_zeromus_flash                                                   ; $03F5B2 | Do another graphical flash effect.
    LDX #0.w                                                                    ; $03F5B5 |\
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F5B8 | | Initially set the BG1 scroll values to zero.
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F5BB |/
    STA r_battle_effect_frame_counter.w                                         ; $03F5BE | Initialize the frame counter to zero.
-   JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F5C1 | Wait for the next frame.
    LDA r_battle_effect_frame_counter.w                                         ; $03F5C5 |\
    AND #%00000111.b                                                            ; $03F5C8 | | Load the current horizontal scroll value based on the current
    TAX                                                                         ; $03F5CA | | value of hte frame counter. Specifically, it rotates through eight
    LDA bank0D.battle_shake_scroll_data.l,X                                     ; $03F5CB | | values and changes each frame.
    TAY                                                                         ; $03F5CF | |
    STY r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F5D0 |/
    LDA r_battle_effect_frame_counter.w                                         ; $03F5D3 |\
    AND #%00001111.b                                                            ; $03F5D6 | | Every sixteen frames, decrease the value of the vertical scroll
    BNE +                                                                       ; $03F5D8 | | register.
    LDY r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F5DA | |
    DEY                                                                         ; $03F5DD | |
    STY r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F5DE |/
+   LDA r_battle_effect_frame_counter.w                                         ; $03F5E1 |\
    CMP #140.b                                                                  ; $03F5E4 | | If the frame counter has a value of 16, 32 or 140, do the flash
    BEQ +                                                                       ; $03F5E6 | | effect.
    CMP #16.b                                                                   ; $03F5E8 | |
    BEQ +                                                                       ; $03F5EA | |
    CMP #32.b                                                                   ; $03F5EC | |
    BNE ++                                                                      ; $03F5EE | |
+   JSR _battle_zeromus_flash                                                   ; $03F5F0 |/
++  INC r_battle_effect_frame_counter.w                                         ; $03F5F3 | Increment the frame counter.
    JSL bank01.battle_set_bg1_scroll                                            ; $03F5F6 | Update the scroll values of BG1 (the monster sprites).
    LDY r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F5FA |\
    CPY #-160.w                                                                 ; $03F5FD | | Loop until the vertical scroll reaches -160.
    BNE -                                                                       ; $03F600 |/
    LDA #AUDIO_EFFECT_QUAKE.b                                                   ; $03F602 |\ Play the Quake sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $03F604 |/
    RTL                                                                         ; $03F608

; _battle_zeromus_flash ($03:F609)
;
; Plays a brief sound effect and does a flash effect on the screen during
; battle, used during the Zeromus death animation.
_battle_zeromus_flash:
    JSR _battle_zeromus_death_play_sound_effect                                 ; $03F609 | Play a sound effect.
    JSL bank01.set_battle_flash_continuous_white                                ; $03F60C |\
    LDA #BATTLE_FLASH_MODE_SINGLE.b                                             ; $03F610 | | Execute a white flash effect.
    STA r_battle_flash_mode.w                                                   ; $03F612 |/
    JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F615 | Wait a frame.
    JSL bank01.set_battle_flash_continuous_yellow                               ; $03F619 |\
    LDA #BATTLE_FLASH_MODE_SINGLE.b                                             ; $03F61D | | Execute a yellow flash effect.
    STA r_battle_flash_mode.w                                                   ; $03F61F |/
    JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F622 | Wait a frame.
    JSL bank01.set_battle_flash_continuous_red                                  ; $03F626 |\
    LDA #BATTLE_FLASH_MODE_SINGLE.b                                             ; $03F62A | | Execute a red flash effect.
    STA r_battle_flash_mode.w                                                   ; $03F62C |/
    RTS                                                                         ; $03F62F

; battle_update_coordinates_walk_left ($03:F630)
;
; Given an offset for a character slot in the visual properties data, sets the
; Y offset for that character and updates the X coordinate to produce the proper
; effect for a character moving left.
battle_update_coordinates_walk_left:
    PHX                                                                         ; $03F630 | Preserve the value of the X register.
    JSR _battle_update_offset_walking                                           ; $03F631 | Update the Y offset and determine the X coordinate delta.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $03F634 |\
    SEC                                                                         ; $03F637 | | Subtract the X coordinate delta from the character's X coordinate.
    SBC <r_battle_generic_tmp_index_lo                                          ; $03F638 | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $03F63A |/
    PLX                                                                         ; $03F63D | Restore the X register.
    RTL                                                                         ; $03F63E

; battle_update_coordinates_walk_right ($03:F63F)
;
; Given an offset for a character slot in the visual properties data, sets the
; Y offset for that character and updates the X coordinate to produce the proper
; effect for a character moving right.
battle_update_coordinates_walk_right:
    PHX                                                                         ; $03F63F | Preserve the value of the X register.
    JSR _battle_update_offset_walking                                           ; $03F640 | Update the Y offset and determine the X coordinate delta.
    LDA r_battle_character_visual_properties.1.x.w,X                            ; $03F643 |\
    CLC                                                                         ; $03F646 | | Add the X coordinate delta to the character's X coordinate.
    ADC <r_battle_generic_tmp_index_lo                                          ; $03F647 | |
    STA r_battle_character_visual_properties.1.x.w,X                            ; $03F649 |/
    PLX                                                                         ; $03F64C | Restore the X register.
    RTL                                                                         ; $03F64D

; _battle_update_offset_walking ($03:F64E)
;
; Given an offset for a character slot in the visual properties data, sets that
; character's Y offset appropriately to produce the hopping effect if they are
; a toad. Additionally, returns the value that should be added to the X
; coordinate that frame (1 for small or toad, and 2 for anything else).
_battle_update_offset_walking:
    TXA                                                                         ; $03F64E | Transfer the X register to the accumulator.
    STZ r_battle_character_visual_properties.1.y_offset.w,X                     ; $03F64F | Set the character's initial Y offset to zero.
    LSR A                                                                       ; $03F652 |\
    LSR A                                                                       ; $03F653 | | Divide the index by four to index the visual status data.
    TAY                                                                         ; $03F654 |/
    LDA r_character_visual_status.1.status_1.w,Y                                ; $03F655 |\
    AND #(STATUS_1_TOAD | STATUS_1_SMALL).b                                     ; $03F658 | | If the character doesn't have the toad or small status, branch.
    BEQ ++                                                                      ; $03F65A |/
    AND #STATUS_1_TOAD.b                                                        ; $03F65C |\
    BEQ +                                                                       ; $03F65E | | If the character is a toad, set the Y offset by taking the frame
    LDA r_battle_character_visual_properties.1.frame_counter.w,X                ; $03F660 | | counter mod 8 and using that to load the appropriate offset.
    AND #%00000111.b                                                            ; $03F663 | |
    PHX                                                                         ; $03F665 | |
    TAX                                                                         ; $03F666 | |
    LDA bank0D.battle_toad_hop_data.l,X                                         ; $03F667 | |
    PLX                                                                         ; $03F66B | |
    STA r_battle_character_visual_properties.1.y_offset.w,X                     ; $03F66C |/
+   LDA #1.b                                                                    ; $03F66F |\ If the character has either the toad or small status, return a
    BRA +                                                                       ; $03F671 |/ value of 1.
++  LDA #2.b                                                                    ; $03F673 |\ Otherwise, return a value of two.
+   STA <r_battle_generic_tmp_index_lo                                          ; $03F675 |/
    RTS                                                                         ; $03F677

; frame_mask_data ($03:F678)
;
; Contains several masks useful to mask a frame counter to check if a periodic
; action should be executed. A value of zero corresponds to being true every
; 128 frames, with each successive index dividing that value by two.
frame_mask_data:
    .db %01111111                                                               ; $03F678 | $00: 128
    .db %00111111                                                               ; $03F679 | $01: 64
    .db %00011111                                                               ; $03F67A | $02: 32
    .db %00001111                                                               ; $03F67B | $03: 16
    .db %00000111                                                               ; $03F67C | $04: 8
    .db %00000011                                                               ; $03F67D | $05: 4
    .db %00000001                                                               ; $03F67E | $06: 2
    .db %00000000                                                               ; $03F67F | $07: 1

; battle_set_monster_center_coordinates ($03:F680)
;
; Loops through the eight monster slots, and sets the top center, center and
; bottom center monster coordinates in $F029, $F043 and $F05D, respectively.
; If the slot is empty, the coordinates are set to $FF.
battle_set_monster_center_coordinates:
    LDY #0.w                                                                    ; $03F680 |\ Initialize the X and Y registers to zero.
    LDX #0.w                                                                    ; $03F683 |/
@start:
    LDA r_monster_slot_to_id_index_initial.w,X                                  ; $03F686 |\
    CMP #$FF.b                                                                  ; $03F689 | | If the slot is empty, set all of the coordinate values to $FF.
    BNE +                                                                       ; $03F68B | |
    STA r_battle_monster_coordinates_center.1.x.w,Y                             ; $03F68D | |
    STA r_battle_monster_coordinates_center.1.y.w,Y                             ; $03F690 | |
    STA r_battle_monster_coordinates_bottom_center.1.x.w,Y                      ; $03F693 | |
    STA r_battle_monster_coordinates_bottom_center.1.y.w,Y                      ; $03F696 | |
    STA r_battle_monster_coordinates_top_center.1.x.w,Y                         ; $03F699 | |
    STA r_battle_monster_coordinates_top_center.1.y.w,Y                         ; $03F69C | |
    BRA ++                                                                      ; $03F69F |/
+   PHX                                                                         ; $03F6A1 | Preserve the slot currently in the X register.
    PHA                                                                         ; $03F6A2 | Preserve the type index.
    LDA r_monster_coordinates.w,X                                               ; $03F6A3 |\
    AND #%11110000.b                                                            ; $03F6A6 | | Calculate the monster's pixel X coordinate by multiplying by eight
    LSR A                                                                       ; $03F6A8 | | and adding 16 (as the leftmost two tiles aren't used for
    CLC                                                                         ; $03F6A9 | | monsters).
    ADC #16.b                                                                   ; $03F6AA | |
    STA <r_battle_generic_tmp_index_2_lo                                        ; $03F6AC |/
    LDA r_monster_coordinates.w,X                                               ; $03F6AE |\
    AND #%00001111.b                                                            ; $03F6B1 | | Calculate the monster's pixel Y coordinate by multiplying by
    ASL A                                                                       ; $03F6B3 | | eight.
    ASL A                                                                       ; $03F6B4 | |
    ASL A                                                                       ; $03F6B5 | |
    STA <r_battle_generic_tmp_index_2_hi                                        ; $03F6B6 |/
    PLA                                                                         ; $03F6B8 |\
    ASL A                                                                       ; $03F6B9 | | Set the X register to the type index times two.
    TAX                                                                         ; $03F6BA |/
    LDA r_monster_type_size.1.width.w,X                                         ; $03F6BB |\
    ASL A                                                                       ; $03F6BE | | Multiply the monster's width in tiles by four to get half the
    ASL A                                                                       ; $03F6BF | | width in pixels. Add that value to the calculated base X
    CLC                                                                         ; $03F6C0 | | coordinate and set that value in all three sets of coordinates (as
    ADC <r_battle_generic_tmp_index_2_lo                                        ; $03F6C1 | | the X coordinate in all three sets always points to the middle).
    STA r_battle_monster_coordinates_center.1.x.w,Y                             ; $03F6C3 | |
    STA r_battle_monster_coordinates_bottom_center.1.x.w,Y                      ; $03F6C6 | |
    STA r_battle_monster_coordinates_top_center.1.x.w,Y                         ; $03F6C9 |/
    LDA <r_battle_generic_tmp_index_2_hi                                        ; $03F6CC |\ Set the top center Y coordinate to the base Y coordinate.
    STA r_battle_monster_coordinates_top_center.1.y.w,Y                         ; $03F6CE |/
    LDA r_monster_type_size.1.height.w,X                                        ; $03F6D1 |\
    ASL A                                                                       ; $03F6D4 | | Set the center Y coordinate to the base Y coordinate plus half the
    ASL A                                                                       ; $03F6D5 | | height.
    CLC                                                                         ; $03F6D6 | |
    ADC <r_battle_generic_tmp_index_2_hi                                        ; $03F6D7 | |
    STA r_battle_monster_coordinates_center.1.y.w,Y                             ; $03F6D9 |/
    LDA r_monster_type_size.1.height.w,X                                        ; $03F6DC |\
    ASL A                                                                       ; $03F6DF | | Set the bottom center Y coordinate to the base Y coordinate plus
    ASL A                                                                       ; $03F6E0 | | the monster's complete height.
    ASL A                                                                       ; $03F6E1 | |
    CLC                                                                         ; $03F6E2 | |
    ADC <r_battle_generic_tmp_index_2_hi                                        ; $03F6E3 | |
    STA r_battle_monster_coordinates_bottom_center.1.y.w,Y                      ; $03F6E5 |/
    PLX                                                                         ; $03F6E8 | Restore the X register to the slot number.
++  INY                                                                         ; $03F6E9 |\
    INY                                                                         ; $03F6EA | | Increment the indexes and loop until all eight monster slots have
    INX                                                                         ; $03F6EB | | been examined.
    CPX #8.w                                                                    ; $03F6EC | |
    BEQ +                                                                       ; $03F6EF | |
    JMP @start                                                                  ; $03F6F1 |/
+   RTL                                                                         ; $03F6F4

; battle_get_character_palette_index ($03:F6F5)
;
; Given a slot number in the accumulator, determines the correct palette for
; that slot and stores it in RAM in the array at $F0A3. Returns the palette
; index in the accumulator.
battle_get_character_palette_index:
    TAX                                                                         ; $03F6F5 |\ Transfer the value in the accumulator to the X register and push it
    PHX                                                                         ; $03F6F6 |/ to the stack.
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F6F7 |\
    ASL A                                                                       ; $03F6F9 | | Multiply the value by 128 and transfer it to the X register.
    ASL A                                                                       ; $03F6FA | |
    ASL A                                                                       ; $03F6FB | |
    ASL A                                                                       ; $03F6FC | |
    ASL A                                                                       ; $03F6FD | |
    ASL A                                                                       ; $03F6FE | |
    ASL A                                                                       ; $03F6FF | |
    TAX                                                                         ; $03F700 | |
    TDC                                                                         ; $03F701 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F702 |/
    LDA r_character_battle.1.sprite_class.w,X                                   ; $03F704 |\
    AND #%00011111.b                                                            ; $03F707 | | If the character is Golbez (has the Golbez class), decrement their
    CMP #CLASS_GOLBEZ.b                                                         ; $03F709 | | palette index, otherwise use their class value directly.
    BNE +                                                                       ; $03F70B | |
    DEC A                                                                       ; $03F70D |/
+   PLX                                                                         ; $03F70E | Transfer the slot number to the X register.
    STA r_battle_character_palette_index.w,X                                    ; $03F70F | Set this slot's palette index.
    RTL                                                                         ; $03F712

; battle_monster_effect_audio_data ($03:F713)
;
; For various monster effects, contains the relevant sound effect track to play
; during that effect.
battle_monster_effect_audio_data:
    .db AUDIO_EFFECT_MONSTER_DEATH                                              ; $03F713
    .db AUDIO_EFFECT_MONSTER_TRANSFORM                                          ; $03F714
    .db AUDIO_EFFECT_MONSTER_TRANSFORM                                          ; $03F715
    .db AUDIO_EFFECT_MONSTER_TRANSFORM                                          ; $03F716
    .db AUDIO_EFFECT_ESCAPE                                                     ; $03F717
    .db AUDIO_EFFECT_MONSTER_DEATH                                              ; $03F718

; _battle_pose_clear_status_override ($03:F719)
;
; Loops through the five character slots and resets their battle pose override
; value if they have any of the following statuses: swoon, stone, paralyze,
; sleep, charm or berserk.
_battle_pose_clear_status_override:
    TDC                                                                         ; $03F719 |\
    TAY                                                                         ; $03F71A | | Initialize the X and Y registers to zero.
    TAX                                                                         ; $03F71B |/
-   LDA r_character_visual_status.1.status_1.w,X                                ; $03F71C |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03F71F | | Clear the pose if the slot has swoon or stone.
    BNE +                                                                       ; $03F721 |/
    LDA r_character_visual_status.1.status_2.w,X                                ; $03F723 |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03F726 | | Clear the pose if the slot has paralyze, sleep, charm or berserk.
    BNE +                                                                       ; $03F728 |/
--  TXA                                                                         ; $03F72A |\
    CLC                                                                         ; $03F72B | | Increment the indexes and loop until all five character slots have
    ADC #_sizeof_character_status.b                                             ; $03F72C | | been checked.
    TAX                                                                         ; $03F72E | |
    INY                                                                         ; $03F72F | |
    CPX #_sizeof_r_character_visual_status.w                                    ; $03F730 | |
    BNE -                                                                       ; $03F733 |/
    RTS                                                                         ; $03F735 | Return to the caller.
+   LDA #BATTLE_POSE_NO_OVERRIDE.b                                              ; $03F736 |\ Configure the pose with no override.
    STA r_battle_character_pose.w,Y                                             ; $03F738 |/
    STA r_battle_character_pose_backup.w,Y                                      ; $03F73B | Store the pose value in the backup pose array as well.
    JMP --                                                                      ; $03F73E

; battle_check_character_disabled_or_monsters_dead ($03:F741)
;
; Sets the carry bit if either the last active character slot has the swoon or
; stone statuses, or if there are no monsters left alive.
battle_check_character_disabled_or_monsters_dead:
    JSR _battle_pose_clear_status_override                                      ; $03F741 | Reset the pose override for characters with certain statuses.
    LDA r_battle_last_active_character_slot.w                                   ; $03F744 |\
    ASL A                                                                       ; $03F747 | | Set the X register to the offset for the last active character's
    ASL A                                                                       ; $03F748 | | visual status data.
    TAX                                                                         ; $03F749 |/
    LDA r_character_visual_status.1.status_1.w,X                                ; $03F74A |\
    AND #(STATUS_1_SWOON | STATUS_1_STONE).b                                    ; $03F74D | | Return true if that character has the swoon or stone statuses.
    BNE @true                                                                   ; $03F74F |/
    LDA r_character_visual_status.1.status_2.w,X                                ; $03F751 |\
    AND #STATUS_2_PARALYZE | STATUS_2_SLEEP | STATUS_2_CHARM | STATUS_2_BERSERK ; $03F754 | | Return true if they have paralyze, sleep, charm or berserk.
    BNE @true                                                                   ; $03F756 |/
    LDX #0.w                                                                    ; $03F758 |\
-   LDA r_monster_slot_to_id_index.w,X                                          ; $03F75B | | Return false if any monster is still alive.
    CMP #$FF.b                                                                  ; $03F75E | |
    BNE @false                                                                  ; $03F760 | |
    INX                                                                         ; $03F762 | |
    CPX #8.w                                                                    ; $03F763 | |
    BNE -                                                                       ; $03F766 |/
    BRA @true                                                                   ; $03F768 | Otherwise, return true.
@false:
    CLC                                                                         ; $03F76A | For false, clear the carry bit.
    RTL                                                                         ; $03F76B
@true
    SEC                                                                         ; $03F76C | For true, set the carry bit.
    RTL                                                                         ; $03F76D

; battle_load_background_palette ($03:F76E)
;
; Loads the palette associated with the current battle background, including
; taking into account the alternate palette bit. The 16 colors are loaded into
; the lower eight colors of the second and third palettes.
battle_load_background_palette:
    LDA r_battle_background.w                                                   ; $03F76E |\
    AND #BATTLE_BACKGROUND_BACKGROUND.b                                         ; $03F771 | | Extract the background number, save it, and put it in the X
    STA <r_battle_generic_tmp_index_lo                                          ; $03F773 | | register.
    TAX                                                                         ; $03F775 |/
    LDA r_battle_background.w                                                   ; $03F776 |\
    AND #BATTLE_BACKGROUND_ALTERNATE_PALETTE.b                                  ; $03F779 | | If the alternate palette bit is set, load the alternate palette
    BEQ +                                                                       ; $03F77B | | from ROM. If there is no configured alternate palette, or the bit
    LDA battle_background_alternate_palette_index_data.l,X                      ; $03F77D | | is not set, simply use the background number instead.
    BNE ++                                                                      ; $03F781 | |
+   CLC                                                                         ; $03F783 | |
    ADC <r_battle_generic_tmp_index_lo                                          ; $03F784 |/
++  LDX #1.w                                                                    ; $03F786 | Initialize the X register to one (the target palette).
    STA <r_battle_load_background_palette_tmp_lo                                ; $03F789 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F78B | | Multiply the determined palette number by 32, to generate an index
    ASL <r_battle_load_background_palette_tmp                                   ; $03F78D | | into actual palette data.
    ASL <r_battle_load_background_palette_tmp                                   ; $03F78F | |
    ASL <r_battle_load_background_palette_tmp                                   ; $03F791 | |
    ASL <r_battle_load_background_palette_tmp                                   ; $03F793 | |
    ASL <r_battle_load_background_palette_tmp                                   ; $03F795 |/
    TXA                                                                         ; $03F797 |\
    ASL A                                                                       ; $03F798 | | Set the Y register to the value in the X register times 32.
    ASL A                                                                       ; $03F799 | |
    ASL A                                                                       ; $03F79A | |
    ASL A                                                                       ; $03F79B | |
    ASL A                                                                       ; $03F79C | |
    TAY                                                                         ; $03F79D | |
    TDC                                                                         ; $03F79E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F79F |/
    LDX <r_battle_load_background_palette_tmp                                   ; $03F7A1 | Set the X register to the palette data index.
    LDA #16.b                                                                   ; $03F7A3 |\ Set the index to copy 16 bytes (8 colors).
    STA <r_battle_generic_tmp_index_lo                                          ; $03F7A5 |/
-   LDA bank0F.battle_background_palette_data.l + 0,X                           ; $03F7A7 |\ Copy the first color of the first palette.
    STA r_battle_cgram_data.1.w,Y                                               ; $03F7AB |/
    LDA bank0F.battle_background_palette_data.l + 16,X                          ; $03F7AE |\ Copy the first color of the second palette.
    STA r_battle_cgram_data.2.w,Y                                               ; $03F7B2 |/
    INX                                                                         ; $03F7B5 |\
    INY                                                                         ; $03F7B6 | | Increment indexes and loop until all colors have been copied.
    DEC <r_battle_generic_tmp_index_lo                                          ; $03F7B7 | |
    BNE -                                                                       ; $03F7B9 |/
    RTL                                                                         ; $03F7BB

; battle_background_alternate_palette_index_data ($03:F7BC)
;
; For battle backgrounds that have an alternate palette available, determines
; the palette to use when the alternate palette is selected.
battle_background_alternate_palette_index_data:
    .db $16                                                                     ; $03F7BC | $00: Grassland
    .db $00                                                                     ; $03F7BD | $01: Forest
    .db $00                                                                     ; $03F7BE | $02: Mountain
    .db $00                                                                     ; $03F7BF | $03: Town/Castle
    .db $11                                                                     ; $03F7C0 | $04: Waterway (ground)
    .db $00                                                                     ; $03F7C1 | $05: Moon
    .db $00                                                                     ; $03F7C2 | $06: Ship
    .db $12                                                                     ; $03F7C3 | $07: Waterway (water)
    .db $14                                                                     ; $03F7C4 | $08: Cavern
    .db $00                                                                     ; $03F7C5 | $09: Desert
    .db $00                                                                     ; $03F7C6 | $0A: Beach
    .db $13                                                                     ; $03F7C7 | $0B: Magical Cave
    .db $15                                                                     ; $03F7C8 | $0C: Tower
    .db $00                                                                     ; $03F7C9 | $0D: Lunar Subterrane
    .db $00                                                                     ; $03F7CA | $0E: Lunar Core
    .db $00                                                                     ; $03F7CB | $0F: Underworld
    .db $00                                                                     ; $03F7CC | $10: Zeromus

; battle_increment_game_time ($03:F7CD)
;
; Increments the in-game timer.
battle_increment_game_time:
    INC r_game_time.frames.w                                                    ; $03F7CD | Increment the frames.
    LDA r_game_time.frames.w                                                    ; $03F7D0 |\
    CMP #60.b                                                                   ; $03F7D3 | | If the frames reaches 60, set it to zero and increment the low
    BCC +                                                                       ; $03F7D5 | | byte of the seconds.
    STZ r_game_time.frames.w                                                    ; $03F7D7 | |
    INC r_game_time.seconds_lo.w                                                ; $03F7DA |/
    BNE +                                                                       ; $03F7DD |\ If the low byte of seconds rolls over to zero, increment the
    INC r_game_time.seconds_md.w                                                ; $03F7DF |/ middle byte of the seconds.
    BNE +                                                                       ; $03F7E2 |\ If the middle byte of the seconds rolls over to zero, increment the
    INC r_game_time.seconds_hi.w                                                ; $03F7E4 |/ high byte of the seconds.
+   RTL                                                                         ; $03F7E7

; battle_alternate_party_sprite_get_next_tile ($03:F7E8)
;
; Returns the next tile while reading an alternate party sprite. The actual data
; is very simple. A value of $FF indicates a blank tile. A value of $FE followed
; by a number indicates that number of blank tiles. Any other value directly
; encodes a tile number.
;
; Returns the current tile number in the accumulator. Sets the carry flag if the
; tile is non-blank, otherwise the carry flag is cleared.
;
; TODO: None of the Call sprites actually use the $FE value. Is this simply
;       overengineering on the developers' parts or is it used by something
;       other than the alternate party sprite code?
battle_alternate_party_sprite_get_next_tile:
    LDA <r_battle_alternate_party_sprite_next_arg_blanks                        ; $03F7E8 |\ If there are no configured blanks, branch ahead to the next part
    BEQ +                                                                       ; $03F7EA |/ of the decoder.
    DEC <r_battle_alternate_party_sprite_next_arg_blanks                        ; $03F7EC | Decrement the blanks count.
    LDA #%00110001.b                                                            ; $03F7EE |\ Set the tile flags to use priority 3, palette 0, and the high name
    STA <r_battle_alternate_party_sprite_next_result_flags                      ; $03F7F0 |/ table.
    LDA #$FF.b                                                                  ; $03F7F2 |\
    CLC                                                                         ; $03F7F4 | | Load a tile number of $FF, clear the carry flag, and return.
    RTL                                                                         ; $03F7F5 |/
+   LDA [<r_battle_effect_spell_frame_data_ptr]                                 ; $03F7F6 | Read the next byte.
    CMP #$FE.b                                                                  ; $03F7F8 |\
    BEQ +                                                                       ; $03F7FA | | If the value is either $FE or $FF, branch to the appropriate code.
    CMP #$FF.b                                                                  ; $03F7FC | |
    BEQ ++                                                                      ; $03F7FE |/
    LDX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F800 |\
    INX                                                                         ; $03F802 | | Increment the pointer to move to the next byte.
    STX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F803 |/
    PHA                                                                         ; $03F805 |\
    LDA r_battle_alternate_party_sprite_tile_flags.w                            ; $03F806 | | Set the tile flags to the passed tile flags.
    STA <r_battle_alternate_party_sprite_next_result_flags                      ; $03F809 | |
    PLA                                                                         ; $03F80B |/
    SEC                                                                         ; $03F80C |\ Set the carry flag to indicate a tile is being returned and return.
    RTL                                                                         ; $03F80D |/
+   LDX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F80E |\
    INX                                                                         ; $03F810 | | If the read byte was $FE, increment the pointer, read the next
    STX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F811 | | byte, and use that value as the number of blanks to return. The
    LDA [<r_battle_effect_spell_frame_data_ptr]                                 ; $03F813 | | first blank will be returned by falling through here, and the
    DEC A                                                                       ; $03F815 | | remainder will be returned on subsequent calls.
    STA <r_battle_alternate_party_sprite_next_arg_blanks                        ; $03F816 |/
++  LDA #%00110001.b                                                            ; $03F818 |\ Set the tile flags to use priority 3, palette 0, and the high name
    STA <r_battle_alternate_party_sprite_next_result_flags                      ; $03F81A |/ table.
    LDA #$FF.b                                                                  ; $03F81C | Load a tile value of $FF into the accumulator.
    LDX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F81E |\
    INX                                                                         ; $03F820 | | Increment the frame data pointer.
    STX <r_battle_effect_spell_frame_data_ptr_addr                              ; $03F821 |/
    CLC                                                                         ; $03F823 | Clear the carry flag to signal no tile was returned.
    RTL                                                                         ; $03F824

; battle_fade_sprites_from_white ($03:F825)
;
; Configures the battle flash to fade to the sprites from white.
battle_fade_sprites_from_white:
    LDA #%01000000.b                                                            ; $03F825 |\ Set color math to half mode, but disabled on all backgrounds.
    JSR _battle_set_cgadsub                                                     ; $03F827 |/
    LDA #31.b                                                                   ; $03F82A |\
    STA r_battle_flash_blue_intensity.w                                         ; $03F82C | | Set the intensity of all colors to maximum.
    STA r_battle_flash_red_intensity.w                                          ; $03F82F | |
    STA r_battle_flash_green_intensity.w                                        ; $03F832 |/
    LDA #%11100000.b                                                            ; $03F835 |\ Enable all three flash colors.
    STA r_battle_flash_color.w                                                  ; $03F837 |/
    LDA #%00010000.b                                                            ; $03F83A |\ Set the flash to operate on sprites.
    STA r_battle_flash_parameters.w                                             ; $03F83C |/
    LDA #BATTLE_FLASH_MODE_FADE_OUT.b                                           ; $03F83F |\ Set the flash mode to fade out.
    STA r_battle_flash_mode.w                                                   ; $03F841 |/
    RTL                                                                         ; $03F844

; battle_effect_chime_and_flash ($03:F845)
;
; Animates a battle effect which plays a chime sound effect and flashes the
; screen.
battle_effect_chime_and_flash:
    LDA #AUDIO_EFFECT_CHIME.b                                                   ; $03F845 |\ Play a chime sound effect.
    JSL bank02.battle_play_sound_effect                                         ; $03F847 |/
    JSL bank01.set_battle_flash_continuous_red                                  ; $03F84B |\ Set the flash to continuous red and wait eight frames.
    JSR _battle_wait_8_frames                                                   ; $03F84F |/
    JSL bank01.set_battle_flash_continuous_yellow                               ; $03F852 |\ Set the flash to continuous yellow and wait eight frames.
    JSR _battle_wait_8_frames                                                   ; $03F856 |/
    JSL bank01.set_battle_flash_continuous_white                                ; $03F859 |\ Set the flash to continuous white and wait eight frames.
    JSR _battle_wait_8_frames                                                   ; $03F85D |/
    STZ r_battle_flash_mode.w                                                   ; $03F860 | Disable the flash.
    RTL                                                                         ; $03F863

; _battle_wait_8_frames ($03:F864)
;
; Waits eight frames by setting the X register and falling through to the next
; function.
_battle_wait_8_frames:
    LDX #8.w                                                                    ; $03F864 | Load 8 into the X register, then fall through to the next function.

; _battle_wait_x_frames ($03:F867)
;
; In battle, waits for the number of frames specified in the X register.
_battle_wait_x_frames:
-   JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F867 | Wait for the next frame, handling any critical updates.
    DEX                                                                         ; $03F86B |\ Loop until the X register is zero.
    BNE -                                                                       ; $03F86C |/
    RTS                                                                         ; $03F86E

; battle_animate_big_bang ($03:F86F)
;
; Animates the Big Bang spell effect.
battle_animate_big_bang:
    JSR _battle_zeromus_background_enable_reverse                               ; $03F86F | Switch the background to high-speed reverse.
    LDX #$80B0.w                                                                ; $03F872 |\ Set OAM entry 88 to have the highest priority (the first entry
    STX r_battle_oam_priority.w                                                 ; $03F875 |/ beyond the spell effect range).
    INC r_unknown_f28b.w                                                        ; $03F878 | TODO: Increment an unknown variable.
    TDC                                                                         ; $03F87B |\ Animate the standard fixed sprite effect using the associated
    JSL bank02.battle_effect_spell_animate_internal                             ; $03F87C |/ script.
    JSL bank02.battle_reset_effect_oam_large                                    ; $03F880 | Reset the effect OAM to large sprites.
    TDC                                                                         ; $03F884 |\
    TAX                                                                         ; $03F885 | | Reset the OAM priority to normal.
    STX r_battle_oam_priority.w                                                 ; $03F886 |/
    INC r_unknown_f28b.w                                                        ; $03F889 | TODO: Increment an unknown variable.
    LDX #4.w                                                                    ; $03F88C | Initialize the X register to four.
-   PHX                                                                         ; $03F88F |\
    JSL bank01.set_battle_flash_continuous_green                                ; $03F890 | | Loop four times through a sequence of shifting the battle flash
    JSR _battle_wait_8_frames                                                   ; $03F894 | | through the following sequence: green, red, yellow, blue and
    JSL bank01.set_battle_flash_continuous_red                                  ; $03F897 | | white, waiting eight frames in between each change.
    JSR _battle_wait_8_frames                                                   ; $03F89B | |
    JSL bank01.set_battle_flash_continuous_yellow                               ; $03F89E | |
    JSR _battle_wait_8_frames                                                   ; $03F8A2 | |
    JSL bank01.set_battle_flash_continuous_blue                                 ; $03F8A5 | |
    JSR _battle_wait_8_frames                                                   ; $03F8A9 | |
    JSL bank01.set_battle_flash_continuous_white                                ; $03F8AC | |
    JSR _battle_wait_8_frames                                                   ; $03F8B0 | |
    PLX                                                                         ; $03F8B3 | |
    DEX                                                                         ; $03F8B4 | |
    BNE -                                                                       ; $03F8B5 |/
    STZ r_battle_flash_mode.w                                                   ; $03F8B7 | Disable the battle flash.
    JSR _battle_zeromus_background_disable_reverse                              ; $03F8BA | Switch the background back to normal mode.
    RTL                                                                         ; $03F8BD

; _battle_zeromus_background_enable_reverse ($03:F8BE)
;
; Adjusts the delta values to switch the Zeromus background to reverse mode for
; use during Big Bang. The speed is additionally three times as fast.
_battle_zeromus_background_enable_reverse:
--  JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F8BE | Wait for the next frame.
    STZ <r_battle_generic_tmp_index_lo                                          ; $03F8C2 | Initialize the count of incomplete rows to zero.
    LDX #0.w                                                                    ; $03F8C4 | Initialize the current row to zero.
-   LDA r_battle_zeromus_background_scroll_delta.w,X                            ; $03F8C7 |\
    CMP zeromus_background_scroll_delta_big_bang_data.l,X                       ; $03F8CA | | If the current row's current delta does not match the target
    BEQ +                                                                       ; $03F8CE | | delta, decrement the delta and increment the incomplete count.
    DEC r_battle_zeromus_background_scroll_delta.w,X                            ; $03F8D0 | |
    INC <r_battle_generic_tmp_index_lo                                          ; $03F8D3 |/
+   INX                                                                         ; $03F8D5 |\
    CPX #_sizeof_r_battle_zeromus_background_scroll_delta.w                     ; $03F8D6 | | Loop until all 18 rows have been checked.
    BNE -                                                                       ; $03F8D9 |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $03F8DB |\ Repeat the overall loop until all rows have reached their target.
    BNE --                                                                      ; $03F8DD |/
    RTS                                                                         ; $03F8DF

; _battle_zeromus_background_disable_reverse ($03:F8E0)
;
; Adjusts the delta values to switch the Zeromus background to normal mode for
; use outside of Big Bang.
_battle_zeromus_background_disable_reverse:
--  JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F8E0 | Wait for the next frame.
    STZ <r_battle_generic_tmp_index_lo                                          ; $03F8E4 | Initialize the count of incomplete rows to zero.
    LDX #0.w                                                                    ; $03F8E6 | Initialize the current row to zero.
-   LDA r_battle_zeromus_background_scroll_delta.w,X                            ; $03F8E9 |\
    CMP zeromus_background_scroll_delta_normal_data.l,X                         ; $03F8EC | | If the current row's current delta does not match the target
    BEQ +                                                                       ; $03F8F0 | | delta, increment the delta and increment the incomplete count.
    INC r_battle_zeromus_background_scroll_delta.w,X                            ; $03F8F2 | |
    INC <r_battle_generic_tmp_index_lo                                          ; $03F8F5 |/
+   INX                                                                         ; $03F8F7 |\
    CPX #_sizeof_r_battle_zeromus_background_scroll_delta.w                     ; $03F8F8 | | Loop until all 18 rows have been checked.
    BNE -                                                                       ; $03F8FB |/
    LDA <r_battle_generic_tmp_index_lo                                          ; $03F8FD |\ Repeat the overall loop until all rows have reached their target.
    BNE --                                                                      ; $03F8FF |/
    RTS                                                                         ; $03F901

; battle_update_zeromus_background_scroll ($03:F902)
;
; This function updates the HDMA tables in memory which control the scrolling of
; the Zeromus battle background, based on the current delta values stored in the
; array at $F488. If $F4A9 is non-zero or the current battle background is not
; the Zeromus battle background, the function returns without doing anything.
battle_update_zeromus_background_scroll:
    PHX                                                                         ; $03F902 |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $03F903 |/
    LDA r_disable_zeromus_background_scroll.w                                   ; $03F904 |\ If the background scrolling effect has been disabled, skip this
    BNE @done                                                                   ; $03F907 |/ function. TODO: Does the value have a different meaning?
    LDA r_battle_background.w                                                   ; $03F909 |\
    CMP #BATTLE_BACKGROUND_ZEROMUS.b                                            ; $03F90C | | Skip this function if the battle background isn't Zeromus.
    BNE @done                                                                   ; $03F90E |/
    TDC                                                                         ; $03F910 |\ Initialize the X register to zero.
    TAX                                                                         ; $03F911 |/
--  LDA zeromus_background_scroll_hdma_count_data.l,X                           ; $03F912 |\
    TAY                                                                         ; $03F916 | | Load the number of entries to modify with the next value.
    STY <r_battle_update_zeromus_background_scroll_count                        ; $03F917 |/
    STZ <r_battle_update_zeromus_background_scroll_value_hi                     ; $03F919 |\
    LDA r_battle_zeromus_background_scroll_delta.w,X                            ; $03F91B | | Load the value to add to the scroll value, and extend it to 16
    STA <r_battle_update_zeromus_background_scroll_value_lo                     ; $03F91E | | bits by setting the high byte to zero if the uppermost bit is
    BPL +                                                                       ; $03F920 | | unset and to $FF if it is.
    DEC <r_battle_update_zeromus_background_scroll_value_hi                     ; $03F922 |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $03F924 |\
    TXA                                                                         ; $03F926 | | Set the Y register to the current index times 32. (Each group of
    ASL A                                                                       ; $03F927 | | entries is eight entries with four bytes each.)
    ASL A                                                                       ; $03F928 | |
    ASL A                                                                       ; $03F929 | | NOTE: It's interesting that this seems to hard code the number of
    ASL A                                                                       ; $03F92A | |       entries per group to eight, making the table of counts seem
    ASL A                                                                       ; $03F92B | |       pointless except to make the last group only four entries.
    TAY                                                                         ; $03F92C |/
    LDA r_battle_bg2_hdma_data.1.horizontal.w,Y                                 ; $03F92D |\
    CLC                                                                         ; $03F930 | | Load the existing scroll value, add the delta, and then store it
    ADC <r_battle_update_zeromus_background_scroll_value                        ; $03F931 | | back to memory.
-   STA r_battle_bg2_hdma_data.1.horizontal.w,Y                                 ; $03F933 |/
    INY                                                                         ; $03F936 |\
    INY                                                                         ; $03F937 | | Increment the Y register by four to move to the next entry.
    INY                                                                         ; $03F938 | |
    INY                                                                         ; $03F939 |/
    DEC <r_battle_update_zeromus_background_scroll_count                        ; $03F93A |\ Loop until the entire set of entries has been updated.
    BNE -                                                                       ; $03F93C |/
    TDC                                                                         ; $03F93E |\
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F93F | | Increment the group index and loop until all 18 groups have been
    INX                                                                         ; $03F941 | | processed.
    CPX #_sizeof_r_battle_zeromus_background_scroll_delta.w                     ; $03F942 | |
    BNE --                                                                      ; $03F945 |/
@done:
    PLY                                                                         ; $03F947 |\ Restore the values of the X and Y registers.
    PLX                                                                         ; $03F948 |/
    RTL                                                                         ; $03F949

; zeromus_background_scroll_delta_normal_data ($03:F94A)
;
; The values added to the horizontal scroll value in the HDMA table for each set
; of entries when the Zeromus background is moving normally.
zeromus_background_scroll_delta_normal_data:
    .db   5                                                                     ; $03F94A
    .db   4                                                                     ; $03F94B
    .db   3                                                                     ; $03F94C
    .db   2                                                                     ; $03F94D
    .db   1                                                                     ; $03F94E
    .db   0                                                                     ; $03F94F
    .db   1                                                                     ; $03F950
    .db   2                                                                     ; $03F951
    .db   3                                                                     ; $03F952
    .db   4                                                                     ; $03F953
    .db   5                                                                     ; $03F954
    .db   6                                                                     ; $03F955
    .db   7                                                                     ; $03F956
    .db   8                                                                     ; $03F957
    .db   9                                                                     ; $03F958
    .db  10                                                                     ; $03F959
    .db  11                                                                     ; $03F95A
    .db  12                                                                     ; $03F95B

; zeromus_background_scroll_delta_big_bang_data ($03:F95C)
;
; The values added to the horizontal scroll value in the HDMA table for each set
; of entries when the Zeromus background is moving during the Big Bang spell.
zeromus_background_scroll_delta_big_bang_data:
    .db -15                                                                     ; $03F95C
    .db -12                                                                     ; $03F95D
    .db  -9                                                                     ; $03F95E
    .db  -6                                                                     ; $03F95F
    .db  -3                                                                     ; $03F960
    .db   0                                                                     ; $03F961
    .db  -3                                                                     ; $03F962
    .db  -6                                                                     ; $03F963
    .db  -9                                                                     ; $03F964
    .db -12                                                                     ; $03F965
    .db -15                                                                     ; $03F966
    .db -18                                                                     ; $03F967
    .db -21                                                                     ; $03F968
    .db -24                                                                     ; $03F969
    .db -27                                                                     ; $03F96A
    .db -30                                                                     ; $03F96B
    .db -33                                                                     ; $03F96C
    .db -36                                                                     ; $03F96D

; zeromus_background_scroll_hdma_count_data ($03:F96E)
;
; Provides the number of HDMA entries to modify using each of the 18 values that
; are added to each entry in the HDMA table.
zeromus_background_scroll_hdma_count_data:
    .db $08                                                                     ; $03F96E | $00
    .db $08                                                                     ; $03F96F | $01
    .db $08                                                                     ; $03F970 | $02
    .db $08                                                                     ; $03F971 | $03
    .db $08                                                                     ; $03F972 | $04
    .db $08                                                                     ; $03F973 | $05
    .db $08                                                                     ; $03F974 | $06
    .db $08                                                                     ; $03F975 | $07
    .db $08                                                                     ; $03F976 | $08
    .db $08                                                                     ; $03F977 | $09
    .db $08                                                                     ; $03F978 | $0A
    .db $08                                                                     ; $03F979 | $0B
    .db $08                                                                     ; $03F97A | $0C
    .db $08                                                                     ; $03F97B | $0D
    .db $08                                                                     ; $03F97C | $0E
    .db $08                                                                     ; $03F97D | $0F
    .db $08                                                                     ; $03F97E | $10
    .db $04                                                                     ; $03F97F | $11

; battle_animate_monster_horizontal_shake ($03:F980)
;
; Animates a horizontal shaking effect on the monsters by adjusting the BG1
; scroll values. The effect lasts for 64 frames.
battle_animate_monster_horizontal_shake:
    STZ <r_battle_monster_effect_counter                                        ; $03F980 | Initialize the effect counter to zero.
    TDC                                                                         ; $03F982 |\
    TAX                                                                         ; $03F983 | | Set the vertical and horizontal BG1 scroll offsets to zero.
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F984 | |
    STX r_battle_set_bg1_scroll_arg_vertical.w                                  ; $03F987 |/
-   JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F98A | Wait for the next frame.
    JSL bank01.battle_set_bg1_scroll                                            ; $03F98E | Set the BG1 scroll values.
    LDA <r_battle_monster_effect_counter                                        ; $03F992 |\
    AND #%00000111.b                                                            ; $03F994 | | Determine the offset into the scroll table by taking the counter
    ASL A                                                                       ; $03F996 | | mod 8 and multiplying by two.
    TAX                                                                         ; $03F997 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03F998 |\
    LDA bank13.monster_shake_scroll_data.l,X                                    ; $03F99A | | Set the horizontal scroll value for this frame.
    STA r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F99E | |
    TDC                                                                         ; $03F9A1 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03F9A2 |/
    INC <r_battle_monster_effect_counter                                        ; $03F9A4 |\
    LDA <r_battle_monster_effect_counter                                        ; $03F9A6 | | Increment the effect counter and loop until 64 frames have been
    CMP #64.b                                                                   ; $03F9A8 | | rendered.
    BNE -                                                                       ; $03F9AA |/
    TDC                                                                         ; $03F9AC |\
    TAX                                                                         ; $03F9AD | | Set the scroll value back to zero.
    STX r_battle_set_bg1_scroll_arg_horizontal.w                                ; $03F9AE | |
    JSL bank01.battle_set_bg1_scroll                                            ; $03F9B1 |/
    RTL                                                                         ; $03F9B5

; _battle_get_next_rng ($03:F9B6)
;
; Increments the battle RNG index and returns the next value. Also preserves the
; value of the X register.
_battle_get_next_rng:
    PHX                                                                         ; $03F9B6 | Preserve the value of the X register.
    INC <r_battle_rng_index                                                     ; $03F9B7 | Increment the battle RNG index.
    LDA <r_battle_rng_index                                                     ; $03F9B9 |\
    TAX                                                                         ; $03F9BB | | Load the next RNG value.
    LDA r_prng_data.w,X                                                         ; $03F9BC |/
    PLX                                                                         ; $03F9BF | Restore the value of the X register.
    RTS                                                                         ; $03F9C0

; battle_animate_bahamut_sprites ($03:F9C1)
;
; Animates the sprites used in the Bahamut spell effect.
battle_animate_bahamut_sprites:
    LDA #32.b                                                                   ; $03F9C1 |\ Initialize the counter to 32.
    STA r_battle_effect_bahamut_counter.w                                       ; $03F9C3 |/
    TDC                                                                         ; $03F9C6 |\
    TAX                                                                         ; $03F9C7 | | Initialize the coordinates for the sprites to appropriate random
-   JSR _battle_effect_bahamut_initialize_coordinates                           ; $03F9C8 | | values.
    CPX #_sizeof_r_battle_effect_bahamut_coordinates.w                          ; $03F9CB | |
    BNE -                                                                       ; $03F9CE |/
    TDC                                                                         ; $03F9D0 |\
    TAX                                                                         ; $03F9D1 | | Initialize the frame index for each of the eight sprites to $FF.
    DEC A                                                                       ; $03F9D2 | |
-   STA r_battle_effect_bahamut_frame_index.w,X                                 ; $03F9D3 | |
    INX                                                                         ; $03F9D6 | |
    CPX #_sizeof_r_battle_effect_bahamut_frame_index.w                          ; $03F9D7 | |
    BNE -                                                                       ; $03F9DA |/
    STZ r_battle_effect_bahamut_frame_index.w                                   ; $03F9DC | Set the frame index for the first sprite to zero.
    JSL bank01.set_battle_flash_continuous_red                                  ; $03F9DF |\
    LDA #BATTLE_FLASH_MODE_PULSE.b                                              ; $03F9E3 | | Set the battle flash to pulse red.
    STA r_battle_flash_mode.w                                                   ; $03F9E5 |/
@start:
    LDX #4.w                                                                    ; $03F9E8 |\
-   JSL bank02.battle_wait_next_frame_preserve_x_y                              ; $03F9EB | | Wait for four frames.
    DEX                                                                         ; $03F9EF | |
    BNE -                                                                       ; $03F9F0 |/
    INC r_battle_disable_oam_update.w                                           ; $03F9F2 | Disable OAM updates.
    JSR _battle_effect_bahamut_update_oam                                       ; $03F9F5 | Update the OAM entries for the effect.
    STZ r_battle_disable_oam_update.w                                           ; $03F9F8 | Re-enable OAM updates.
    LDX #15 + 7.w                                                               ; $03F9FB |\
-   LDA r_battle_effect_bahamut_frame_index.w - 16,X                            ; $03F9FE | | Copy the frame index for each sprite to the next sprite in reverse
    STA r_battle_effect_bahamut_frame_index.w - 15,X                            ; $03FA01 | | order, in order to advance the frame index for each sprite.
    DEX                                                                         ; $03FA04 | |
    CPX #15.w                                                                   ; $03FA05 | | NOTE: The way they handled the index here is really weird.
    BNE -                                                                       ; $03FA08 |/
    LDA r_battle_effect_bahamut_frame_index.w                                   ; $03FA0A |\
    INC A                                                                       ; $03FA0D | | Add one to the frame index for the first sprite and then take the
    AND #%00000111.b                                                            ; $03FA0E | | result mod 8, to ensure it remains from 0 to 7.
    STA r_battle_effect_bahamut_frame_index.w                                   ; $03FA10 |/
    TDC                                                                         ; $03FA13 |\ Initialize the X register to zero.
    TAX                                                                         ; $03FA14 |/
-   LDA r_battle_effect_bahamut_frame_index.w,X                                 ; $03FA15 |\
    BNE +                                                                       ; $03FA18 | | If the new frame index is equal to zero, give the sprite a new set
    PHX                                                                         ; $03FA1A | | of random coordinates.
    TXA                                                                         ; $03FA1B | |
    ASL A                                                                       ; $03FA1C | | NOTE: The way this is done means that the random coordinates
    TAX                                                                         ; $03FA1D | |       generated for all but the first sprite earlier in the
    JSR _battle_effect_bahamut_initialize_coordinates                           ; $03FA1E | |       function will be completely discarded without being used.
    PLX                                                                         ; $03FA21 |/
+   INX                                                                         ; $03FA22 |\
    CPX #_sizeof_r_battle_effect_bahamut_frame_index.w                          ; $03FA23 | | Loop through all eight sprites.
    BNE -                                                                       ; $03FA26 |/
    DEC r_battle_effect_bahamut_counter.w                                       ; $03FA28 |\ Decrement the counter and loop until it reaches zero.
    BNE @start                                                                  ; $03FA2B |/
    STZ r_battle_flash_mode.w                                                   ; $03FA2D | Disable the battle flashing effect.
    RTL                                                                         ; $03FA30

; _battle_effect_bahamut_initialize_coordinates ($03:FA31)
;
; Given the index to a set of coordinates in the X register (relative to the
; array at $F398), sets the X and Y coordinate to appropriate random values.
_battle_effect_bahamut_initialize_coordinates:
    JSR _battle_get_next_rng                                                    ; $03FA31 |\
    AND #%01111111.b                                                            ; $03FA34 | | Initialize the X coordinate to a random value from 0 to 127.
    CLC                                                                         ; $03FA36 | |
    STA r_battle_effect_bahamut_coordinates.w,X                                 ; $03FA37 | |
    INX                                                                         ; $03FA3A |/
    JSR _battle_get_next_rng                                                    ; $03FA3B |\
    AND #%00111111.b                                                            ; $03FA3E | | Initialize the Y coordinate to a random value from 32 to 95.
    CLC                                                                         ; $03FA40 | |
    ADC #32.b                                                                   ; $03FA41 | |
    STA r_battle_effect_bahamut_coordinates.w,X                                 ; $03FA43 | |
    INX                                                                         ; $03FA46 |/
    RTS                                                                         ; $03FA47

; _battle_effect_bahamut_update_oam ($03:FA48)
;
; Updates the OAM entries for the sprites used in the Bahamut spell.
_battle_effect_bahamut_update_oam:
    TDC                                                                         ; $03FA48 |\
    TAX                                                                         ; $03FA49 | | Initialize the X and Y registers to zero.
    TAY                                                                         ; $03FA4A |/
@outer_start:
    LDA r_battle_effect_bahamut_frame_index.w,X                                 ; $03FA4B |\
    CMP #$FF.b                                                                  ; $03FA4E | | Skip this sprite if its frame index is still $FF.
    BEQ @next                                                                   ; $03FA50 |/
    ASL A                                                                       ; $03FA52 |\
    PHX                                                                         ; $03FA53 | | Load the pointer to the data for the frame referenced by the frame
    TAX                                                                         ; $03FA54 | | index.
    LDA bank13.battle_effect_call_bahamut_oam_pointer_data.l + 0,X              ; $03FA55 | |
    STA <r_battle_generic_tmp_ptr_2_addr_lo                                     ; $03FA59 | |
    LDA bank13.battle_effect_call_bahamut_oam_pointer_data.l + 1,X              ; $03FA5B | |
    STA <r_battle_generic_tmp_ptr_2_addr_hi                                     ; $03FA5F | |
    LDA #:bank13.battle_effect_call_bahamut_oam_pointer_data.b                  ; $03FA61 | |
    STA <r_battle_generic_tmp_ptr_2_bank                                        ; $03FA63 | |
    PLX                                                                         ; $03FA65 |/
    PHX                                                                         ; $03FA66 | Preserve the value of the X register (the current sprite index).
    TXA                                                                         ; $03FA67 |\
    ASL A                                                                       ; $03FA68 | | Transfer the coordinates for this sprite to temporary variables.
    TAX                                                                         ; $03FA69 | |
    LDA r_battle_effect_bahamut_coordinates.1.x.w,X                             ; $03FA6A | |
    STA <r_battle_generic_tmp_index_3_lo                                        ; $03FA6D | |
    LDA r_battle_effect_bahamut_coordinates.1.y.w,X                             ; $03FA6F | |
    STA <r_battle_generic_tmp_index_3_hi                                        ; $03FA72 |/
@inner_start:
    LDA [<r_battle_generic_tmp_ptr_2]                                           ; $03FA74 |\
    CMP #$FF.b                                                                  ; $03FA76 | | If the next byte is $FF, branch to work on the next sprite.
    BEQ @inner_done                                                             ; $03FA78 |/
    CLC                                                                         ; $03FA7A |\
    ADC <r_battle_generic_tmp_index_3_lo                                        ; $03FA7B | | Otherwise, add the base X coordinate for this sprite.
    PHA                                                                         ; $03FA7D |/
    LDA r_formation_back_attack_copy.w                                          ; $03FA7E |\
    BEQ +                                                                       ; $03FA81 | | If it's a back attack, flip the bits on the coordinate to mirror
    PLA                                                                         ; $03FA83 | | them to the other side.
    EOR #%11111111.b                                                            ; $03FA84 | |
    PHA                                                                         ; $03FA86 |/
+   PLA                                                                         ; $03FA87 |\ Either way, set the calculated value as the X coordinate for the
    STA r_oam.17.x.w,Y                                                          ; $03FA88 |/ sprite.
    JSR _battle_increment_generic_tmp_ptr_2_addr                                ; $03FA8B |\
    LDA [<r_battle_generic_tmp_ptr_2]                                           ; $03FA8E | | Read the next byte, add the base Y coordinate for this sprite and
    CLC                                                                         ; $03FA90 | | set that as the Y coordinate for the sprite.
    ADC <r_battle_generic_tmp_index_3_hi                                        ; $03FA91 | |
    STA r_oam.17.y.w,Y                                                          ; $03FA93 |/
    JSR _battle_increment_generic_tmp_ptr_2_addr                                ; $03FA96 |\
    LDA [<r_battle_generic_tmp_ptr_2]                                           ; $03FA99 | | Read the next byte and use that as the tile number.
    STA r_oam.17.tile.w,Y                                                       ; $03FA9B |/
    JSR _battle_increment_generic_tmp_ptr_2_addr                                ; $03FA9E |\
    LDA [<r_battle_generic_tmp_ptr_2]                                           ; $03FAA1 | | Read the next byte, using it as the tile flags, toggling the
    PHA                                                                         ; $03FAA3 | | horizontal flip bit if this is a back attack.
    LDA r_formation_back_attack_copy.w                                          ; $03FAA4 | |
    BEQ +                                                                       ; $03FAA7 | |
    PLA                                                                         ; $03FAA9 | |
    EOR #%01000000.b                                                            ; $03FAAA | |
    PHA                                                                         ; $03FAAC | |
+   PLA                                                                         ; $03FAAD | |
    STA r_oam.17.flags.w,Y                                                      ; $03FAAE |/
    INY                                                                         ; $03FAB1 |\
    INY                                                                         ; $03FAB2 | | Increment the Y register by four to move to the next OAM entry.
    INY                                                                         ; $03FAB3 | |
    INY                                                                         ; $03FAB4 |/
    JSR _battle_increment_generic_tmp_ptr_2_addr                                ; $03FAB5 | Increment the pointer address to the next tile.
    BRA @inner_start                                                            ; $03FAB8 | Branch to read the next tile for this sprite.
@inner_done:
    PLX                                                                         ; $03FABA | Restore the sprite number to the X register.
@next:
    INX                                                                         ; $03FABB |\
    CPX #_sizeof_r_battle_effect_bahamut_frame_index.w                          ; $03FABC | | Increment the X register and loop until all sprites are done.
    BNE @outer_start                                                            ; $03FABF |/
    RTS                                                                         ; $03FAC1

; _battle_increment_generic_tmp_ptr_2_addr ($03:FAC2)
;
; Increments the 16-bit value in $00 by one. This address is often used for a
; pointer in the battle code.
_battle_increment_generic_tmp_ptr_2_addr:
    LDX <r_battle_generic_tmp_ptr_2_addr                                        ; $03FAC2 |\
    INX                                                                         ; $03FAC4 | | Increment the pointer by one.
    STX <r_battle_generic_tmp_ptr_2_addr                                        ; $03FAC5 |/
    RTS                                                                         ; $03FAC7

; battle_update_monster_dissolve ($03:FAC8)
;
; This strange function checks the value of $38E6 and then regardless of the
; value, calls _battle_update_monster_dissolve. It's possible that in earlier
; iterations of the game, different functions were called for different values.
;
; More practically, it serves as an unusual proxy to call the local function
; from another bank.
battle_update_monster_dissolve:
    LDA r_battle_monster_special_transition.w                                   ; $03FAC8 |\
    BNE +                                                                       ; $03FACB | | If $38E6 is equal to zero, call the function.
    JSR _battle_update_monster_dissolve                                         ; $03FACD | |
    RTL                                                                         ; $03FAD0 |/
+   CMP #BATTLE_MONSTER_TRANSITION_ALERT.b                                      ; $03FAD1 |\
    BNE +                                                                       ; $03FAD3 | | If the value is one, also call the same function.
    JSR _battle_update_monster_dissolve                                         ; $03FAD5 | |
    RTL                                                                         ; $03FAD8 |/
+   CMP #BATTLE_MONSTER_TRANSITION_LIFE.b                                       ; $03FAD9 |\
    BNE +                                                                       ; $03FADB | | If the value is two, also call the same function.
    JSR _battle_update_monster_dissolve                                         ; $03FADD | |
    RTL                                                                         ; $03FAE0 |/
+   JSR _battle_update_monster_dissolve                                         ; $03FAE1 |\ Finally, if the value is any other value, call the same function.
    RTL                                                                         ; $03FAE4 |/

; _battle_update_monster_dissolve ($03:FAE5)
;
; Based on the value in $004E, which acts roughly as a progress counter ranging
; from $00 to $2F (though higher values will simply read further into ROM),
; updates the high bits in the HDMA table of BG1 to cause some lines to be
; drawn from the theoretically empty left half or the right half (which contains
; the monster sprite in the blue palette).
;
; NOTE: The data in ROM is used in a strange way, with only one bit of each
;       word being used. This may, in fact, be a bug, though it's hard to tell,
;       and even if it is, the way it is used ends up producing much the same
;       effect.
_battle_update_monster_dissolve:
    TDC                                                                         ; $03FAE5 |\ Initialize the Y register to zero.
    TAY                                                                         ; $03FAE6 |/
    LDA <r_battle_monster_effect_counter                                        ; $03FAE7 |\
    ASL A                                                                       ; $03FAE9 | | Initialize the X register to the effect counter times two.
    TAX                                                                         ; $03FAEA |/
-   LDA bank13.battle_monster_dissolve_data.l + 0,X                             ; $03FAEB |\
    STA <r_battle_generic_tmp_index_hi                                          ; $03FAEF | | Load the next value from ROM and save it to RAM, noting that the
    LDA bank13.battle_monster_dissolve_data.l + 1,X                             ; $03FAF1 | | high and low bytes have been swapped.
    STA <r_battle_generic_tmp_index_lo                                          ; $03FAF5 |/
    INX                                                                         ; $03FAF7 |\ Increment the X register to move to the next value.
    INX                                                                         ; $03FAF8 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03FAF9 |\
    ASL <r_battle_generic_tmp_index                                             ; $03FAFB | | Extract the uppermost bit into another variable.
    ROL <r_battle_generic_tmp_index_2                                           ; $03FAFD | |
    TDC                                                                         ; $03FAFF | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03FB00 |/
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $03FB02 |\
    AND #%00000001.b                                                            ; $03FB04 | | Mask out all but that single bit and flip it.
    EOR #%00000001.b                                                            ; $03FB06 |/
    STA r_battle_bg1_hdma_data.1.horizontal_hi.w,Y                              ; $03FB08 |\
    STA r_battle_bg1_hdma_data.33.horizontal_hi.w,Y                             ; $03FB0B | | Write the bit to various lines' high bits, which will semi-
    STA r_battle_bg1_hdma_data.65.horizontal_hi.w,Y                             ; $03FB0E | | randomly decide which rows are pulling from the empty left side of
    STA r_battle_bg1_hdma_data.97.horizontal_hi.w,Y                             ; $03FB11 | | BG1 and the right side which has the monster.
    STA r_battle_bg1_hdma_data.129.horizontal_hi.w,Y                            ; $03FB14 | |
    STA r_battle_bg1_hdma_data.161.horizontal_hi.w,Y                            ; $03FB17 |/
    INY                                                                         ; $03FB1A |\
    INY                                                                         ; $03FB1B | | Increment the Y index by four to move to the next entries.
    INY                                                                         ; $03FB1C | |
    INY                                                                         ; $03FB1D |/
    CPY #_sizeof_scroll_hdma_data_entry.w * 16                                  ; $03FB1E |\ Loop until sixteen lines have been processed.
    BNE -                                                                       ; $03FB21 |/
    LDY #_sizeof_scroll_hdma_data_entry.w * 16.w                                ; $03FB23 | Initialize the Y register to the end of sixteen lines.
    LDA <r_battle_monster_effect_counter                                        ; $03FB26 |\
    ASL A                                                                       ; $03FB28 | | Set the X register to the effect counter times two.
    TAX                                                                         ; $03FB29 |/
-   LDA bank13.battle_monster_dissolve_data.l + 0,X                             ; $03FB2A |\
    STA <r_battle_generic_tmp_index_hi                                          ; $03FB2E | | Load the next value from ROM, noting that the high and low bytes
    LDA bank13.battle_monster_dissolve_data.l + 1,X                             ; $03FB30 | | have been swapped.
    STA <r_battle_generic_tmp_index_lo                                          ; $03FB34 |/
    INX                                                                         ; $03FB36 |\ Increment the X register by two to move to the next value.
    INX                                                                         ; $03FB37 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $03FB38 |\
    ASL <r_battle_generic_tmp_index                                             ; $03FB3A | | Extract the uppermost bit from the value and save it to another
    ROL <r_battle_generic_tmp_index_2                                           ; $03FB3C | | variable.
    TDC                                                                         ; $03FB3E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $03FB3F |/
    LDA <r_battle_generic_tmp_index_2_lo                                        ; $03FB41 |\
    AND #%00000001.b                                                            ; $03FB43 | | Load the extracted byte, mask out only that bit, and flip the bit.
    EOR #%00000001.b                                                            ; $03FB45 |/
    STA r_battle_bg1_hdma_data.16.horizontal_hi.w,Y                             ; $03FB47 |\
    STA r_battle_bg1_hdma_data.48.horizontal_hi.w,Y                             ; $03FB4A | | Write the value to the groups of lines in between the previous
    STA r_battle_bg1_hdma_data.80.horizontal_hi.w,Y                             ; $03FB4D | | sets of groups.
    STA r_battle_bg1_hdma_data.112.horizontal_hi.w,Y                            ; $03FB50 | |
    STA r_battle_bg1_hdma_data.144.horizontal_hi.w,Y                            ; $03FB53 |/
    DEY                                                                         ; $03FB56 |\
    DEY                                                                         ; $03FB57 | | Decrement the Y register by four to move to the next value.
    DEY                                                                         ; $03FB58 | |
    DEY                                                                         ; $03FB59 |/
    BNE -                                                                       ; $03FB5A | Loop until all sixteen lines have been processed.
    RTS                                                                         ; $03FB5C

; _battle_menu_toggle_pause_display ($03:FB5D)
;
; Toggles the display of the pause window by updating the HDMA tables for BG3.
_battle_menu_toggle_pause_display:
    TDC                                                                         ; $03FB5D |\ Initialize the X register to zero.
    TAX                                                                         ; $03FB5E |/
-   LDA r_battle_menu_hdma_data_pause.w,X                                       ; $03FB5F |\
    PHA                                                                         ; $03FB62 | | Swap the HDMA data for the pause array and the actual BG3 data to
    LDA r_battle_bg3_hdma_data.w + _sizeof_scroll_hdma_data_entry * 64,X        ; $03FB63 | | either enable or disable the display of the pause window.
    STA r_battle_menu_hdma_data_pause.w,X                                       ; $03FB66 | |
    PLA                                                                         ; $03FB69 | |
    STA r_battle_bg3_hdma_data.w + _sizeof_scroll_hdma_data_entry * 64,X        ; $03FB6A |/
    INX                                                                         ; $03FB6D |\
    CPX #_sizeof_scroll_hdma_data_entry.w * 32                                  ; $03FB6E | | Loop until 32 lines have been updated.
    BNE -                                                                       ; $03FB71 |/
    RTS                                                                         ; $03FB73

; _battle_audio_pause_* ($03:FB74)
;
; Depending on the entry point, either reduces the volume to a lower level or
; sets it to normal. Either way, afterward, it plays the pause sound effect.
_battle_audio_pause_enable:
    LDA #AUDIO_MODE_VOLUME_QUIET.b                                              ; $03FB74 |\
    STA r_play_audio_arg_mode.w                                                 ; $03FB76 | | Set the volume to a lower level.
    JSL bank04.play_audio                                                       ; $03FB79 | |
    BRA _battle_audio_pause_common                                              ; $03FB7D |/
_battle_audio_pause_disable:
    LDA #AUDIO_MODE_VOLUME_NORMAL.b                                             ; $03FB7F |\
    STA r_play_audio_arg_mode.w                                                 ; $03FB81 | | Set the volume to normal.
    JSL bank04.play_audio                                                       ; $03FB84 |/
_battle_audio_pause_common:
    LDA #AUDIO_MODE_EFFECT.b                                                    ; $03FB88 |\
    STA r_play_audio_arg_mode.w                                                 ; $03FB8A | | Play the pause sound effect (shared with the Hatch spell).
    LDA #AUDIO_EFFECT_HATCH.b                                                   ; $03FB8D | |
    STA r_play_audio_arg_track.w                                                ; $03FB8F | |
    LDA #AUDIO_PAN_CENTER.b                                                     ; $03FB92 | |
    STA r_play_audio_arg_pan.w                                                  ; $03FB94 | |
    JSL bank04.play_audio                                                       ; $03FB97 |/
    RTS                                                                         ; $03FB9B

; battle_check_pause ($03:FB9C)
;
; This routine checks the current pause state and will either enable or disable
; pause depending on if the start button is pressed. There is a built-in timer
; that causes a transition to/from the paused state to take 11 frames. If the
; system is either transitioning to/from the pause state or if the game is
; currently paused and won't be unpaused on this frame, the carry flag is set.
; Otherwise, it is cleared.
battle_check_pause:
    LDA reg_cpu_stdcntrl1h.l                                                    ; $03FB9C |\
    ORA reg_cpu_stdcntrl2h.l                                                    ; $03FBA0 | | If either controller is pressing start, add the value to the
    AND #JOYPAD_H_START.b                                                       ; $03FBA4 | | battle joypad repeat variable.
    ORA <r_battle_joypad_repeat_hi                                              ; $03FBA6 | |
    STA <r_battle_joypad_repeat_hi                                              ; $03FBA8 |/
    LDA r_battle_pause_disabled.w                                               ; $03FBAA |\
    CMP #$FF.b                                                                  ; $03FBAD | | Clear the carry flag and return if pause is flagged as disabled.
    BEQ @clear_and_return_proxy                                                 ; $03FBAF |/
    LDA r_battle_enable_input.w                                                 ; $03FBB1 |\ Clear the carry flag and return if input is disabled.
    BEQ @clear_and_return_proxy                                                 ; $03FBB4 |/
    LDA r_battle_pause_state.w                                                  ; $03FBB6 |\ Branch forward to the steady code if the pause state is not
    BEQ @steady                                                                 ; $03FBB9 |/ currently transitioning.
    CMP #BATTLE_PAUSE_STATE_PAUSING.b                                           ; $03FBBB |\ If currently pausing, branch ahead to pausing code.
    BEQ +                                                                       ; $03FBBD |/
    INC r_battle_pause_timer.w                                                  ; $03FBBF |\
    LDA r_battle_pause_timer.w                                                  ; $03FBC2 | | If unpausing, increment the timer value, and if it hasn't reached
    CMP #BATTLE_PAUSE_TIMER_MAXIMUM.b                                           ; $03FBC5 | | the maximum value, set the carry flag and return.
    BNE @set_and_return                                                         ; $03FBC7 |/
    STZ r_battle_pause_state.w                                                  ; $03FBC9 | Change the pause state to steady, as the unpausing is complete.
    STZ r_battle_paused.w                                                       ; $03FBCC | Reset the paused flag.
-   LDA r_battle_pause_disabled.w                                               ; $03FBCF |\
    CMP #$FE.b                                                                  ; $03FBD2 | | If pause is pending to be disabled, increment the flag to actually
    BNE @set_and_return                                                         ; $03FBD4 | | disable pause, set the carry flag, and return.
    INC r_battle_pause_disabled.w                                               ; $03FBD6 | |
    BRA @set_and_return                                                         ; $03FBD9 |/
+   DEC r_battle_pause_timer.w                                                  ; $03FBDB |\
    LDA r_battle_pause_timer.w                                                  ; $03FBDE | | If pausing, decrement the timer value, and if it hasn't reached
    CMP #BATTLE_PAUSE_TIMER_MINIMUM.b                                           ; $03FBE1 | | the minimum value, set the carry flag and return.
    BNE @set_and_return                                                         ; $03FBE3 |/
    STZ r_battle_pause_state.w                                                  ; $03FBE5 | Change the pause state to steady.
    INC r_battle_paused.w                                                       ; $03FBE8 | Set the paused flag.
    BRA -                                                                       ; $03FBEB | Branch back to update the pause disabled flag if appropriate.
@clear_and_return_proxy:
    BRA @clear_and_return                                                       ; $03FBED | Branch to clear the carry flag and return.
@steady:
    LDA r_battle_paused.w                                                       ; $03FBEF |\ Branch ahead to other code if the battle is currently paused.
    BNE +++                                                                     ; $03FBF2 |/
    LDA r_battle_pause_disabled.w                                               ; $03FBF4 |\
    BEQ +                                                                       ; $03FBF7 | | If the pause disabled flag is non-zero, set it again to pending
    LDA #$FE.b                                                                  ; $03FBF9 | | and branch ahead past the next block.
    STA r_battle_pause_disabled.w                                               ; $03FBFB | |
    BRA ++                                                                      ; $03FBFE |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $03FC00 |\
    AND #JOYPAD_H_START.b                                                       ; $03FC02 | | If the start button isn't pressed, clear the flag and return.
    BEQ @clear_and_return                                                       ; $03FC04 |/
    JSR _battle_audio_pause_enable.w                                            ; $03FC06 | Enable pause audio.
    JSR _battle_menu_toggle_pause_display                                       ; $03FC09 | Toggle the display of the pause window.
++  LDA #BATTLE_PAUSE_STATE_PAUSING.b                                           ; $03FC0C |\
    STA r_battle_pause_state.w                                                  ; $03FC0E | | Set the pause state to pausing and set the timer to the maximum
    LDA #BATTLE_PAUSE_TIMER_MAXIMUM.b                                           ; $03FC11 | | value.
    STA r_battle_pause_timer.w                                                  ; $03FC13 | |
    BRA @set_and_return                                                         ; $03FC16 |/
+++ LDA r_battle_pause_disabled.w                                               ; $03FC18 |\
    BEQ +                                                                       ; $03FC1B | | If currently paused and pause is disabled, set the disabled flag
    LDA #$FE.b                                                                  ; $03FC1D | | to pending and skip the next block.
    STA r_battle_pause_disabled.w                                               ; $03FC1F | |
    BRA ++                                                                      ; $03FC22 |/
+   LDA <r_battle_joypad_repeat_hi                                              ; $03FC24 |\
    AND #JOYPAD_H_START.b                                                       ; $03FC26 | | If the start button isn't pressed, set the carry flag and return.
    BEQ @set_and_return                                                         ; $03FC28 |/
++  JSR _battle_audio_pause_disable                                             ; $03FC2A | Disable the pause audio.
    JSR _battle_menu_toggle_pause_display                                       ; $03FC2D | Toggle the display of the pause window.
    LDA #BATTLE_PAUSE_STATE_UNPAUSING.b                                         ; $03FC30 |\ Set the pause state to unpausing.
    STA r_battle_pause_state.w                                                  ; $03FC32 |/
    LDA #BATTLE_PAUSE_TIMER_MINIMUM.b                                           ; $03FC35 |\ Set the pause timer to the minimum value.
    STA r_battle_pause_timer.w                                                  ; $03FC37 |/
@clear_and_return:
    CLC                                                                         ; $03FC3A | Clear the carry flag.
    RTL                                                                         ; $03FC3B
@set_and_return:
    SEC                                                                         ; $03FC3C | Set the carry flag.
    RTL                                                                         ; $03FC3D

; battle_update_color_math ($03:FC3E)
;
; Based on various variables in memory, updates the current color math settings
; for the battle.
battle_update_color_math:
    LDA r_battle_flash_mode.w                                                   ; $03FC3E |\
    BNE +                                                                       ; $03FC41 | | If the flash is not enabled, simply do the default processing.
    JMP @default                                                                ; $03FC43 |/
+   LDA r_battle_flash_parameters.w                                             ; $03FC46 |\
    BEQ +                                                                       ; $03FC49 | | IF a specific value has been provided, use that to set the color
    LDA r_battle_flash_parameters.w                                             ; $03FC4B | | math basic parameters. Otherwise, enable regular addition on BG1
    BRA ++                                                                      ; $03FC4E | | and BG2.
+   LDA #%00000011.b                                                            ; $03FC50 | |
++  JSR _battle_set_cgadsub                                                     ; $03FC52 |/
    LDA #%11100000.b                                                            ; $03FC55 |\ Initialize the fixed color to black to erase any existing color.
    STA reg_ppu_coldata.l                                                       ; $03FC57 |/
    LDA r_battle_flash_mode.w                                                   ; $03FC5B |\
    CMP #BATTLE_FLASH_MODE_CONTINUOUS.b                                         ; $03FC5E | | Depending on the configured mode, branch to the correct section
    BEQ @flash                                                                  ; $03FC60 | | of code to handle that mode.
    CMP #BATTLE_FLASH_MODE_PULSE.b                                              ; $03FC62 | |
    BEQ @pulse                                                                  ; $03FC64 | |
    CMP #BATTLE_FLASH_MODE_SINGLE.b                                             ; $03FC66 | |
    BEQ @flash                                                                  ; $03FC68 | |
    CMP #BATTLE_FLASH_MODE_FADE_IN.b                                            ; $03FC6A | |
    BEQ @fadein                                                                 ; $03FC6C | |
    CMP #BATTLE_FLASH_MODE_FADE_OUT.b                                           ; $03FC6E | |
    BEQ @fadeout                                                                ; $03FC70 | |
    CMP #BATTLE_FLASH_MODE_PULSE_2.b                                            ; $03FC72 | |
    BEQ @pulse                                                                  ; $03FC74 |/
@fadeout:
    LDA r_battle_flash_red_intensity.w                                          ; $03FC76 |\
    BEQ +                                                                       ; $03FC79 | | If the red intensity is greater than zero, decrease the intensity
    DEC r_battle_flash_red_intensity.w                                          ; $03FC7B | | of all three colors.
    DEC r_battle_flash_green_intensity.w                                        ; $03FC7E | |
    DEC r_battle_flash_blue_intensity.w                                         ; $03FC81 | |
    BRA @set_color                                                              ; $03FC84 |/
+   STZ r_battle_flash_parameters.w                                             ; $03FC86 |\
    STZ r_battle_flash_mode.w                                                   ; $03FC89 | | Otherwise, reset the mode variables to end the flash.
    BRA @set_color                                                              ; $03FC8C |/
@fadein:
    LDA r_battle_flash_red_intensity.w                                          ; $03FC8E |\
    CMP r_battle_flash_intensity_target.w                                       ; $03FC91 | | If the red intensity is not equal to the intensity target,
    BEQ +                                                                       ; $03FC94 | | increase the intensity of all three colors.
    INC r_battle_flash_red_intensity.w                                          ; $03FC96 | |
    INC r_battle_flash_green_intensity.w                                        ; $03FC99 | |
    INC r_battle_flash_blue_intensity.w                                         ; $03FC9C | |
+   BRA @set_color                                                              ; $03FC9F |/
@pulse:
    LDA r_battle_flash_phase.w                                                  ; $03FCA1 |\
    BNE ++                                                                      ; $03FCA4 | | If in the fade-in phase and the red intensity is less than 31,
    LDA r_battle_flash_red_intensity.w                                          ; $03FCA6 | | increase the intensity of all three colors.
    CMP #31.b                                                                   ; $03FCA9 | |
    BEQ +                                                                       ; $03FCAB | |
    INC r_battle_flash_red_intensity.w                                          ; $03FCAD | |
    INC r_battle_flash_green_intensity.w                                        ; $03FCB0 | |
    INC r_battle_flash_blue_intensity.w                                         ; $03FCB3 | |
    BRA @set_color                                                              ; $03FCB6 |/
+   LDA #1.b                                                                    ; $03FCB8 |\
    STA r_battle_flash_phase.w                                                  ; $03FCBA | | If the intensity is 31, switch to the fade-out phase.
    BRA @set_color                                                              ; $03FCBD |/
++  LDA r_battle_flash_red_intensity.w                                          ; $03FCBF |\
    BEQ +                                                                       ; $03FCC2 | | If this is the fade-out phase, decrease intensity of all three
    DEC r_battle_flash_red_intensity.w                                          ; $03FCC4 | | colors unless the red intensity is already zero.
    DEC r_battle_flash_green_intensity.w                                        ; $03FCC7 | |
    DEC r_battle_flash_blue_intensity.w                                         ; $03FCCA | |
    BRA @set_color                                                              ; $03FCCD |/
+   STZ r_battle_flash_phase.w                                                  ; $03FCCF |\ If intensity is already zero, change the phase back to fade-in.
    BRA @set_color                                                              ; $03FCD2 |/
@flash:
    LDA r_battle_flash_counter.w                                                ; $03FCD4 |\
    AND #%00000010.b                                                            ; $03FCD7 | | Skip to the end if the counter has bit 1 set.
    BNE @done                                                                   ; $03FCD9 |/
@set_color:
    LDA r_battle_flash_color.w                                                  ; $03FCDB |\
    AND #%10000000.b                                                            ; $03FCDE | | If blue is enabled, set the intensity of the blue component.
    BEQ +                                                                       ; $03FCE0 | |
    LDA r_battle_flash_blue_intensity.w                                         ; $03FCE2 | |
    ORA #%10000000.b                                                            ; $03FCE5 | |
    STA reg_ppu_coldata.l                                                       ; $03FCE7 |/
+   LDA r_battle_flash_color.w                                                  ; $03FCEB |\
    AND #%01000000.b                                                            ; $03FCEE | | If green is enabled, set the intensity of the green component.
    BEQ +                                                                       ; $03FCF0 | |
    LDA r_battle_flash_green_intensity.w                                        ; $03FCF2 | |
    ORA #%01000000.b                                                            ; $03FCF5 | |
    STA reg_ppu_coldata.l                                                       ; $03FCF7 |/
+   LDA r_battle_flash_color.w                                                  ; $03FCFB |\
    AND #%00100000.b                                                            ; $03FCFE | | If red is enabled, set the intensity of the red component.
    BEQ +                                                                       ; $03FD00 | |
    LDA r_battle_flash_red_intensity.w                                          ; $03FD02 | |
    ORA #%00100000.b                                                            ; $03FD05 | |
    STA reg_ppu_coldata.l                                                       ; $03FD07 |/
+   LDA r_battle_flash_mode.w                                                   ; $03FD0B |\
    CMP #BATTLE_FLASH_MODE_SINGLE.b                                             ; $03FD0E | | If the flash mode is set to single and the flash counter has
    BNE @done                                                                   ; $03FD10 | | its second bit unset, reset the flash mode to zero to end the
    INC r_battle_flash_counter.w                                                ; $03FD12 | | flash.
    LDA r_battle_flash_counter.w                                                ; $03FD15 | |
    AND #%00000010.b                                                            ; $03FD18 | |
    BNE +                                                                       ; $03FD1A | |
    STZ r_battle_flash_mode.w                                                   ; $03FD1C | |
+   RTL                                                                         ; $03FD1F |/
@done:
    INC r_battle_flash_counter.w                                                ; $03FD20 |\ Increment the flash counter and return.
    RTL                                                                         ; $03FD23 |/
@default:
    LDA r_formation_flags2_copy_2.w                                             ; $03FD24 |\
    AND #FORMATION_FLAGS_2_TRANSPARENT.b                                        ; $03FD27 | | If the formation is configured to have transparent enemies, enable
    BEQ +                                                                       ; $03FD29 | | 1/2 color addition on BG1 with BG2 as the sub screen and return.
    LDA #%00000010.b                                                            ; $03FD2B | |
    STA reg_ppu_cgswsel.l                                                       ; $03FD2D | |
    STA reg_ppu_ts.l                                                            ; $03FD31 | |
    LDA #%01000001.b                                                            ; $03FD35 | |
    JSR _battle_set_cgadsub                                                     ; $03FD37 | |
    RTL                                                                         ; $03FD3A |/
+   TDC                                                                         ; $03FD3B |\
    STA reg_ppu_cgswsel.l                                                       ; $03FD3C | | Otherwise, disable color math.
    STA reg_ppu_ts.l                                                            ; $03FD40 | |
    JSR _battle_set_cgadsub                                                     ; $03FD44 |/
    RTL                                                                         ; $03FD47

; _battle_set_cgadsub ($03:FD48)
;
; Given a value in the accumulator, sets the value of the cgadsub register, as
; well as the entries in the HDMA table.
_battle_set_cgadsub:
    STA reg_ppu_cgadsub.l                                                       ; $03FD48 | Set the actual color math parameters.
    STA r_battle_cgadsub_hdma_data.1.value.w                                    ; $03FD4C |\ Set the cgadsub parameter for the first two screen sections
    STA r_battle_cgadsub_hdma_data.2.value.w                                    ; $03FD4F |/ (everything but the menu area) to the same value.
    RTS                                                                         ; $03FD52

; battle_initialize_alternate_party_sprite ($03:FD53)
;
; Given a spell ID in the accumulator, initializes the parameters of the
; alternate party sprite to prepare for its display.
battle_initialize_alternate_party_sprite:
    STZ r_battle_alternate_party_sprite_frame_counter.w                         ; $03FD53 |\
    STZ r_battle_alternate_party_sprite_auto_animate.w                          ; $03FD56 | | Initialize various alternate party sprite parameters to zero.
    STZ r_battle_alternate_party_sprite_invisible_columns.w                     ; $03FD59 | |
    STZ r_battle_alternate_party_sprite_invisible_column_index.w                ; $03FD5C | |
    STZ r_battle_alternate_party_sprite_sine_offsets_enabled.w                  ; $03FD5F | |
    STZ r_battle_alternate_party_sprite_sine_offsets_speed.w                    ; $03FD62 |/
    PHA                                                                         ; $03FD65 | Preserve the spell ID in the accumulator.
    SEC                                                                         ; $03FD66 |\ Subtract the first call spell ID to get the value relative to the
    SBC #SPELL_FIRST_CALL.b                                                     ; $03FD67 |/ base.
    STA r_battle_alternate_party_sprite_index.w                                 ; $03FD69 | Save that value as the alternate party sprite index.
    CMP #SPELL_CALL_ASURA_CURE_WEAK.b - SPELL_FIRST_CALL                        ; $03FD6C |\
    BCC +                                                                       ; $03FD6E | | Skip this next block unless the spell is one of the Asura spells.
    CMP #SPELL_CALL_BAHAMUT.b - SPELL_FIRST_CALL                                ; $03FD70 | | (Bahamut immediately follows Asura.)
    BEQ +                                                                       ; $03FD72 |/
    PHA                                                                         ; $03FD74 | Preserve the relative spell ID value.
    INC r_battle_alternate_party_sprite_auto_animate.w                          ; $03FD75 | Initially enable auto-animation of the alternate party sprite.
    LDA r_battle_frame_counter.w                                                ; $03FD78 |\
    TAY                                                                         ; $03FD7B | | Initialize the alternate party sprite frame counter to a random
    LDA r_prng_data.w,Y                                                         ; $03FD7C | | value from 0 to 3.
    AND #%00000011.b                                                            ; $03FD7F | |
    STA r_battle_alternate_party_sprite_frame_counter.w                         ; $03FD81 |/
    PLA                                                                         ; $03FD84 |\
+   CMP #SPELL_CALL_SYLPH.b - SPELL_FIRST_CALL                                  ; $03FD85 | | Skip this next block unless the spell is the Sylph spell.
    BNE +                                                                       ; $03FD87 | |
    PHA                                                                         ; $03FD89 |/
    STZ r_battle_effect_frame_counter.w                                         ; $03FD8A | Set the frame counter to zero.
    LDA #64.b                                                                   ; $03FD8D |\ Set the second sine index to 64.
    STA r_battle_effect_sine_index_2.w                                          ; $03FD8F |/
    LDA #8.b                                                                    ; $03FD92 |\
    STA r_battle_effect_sine_magnitude.w                                        ; $03FD94 | | Set the sine magnitudes to eight.
    STA r_battle_effect_sine_magnitude_2.w                                      ; $03FD97 |/
    LDA #2.b                                                                    ; $03FD9A |\ Set the alternate party sprite sine speed to 2.
    STA r_battle_alternate_party_sprite_sine_offsets_speed.w                    ; $03FD9C |/
    INC r_battle_alternate_party_sprite_sine_offsets_enabled.w                  ; $03FD9F | Enable the sine offset effect on the alternate party sprite.
    PLA                                                                         ; $03FDA2 |\
+   ASL A                                                                       ; $03FDA3 | | Set the X register to the relative spell ID times four.
    ASL A                                                                       ; $03FDA4 | |
    TAX                                                                         ; $03FDA5 |/
    TDC                                                                         ; $03FDA6 |\
    TAY                                                                         ; $03FDA7 | | Copy the coordinates and size of the alternate party sprite for
-   LDA bank13.battle_call_sprite_position_data.l,X                             ; $03FDA8 | | this spell.
    STA r_battle_alternate_party_sprite_coordinates.x.w,Y                       ; $03FDAC | |
    INX                                                                         ; $03FDAF | |
    INY                                                                         ; $03FDB0 | |
    CPY #4.w                                                                    ; $03FDB1 | |
    BNE -                                                                       ; $03FDB4 |/
    PLA                                                                         ; $03FDB6 | Restore the original spell ID to the accumulator.
    LDA #%00111000.b                                                            ; $03FDB7 |\ Set the alternate party sprite tile flags to be priority 3 with
    STA r_battle_alternate_party_sprite_tile_flags.w                            ; $03FDB9 |/ palette 4.
    TDC                                                                         ; $03FDBC |\
    TAY                                                                         ; $03FDBD | | Zero out palette 10, which will serve as the flash palette for the
-   TDC                                                                         ; $03FDBE | | sprite.
    STA r_battle_cgram_data.11.w,Y                                              ; $03FDBF | |
    INX                                                                         ; $03FDC2 | |
    INY                                                                         ; $03FDC3 | |
    CPY #_sizeof_palette.w                                                      ; $03FDC4 | |
    BNE -                                                                       ; $03FDC7 |/
    LDX #$7FFF.w                                                                ; $03FDC9 |\ Set color 2 in palette 10 to white.
    STX r_battle_cgram_data.11.color2.w                                         ; $03FDCC |/
    RTL                                                                         ; $03FDCF

; battle_update_joypad ($03:FDD0)
;
; Updates the battle joypad values at $0037 through $003A. In addition, unsets
; the dialog waiting input flag at $F43A if input is detected and the flag is
; set.
battle_update_joypad:
    LDA r_battle_enable_input.w                                                 ; $03FDD0 |\ Skip this routine if battle input is not enabled.
    BEQ ++                                                                      ; $03FDD3 |/
    PHD                                                                         ; $03FDD5 |\
    LDX #r_battle_joypad_repeat.w                                               ; $03FDD6 | | Update the current joypad values. The routine writes to $00
    PHX                                                                         ; $03FDD9 | | through $03, relative to the direct register.
    PLD                                                                         ; $03FDDA | |
    JSL bank01.update_joypad                                                    ; $03FDDB | |
    PLD                                                                         ; $03FDDF |/
    LDA reg_cpu_stdcntrl1l.l                                                    ; $03FDE0 |\
    ORA reg_cpu_stdcntrl2l.l                                                    ; $03FDE4 | | If both L and R are pressed in any combination on the first two
    AND #(JOYPAD_L_L | JOYPAD_L_R).b                                            ; $03FDE8 | | controllers, unset any A button press in the battle repeat
    CMP #(JOYPAD_L_L | JOYPAD_L_R).b                                            ; $03FDEA | | button data.
    BNE +                                                                       ; $03FDEC | |
    LDA <r_battle_joypad_repeat_lo                                              ; $03FDEE | |
    AND #~JOYPAD_L_A.b                                                          ; $03FDF0 | |
    STA <r_battle_joypad_repeat_lo                                              ; $03FDF2 |/
+   LDA r_battle_dialog_waiting_input.w                                         ; $03FDF4 |\
    BEQ ++                                                                      ; $03FDF7 | | If a battle dialog is waiting for input, and input has been
    LDA <r_battle_joypad_repeat_lo                                              ; $03FDF9 | | detected, unset the waiting for input flag.
    ORA <r_battle_joypad_repeat_hi                                              ; $03FDFB | |
    BEQ ++                                                                      ; $03FDFD | |
    STZ r_battle_dialog_waiting_input.w                                         ; $03FDFF |/
++  RTL                                                                         ; $03FE02

; battle_copy_oam_to_ppu ($03:FE03)
;
; Unless $F42B is non-zero, transfers the data in the OAM staging area at $0300
; to the PPU. Additionally, if the 16-bit value at $F289 specifies a valid OAM
; priority setting, it will be set.
battle_copy_oam_to_ppu:
    LDA r_battle_disable_oam_update.w                                           ; $03FE03 |\ Skip this function if OAM updating is disabled.
    BNE ++                                                                      ; $03FE06 |/
    PHB                                                                         ; $03FE08 |\
    TDC                                                                         ; $03FE09 | | Set the data bank register to $00.
    PHA                                                                         ; $03FE0A | |
    PLB                                                                         ; $03FE0B |/
    LDX #$0000.w                                                                ; $03FE0C |\
    STX reg_ppu_oamadd.w                                                        ; $03FE0F | | Use a DMA transfer to copy the OAM data from the staging area in
    LDX #$0400.w                                                                ; $03FE12 | | RAM at $0300 to the actual OAM.
    STX reg_cpu_dmap4.w                                                         ; $03FE15 | |
    LDX #r_oam.w                                                                ; $03FE18 | |
    STX reg_cpu_a1t4.w                                                          ; $03FE1B | |
    TDC                                                                         ; $03FE1E | |
    STA reg_cpu_a1b4.w                                                          ; $03FE1F | |
    STA reg_cpu_hdb4.w                                                          ; $03FE22 | |
    LDX #(_sizeof_r_oam + _sizeof_r_oam_hi).w                                   ; $03FE25 | |
    STX reg_cpu_das4.w                                                          ; $03FE28 | |
    LDA #%00010000.b                                                            ; $03FE2B | |
    STA reg_cpu_mdmaen.w                                                        ; $03FE2D |/
    LDA r_battle_oam_priority_hi.l                                              ; $03FE30 |\
    BPL +                                                                       ; $03FE34 | | If a sprite other than the default should have the highest
    LDA r_battle_oam_priority_hi.l                                              ; $03FE36 | | priority, set the register accordingly.
    STA reg_ppu_oamaddh.w                                                       ; $03FE3A | |
    LDA r_battle_oam_priority_lo.l                                              ; $03FE3D | |
    STA reg_ppu_oamaddl.w                                                       ; $03FE41 |/
+   PLB                                                                         ; $03FE44 | Restore the data bank register.
++  RTL                                                                         ; $03FE45

; battle_init_hdma ($03:FE46)
;
; Initializes the HDMA channels used in battle.
battle_init_hdma:
    LDA #100.b                                                                  ; $03FE46 |\
    STA r_battle_cgadsub_hdma_data.1.scanlines.w                                ; $03FE48 | | Initialize the color math configuration HDMA data into three
    LDA #40.b                                                                   ; $03FE4B | | on-screen sections: one of 100 lines, 40 lines for the second, and
    STA r_battle_cgadsub_hdma_data.2.scanlines.w                                ; $03FE4D | | the remainder in the third section. The third section is
    LDA #1.b                                                                    ; $03FE50 | | explicitly set to a value of zero, but the other two are left
    STA r_battle_cgadsub_hdma_data.3.scanlines.w                                ; $03FE52 | | unset, as they are set elsewhere.
    STZ r_battle_cgadsub_hdma_data.3.value.w                                    ; $03FE55 | |
    STZ r_battle_cgadsub_hdma_data.4.scanlines.w                                ; $03FE58 |/
    PHB                                                                         ; $03FE5B |\
    TDC                                                                         ; $03FE5C | | Preserve the existing data bank register and then set it to $00.
    PHA                                                                         ; $03FE5D | |
    PLB                                                                         ; $03FE5E |/
    LDA #%01000011.b                                                            ; $03FE5F |\
    STA reg_cpu_dmap0.w                                                         ; $03FE61 | | Configure DMA channels 0, 1 and 2 for HDMA indirect addressing,
    STA reg_cpu_dmap1.w                                                         ; $03FE64 | | writing two addresses twice.
    STA reg_cpu_dmap2.w                                                         ; $03FE67 |/
    LDA #<reg_ppu_bg1h0fs                                                       ; $03FE6A |\
    STA reg_cpu_bbad0.w                                                         ; $03FE6C | | Configure the three HDMA channels to have their target addresses as
    LDA #<reg_ppu_bg2h0fs                                                       ; $03FE6F | | the scroll registers for BG1, BG2 and BG3, respectively.
    STA reg_cpu_bbad1.w                                                         ; $03FE71 | |
    LDA #<reg_ppu_bg3h0fs                                                       ; $03FE74 | |
    STA reg_cpu_bbad2.w                                                         ; $03FE76 |/
    LDX #r_battle_bg1_hdma_table.w                                              ; $03FE79 |\
    STX reg_cpu_a1t0.w                                                          ; $03FE7C | | Set the A address for the HDMA channels to the three HDMA tables.
    LDX #r_battle_bg2_hdma_table.w                                              ; $03FE7F | |
    STX reg_cpu_a1t1.w                                                          ; $03FE82 | |
    LDX #r_battle_bg3_hdma_table.w                                              ; $03FE85 | |
    STX reg_cpu_a1t2.w                                                          ; $03FE88 |/
    LDA #:r_battle_bg1_hdma_table.b                                             ; $03FE8B |\
    STA reg_cpu_a1b0.w                                                          ; $03FE8D | | Set the bank number for the three channels to $7E.
    STA reg_cpu_a1b1.w                                                          ; $03FE90 | |
    STA reg_cpu_a1b2.w                                                          ; $03FE93 |/
    STA reg_cpu_hdb0.w                                                          ; $03FE96 |\
    STA reg_cpu_hdb1.w                                                          ; $03FE99 | | Set the HDMA indirect pointer bank to $7E as well.
    STA reg_cpu_hdb2.w                                                          ; $03FE9C |/
    LDA #%00000000.b                                                            ; $03FE9F |\ Configure DMA channel 7 to write one address.
    STA reg_cpu_dmap7.w                                                         ; $03FEA1 |/
    LDA #<reg_ppu_cgadsub                                                       ; $03FEA4 |\ Set DMA channel 7 to write to one of the color math configuration
    STA reg_cpu_bbad7.w                                                         ; $03FEA6 |/ registers.
    LDX #r_battle_cgadsub_hdma_data.w                                           ; $03FEA9 |\ Set the channel 7 source HDMA table location.
    STX reg_cpu_a1t7.w                                                          ; $03FEAC |/
    LDA #:r_battle_cgadsub_hdma_data.b                                          ; $03FEAF |\ Set the HDMA indirect pointer bank to $7E for channel 7, not that
    STA reg_cpu_hdb7.w                                                          ; $03FEB1 |/ indirect mode is being used.
    STA reg_cpu_a1b7.w                                                          ; $03FEB4 | Set the bank number to $7E as well.
    LDA #%10000111.b                                                            ; $03FEB7 |\ Enable HDMA on channels 0, 1, 2 and 7.
    STA reg_cpu_hdmaen.w                                                        ; $03FEB9 |/
    PLB                                                                         ; $03FEBC | Restore the original data bank register.
    RTL                                                                         ; $03FEBD

; battle_copy_cgram_to_ppu ($03:FEBE)
;
; Copies the palette data from $7EED50 to CG-RAM.
battle_copy_cgram_to_ppu:
    PHB                                                                         ; $03FEBE |\
    TDC                                                                         ; $03FEBF | | Set the data bank register to $00.
    PHA                                                                         ; $03FEC0 | |
    PLB                                                                         ; $03FEC1 |/
    STA reg_ppu_cgadd                                                           ; $03FEC2 | Set the CG-RAM address to zero.
    LDX #$2202.w                                                                ; $03FEC5 |\ Configure DMA to write one address twice and set the target address
    STX reg_cpu_dmap4                                                           ; $03FEC8 |/ to CG-RAM write.
    LDX #r_battle_cgram_data.w                                                  ; $03FECB |\
    STX reg_cpu_a1t4                                                            ; $03FECE | | Set the source address to $7EED50.
    LDA #$7E.b                                                                  ; $03FED1 | |
    STA reg_cpu_a1b4                                                            ; $03FED3 |/
    LDX #$0200.w                                                                ; $03FED6 |\ Copy 512 bytes, which is the entirety of CG-RAM.
    STX reg_cpu_das4                                                            ; $03FED9 |/
    LDA #%00010000.b                                                            ; $03FEDC |\ Enable DMA on channel 4.
    STA reg_cpu_mdmaen                                                          ; $03FEDE |/
    PLB                                                                         ; $03FEE1 | Restore the data bank register.
    RTL                                                                         ; $03FEE2

UNUSED_03FEE3:
    .dsb $011D $FF                                                              ; $03FEE3.FFFF

.ends
