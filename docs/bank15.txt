.include "header.inc"

.define r_init_spell_lists_index                         $07 ; 8-bit

.define r_draw_field_sprite_player_tmp_shift           $0606 ; 8-bit
.define r_copy_player_field_sprite_to_vram_tmp         $0606 ; 8-bit
.define r_check_coordinates_visible_tmp                $0606 ; 8-bit
.define r_draw_zoomed_vehicle_tmp                      $0606 ; 8-bit
.define r_draw_field_sprite_shadow_tmp                 $0606 ; 8-bit
.define r_clear_tilemap_vram_high_tmp                  $0606 ; 8-bit
.define r_set_oam_hi_x_tmp                             $0607 ; 8-bit
.define r_draw_field_sprite_tmp                        $0607 ; 8-bit
.define r_load_map_outdoor_tiles_tmp                   $0608 ; 8-bit

.define r_check_coordinates_visible_tmp_negative       $060A ; 8-bit
.define r_draw_field_sprite_tanks_index                $060B ; 8-bit
.define r_check_coordinates_visible_arg_x              $060C ; 16-bit
.define r_check_coordinates_visible_arg_x_lo           $060C ; 8-bit
.define r_check_coordinates_visible_arg_x_hi           $060D ; 8-bit
.define r_check_coordinates_visible_arg_y              $060E ; 16-bit
.define r_check_coordinates_visible_arg_y_lo           $060E ; 8-bit
.define r_check_coordinates_visible_arg_y_hi           $060F ; 8-bit
.define r_copy_3bpp_to_vram_tmp                        $0610 ; 16-bit
.define r_copy_animated_tiles_to_vram_offset           $0612 ; 16-bit
.define r_copy_animated_tiles_to_vram_offset_lo        $0612 ; 8-bit
.define r_copy_animated_tiles_to_vram_offset_hi        $0613 ; 8-bit

.define r_load_dungeon_palette_tmp_index               $0618 ; 16-bit
.define r_load_dungeon_palette_tmp_index_lo            $0618 ; 8-bit
.define r_load_dungeon_palette_tmp_index_hi            $0619 ; 8-bit

.define r_replace_overworld_plot_tiles_index           $063D ; 16-bit
.define r_load_map_outdoor_tiles_index                 $063D ; 16-bit
.define r_replace_overworld_plot_tiles_index_lo        $063D ; 8-bit
.define r_load_map_outdoor_tiles_index_lo              $063D ; 8-bit
.define r_replace_overworld_plot_tiles_index_hi        $063E ; 8-bit
.define r_load_map_outdoor_tiles_index_hi              $063E ; 8-bit

.define r_draw_field_sprite_big_whale_oam_index        $0640 ; 16-bit
.define r_draw_field_sprite_big_whale_coordinate_index $0643 ; 16-bit

.define r_draw_field_sprite_player_tmp_offset          $064A ; 16-bit
.define r_draw_field_sprite_player_tmp_offset_lo       $064A ; 8-bit
.define r_draw_field_sprite_player_tmp_offset_hi       $064B ; 8-bit
.define r_get_player_field_sprite_offset_tmp           $064A ; 16-bit
.define r_get_player_field_sprite_offset_tmp_lo        $064A ; 8-bit
.define r_get_player_field_sprite_offset_tmp_hi        $064B ; 8-bit

.define r_check_coordinates_visible_result             $06D7 ; 8-bit

.bank 21 slot 1
.section "Bank" namespace "bank15"

; This section of this file was data and has been excluded from this copy.

; copy_3bpp_to_vram ($15:B000)
;
; Copies 3-bit-per-pixel data in ROM or RAM to VRAM, while expanding it to the
; 4-bit-per-pixel format needed in VRAM. This function takes four parameters:
; The bank to read from in $49, the 16-bit address to read from in $4A, the
; 16-bit target VRAM address in $4C, and the total number of words to fill in
; VRAM at $4E. (The data uses 16 words per tile in VRAM, but 12 words per tile
; in RAM or ROM.)
copy_3bpp_to_vram:
    STZ reg_cpu_mdmaen                                                          ; $15B000 |\
    LDA #$80                                                                    ; $15B003 | | Perform a DMA transfer to zero out VRAM at the address given in
    STA reg_ppu_vmainc                                                          ; $15B005 | | the parameter. Only the high bytes are zeroed, up to the number
    LDA #$08                                                                    ; $15B008 | | given in the words parameter.
    STA reg_cpu_dmap0                                                           ; $15B00A | |
    LDA #<reg_ppu_vmdatah_write                                                 ; $15B00D | | This transfer uses the DMA fixed-address option to read a zero
    STA reg_cpu_bbad0                                                           ; $15B00F | | stored to a temporary variable. It was additionally configured to
    STZ reg_cpu_a1b0                                                            ; $15B012 | | increment the VRAM address 1 by 1, and to write once to the
    LDX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $15B015 | | VRAM high byte write register.
    STX reg_ppu_vmadd                                                           ; $15B017 | |
    STZ <r_copy_3bpp_to_vram_tmp                                                ; $15B01A | |
    LDX #r_copy_3bpp_to_vram_tmp.w                                              ; $15B01C | |
    STX reg_cpu_a1t0                                                            ; $15B01F | |
    LDX <r_copy_3bpp_to_vram_arg_words                                          ; $15B022 | |
    STX reg_cpu_das0                                                            ; $15B024 | |
    LDA #$01                                                                    ; $15B027 | |
    STA reg_cpu_mdmaen                                                          ; $15B029 |/
    STZ reg_cpu_mdmaen                                                          ; $15B02C | Reset DMA for the next transfer.
    LSR <r_copy_3bpp_to_vram_arg_words_hi                                       ; $15B02F |\
    ROR <r_copy_3bpp_to_vram_arg_words_lo                                       ; $15B031 | | Divide the number of words given as an argument by 16, which gives
    LSR <r_copy_3bpp_to_vram_arg_words_hi                                       ; $15B033 | | the total number of 8x8 tiles to transfer. (Each tile uses 32
    ROR <r_copy_3bpp_to_vram_arg_words_lo                                       ; $15B035 | | bytes at 4 bits per pixel in VRAM.)
    LSR <r_copy_3bpp_to_vram_arg_words_hi                                       ; $15B037 | |
    ROR <r_copy_3bpp_to_vram_arg_words_lo                                       ; $15B039 | |
    LSR <r_copy_3bpp_to_vram_arg_words_hi                                       ; $15B03B | |
    ROR <r_copy_3bpp_to_vram_arg_words_lo                                       ; $15B03D |/
    LDA #<reg_ppu_vmdatal_write                                                 ; $15B03F |\
    STA reg_cpu_bbad0                                                           ; $15B041 | | The data is stored 3 bits per pixel in ROM, so the copy is done in
    LDX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $15B044 | | two phases: one to copy 16 bytes directly, and one to copy 8 bytes
    STX reg_ppu_vmadd                                                           ; $15B046 | | into only the lower byte of each word (expanding to the 4bpp
    LDX <r_copy_3bpp_to_vram_arg_address                                        ; $15B049 | | format). This part sets up the initil address to read from in ROM
    STX reg_cpu_a1t0                                                            ; $15B04B | | and the address to write to in VRAM. It also configures VRAM to
    LDA <r_copy_3bpp_to_vram_arg_bank                                           ; $15B04E | | write to the low byte (or the entire word).
    STA reg_cpu_a1b0                                                            ; $15B050 |/
    LDY #$0000.w                                                                ; $15B053 |\
-   STZ reg_cpu_mdmaen                                                          ; $15B056 | | Copies the first 16 bytes from ROM into VRAM. These bytes can be
    LDA #$80                                                                    ; $15B059 | | copied as is, and the VRAM increment is set to increment 1 by 1
    STA reg_ppu_vmainc                                                          ; $15B05B | | after the high byte is written. The DMA is set to write two
    LDA #$01                                                                    ; $15B05E | | addresses.
    STA reg_cpu_dmap0                                                           ; $15B060 | |
    LDX #$0010.w                                                                ; $15B063 | |
    STX reg_cpu_das0                                                            ; $15B066 | |
    LDA #$01                                                                    ; $15B069 | |
    STA reg_cpu_mdmaen                                                          ; $15B06B |/
    STZ reg_cpu_mdmaen                                                          ; $15B06E |\
    STZ reg_ppu_vmainc                                                          ; $15B071 | | Copy the second 16 bytes from ROM into VRAM. This actually copies
    STZ reg_cpu_dmap0                                                           ; $15B074 | | 8 bytes from ROM into the lower bytes of each word. The high byte
    LDX #$0008.w                                                                ; $15B077 | | of each word is left at $00, as this fourth bitplane is not used.
    STX reg_cpu_das0                                                            ; $15B07A | |
    LDA #$01                                                                    ; $15B07D | |
    STA reg_cpu_mdmaen                                                          ; $15B07F | |
    INY                                                                         ; $15B082 | |
    CPY <r_copy_3bpp_to_vram_arg_words                                          ; $15B083 | |
    BNE -                                                                       ; $15B085 |/
    RTL                                                                         ; $15B087

; load_tileset_tiles ($15:B088)
;
; Reads the current map's tileset value and loads the appropriate tile data from
; ROM into VRAM.
load_tileset_tiles:
    LDA r_map_properties.tileset.w                                              ; $15B088 |\
    BEQ +                                                                       ; $15B08B | | If using the ship or airship tileset, branch to a special set of
    CMP #TILESET_SHIP.b                                                         ; $15B08D | | code to handle the 4 bits per pixel data. All other tilesets use
    BNE ++                                                                      ; $15B08F | | 3 bits per pixel.
+   JMP @airship                                                                ; $15B091 |/
++  JSL bank15.clear_tilemap_vram_high                                          ; $15B094 | Clear the high bytes of VRAM, as 3bpp data doesn't always use it.
    STZ reg_cpu_mdmaen                                                          ; $15B098 | Reset DMA.
    LDA r_map_properties.tileset.w                                              ; $15B09B |\
    ASL A                                                                       ; $15B09E | | Set the offset to the tile data based on the tileset number.
    TAX                                                                         ; $15B09F | |
    LDA bank1E.tileset_offset_data.l,X                                          ; $15B0A0 | |
    STA reg_cpu_a1t0l                                                           ; $15B0A4 | |
    LDA bank1E.tileset_offset_data.l + 1,X                                      ; $15B0A7 | |
    STA reg_cpu_a1t0h                                                           ; $15B0AB |/
    LDA r_map_properties.tileset.w                                              ; $15B0AE |\
    TAX                                                                         ; $15B0B1 | | Set the bank number based on the tileset number.
    LDA tileset_bank_data.l,X                                                   ; $15B0B2 | |
    STA reg_cpu_a1b0                                                            ; $15B0B6 |/
    JSL copy_3bpp_tileset_to_vram                                               ; $15B0B9 | Copy the tileset data into VRAM.
    RTL                                                                         ; $15B0BD
@airship:
    LDX #$0000.w                                                                ; $15B0BE |\ Set the target VRAM address to $0000.
    STX <r_start_vram_dma_arg_vram_target                                       ; $15B0C1 |/
    LDX #$2400.w                                                                ; $15B0C3 |\ Transfer $2400 bytes.
    STX <r_start_vram_dma_arg_bytes                                             ; $15B0C6 |/
    LDA #:tileset_airship_ship_data.b                                           ; $15B0C8 |\ Set the source bank to $15.
    STA <r_start_vram_dma_arg_bank                                              ; $15B0CA |/
    LDA bank1E.tileset_offset_data.l                                            ; $15B0CC |\
    STA <r_start_vram_dma_arg_address.lo                                        ; $15B0D0 | | Set the source address to the value stored at $1E8000.
    LDA bank1E.tileset_offset_data.l + 1                                        ; $15B0D2 | |
    STA <r_start_vram_dma_arg_address.hi                                        ; $15B0D6 |/
    LDA #%10000000.b                                                            ; $15B0D8 |\ Set the VRAM increment to 1 by 1 on high byte.
    STA reg_ppu_vmainc                                                          ; $15B0DA |/
    STZ reg_cpu_mdmaen                                                          ; $15B0DD | Reset DMA.
    LDA #%00000001.b                                                            ; $15B0E0 |\
    STA reg_cpu_dmap0                                                           ; $15B0E2 | | Configure and perform the actual DMA transfer with the values
    LDA #<reg_ppu_vmdatal_write.b                                               ; $15B0E5 | | calculated above.
    STA reg_cpu_bbad0                                                           ; $15B0E7 | |
    LDA <r_start_vram_dma_arg_bank                                              ; $15B0EA | |
    STA reg_cpu_a1b0                                                            ; $15B0EC | |
    LDX <r_start_vram_dma_arg_vram_target                                       ; $15B0EF | |
    STX reg_ppu_vmadd                                                           ; $15B0F1 | |
    LDX <r_start_vram_dma_arg_address                                           ; $15B0F4 | |
    STX reg_cpu_a1t0                                                            ; $15B0F6 | |
    LDX <r_start_vram_dma_arg_bytes                                             ; $15B0F9 | |
    STX reg_cpu_das0                                                            ; $15B0FB | |
    LDA #%00000001.b                                                            ; $15B0FE | |
    STA reg_cpu_mdmaen                                                          ; $15B100 |/
    RTL                                                                         ; $15B103

; tileset_bank_data ($15:B104)
;
; For each of the sixteen tilesets, contains the bank number for the tileset
; tile data.
tileset_bank_data:
    .db :bank15.tileset_airship_ship_data                                       ; $15B104 | $00: Airship
    .db :bank1E.tileset_lunar_subterrane_data                                   ; $15B105 | $01: Lunar Core
    .db :bank1E.tileset_cavern_data                                             ; $15B106 | $02: Cavern
    .db :bank1D.tileset_castle_exterior_data                                    ; $15B107 | $03: Castle Exterior
    .db :bank1E.tileset_town_exterior_data                                      ; $15B108 | $04: Town Exterior
    .db :bank1E.tileset_town_interior_data                                      ; $15B109 | $05: Town Interior
    .db :bank1E.tileset_castle_interior_data                                    ; $15B10A | $06: Castle Interior
    .db :bank1E.tileset_crystal_room_data                                       ; $15B10B | $07: Crystal Room
    .db :bank1F.tileset_big_whale_tower_giant_data                              ; $15B10C | $08: Big Whale
    .db :bank1F.tileset_underworld_cave_data                                    ; $15B10D | $09: Underworld Cave
    .db :bank1F.tileset_big_whale_tower_giant_data                              ; $15B10E | $0A: Tower
    .db :bank1F.tileset_big_whale_tower_giant_data                              ; $15B10F | $0B: Giant
    .db :bank1E.tileset_lunar_subterrane_data                                   ; $15B110 | $0C: Lunar Subterrane
    .db :bank1F.tileset_mountain_data                                           ; $15B111 | $0D: Mountain
    .db :bank1F.tileset_waterway_data                                           ; $15B112 | $0E: Waterway
    .db :bank15.tileset_airship_ship_data                                       ; $15B113 | $0F: Ship

; clear_tilemap_vram_high ($15:B114)
;
; For the portion of VRAM used for dungeon tilemap data, sets the high bytes to
; zero.
clear_tilemap_vram_high:
    STZ reg_cpu_mdmaen                                                          ; $15B114 | Reset DMA.
    LDA #%10000000.b                                                            ; $15B117 |\
    STA reg_ppu_vmainc                                                          ; $15B119 | | Configure and execute a DMA transfer to set the high bytes of the
    LDA #%00001000.b                                                            ; $15B11C | | first $1800 words of VRAM to zero. This essentially clears the
    STA reg_cpu_dmap0                                                           ; $15B11E | | high bytes of the tiles that the game uses for tilemap data.
    LDA #<reg_ppu_vmdatah_write.b                                               ; $15B121 | |
    STA reg_cpu_bbad0                                                           ; $15B123 | |
    LDX #$0000.w                                                                ; $15B126 | |
    STX reg_ppu_vmadd                                                           ; $15B129 | |
    STZ <r_clear_tilemap_vram_high_tmp                                          ; $15B12C | |
    LDX #r_clear_tilemap_vram_high_tmp.w                                        ; $15B12E | |
    STX reg_cpu_a1t0                                                            ; $15B131 | |
    STZ reg_cpu_a1b0                                                            ; $15B134 | |
    LDX #$1800.w                                                                ; $15B137 | |
    STX reg_cpu_das0                                                            ; $15B13A | |
    LDA #%00000001.b                                                            ; $15B13D | |
    STA reg_cpu_mdmaen                                                          ; $15B13F |/
    RTL                                                                         ; $15B142

; copy_3bpp_tileset_to_vram ($15:B143)
;
; Executes a DMA to expand 3 bits per pixel graphical data and copy it to VRAM
; at $0000. Expects the DMA source address and bank to have already been set on
; DMA channel zero. Explicitly reads $2400 bytes from that location, expanding
; it to the full $3000 in VRAM.
copy_3bpp_tileset_to_vram:
    LDA #<reg_ppu_vmdatal_write.b                                               ; $15B143 |\ Set the DMA write address to write VRAM.
    STA reg_cpu_bbad0                                                           ; $15B145 |/
    LDX #$0000.w                                                                ; $15B148 |\ Set the VRAM write address to $0000.
    STX reg_ppu_vmadd                                                           ; $15B14B |/
    LDY #$0000.w                                                                ; $15B14E | Initialize the loop variable.
-   LDA #%10000000.b                                                            ; $15B151 |\ Set VRAM to increment 1 by 1, on high byte.
    STA reg_ppu_vmainc                                                          ; $15B153 |/
    LDA #%000000001.b                                                           ; $15B156 |\ Configure DMA to write two bytes.
    STA reg_cpu_dmap0                                                           ; $15B158 |/
    LDX #$0010.w                                                                ; $15B15B |\ Transfer 16 bytes.
    STX reg_cpu_das0                                                            ; $15B15E |/
    LDA #%00000001.b                                                            ; $15B161 |\ Enable the DMA transfer.
    STA reg_cpu_mdmaen                                                          ; $15B163 |/
    STZ reg_cpu_mdmaen                                                          ; $15B166 | Reset DMA.
    STZ reg_ppu_vmainc                                                          ; $15B169 | Set VRAM to increment 1 by 1, on low byte.
    STZ reg_cpu_dmap0                                                           ; $15B16C | Configure DMA to write one byte.
    LDX #$0008.w                                                                ; $15B16F |\ Transfer 8 bytes.
    STX reg_cpu_das0                                                            ; $15B172 |/
    LDA #%00000001.b                                                            ; $15B175 |\ Enable the DMA transfer.
    STA reg_cpu_mdmaen                                                          ; $15B177 |/
    INY                                                                         ; $15B17A |\
    CPY #$0180.w                                                                ; $15B17B | | Loop until 384 blocks have been copied.
    BNE -                                                                       ; $15B17E |/
    RTL                                                                         ; $15B180

; load_map_outdoor_tiles ($15:B181)
;
; Reads the current map area and loads the associates tiles to VRAM. This
; function assumes it's only called for an outdoor map and strange things
; will no doubt happen if that is violated.
load_map_outdoor_tiles:
    LDA #%10000000.b                                                            ; $15B181 |\
    STA reg_ppu_vmainc                                                          ; $15B183 | | Set the VRAM increment to 1x1 after high byte, and set the VRAM
    LDX #$0000.w                                                                ; $15B186 | | write address to $0000.
    STX reg_ppu_vmadd                                                           ; $15B189 |/
    LDA r_map_area.w                                                            ; $15B18C |\
    STA <r_load_map_outdoor_tiles_index_hi                                      ; $15B18F | | Calculate the index into the upper data by multiplying the map
    STZ <r_load_map_outdoor_tiles_index_lo                                      ; $15B191 | | area by $100 (as each area gets 256 bytes).
    LDX <r_load_map_outdoor_tiles_index                                         ; $15B193 |/
    LDY #$0000.w                                                                ; $15B195 |\
-   LDA bank14.tiles_map_outdoor_upper_data.l,X                                 ; $15B198 | | Copy the 256 bytes for this map area into the alternate CG-RAM
    STA r_alternate_cgram_data,Y                                                ; $15B19C | | area, despite not using it for CG-RAM data.
    INX                                                                         ; $15B19F | |
    INY                                                                         ; $15B1A0 | |
    CPY #$0100.w                                                                ; $15B1A1 | |
    BNE -                                                                       ; $15B1A4 |/
    LDA r_map_area.w                                                            ; $15B1A6 |\
    ASL A                                                                       ; $15B1A9 | | Calculate the index into the low data by multiplying by $2000.
    ASL A                                                                       ; $15B1AA | | Each map area gets 8192 bytes, one byte for every two pixels (as
    ASL A                                                                       ; $15B1AB | | only the lower half of each final byte is stored there).
    ASL A                                                                       ; $15B1AC | |
    ASL A                                                                       ; $15B1AD | |
    STA <r_load_map_outdoor_tiles_index_hi                                      ; $15B1AE | |
    STZ <r_load_map_outdoor_tiles_index_lo                                      ; $15B1B0 | |
    LDX <r_load_map_outdoor_tiles_index                                         ; $15B1B2 | |
    LDY #$0000.w                                                                ; $15B1B4 |/
-   LDA bank1D.tiles_map_outdoor_lower_data.l,X                                 ; $15B1B7 |\
    STA <r_load_map_outdoor_tiles_tmp                                           ; $15B1BB | | Load the byte, save it for later use, mask out the four bits we
    INX                                                                         ; $15B1BD | | care about, add the upper bits saved earlier, and then send the
    AND #%00001111.b                                                            ; $15B1BE | | final value to VRAM.
    CLC                                                                         ; $15B1C0 | |
    ADC r_alternate_cgram_data,Y                                                ; $15B1C1 | |
    STA reg_ppu_vmdatah_write                                                   ; $15B1C4 |/
    LDA <r_load_map_outdoor_tiles_tmp                                           ; $15B1C7 |\
    LSR A                                                                       ; $15B1C9 | | Repeat the process, except using the upper four bits of the read
    LSR A                                                                       ; $15B1CA | | byte.
    LSR A                                                                       ; $15B1CB | |
    LSR A                                                                       ; $15B1CC | |
    CLC                                                                         ; $15B1CD | |
    ADC r_alternate_cgram_data,Y                                                ; $15B1CE | |
    STA reg_ppu_vmdatah_write                                                   ; $15B1D1 | |
    TXA                                                                         ; $15B1D4 |/
    AND #%00011111.b                                                            ; $15B1D5 |\ Loop until the X register reaches $20.
    BNE -                                                                       ; $15B1D7 |/
    INY                                                                         ; $15B1D9 |\  Increment the Y index to change the upper bits and then loop until
    CPY #$0100.w                                                                ; $15B1DA | | all 256 bytes have been used (and all 256 tiles have been copied
    BNE -                                                                       ; $15B1DD |/  into VRAM.
    RTL                                                                         ; $15B1DF

; draw_dungeon_field_sprite_player ($15:B1E0)
;
; Draws the player field sprite at the correct location in the center of the
; screen by setting the correct bytes in the RAM OAM mirror, which will be
; transferred to the OAM during the NMI. Also handles masking effects such as
; the lower half of the sprite being hidden or being entirely hidden. Also
; handles sprite animations during movement.
draw_dungeon_field_sprite_player:
    LDA <r_player_field_sprite_invisible                                        ; $15B1E0 |\
    BEQ +                                                                       ; $15B1E2 | | Skip this function if the player field sprite is invisible.
    RTL                                                                         ; $15B1E4 |/
+   PHB                                                                         ; $15B1E5 |\
    LDA #$15.b                                                                  ; $15B1E6 | | Preserve the data bank register and set it to $15.
    PHA                                                                         ; $15B1E8 | |
    PLB                                                                         ; $15B1E9 |/
    LDA r_field_sprite_slot.w                                                   ; $15B1EA |\
    STZ <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B1ED | | Calculate the offset into the character field data by multiplying
    LSR A                                                                       ; $15B1EF | | the slot by 64.
    ROR <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B1F0 | |
    LSR A                                                                       ; $15B1F2 | |
    ROR <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B1F3 | |
    STA <r_draw_field_sprite_player_tmp_offset_hi                               ; $15B1F5 | |
    LDX <r_draw_field_sprite_player_tmp_offset                                  ; $15B1F7 |/
    LDA r_character_field.1.sprite_class.w,X                                    ; $15B1F9 |\
    AND #%00011111.b                                                            ; $15B1FC | | Load the correct palette data for the current sprite.
    TAX                                                                         ; $15B1FE | |
    LDA player_field_sprite_palette_index_data.w,X                              ; $15B1FF | |
    ASL A                                                                       ; $15B202 | |
    STA r_draw_field_sprite_player_palette.w                                    ; $15B203 |/
    LDA <r_enable_spinning                                                      ; $15B206 |\
    BEQ +                                                                       ; $15B208 | | If spinning is currently enabled, set the current direction to
    LDA #DIRECTION_SPINNING.b                                                   ; $15B20A | | spinning.
    STA r_direction.w                                                           ; $15B20C |/
+   LDA r_direction.w                                                           ; $15B20F |\
    CMP #DIRECTION_SPINNING.b                                                   ; $15B212 | | If the direction is set to spinning, calculate the direction by
    BNE +                                                                       ; $15B214 | | dividing the movement frame counter by 8 (so the sprite changes
    LDA <r_movement_frame_counter                                               ; $15B216 | | every eight frames. In addition, add two and take the result mod
    CLC                                                                         ; $15B218 | | 4 so that the first frame in the sequence is facing down rather
    ADC #16.b                                                                   ; $15B219 | | than facing up.
    LSR A                                                                       ; $15B21B | |
    LSR A                                                                       ; $15B21C | |
    LSR A                                                                       ; $15B21D | |
    AND #%00000011.b                                                            ; $15B21E |/
+   ASL A                                                                       ; $15B220 |\
    ASL A                                                                       ; $15B221 | | Calculate an index by multiplying the direction by 16.
    ASL A                                                                       ; $15B222 | |
    ASL A                                                                       ; $15B223 | |
    STA <r_draw_field_sprite_tmp                                                ; $15B224 |/
    STZ <r_draw_field_sprite_player_tmp_shift                                   ; $15B226 | Initialize the shift value to zero.
    LDA r_direction.w                                                           ; $15B228 |\
    CMP #DIRECTION_SPINNING.b                                                   ; $15B22B | | If the character is spinning, skip ahead a bit.
    BEQ ++                                                                      ; $15B22D |/
    CMP #DIRECTION_WAVING_1.b                                                   ; $15B22F |\
    BCS +                                                                       ; $15B231 | | If the character has a normal direction, skip ahead unless they
    LDA <r_movement_direction                                                   ; $15B233 | | are moving.
    BEQ ++                                                                      ; $15B235 |/
+   LDA <r_movement_frame_counter                                               ; $15B237 |\
    AND #%00001000.b                                                            ; $15B239 | | If we reach this point, the sprite is either moving or doing one
    CLC                                                                         ; $15B23B | | of the special poses. Calculate the index by adding bit 3 of the
    ADC <r_draw_field_sprite_tmp                                                ; $15B23C | | movement frame counter (changes every eight frames).
    STA <r_draw_field_sprite_tmp                                                ; $15B23E |/
    LDA <r_movement_direction                                                   ; $15B240 |\
    AND #MOVEMENT_DIRECTION_VERTICAL.b                                          ; $15B242 | | If the sprite is moving horizontally, calculate the shift value
    BNE ++                                                                      ; $15B244 | | to alternate between 0 and 1 every eight frames.
    LDA <r_movement_frame_counter                                               ; $15B246 | |
    AND #%00001000.b                                                            ; $15B248 | |
    LSR A                                                                       ; $15B24A | |
    LSR A                                                                       ; $15B24B | |
    LSR A                                                                       ; $15B24C | |
    STA <r_draw_field_sprite_player_tmp_shift                                   ; $15B24D |/
++  LDA <r_draw_field_sprite_tmp                                                ; $15B24F |\ Load the calculated index and put it in the X register.
    TAX                                                                         ; $15B251 |/
    LDY #$0000.w                                                                ; $15B252 | Initialize the Y register to zero.
-   LDA player_field_sprite_coordinate_data,Y                                   ; $15B255 |\
    STA r_oam.93,Y                                                              ; $15B258 | | Set the tile's X coordinate by reading from ROM.
    INY                                                                         ; $15B25B |/
    LDA player_field_sprite_coordinate_data,Y                                   ; $15B25C |\
    SEC                                                                         ; $15B25F | | Set the tile's Y coordinate by reading from ROM, but subtracting
    SBC <r_draw_field_sprite_player_tmp_shift                                   ; $15B260 | | any potential shift value.
    STA r_oam.93,Y                                                              ; $15B262 | |
    INY                                                                         ; $15B265 |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B266 |\
    STA r_oam.93,Y                                                              ; $15B269 | | Set the tile number.
    INX                                                                         ; $15B26C | |
    INY                                                                         ; $15B26D |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B26E |\
    AND #%11110001.b                                                            ; $15B271 | | Set the flags, replacing the palette with the correct palette for
    CLC                                                                         ; $15B273 | | this sprite.
    ADC r_draw_field_sprite_player_palette.w                                    ; $15B274 | |
    STA r_oam.93,Y                                                              ; $15B277 | |
    INX                                                                         ; $15B27A | |
    INY                                                                         ; $15B27B |/
    CPY #$0008.w                                                                ; $15B27C |\ Loop until the two top tiles have been set.
    BNE -                                                                       ; $15B27F |/
    LDY #$0000.w                                                                ; $15B281 |\
-   LDA player_field_sprite_coordinate_data + 8,Y                               ; $15B284 | | Set the tile's X coordinate.
    STA r_oam.125,Y                                                             ; $15B287 | |
    INY                                                                         ; $15B28A |/
    LDA player_field_sprite_coordinate_data + 8,Y                               ; $15B28B |\
    SEC                                                                         ; $15B28E | | Set the tile's Y coordinate, subtracting any shift value.
    SBC <r_draw_field_sprite_player_tmp_shift                                   ; $15B28F | |
    STA r_oam.125,Y                                                             ; $15B291 | |
    INY                                                                         ; $15B294 |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B295 |\
    STA r_oam.125,Y                                                             ; $15B298 | | Set the tile number.
    INX                                                                         ; $15B29B | |
    INY                                                                         ; $15B29C |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B29D |\
    AND #%11110001.b                                                            ; $15B2A0 | | Set the tile's flags, replacing the palette with the correct
    CLC                                                                         ; $15B2A2 | | palette.
    ADC r_draw_field_sprite_player_palette.w                                    ; $15B2A3 | |
    STA r_oam.125,Y                                                             ; $15B2A6 | |
    INX                                                                         ; $15B2A9 | |
    INY                                                                         ; $15B2AA |/
    CPY #$0008.w                                                                ; $15B2AB |\ Loop until both bottom tiles have been set.
    BNE -                                                                       ; $15B2AE |/
    LDA <r_tile_properties_current.properties_2                                 ; $15B2B0 |\
    AND #TILE_PROPERTY_2_HIDE_LOWER.b                                           ; $15B2B2 | | If the current tile has the "hide lower" property, the top two
    BEQ +                                                                       ; $15B2B4 | | tiles have their priority increased, and the lower tiles have
    LDA r_oam.93.flags.w                                                        ; $15B2B6 | | their priority set to zero.
    ORA #%00100000.b                                                            ; $15B2B9 | |
    STA r_oam.93.flags.w                                                        ; $15B2BB | | Technically, the top two tiles have their high priority bit set,
    LDA r_oam.94.flags.w                                                        ; $15B2BE | | which was probably already set anyway.
    ORA #%00100000.b                                                            ; $15B2C1 | |
    STA r_oam.94.flags.w                                                        ; $15B2C3 | |
    LDA r_oam.125.flags.w                                                       ; $15B2C6 | |
    AND #%11001111.b                                                            ; $15B2C9 | |
    STA r_oam.125.flags.w                                                       ; $15B2CB | |
    LDA r_oam.126.flags.w                                                       ; $15B2CE | |
    AND #%11001111.b                                                            ; $15B2D1 | |
    STA r_oam.126.flags.w                                                       ; $15B2D3 |/
+   LDA <r_tile_properties_current.properties_2                                 ; $15B2D6 |\
    AND #TILE_PROPERTY_2_WALK_BEHIND.b                                          ; $15B2D8 | | If the current tile has the walk behind property set and is either
    BEQ ++                                                                      ; $15B2DA | | not a bridge or if it is a bridge, the player is not on the bridge
    LDA <r_tile_properties_current.properties_1                                 ; $15B2DC | | move the four tiles so the sprite is not drawn on screen.
    AND #TILE_PROPERTY_1_DUNGEON_BRIDGE.b                                       ; $15B2DE | |
    BEQ +                                                                       ; $15B2E0 | |
    LDA <r_tile_properties_current.properties_1                                 ; $15B2E2 | |
    AND #TILE_PROPERTY_1_DUNGEON_LAYER_1 | TILE_PROPERTY_1_DUNGEON_LAYER_2.b    ; $15B2E4 | |
    AND <r_current_map_layer                                                    ; $15B2E6 | |
    BNE ++                                                                      ; $15B2E8 | |
+   LDA #248.b                                                                  ; $15B2EA | |
    STA r_oam.93.y.w                                                            ; $15B2EC | |
    STA r_oam.94.y.w                                                            ; $15B2EF | |
    STA r_oam.125.y.w                                                           ; $15B2F2 | |
    STA r_oam.126.y.w                                                           ; $15B2F5 |/
++  PLB                                                                         ; $15B2F8 |/
    RTL                                                                         ; $15B2F9

; player_field_sprite_palette_index_data ($15:B2FA)
;
; For each possible player field sprite, designates the proper palette index to
; use with that sprite.
player_field_sprite_palette_index_data:
    .db 0                                                                       ; $15B2FA | $00 | Cecil (dark knight)
    .db 0                                                                       ; $15B2FB | $01 | Kain
    .db 1                                                                       ; $15B2FC | $02 | Rydia (child)
    .db 2                                                                       ; $15B2FD | $03 | Tellah
    .db 2                                                                       ; $15B2FE | $04 | Edward
    .db 2                                                                       ; $15B2FF | $05 | Rosa
    .db 0                                                                       ; $15B300 | $06 | Yang
    .db 1                                                                       ; $15B301 | $07 | Palom
    .db 1                                                                       ; $15B302 | $08 | Porom
    .db 3                                                                       ; $15B303 | $09 | Cecil (paladin)
    .db 0                                                                       ; $15B304 | $0A | Cid
    .db 1                                                                       ; $15B305 | $0B | Rydia (adult)
    .db 0                                                                       ; $15B306 | $0C | Edge
    .db 0                                                                       ; $15B307 | $0D | FuSoYa

    .dsb 4 $00                                                                  ; $15B308 | $0E.$11

; draw_outdoor_field_sprite_player ($15:B30C)
;
; Draws the player field sprite at the correct location in the center of the
; screen by setting the correct bytes in the RAM OAM mirror, which will be
; transferred to the OAM during the NMI.
draw_outdoor_field_sprite_player:
    LDA <r_player_field_sprite_invisible                                        ; $15B30C |\
    BEQ +                                                                       ; $15B30E | | Skip this function if the player sprite is invisible.
    RTL                                                                         ; $15B310 |/
+   LDA <r_zoom_level                                                           ; $15B311 |\
    CMP #$10.b                                                                  ; $15B313 | | If the zoom level is currently set to anything other than minimum,
    BNE +                                                                       ; $15B315 | | skip this function. Otherwise, make sure the player is currently
    LDA r_vehicle.w                                                             ; $15B317 | | not in a vehicle.
    BEQ ++                                                                      ; $15B31A | |
+   RTL                                                                         ; $15B31C |/
++  PHB                                                                         ; $15B31D |\
    LDA #$15.b                                                                  ; $15B31E | | Set the data bank register to $15.
    PHA                                                                         ; $15B320 | |
    PLB                                                                         ; $15B321 |/
    LDA r_field_sprite_slot.w                                                   ; $15B322 |\
    STZ <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B325 | | Calculate the offset by multiplying the slot number by 64.
    LSR A                                                                       ; $15B327 | |
    ROR <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B328 | |
    LSR A                                                                       ; $15B32A | |
    ROR <r_draw_field_sprite_player_tmp_offset_lo                               ; $15B32B | |
    STA <r_draw_field_sprite_player_tmp_offset_hi                               ; $15B32D | |
    LDX <r_draw_field_sprite_player_tmp_offset                                  ; $15B32F |/
    LDA r_character_field.1.sprite_class.w,X                                    ; $15B331 |\
    AND #%00011111.b                                                            ; $15B334 | | Determine the active character's sprite index.
    TAX                                                                         ; $15B336 |/
    LDA player_field_sprite_palette_index_data.w,X                              ; $15B337 |\
    ASL A                                                                       ; $15B33A | | Store the sprite palette index times two for later use.
    STA r_draw_field_sprite_player_palette.w                                    ; $15B33B |/
    LDA r_direction.w                                                           ; $15B33E |\
    ASL A                                                                       ; $15B341 | | Determine the sprite index by multiplying the direction by 16.
    ASL A                                                                       ; $15B342 | |
    ASL A                                                                       ; $15B343 | |
    ASL A                                                                       ; $15B344 | |
    STA <r_draw_field_sprite_tmp                                                ; $15B345 |/
    STZ <r_draw_field_sprite_player_tmp_shift                                   ; $15B347 | Set the vertical shift to zero.
    LDA <r_movement_direction                                                   ; $15B349 |\
    BEQ +                                                                       ; $15B34B | | If the player is currently moving, determine which frame of
    LDA <r_movement_frame_counter                                               ; $15B34D | | animation to use by checking the movement frame counter. The frame
    AND #%00001000.b                                                            ; $15B34F | | changes every 8 frames.
    CLC                                                                         ; $15B351 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B352 |/
    STA <r_draw_field_sprite_tmp                                                ; $15B354 |\
    LDA <r_movement_direction                                                   ; $15B356 | | If the player is moving horizontally, set the vertical shift to
    AND #MOVEMENT_DIRECTION_VERTICAL.b                                          ; $15B358 | | 1 on the same rhythm (eight frames off, eight frames on). This
    BNE +                                                                       ; $15B35A | | results in the second frame of animation being shifted one pixel
    LDA <r_movement_frame_counter                                               ; $15B35C | | higher, which enhances the walking effect.
    AND #%00001000.b                                                            ; $15B35E | |
    LSR A                                                                       ; $15B360 | |
    LSR A                                                                       ; $15B361 | |
    LSR A                                                                       ; $15B362 | |
    STA <r_draw_field_sprite_player_tmp_shift                                   ; $15B363 |/
+   LDA <r_draw_field_sprite_tmp                                                ; $15B365 |\ Load the sprite index and put it in the X register.
    TAX                                                                         ; $15B367 |/
    LDY #$0000.w                                                                ; $15B368 |\
-   LDA player_field_sprite_coordinate_data.w,Y                                 ; $15B36B | | Set the tile's X coordinate.
    STA r_oam.82,Y                                                              ; $15B36E | |
    INY                                                                         ; $15B371 |/
    LDA player_field_sprite_coordinate_data.w,Y                                 ; $15B372 |\
    SEC                                                                         ; $15B375 | | Set the tile's Y coordinate, subtracting the calculated vertical
    SBC <r_draw_field_sprite_player_tmp_shift                                   ; $15B376 | | shift.
    STA r_oam.82,Y                                                              ; $15B378 | |
    INY                                                                         ; $15B37B |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B37C |\
    STA r_oam.82,Y                                                              ; $15B37F | | Set the tile number.
    INX                                                                         ; $15B382 | |
    INY                                                                         ; $15B383 |/
    LDA player_field_sprite_oam_data.w,X                                        ; $15B384 |\
    AND #%11110001.b                                                            ; $15B387 | | Set the tile flags. Importantly, any existing palette data is
    CLC                                                                         ; $15B389 | | masked out and replaced with the palette calculated earlier. The
    ADC r_draw_field_sprite_player_palette.w                                    ; $15B38A | | multiplying by two was to ensure it would occupy the correct bits
    STA r_oam.82,Y                                                              ; $15B38D | | here.
    INX                                                                         ; $15B390 | |
    INY                                                                         ; $15B391 |/
    CPY #$0010.w                                                                ; $15B392 |\ Loop until all 16 bytes have been copied.
    BNE -                                                                       ; $15B395 |/
    LDA <r_tile_properties_current.properties_2                                 ; $15B397 |\
    AND #TILE_PROPERTY_2_HIDE_LOWER.b                                           ; $15B399 | | If the player is currently standing on a tile that has the hide
    BEQ +                                                                       ; $15B39B | | lower property set, lower the priority of the two lower tiles so
    LDA r_oam.84.flags.w                                                        ; $15B39D | | they are invisible.
    AND #%11001111.b                                                            ; $15B3A0 | |
    STA r_oam.84.flags.w                                                        ; $15B3A2 | |
    LDA r_oam.85.flags.w                                                        ; $15B3A5 | |
    AND #%11001111.b                                                            ; $15B3A8 | |
    STA r_oam.85.flags.w                                                        ; $15B3AA |/
+   PLB                                                                         ; $15B3AD | Restore the data bank register.
    RTL                                                                         ; $15B3AE

; set_oam_hi_x ($15:B3AF)
;
; Given a base sprite number in the accumulator and an index to the actual
; sprite number in the Y register (which needs to be divided by four to get an
; actual sprite number), sets the high bit in the high OAM table for the X
; coordinate.
set_oam_hi_x:
    PHX                                                                         ; $15B3AF |\
    PHY                                                                         ; $15B3B0 | | Preserve various registers.
    PHA                                                                         ; $15B3B1 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $15B3B2 |\
    TYA                                                                         ; $15B3B4 | | Divide the value in the Y register by 4, which gives us the sprite
    LSR A                                                                       ; $15B3B5 | | number relative to the base location.
    LSR A                                                                       ; $15B3B6 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15B3B7 | |
    STA <r_set_oam_hi_x_tmp                                                     ; $15B3B9 |/
    PLA                                                                         ; $15B3BB |\
    CLC                                                                         ; $15B3BC | | Calculate the index into the bit table by determining the total
    ADC <r_set_oam_hi_x_tmp                                                     ; $15B3BD | | sprite number and then taking the lowest two bits, and then store
    PHA                                                                         ; $15B3BF | | the value for later use. Push the total sprite number to the
    AND #%00000011.b                                                            ; $15B3C0 | | stack.
    TAX                                                                         ; $15B3C2 | |
    LDA oam_hi_x_bit_data.l,X                                                   ; $15B3C3 | |
    STA <r_set_oam_hi_x_tmp                                                     ; $15B3C7 |/
    PLA                                                                         ; $15B3C9 |\
    LSR A                                                                       ; $15B3CA | | Restore the total sprite number and divide by 4 to determine the
    LSR A                                                                       ; $15B3CB | | index into the high OAM table.
    TAY                                                                         ; $15B3CC |/
    LDA r_oam_hi,Y                                                              ; $15B3CD |\
    ORA <r_set_oam_hi_x_tmp                                                     ; $15B3D0 | | Set the appropriate bit and re-store it in the high OAM table.
    STA r_oam_hi,Y                                                              ; $15B3D2 |/
    PLY                                                                         ; $15B3D5 |\ Restore the other registers.
    PLX                                                                         ; $15B3D6 |/
    RTL                                                                         ; $15B3D7

; oam_hi_x_bit_data ($15:B3D8)
;
; Indexed by the lower two bits of a sprite number, this table gives the correct
; value to ORA into a value for storing in the high OAM table.
oam_hi_x_bit_data:
    .db %00000001                                                               ; $15B3D8
    .db %00000100                                                               ; $15B3D9
    .db %00010000                                                               ; $15B3DA
    .db %01000000                                                               ; $15B3DB

; draw_field_sprite_yellow_chocobo ($15:B3DC)
;
; Draws the yellow chocobo by putting the correct information about the sprite
; into the OAM tables to eventually be copied to the real OAM tables during NMI.
; Interestingly, this function has some presumably unused code that suggests at
; least some development was spent on having a yellow chocobo that could be
; parked. Why this was abandoned is, of course, unknown.
draw_field_sprite_yellow_chocobo:
    PHB                                                                         ; $15B3DC |\
    LDA #$15.b                                                                  ; $15B3DD | | Set the data bank register to $15.
    PHA                                                                         ; $15B3DF | |
    PLB                                                                         ; $15B3E0 |/
    LDA r_yellow_chocobo_status.w                                               ; $15B3E1 |\ Only continue if a yellow chocobo is active.
    BEQ +                                                                       ; $15B3E4 |/
    CMP #YELLOW_CHOCOBO_STATUS_LEAVING.b                                        ; $15B3E6 |\ If the chocobo is currently leaving, branch accordingly.
    BEQ @leaving                                                                ; $15B3E8 |/
    LDA r_map_plane.w                                                           ; $15B3EA |\ If the map plane is anything other than zero, skip this function.
    BNE +                                                                       ; $15B3ED |/
    LDA <r_zoom_level                                                           ; $15B3EF |\
    CMP #$10.b                                                                  ; $15B3F1 | | Skip this function if the zoom level is anything other than ground
    BEQ ++                                                                      ; $15B3F3 | | level.
+   JMP @done                                                                   ; $15B3F5 |/
++  LDA r_vehicle.w                                                             ; $15B3F8 |\
    CMP #VEHICLE_YELLOW_CHOCOBO.b                                               ; $15B3FB | | This section of code will only run if a yellow chocobo is active,
    BEQ @active                                                                 ; $15B3FD | | but not the current vehicle. As far as I know, this situation does
    LDA r_yellow_chocobo_coordinates.x.w                                        ; $15B3FF | | not occur in the game. It suggests there was an abandoned ability
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B402 | | to park the yellow chocobo.
    LDA r_yellow_chocobo_coordinates.y.w                                        ; $15B404 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B407 | |
    JSL check_coordinates_visible                                               ; $15B409 | |
    LDA <r_check_coordinates_visible_result                                     ; $15B40D | |
    BNE +                                                                       ; $15B40F | |
    JMP @done                                                                   ; $15B411 | |
+   LDA #DIRECTION_LEFT.b                                                       ; $15B414 | |
    JMP ++                                                                      ; $15B416 |/
@leaving:
    LDA r_yellow_chocobo_coordinates.x.w                                        ; $15B419 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B41C | | If the chocobo is currently returning to the forest, set the X and
    LDA r_yellow_chocobo_coordinates.y.w                                        ; $15B41E | | Y coordinates to its coordinates in RAM.
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B421 | |
    JMP +                                                                       ; $15B423 |/
@active:
    LDA #112.b                                                                  ; $15B426 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B428 | | If the chocobo is currently active, set the coordinates to the
    LDA #112.b                                                                  ; $15B42A | | near center point where the player field sprite is.
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B42C |/
+   STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15B42E |\ Zero out the high bytes of the coordinates.
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15B430 |/
    LDA r_direction.w                                                           ; $15B432 |\
++  ASL A                                                                       ; $15B435 | | Multiply the direction by 32 to generate the first part of the
    ASL A                                                                       ; $15B436 | | index into the sprite data. (Each direction has 32 bytes of data.)
    ASL A                                                                       ; $15B437 | |
    ASL A                                                                       ; $15B438 | |
    ASL A                                                                       ; $15B439 | |
    STA <r_draw_field_sprite_tmp                                                ; $15B43A |/
    LDA r_vehicle.w                                                             ; $15B43C |\
    CMP #VEHICLE_YELLOW_CHOCOBO.b                                               ; $15B43F | | If the current vehicle is not a yellow chocobo, the first frame
    BNE +                                                                       ; $15B441 | | of the animation is always drawn. If the player is not currently
    LDA <r_movement_direction                                                   ; $15B443 | | moving, the first frame of the animation is always drawn.
    BEQ ++                                                                      ; $15B445 | | Otherwise, which of the two frames is determined by bit 3 of the
    LDA <r_map_frame_counter                                                    ; $15B447 | | map frame counter. This results in the animation frame alternating
    AND #%00000100.b                                                            ; $15B449 | | every four frames. If the second frame is chosen, 16 is added to
    ASL A                                                                       ; $15B44B | | the index.
    ASL A                                                                       ; $15B44C | |
    JMP ++                                                                      ; $15B44D | |
+   LDA #$00.b                                                                  ; $15B450 | |
++  CLC                                                                         ; $15B452 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B453 | |
    TAX                                                                         ; $15B455 |/
    LDY #$0000.w                                                                ; $15B456 |\
-   LDA yellow_chocobo_oam_data.w,X                                             ; $15B459 | | The X coordinate in the OAM data is added to the previously set X
    CLC                                                                         ; $15B45C | | coordinate to determine the final X coordinate the tile should be
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B45D | | drawn.
    STA r_oam.101.x,Y                                                           ; $15B45F |/
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B462 |\
    ADC #$00.b                                                                  ; $15B464 | | If the X coordinate overflows, a routine is called to set the high
    AND #%00000001.b                                                            ; $15B466 | | bit in the high OAM table.
    BEQ +                                                                       ; $15B468 | |
    LDA #100.b                                                                  ; $15B46A | |
    JSL set_oam_hi_x                                                            ; $15B46C |/
+   LDA yellow_chocobo_oam_data.w + 1,X                                         ; $15B470 |\
    CLC                                                                         ; $15B473 | | Set the remaining three fields of the OAM data.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B474 | |
    STA r_oam.101.y,Y                                                           ; $15B476 | |
    LDA yellow_chocobo_oam_data.w + 2,X                                         ; $15B479 | |
    STA r_oam.101.tile,Y                                                        ; $15B47C | |
    LDA yellow_chocobo_oam_data.w + 3,X                                         ; $15B47F | |
    STA r_oam.101.flags,Y                                                       ; $15B482 |/
    INX                                                                         ; $15B485 |\
    INX                                                                         ; $15B486 | | Both the X and Y indexes are incremented by 4 and the loop is
    INX                                                                         ; $15B487 | | repeated until the Y index register is set to 16. (This copies
    INX                                                                         ; $15B488 | | four bytes for each of the four tiles of the sprite.)
    INY                                                                         ; $15B489 | |
    INY                                                                         ; $15B48A | |
    INY                                                                         ; $15B48B | |
    INY                                                                         ; $15B48C | |
    CPY #$0010.w                                                                ; $15B48D | |
    BNE -                                                                       ; $15B490 |/
    LDA r_vehicle.w                                                             ; $15B492 |\
    CMP #VEHICLE_YELLOW_CHOCOBO                                                 ; $15B495 | | If the current vehicle is not the yellow chocobo, nothing needs to
    BNE +                                                                       ; $15B497 | | be done here.
    LDA <r_tile_properties_current.properties_2                                 ; $15B499 | |
    AND #TILE_PROPERTY_2_HIDE_LOWER.b                                           ; $15B49B | | If the current tile has bit 3 set in its second properties byte,
    STA r_yellow_chocobo_display_flags.w                                        ; $15B49D | | lower the priority of the lower two tiles of the sprite so they
+   LDA r_yellow_chocobo_display_flags.w                                        ; $15B4A0 | | do not display. (This creates the effect when walking in the water
    BEQ @done                                                                   ; $15B4A3 | | or in forests.)
    LDA r_oam.103.flags.w                                                       ; $15B4A5 | |
    AND #%11001111.b                                                            ; $15B4A8 | |
    STA r_oam.103.flags.w                                                       ; $15B4AA | |
    LDA r_oam.104.flags.w                                                       ; $15B4AD | |
    AND #%11001111.b                                                            ; $15B4B0 | |
    STA r_oam.104.flags.w                                                       ; $15B4B2 |/
@done:
    PLB                                                                         ; $15B4B5 | Restore the data bank register to its original value.
    RTL                                                                         ; $15B4B6

; _draw_zoomed_vehicle ($15:B4B7)
;
; Given a vehicle number in the accumulator, draws the sprite based on the
; current zoom level (which should be at either airship or Big Whale zoom).
; This function assumes it is run as part of one of the field sprite draw
; routines and should not be called otherwise.
_draw_zoomed_vehicle:
    SEC                                                                         ; $15B4B7 |\
    SBC #2.b                                                                    ; $15B4B8 | | Calculate the index. Since this function ignores the first two
    TAX                                                                         ; $15B4BA | | vehicles, the index is calculated by subtracting 2 from the
    ASL A                                                                       ; $15B4BB | | vehicle. The Y register, used to index the OAM data, is calculated
    ASL A                                                                       ; $15B4BC | | by multiplying this value by 4 (so each vehicle gets its own).
    TAY                                                                         ; $15B4BD |/
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15B4BE |\
    SEC                                                                         ; $15B4C0 | | Set the X and Y coordinates in the OAM. The X coordinate is set to
    SBC #4.b                                                                    ; $15B4C1 | | the value in the parameter minus four. If this is negative, the Y
    BCS +                                                                       ; $15B4C3 | | coordinate is set to 248 (to make the sprite invisible) and the X
    LDA #248.b                                                                  ; $15B4C5 | | coordinate isn't actually set.
    STA r_oam.125.y,Y                                                           ; $15B4C7 | |
    JMP ++                                                                      ; $15B4CA | | Otherwise, the Y coordinate is set to the passed Y coordinate
+   STA r_oam.125.x,Y                                                           ; $15B4CD | | minus five.
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15B4D0 | |
    SEC                                                                         ; $15B4D2 | |
    SBC #5.b                                                                    ; $15B4D3 | |
    STA r_oam.125.y,Y                                                           ; $15B4D5 |/
++  LDA <r_zoom_level                                                           ; $15B4D8 |\
    LSR A                                                                       ; $15B4DA | | Calculate the tile offset by taking into account the vehicle and
    LSR A                                                                       ; $15B4DB | | the zoom level. The actual sprites are in VRAM starting at tile
    LSR A                                                                       ; $15B4DC | | $30, and each vehicle has two sprites, one for each zoom level.
    LSR A                                                                       ; $15B4DD | |
    DEC A                                                                       ; $15B4DE | |
    DEC A                                                                       ; $15B4DF | |
    STA <r_draw_zoomed_vehicle_tmp                                              ; $15B4E0 | |
    TXA                                                                         ; $15B4E2 | |
    ASL A                                                                       ; $15B4E3 | |
    CLC                                                                         ; $15B4E4 | |
    ADC <r_draw_zoomed_vehicle_tmp                                              ; $15B4E5 | |
    ADC #$30.b                                                                  ; $15B4E7 | |
    STA r_oam.125.tile,Y                                                        ; $15B4E9 |/
    LDA zoomed_vehicle_oam_flags_data.l,X                                       ; $15B4EC |\ Read the appropriate flags and set them in the OAM.
    STA r_oam.125.flags,Y                                                       ; $15B4F0 |/
    PLB                                                                         ; $15B4F3 | Restore the value of the data bank register.
    RTL                                                                         ; $15B4F4

; zoomed_vehicle_oam_flags_data ($15:B4F5)
;
; Provides the necessary flags to put the four zoomed vehicles (other than the
; Big Whale) into the OAM. In particular, for each of the four, it sets the
; priority to 1 and sets the appropriate palette number.
zoomed_vehicle_oam_flags_data:
    .db (1 << 4) + (5 << 1)                                                     ; $15B4F5 | $00: Black Chocobo
    .db (1 << 4) + (4 << 1)                                                     ; $15B4F6 | $01: Hovercraft
    .db (1 << 4) + (4 << 1)                                                     ; $15B4F7 | $02: Enterprise
    .db (1 << 4) + (6 << 1)                                                     ; $15B4F8 | $03: Falcon

; draw_field_sprite_black_chocobo ($15:B4F9)
;
; Draws the black chocobo field sprite if appropriate. Actually put data in the
; OAM staging area, which will ultimately be drawn when transferred by the NMI
; handler.
draw_field_sprite_black_chocobo:
    PHB                                                                         ; $15B4F9 |\
    LDA #$15.b                                                                  ; $15B4FA | | Set the data bank register to $15.
    PHA                                                                         ; $15B4FC | |
    PLB                                                                         ; $15B4FD |/
    LDA r_black_chocobo_status.w                                                ; $15B4FE |\
    BEQ +                                                                       ; $15B501 | | Skip this function if the black chocobo is inactive or if the map
    LDA r_map_plane.w                                                           ; $15B503 | | plane is anything but zero.
    BNE +                                                                       ; $15B506 |/
    LDA r_vehicle.w                                                             ; $15B508 |\
    CMP #VEHICLE_BLACK_CHOCOBO.b                                                ; $15B50B | | If the current vehicle is the black chocobo, move to that section.
    BEQ @active                                                                 ; $15B50D |/
    LDA <r_zoom_level                                                           ; $15B50F |\
    AND #%00001111.b                                                            ; $15B511 | | Skip this function if the zoom level mod 16 is not zero.
    BNE +                                                                       ; $15B513 |/
    LDA r_black_chocobo_coordinates.x.w                                         ; $15B515 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B518 | | If there is an active black chocobo, but it is not the active
    LDA r_black_chocobo_coordinates.y.w                                         ; $15B51A | | vehicle, first check that it's coordinates make it visible.
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B51D | |
    JSL check_coordinates_visible                                               ; $15B51F | |
    LDA <r_check_coordinates_visible_result                                     ; $15B523 | |
    BNE ++                                                                      ; $15B525 | |
+   JMP @done                                                                   ; $15B527 |/
++  LDA <r_zoom_level                                                           ; $15B52A |\
    CMP #$10.b                                                                  ; $15B52C | | If the black chocobo is not the active vehicle, and the zoom level
    BEQ +                                                                       ; $15B52E | | is anything other than $10, switch to drawing the zoomed version
    LDA #VEHICLE_BLACK_CHOCOBO.b                                                ; $15B530 | | of the vehicle. If the zoom level is $10, set the accumulator to
    JMP _draw_zoomed_vehicle                                                    ; $15B532 | | 3 and skip to the next part of the function.
+   LDA #DIRECTION_LEFT.b                                                       ; $15B535 | |
    JMP +                                                                       ; $15B537 |/
@active:
    LDA #$00.b                                                                  ; $15B53A |\ Draw the shadow for the black chocobo.
    JSL draw_field_sprite_shadow                                                ; $15B53C |/
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15B540 |\
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15B542 | | Set the coordinates of the black chocobo to 112,112 except
    LDA #112.b                                                                  ; $15B544 | | subtract the chocobo's current altitude from the Y coordinate.
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B546 | |
    LDA #112.b                                                                  ; $15B548 | |
    SEC                                                                         ; $15B54A | |
    SBC <r_black_chocobo_altitude                                               ; $15B54B | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B54D |/
    LDA r_direction.w                                                           ; $15B54F |\
+   ASL A                                                                       ; $15B552 | | Calculate the index into the sprite data. Each frame consists of
    ASL A                                                                       ; $15B553 | | 16 bytes, and each direction has two frames, so multiply the
    ASL A                                                                       ; $15B554 | | direction by 32. If the active vehicle is the black chocobo, add
    ASL A                                                                       ; $15B555 | | 16 on an alternating pattern of 4 frames on, 4 frames off.
    ASL A                                                                       ; $15B556 | |
    STA <r_draw_field_sprite_tmp                                                ; $15B557 | | If the black chocobo isn't the active vehicle, the offset is
    LDA r_vehicle.w                                                             ; $15B559 | | always zero.
    CMP #VEHICLE_BLACK_CHOCOBO.b                                                ; $15B55C | |
    BNE +                                                                       ; $15B55E | |
    LDA <r_map_frame_counter                                                    ; $15B560 | |
    AND #%00000100.b                                                            ; $15B562 | |
    ASL A                                                                       ; $15B564 | |
    ASL A                                                                       ; $15B565 | |
    JMP ++                                                                      ; $15B566 | |
+   LDA #$00.b                                                                  ; $15B569 | |
++  CLC                                                                         ; $15B56B | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B56C | |
    TAX                                                                         ; $15B56E |/
    LDY #$0000.w                                                                ; $15B56F |\
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15B572 | | For the current tile, set the X coordinate. If it overflows, make
    CLC                                                                         ; $15B575 | | sure the high bit is set in the high OAM table. X coordinate is
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B576 | | the base X coordinate plus the offset for this specific tile.
    STA r_oam.70.x,Y                                                            ; $15B578 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B57B | |
    ADC #$00.b                                                                  ; $15B57D | |
    AND #%00000001.b                                                            ; $15B57F | |
    BEQ +                                                                       ; $15B581 | |
    LDA #69.b                                                                   ; $15B583 | |
    JSL set_oam_hi_x                                                            ; $15B585 |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15B589 |\
    CLC                                                                         ; $15B58C | | Set the Y coordinate to the base Y coordinate plus the tile
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B58D | | offset.
    STA r_oam.70.y,Y                                                            ; $15B58F |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15B592 |\
    CLC                                                                         ; $15B595 | | Set the tile number to $90 plus the tile offset. This is the black
    ADC #$90.b                                                                  ; $15B596 | | chocobo flying set.
    STA r_oam.70.tile,Y                                                         ; $15B598 |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15B59B |\
    CLC                                                                         ; $15B59E | | Set the flags, adding 1 to the base priority and using the sixth
    ADC #$1A.b                                                                  ; $15B59F | | sprite palette.
    STA r_oam.70.flags,Y                                                        ; $15B5A1 |/
    INX                                                                         ; $15B5A4 |\
    INX                                                                         ; $15B5A5 | | Increment the index registers and repeat until all 16 bytes have
    INX                                                                         ; $15B5A6 | | been read and set.
    INX                                                                         ; $15B5A7 | |
    INY                                                                         ; $15B5A8 | |
    INY                                                                         ; $15B5A9 | |
    INY                                                                         ; $15B5AA | |
    INY                                                                         ; $15B5AB | |
    CPY #$0010.w                                                                ; $15B5AC | |
    BNE -                                                                       ; $15B5AF |/
    LDA r_vehicle.w                                                             ; $15B5B1 |\
    CMP #VEHICLE_BLACK_CHOCOBO.b                                                ; $15B5B4 | | If the current vehicle is not the black chocobo, but visible, it
    BEQ +                                                                       ; $15B5B6 | | must be landed in a forest, so set its two lower tiles to
    LDA #248.b                                                                  ; $15B5B8 | | invisible.
    STA r_oam.72.y.w                                                            ; $15B5BA | |
    STA r_oam.73.y.w                                                            ; $15B5BD | |
    JMP @done                                                                   ; $15B5C0 |/
+   LDA <r_tile_properties_current.properties_1                                 ; $15B5C3 |\
    AND #TILE_PROPERTY_1_OUTDOOR_FOREST.b                                       ; $15B5C5 | | If the black chocobo is the active vehicle, and the tile
    BEQ @done                                                                   ; $15B5C7 | | properties of the current tile has bit 3 of byte 1 set, draw a
    LDA #112.b                                                                  ; $15B5C9 | | strange shadow effect. It looks dumb, and I honestly don't
    STA r_oam.68.x.w                                                            ; $15B5CB | | understand the purpose, but there it is. (It affects the shadow
    LDA #120.b                                                                  ; $15B5CE | | when flying over a forest.)
    STA r_oam.68.y.w                                                            ; $15B5D0 | |
    LDA #$43.b                                                                  ; $15B5D3 | | It appears to hide half the shadow within the forest.
    STA r_oam.68.tile.w                                                         ; $15B5D5 | |
    STZ r_oam.68.flags.w                                                        ; $15B5D8 | |
    LDA #120.b                                                                  ; $15B5DB | |
    STA r_oam.69.x.w                                                            ; $15B5DD | |
    LDA #120.b                                                                  ; $15B5E0 | |
    STA r_oam.69.y.w                                                            ; $15B5E2 | |
    LDA #$43.b                                                                  ; $15B5E5 | |
    STA r_oam.69.tile.w                                                         ; $15B5E7 | |
    STZ r_oam.69.flags.w                                                        ; $15B5EA |/
@done:
    PLB                                                                         ; $15B5ED | Restore the data bank register.
    RTL                                                                         ; $15B5EE

; draw_field_sprite_tanks ($15:B5EF)
;
; Draws the five tanks in front of the Tower of Bab-il.
draw_field_sprite_tanks:
    PHB                                                                         ; $15B5EF |\
    LDA #$15.b                                                                  ; $15B5F0 | | Set the data bank register to $15.
    PHA                                                                         ; $15B5F2 | |
    PLB                                                                         ; $15B5F3 |/
    LDA r_map_plane.w                                                           ; $15B5F4 |\
    CMP #MAP_PLANE_UNDERWORLD_MOON.b                                            ; $15B5F7 | | Only draw tanks underground. (The moon overworld is a different plane.)
    BNE @done                                                                   ; $15B5F9 |/
    STZ <r_draw_field_sprite_tanks_index                                        ; $15B5FB |\ Initialize the main loop to draw the five tanks.
--  LDA <r_draw_field_sprite_tanks_index                                        ; $15B5FD | |
    TAX                                                                         ; $15B5FF |/
    LDA field_sprite_tank_x_coordinate_data.w,X                                 ; $15B600 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B603 | | Check that this tank is visible, otherwise skip to the next tank.
    LDA field_sprite_tank_y_coordinate_data.w,X                                 ; $15B605 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B608 | |
    JSL check_coordinates_visible                                               ; $15B60A | |
    LDA <r_check_coordinates_visible_result                                     ; $15B60E | |
    BEQ @next                                                                   ; $15B610 |/
    LDX #$0000.w                                                                ; $15B612 |\
    LDA <r_draw_field_sprite_tanks_index                                        ; $15B615 | | Determine the OAM index by multiplying the tank by 16.
    ASL A                                                                       ; $15B617 | |
    ASL A                                                                       ; $15B618 | |
    ASL A                                                                       ; $15B619 | |
    ASL A                                                                       ; $15B61A | |
    TAY                                                                         ; $15B61B |/
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15B61C |\
    CLC                                                                         ; $15B61F | | Set the tile X coordinate.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B620 | |
    STA r_oam.97.x,Y                                                            ; $15B622 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B625 | |
    ADC #$00.b                                                                  ; $15B627 | |
    AND #%00000001.b                                                            ; $15B629 | |
    BEQ +                                                                       ; $15B62B | |
    LDA #96.b                                                                   ; $15B62D | |
    JSL set_oam_hi_x                                                            ; $15B62F |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15B633 |\
    CLC                                                                         ; $15B636 | | Set the tile Y coordinate.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B637 | |
    STA r_oam.97.y,Y                                                            ; $15B639 |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15B63C |\
    CLC                                                                         ; $15B63F | | Set the tile number by adding $A8 to the field sprite offset.
    ADC #$A8.b                                                                  ; $15B640 | |
    STA r_oam.97.tile,Y                                                         ; $15B642 |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15B645 |\
    CLC                                                                         ; $15B648 | | Add one to the priority and set the fifth palette when setting
    ADC #$18.b                                                                  ; $15B649 | | flags.
    STA r_oam.97.flags,Y                                                        ; $15B64B |/
    INX                                                                         ; $15B64E |\
    INX                                                                         ; $15B64F | | Increment the indexes and repeat until four tiles have been
    INX                                                                         ; $15B650 | | set.
    INX                                                                         ; $15B651 | |
    INY                                                                         ; $15B652 | |
    INY                                                                         ; $15B653 | |
    INY                                                                         ; $15B654 | |
    INY                                                                         ; $15B655 | |
    CPX #$0010.w                                                                ; $15B656 | |
    BNE -                                                                       ; $15B659 |/
@next:
    INC <r_draw_field_sprite_tanks_index                                        ; $15B65B |\
    LDA <r_draw_field_sprite_tanks_index                                        ; $15B65D | | Increment the tank number and repeat until all five tanks have
    CMP #$05.b                                                                  ; $15B65F | | been drawn.
    BNE --                                                                      ; $15B661 |/
@done:
    PLB                                                                         ; $15B663 | Restore the data bank register.
    RTL                                                                         ; $15B664

; field_sprite_tank_x_coordinate_data ($15:B665)
;
; The X coordinates of the five dwarf tanks in front of the Tower of Bab-il.
field_sprite_tank_x_coordinate_data:
    .db 46                                                                      ; $15B665
    .db 47                                                                      ; $15B666
    .db 48                                                                      ; $15B667
    .db 49                                                                      ; $15B668
    .db 50                                                                      ; $15B669

; field_sprite_tank_y_coordinate_data ($15:B66A)
;
; The Y coordinates of the five dwarf tanks in front of the Tower of Bab-il.
field_sprite_tank_y_coordinate_data:
    .db 19                                                                      ; $15B66A
    .db 20                                                                      ; $15B66B
    .db 19                                                                      ; $15B66C
    .db 20                                                                      ; $15B66D
    .db 19                                                                      ; $15B66E

; draw_field_sprite_ship ($15:B66F)
;
; Draws the ship to the OAM.
draw_field_sprite_ship:
    PHB                                                                         ; $15B66F |\
    LDA #$15.b                                                                  ; $15B670 | | Set the data bank register to $15.
    PHA                                                                         ; $15B672 | |
    PLB                                                                         ; $15B673 |/
    LDA r_ship_status.w                                                         ; $15B674 |\
    BEQ +                                                                       ; $15B677 | | If the ship status is not active or the map plane is not zero,
    LDA r_map_plane.w                                                           ; $15B679 | | skip drawing the ship.
    BNE +                                                                       ; $15B67C |/
    LDA r_vehicle.w                                                             ; $15B67E |\
    CMP #VEHICLE_SHIP.b                                                         ; $15B681 | | If the ship is the active vehicle, branch accordingly.
    BEQ @active                                                                 ; $15B683 |/
    LDA r_ship_coordinates.x.w                                                  ; $15B685 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B688 | | If the ship is parked, check to see if its coordinates are visible
    LDA r_ship_coordinates.y.w                                                  ; $15B68A | | and draw it if so. Set the direction to up (instead of left as
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B68D | | with other vehicles) because the only time the ship appears is
    JSL check_coordinates_visible                                               ; $15B68F | | next to the Fabul dock.
    LDA <r_check_coordinates_visible_result                                     ; $15B693 | |
    BNE ++                                                                      ; $15B695 | |
+   JMP @done                                                                   ; $15B697 | |
++  LDA #DIRECTION_UP.b                                                         ; $15B69A | |
    JMP +                                                                       ; $15B69C |/
@active:
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15B69F |\
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15B6A1 | | If the ship is the active vehicle, set both its coordinates to
    LDA #112.b                                                                  ; $15B6A3 | | 112 and load the actual direction.
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B6A5 | |
    LDA #112.b                                                                  ; $15B6A7 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B6A9 | |
    LDA r_direction.w                                                           ; $15B6AB |/
+   ASL A                                                                       ; $15B6AE |\
    ASL A                                                                       ; $15B6AF | | Determine the index by multiplying the direction by 32 and then
    ASL A                                                                       ; $15B6B0 | | adding 16 if the current frame had bit 2 set. In other words,
    ASL A                                                                       ; $15B6B1 | | change the animation frame every 4 frames.
    ASL A                                                                       ; $15B6B2 | |
    STA <r_draw_field_sprite_tmp                                                ; $15B6B3 | |
    LDA r_vehicle.w                                                             ; $15B6B5 | |
    CMP #VEHICLE_SHIP.b                                                         ; $15B6B8 | |
    BNE +                                                                       ; $15B6BA | |
    LDA <r_map_frame_counter                                                    ; $15B6BC | |
    AND #%00000100.b                                                            ; $15B6BE | |
    ASL A                                                                       ; $15B6C0 | |
    ASL A                                                                       ; $15B6C1 | |
    JMP ++                                                                      ; $15B6C2 | |
+   LDA #$00.b                                                                  ; $15B6C5 | |
++  CLC                                                                         ; $15B6C7 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B6C8 | |
    TAX                                                                         ; $15B6CA |/
    LDY #$0000.w                                                                ; $15B6CB |\
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15B6CE | | Set the X coordinate of the tile, setting the high OAM X bit if
    CLC                                                                         ; $15B6D1 | | necessary.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B6D2 | |
    STA r_oam.97.x,Y                                                            ; $15B6D4 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B6D7 | |
    ADC #$00.b                                                                  ; $15B6D9 | |
    AND #%00000001.b                                                            ; $15B6DB | |
    BEQ +                                                                       ; $15B6DD | |
    LDA #96.b                                                                   ; $15B6DF | |
    JSL set_oam_hi_x                                                            ; $15B6E1 |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15B6E5 |\
    CLC                                                                         ; $15B6E8 | | Set the tile's Y coordinate.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B6E9 | |
    STA r_oam.97.y,Y                                                            ; $15B6EB |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15B6EE |\
    CLC                                                                         ; $15B6F1 | | Set the tile number by adding $60.
    ADC #$60.b                                                                  ; $15B6F2 | |
    STA r_oam.97.tile,Y                                                         ; $15B6F4 |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15B6F7 |\
    CLC                                                                         ; $15B6FA | | Set the flags, adding 1 to the priority and setting the the fifth
    ADC #$18.b                                                                  ; $15B6FB | | palette.
    STA r_oam.97.flags,Y                                                        ; $15B6FD |/
    INX                                                                         ; $15B700 |\
    INX                                                                         ; $15B701 | | Increment the indexes and repeat until all four tiles have been
    INX                                                                         ; $15B702 | | set in the OAM.
    INX                                                                         ; $15B703 | |
    INY                                                                         ; $15B704 | |
    INY                                                                         ; $15B705 | |
    INY                                                                         ; $15B706 | |
    INY                                                                         ; $15B707 | |
    CPY #$0010.w                                                                ; $15B708 | |
    BNE -                                                                       ; $15B70B |/
@done:
    PLB                                                                         ; $15B70D | Restore the data bank register.
    RTL                                                                         ; $15B70E

; draw_field_sprite_hovercraft ($15:B70F)
;
; Draws the field sprite hovercraft if appropriate by copying the relevant data
; into the OAM staging area.
draw_field_sprite_hovercraft:
    PHB                                                                         ; $15B70F |\
    LDA #$15.b                                                                  ; $15B710 | | Set the data bank register to $15.
    PHA                                                                         ; $15B712 | |
    PLB                                                                         ; $15B713 |/
    LDA r_hovercraft_status.w                                                   ; $15B714 |\ Skip this function if the hovercraft isn't active.
    BEQ ++                                                                      ; $15B717 |/
    LDA r_map_plane.w                                                           ; $15B719 |\
    CMP r_hovercraft_plane.w                                                    ; $15B71C | | Ensure that the current plane matches the hovercraft plane.
    BNE ++                                                                      ; $15B71F |/
    LDA r_vehicle.w                                                             ; $15B721 |\
    CMP #VEHICLE_HOVERCRAFT.b                                                   ; $15B724 | | If the hovercraft is the current vehicle, branch accordingly.
    BEQ @active                                                                 ; $15B726 |/
    LDA r_hovercraft_hooked.w                                                   ; $15B728 |\
    BEQ +                                                                       ; $15B72B | | If the hovercraft is hooked to the Enterprise, branch accordingly.
    JMP @hooked                                                                 ; $15B72D |/
+   LDA <r_zoom_level                                                           ; $15B730 |\
    AND #%00001111.b                                                            ; $15B732 | | If the hovercraft is parked, make sure the zoom level mod 16 is 0.
    BNE ++                                                                      ; $15B734 |/
    LDA r_hovercraft_coordinates.x.w                                            ; $15B736 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B739 | | If the hovercraft is parked and the zoom level is other than $10
    LDA r_hovercraft_coordinates.y.w                                            ; $15B73B | | switch to drawing the zoomed version.
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B73E | |
    JSL check_coordinates_visible                                               ; $15B740 | |
    LDA <r_check_coordinates_visible_result                                     ; $15B744 | |
    BNE +                                                                       ; $15B746 | |
++  JMP @done                                                                   ; $15B748 | |
+   LDA <r_zoom_level                                                           ; $15B74B | |
    CMP #$10.b                                                                  ; $15B74D | |
    BEQ +                                                                       ; $15B74F | |
    LDA #VEHICLE_HOVERCRAFT.b                                                   ; $15B751 | |
    JMP _draw_zoomed_vehicle                                                    ; $15B753 |/
+   LDA #DIRECTION_LEFT.b                                                       ; $15B756 |\ Otherwise, set the direction to left and rejoin the function.
    JMP +                                                                       ; $15B758 |/
@active:
    LDA #$00.b                                                                  ; $15B75B |\
    JSL draw_field_sprite_shadow                                                ; $15B75D | | If the hovercraft is the active vehicle, draw a shadow and set its
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15B761 | | X and Y coordinates to 112, 112 ensuring that we also subtract the
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15B763 | | altitude from the Y coordinate.
    LDA #112.b                                                                  ; $15B765 | |
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B767 | |
    LDA #112.b                                                                  ; $15B769 | |
    SEC                                                                         ; $15B76B | |
    SBC <r_hovercraft_altitude                                                  ; $15B76C | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B76E | |
    LDA r_direction.w                                                           ; $15B770 |/
+   ASL A                                                                       ; $15B773 |\
    ASL A                                                                       ; $15B774 | | Determine the correct index for the sprite data. Start by
    ASL A                                                                       ; $15B775 | | multiplying the direction by 32, and then adding 16 if the current
    ASL A                                                                       ; $15B776 | | frame counter has bit 1 set. (Thus, the animation frame will change
    ASL A                                                                       ; $15B777 | | back and forth every 2 frames.)
    STA <r_draw_field_sprite_tmp                                                ; $15B778 | |
    LDA r_vehicle.w                                                             ; $15B77A | |
    CMP #VEHICLE_HOVERCRAFT.b                                                   ; $15B77D | |
    BNE +                                                                       ; $15B77F | |
    LDA <r_map_frame_counter                                                    ; $15B781 | |
    AND #%00000010.b                                                            ; $15B783 | |
    ASL A                                                                       ; $15B785 | |
    ASL A                                                                       ; $15B786 | |
    ASL A                                                                       ; $15B787 | |
    JMP ++                                                                      ; $15B788 | |
+   LDA #$00.b                                                                  ; $15B78B | |
++  CLC                                                                         ; $15B78D | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B78E | |
    TAX                                                                         ; $15B790 |/
    LDY #$0000.w                                                                ; $15B791 |\
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15B794 | | Set the tile X coordinate in the OAM data, adding the tile offset
    CLC                                                                         ; $15B797 | | from the field sprite OAM data. Set the OAM high bit if necessary.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B798 | |
    STA r_oam.97.x,Y                                                            ; $15B79A | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B79D | |
    ADC #$00.b                                                                  ; $15B79F | |
    AND #%00000001.b                                                            ; $15B7A1 | |
    BEQ +                                                                       ; $15B7A3 | |
    LDA #96.b                                                                   ; $15B7A5 | |
    JSL set_oam_hi_x                                                            ; $15B7A7 |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15B7AB |\
    CLC                                                                         ; $15B7AE | | Set the Y coordinate, adding the tile offset.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B7AF | |
    STA r_oam.97.y,Y                                                            ; $15B7B1 |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15B7B4 |\
    CLC                                                                         ; $15B7B7 | | Set the tile number, adding $48 to the base value.
    ADC #$48.b                                                                  ; $15B7B8 | |
    STA r_oam.97.tile,Y                                                         ; $15B7BA |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15B7BD |\
    CLC                                                                         ; $15B7C0 | | Set the flags, adding one to the priority and choosing the fifth
    ADC #$18.b                                                                  ; $15B7C1 | | palette.
    STA r_oam.97.flags,Y                                                        ; $15B7C3 |/
    INX                                                                         ; $15B7C6 |\
    INX                                                                         ; $15B7C7 | | Increment the index registers and repeat until all four tiles have
    INX                                                                         ; $15B7C8 | | been set.
    INX                                                                         ; $15B7C9 | |
    INY                                                                         ; $15B7CA | |
    INY                                                                         ; $15B7CB | |
    INY                                                                         ; $15B7CC | |
    INY                                                                         ; $15B7CD | |
    CPY #$0010.w                                                                ; $15B7CE | |
    BNE -                                                                       ; $15B7D1 | |
    JMP @done                                                                   ; $15B7D3 |/
@hooked:
    LDA r_hook_height.w                                                         ; $15B7D6 |\
    BNE +                                                                       ; $15B7D9 | | If the hovercraft is hooked, determine the correct index into the
    LDA r_direction.w                                                           ; $15B7DB | | sprite data. If the hook is still raising or lowering, the sprite
    ASL A                                                                       ; $15B7DE | | at $40 is selected. Otherwise, one of the previous four is
    ASL A                                                                       ; $15B7DF | | selected depending on the current direction.
    ASL A                                                                       ; $15B7E0 | |
    ASL A                                                                       ; $15B7E1 | |
    JMP ++                                                                      ; $15B7E2 | |
+   LDA #$40.b                                                                  ; $15B7E5 | |
++  TAX                                                                         ; $15B7E7 |/
    LDY #$0000.w                                                                ; $15B7E8 |\
-   LDA field_sprite_hovercraft_oam_data.w,X                                    ; $15B7EB | | Put data about the tile into the OAM staging area. The only real
    STA r_oam.97.x,Y                                                            ; $15B7EE | | point of note is that the hook height (how far it is extended) is
    LDA field_sprite_hovercraft_oam_data.w + 1,X                                ; $15B7F1 | | added to the base location to raise/lower the sprite.
    CLC                                                                         ; $15B7F4 | |
    ADC r_hook_height.w                                                         ; $15B7F5 | |
    STA r_oam.97.y,Y                                                            ; $15B7F8 | |
    LDA field_sprite_hovercraft_oam_data.w + 2,X                                ; $15B7FB | |
    STA r_oam.97.tile,Y                                                         ; $15B7FE | |
    LDA field_sprite_hovercraft_oam_data.w + 3,X                                ; $15B801 | |
    STA r_oam.97.flags,Y                                                        ; $15B804 |/
    INX                                                                         ; $15B807 |\
    INX                                                                         ; $15B808 | | Increment the indexes and loop until the four tiles have been set.
    INX                                                                         ; $15B809 | |
    INX                                                                         ; $15B80A | |
    INY                                                                         ; $15B80B | |
    INY                                                                         ; $15B80C | |
    INY                                                                         ; $15B80D | |
    INY                                                                         ; $15B80E | |
    CPY #$0010.w                                                                ; $15B80F | |
    BNE -                                                                       ; $15B812 |/
@done:
    PLB                                                                         ; $15B814 | Restore the data bank register.
    RTL                                                                         ; $15B815

; field_sprite_hovercraft_oam_data ($15:B816)
;
; Contains the data necessary to put into the OAM in order to draw the
; hovercraft when carried by the Enterprise. The first four sprites are the
; four directions for the completely raised hovercraft, and the last sprite is
; a left-facing sprite used when the hovercraft is being raised or lowered.
field_sprite_hovercraft_oam_data:
    OAM 112, 106, 0, 0, 2, 5, 0, $C0                                            ; $15B816 | $00: Hanging hovercraft, up
    OAM 120, 106, 0, 0, 2, 5, 0, $C1                                            ; $15B81A
    OAM 112, 114, 0, 0, 2, 5, 0, $C2                                            ; $15B81E
    OAM 120, 114, 0, 0, 2, 5, 0, $C3                                            ; $15B822

    OAM 112, 106, 0, 0, 2, 5, 0, $C4                                            ; $15B826 | $01: Hanging hovercraft, right
    OAM 120, 106, 0, 0, 2, 5, 0, $C5                                            ; $15B82A
    OAM 112, 114, 0, 0, 2, 5, 0, $C6                                            ; $15B82E
    OAM 120, 114, 0, 0, 2, 5, 0, $C7                                            ; $15B832

    OAM 112, 106, 0, 0, 2, 5, 0, $C8                                            ; $15B836 | $02: Hanging hovercraft, down
    OAM 120, 106, 0, 0, 2, 5, 0, $C9                                            ; $15B83A
    OAM 112, 114, 0, 0, 2, 5, 0, $CA                                            ; $15B83E
    OAM 120, 114, 0, 0, 2, 5, 0, $CB                                            ; $15B842

    OAM 112, 106, 0, 0, 2, 5, 0, $CC                                            ; $15B846 | $03: Hanging hovercraft, left
    OAM 120, 106, 0, 0, 2, 5, 0, $CD                                            ; $15B84A
    OAM 112, 114, 0, 0, 2, 5, 0, $CE                                            ; $15B84E
    OAM 120, 114, 0, 0, 2, 5, 0, $CF                                            ; $15B852

    OAM 112, 106, 0, 0, 2, 5, 1, $2A                                            ; $15B856 | $04: Hanging hovercraft, raising or lowering
    OAM 120, 106, 0, 0, 2, 5, 1, $2B                                            ; $15B85A
    OAM 112, 114, 0, 0, 2, 5, 1, $2C                                            ; $15B85E
    OAM 120, 114, 0, 0, 2, 5, 1, $2D                                            ; $15B862

; draw_field_sprite_shadow ($15:B866)
;
; Draws a shadow to the center of the screen. The size of the shadow is
; specified by the value passed in the accumulator. Meaningful values range
; from 0 to 16, but the shadow only changes every 4 steps. Values lower than
; 16 will result in a shadow that is only drawn on even frames. The shadow
; decreases in size with larger values.
draw_field_sprite_shadow:
    CMP #$10.b                                                                  ; $15B866 |\
    BCC +                                                                       ; $15B868 | | Determine the shadow index by taking the parameter and dividing by
    LDA #$10.b                                                                  ; $15B86A | | ignoring the lowest two bits. This results in the shadow changing
+   AND #%11111100.b                                                            ; $15B86C | | every four times the value is incremented.
    TAX                                                                         ; $15B86E |/
    CMP #$10.b                                                                  ; $15B86F |\
    BEQ +                                                                       ; $15B871 | | Except for the value of $10, check the map frame counter and only
    LDA <r_map_frame_counter                                                    ; $15B873 | | show the shadow on even frames.
    AND #%00000001.b                                                            ; $15B875 | |
    BNE @done                                                                   ; $15B877 |/
+   LDA <r_suppress_field_sprite_shadows                                        ; $15B879 |\ Return if field sprite shadows are suppressed.
    BNE @done                                                                   ; $15B87B |/
    LDA <r_tile_properties_current.properties_1                                 ; $15B87D |\
    AND #TILE_PROPERTY_1_OUTDOOR_FOREST.b                                       ; $15B87F | | Depending on two bits of the current tile's properties, the shadow
    BNE +                                                                       ; $15B881 | | is moved two pixels higher on the screen. Practically speaking,
    LDA <r_tile_properties_current.properties_1                                 ; $15B883 | | this occurs when over high terrain (mountains, plateaus, forests).
    AND #TILE_PROPERTY_1_OUTDOOR_BLACK_CHOCOBO.b                                ; $15B885 | | In other words, if the tile is a forest or if the black chocobo
    BNE ++                                                                      ; $15B887 | | cannot fly there.
+   LDA #-2.b                                                                   ; $15B889 | |
    JMP +++                                                                     ; $15B88B | |
++  LDA #0.b                                                                    ; $15B88E | |
+++ STA <r_draw_field_sprite_shadow_tmp                                         ; $15B890 |/
    LDA #112.b                                                                  ; $15B892 |\
    STA r_oam.113.x.w                                                           ; $15B894 | | By default, the shadow is drawn at 112, 120. Again, this shadow is
    LDA #120.b                                                                  ; $15B897 | | potentially moved up two pixels depending on tile properties.
    CLC                                                                         ; $15B899 | |
    ADC <r_draw_field_sprite_shadow_tmp                                         ; $15B89A | |
    STA r_oam.113.y.w                                                           ; $15B89C |/
    LDA field_sprite_shadow_oam_data.l,X                                        ; $15B89F |\
    STA r_oam.113.tile.w                                                        ; $15B8A3 | | Draw the second tile of the shadow using the same process, except
    LDA field_sprite_shadow_oam_data.l + 1,X                                    ; $15B8A6 | | shifted 8 pixels to the right.
    STA r_oam.113.flags.w                                                       ; $15B8AA | |
    LDA #120.b                                                                  ; $15B8AD | |
    STA r_oam.114.x.w                                                           ; $15B8AF | |
    LDA #120.b                                                                  ; $15B8B2 | |
    CLC                                                                         ; $15B8B4 | |
    ADC <r_draw_field_sprite_shadow_tmp                                         ; $15B8B5 | |
    STA r_oam.114.y.w                                                           ; $15B8B7 | |
    LDA field_sprite_shadow_oam_data.l + 2,X                                    ; $15B8BA | |
    STA r_oam.114.tile.w                                                        ; $15B8BE | |
    LDA field_sprite_shadow_oam_data.l + 3,X                                    ; $15B8C1 | |
    STA r_oam.114.flags.w                                                       ; $15B8C5 |/
@done:
    RTL                                                                         ; $15B8C8

; field_sprite_shadow_oam_data ($15:B8C9)
;
; Contains the data necessary to draw shadows to the OAM.
field_sprite_shadow_oam_data:
    .db $3B, $28                                                                ; $15B8C9 | $00: Large shadow
    .db $3B, $68                                                                ; $15B8CB
    .db $3A, $28                                                                ; $15B8CD | $01: Medium shadow
    .db $3A, $68                                                                ; $15B8CF
    .db $39, $28                                                                ; $15B8D1 | $02: Small shadow
    .db $39, $68                                                                ; $15B8D3
    .db $38, $28                                                                ; $15B8D5 | $03: Extra small shadow
    .db $38, $68                                                                ; $15B8D7
    .db $38, $28                                                                ; $15B8D9 | $04: Solid extra small shadow
    .db $38, $68                                                                ; $15B8DB

; draw_field_sprite_enterprise ($15:B8DD)
;
; Draws the Enterprise field sprite to the OAM staging area.
draw_field_sprite_enterprise:
    PHB                                                                         ; $15B8DD |\
    LDA #$15.b                                                                  ; $15B8DE | | Set the data bank register to $15.
    PHA                                                                         ; $15B8E0 | |
    PLB                                                                         ; $15B8E1 |/
    LDA r_vehicle.w                                                             ; $15B8E2 |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $15B8E5 | | If the Enterprise is the current vehicle, branch accordingly.
    BEQ @active                                                                 ; $15B8E7 |/
    LDA r_enterprise_status.w                                                   ; $15B8E9 |\
    BEQ +                                                                       ; $15B8EC | | Skip this function if the Enterprise isn't active or if its plane
    LDA r_map_plane.w                                                           ; $15B8EE | | doesn't match the current plane.
    CMP r_enterprise_plane.w                                                    ; $15B8F1 | |
    BNE +                                                                       ; $15B8F4 |/
    LDA <r_zoom_level                                                           ; $15B8F6 |\
    AND #%00001111.b                                                            ; $15B8F8 | | Skip this function if the zoom level mod 16 isn't zero.
    BNE +                                                                       ; $15B8FA |/
    LDA r_enterprise_coordinates.x.w                                            ; $15B8FC |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B8FF | | If the Enterprise isn't the current vehicle and the zoom level is
    LDA r_enterprise_coordinates.y.w                                            ; $15B901 | | zoomed out, draw the zoomed version of the vehicle. Otherwise,
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B904 | | set the direction to left and continue. (Parked vehicles face
    JSL check_coordinates_visible                                               ; $15B906 | | left.)
    LDA <r_check_coordinates_visible_result                                     ; $15B90A | |
    BNE ++                                                                      ; $15B90C | |
+   JMP @done                                                                   ; $15B90E | |
++  LDA <r_zoom_level                                                           ; $15B911 | |
    CMP #$10.b                                                                  ; $15B913 | |
    BEQ +                                                                       ; $15B915 | |
    LDA #VEHICLE_ENTERPRISE.b                                                   ; $15B917 | |
    JMP _draw_zoomed_vehicle                                                    ; $15B919 | |
+   LDA #DIRECTION_LEFT.b                                                       ; $15B91C | |
    JMP +                                                                       ; $15B91E |/
@active:
    LDA <r_enterprise_altitude                                                  ; $15B921 |\
    JSL draw_field_sprite_shadow                                                ; $15B923 | | If the Enterprise is the currently active vehicle, draw an
    LDA #112.b                                                                  ; $15B927 | | appropriate shadow, and set the coordinates to 112, 112, adjusting
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B929 | | for the current altitude. Set the accumulator to the current
    LDA #112.b                                                                  ; $15B92B | | direction.
    SEC                                                                         ; $15B92D | |
    SBC <r_enterprise_altitude                                                  ; $15B92E | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B930 | |
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15B932 | |
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15B934 | |
    LDA r_direction.w                                                           ; $15B936 |/
+   ASL A                                                                       ; $15B939 |\
    ASL A                                                                       ; $15B93A | | Set the index into the sprite data. Multiply the direction by 32,
    ASL A                                                                       ; $15B93B | | and then select an animation frame. Load the airship animation
    ASL A                                                                       ; $15B93C | | speed and use that to index into a table that provides the mask
    ASL A                                                                       ; $15B93D | | that determines which frame is used.
    STA <r_draw_field_sprite_tmp                                                ; $15B93E | |
    LDA r_vehicle.w                                                             ; $15B940 | |
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $15B943 | |
    BNE +                                                                       ; $15B945 | |
    LDA r_airship_animation_speed.w                                             ; $15B947 | |
    TAX                                                                         ; $15B94A | |
    LDA <r_map_frame_counter                                                    ; $15B94B | |
    AND airship_animation_speed_data.w,X                                        ; $15B94D | |
    BNE +                                                                       ; $15B950 | |
    LDA #$10.b                                                                  ; $15B952 | |
    JMP ++                                                                      ; $15B954 | |
+   LDA #$00.b                                                                  ; $15B957 | |
++  CLC                                                                         ; $15B959 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15B95A | |
    TAX                                                                         ; $15B95C |/
    LDY #$0000.w                                                                ; $15B95D |\
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15B960 | | Set the X coordinate of the tile, making sure to set the OAM high
    CLC                                                                         ; $15B963 | | bit if it overflows after adding the tile offset.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15B964 | |
    STA r_oam.92.x,Y                                                            ; $15B966 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15B969 | |
    ADC #$00.b                                                                  ; $15B96B | |
    AND #%00000001.b                                                            ; $15B96D | |
    BEQ +                                                                       ; $15B96F | |
    LDA #91.b                                                                   ; $15B971 | |
    JSL set_oam_hi_x                                                            ; $15B973 |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15B977 |\
    CLC                                                                         ; $15B97A | | Set the Y coordinate in the OAM data.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15B97B | |
    STA r_oam.92.y,Y                                                            ; $15B97D |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15B980 |\
    CLC                                                                         ; $15B983 | | Set the tile number, adding $78 to the base.
    ADC #TILE_BASE_ENTERPRISE.b                                                 ; $15B984 | |
    STA r_oam.92.tile,Y                                                         ; $15B986 |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15B989 |\
    CLC                                                                         ; $15B98C | | Set the flags, adding 1 to the priority and setting the fifth
    ADC #$18.b                                                                  ; $15B98D | | palette.
    STA r_oam.92.flags,Y                                                        ; $15B98F |/
    INX                                                                         ; $15B992 |\
    INX                                                                         ; $15B993 | | Increment the index registers and loop until all four tiles have
    INX                                                                         ; $15B994 | | been set.
    INX                                                                         ; $15B995 | |
    INY                                                                         ; $15B996 | |
    INY                                                                         ; $15B997 | |
    INY                                                                         ; $15B998 | |
    INY                                                                         ; $15B999 | |
    CPY #$0010.w                                                                ; $15B99A | |
    BNE -                                                                       ; $15B99D |/
    LDA r_vehicle.w                                                             ; $15B99F |\
    CMP #VEHICLE_ENTERPRISE.b                                                   ; $15B9A2 | | Decide whether or not to draw the hook. The Enterprise must be the
    BNE @done                                                                   ; $15B9A4 | | active vehicle, the zoom level must be $20, and the Enterprise
    LDA <r_zoom_level                                                           ; $15B9A6 | | altitude must be $10.
    CMP #$20.b                                                                  ; $15B9A8 | |
    BNE @done                                                                   ; $15B9AA | |
    LDA <r_enterprise_altitude                                                  ; $15B9AC | |
    CMP #$10.b                                                                  ; $15B9AE | |
    BNE @done                                                                   ; $15B9B0 |/
    LDA #116.b                                                                  ; $15B9B2 |\ Set the hook X coordinate to 116.
    STA r_oam.96.x.w                                                            ; $15B9B4 |/
    LDA r_hook_height.w                                                         ; $15B9B7 |\
    CLC                                                                         ; $15B9BA | | Set the hook Y coordinate to 104 plus the hook height.
    ADC #104.b                                                                  ; $15B9BB | |
    STA r_oam.96.y.w                                                            ; $15B9BD |/
    LDA #$2E.b                                                                  ; $15B9C0 |\
    STA r_oam.96.tile.w                                                         ; $15B9C2 | | Set the tile number to $12E (hook), set the priority to 2, and set
    LDA #$21.b                                                                  ; $15B9C5 | | the palette to zero.
    STA r_oam.96.flags.w                                                        ; $15B9C7 |/
@done:
    PLB                                                                         ; $15B9CA | Restore the data bank register.
    RTL                                                                         ; $15B9CB

; draw_field_sprite_falcon ($15:B9CC)
;
; Draws the Falcon to the OAM staging area if appropriate. This includes drawing
; the drill.
draw_field_sprite_falcon:
    PHB                                                                         ; $15B9CC |\
    LDA #$15.b                                                                  ; $15B9CD | | Set the data bank register to $15.
    PHA                                                                         ; $15B9CF | |
    PLB                                                                         ; $15B9D0 |/
    LDA r_vehicle.w                                                             ; $15B9D1 |\
    CMP #VEHICLE_FALCON.b                                                       ; $15B9D4 | | If the Falcon is the active vehicle, branch accordingly.
    BEQ @active                                                                 ; $15B9D6 |/
    LDA r_falcon_status.w                                                       ; $15B9D8 |\
    BEQ +                                                                       ; $15B9DB | | Skip this function if the Falcon is not active, if the Falcon's
    LDA r_map_plane.w                                                           ; $15B9DD | | plane doesn't match the current plane, or if the zoom level mod 16
    CMP r_falcon_plane.w                                                        ; $15B9E0 | | is not zero.
    BNE +                                                                       ; $15B9E3 | |
    LDA <r_zoom_level                                                           ; $15B9E5 | |
    AND #%00001111.b                                                            ; $15B9E7 | |
    BNE +                                                                       ; $15B9E9 |/
    LDA r_falcon_coordinates.x.w                                                ; $15B9EB |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15B9EE | | If the Falcon is parked, check that its coordinates are visible on
    LDA r_falcon_coordinates.y.w                                                ; $15B9F0 | | screen. If the current zoom level is zoomed out, draw the zoomed
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15B9F3 | | version of the sprite. Otherwise, set the accumulator to make the
    JSL check_coordinates_visible                                               ; $15B9F5 | | Falcon face left.
    LDA <r_check_coordinates_visible_result                                     ; $15B9F9 | |
    BNE ++                                                                      ; $15B9FB | |
+   JMP @done                                                                   ; $15B9FD | |
++  LDA <r_zoom_level                                                           ; $15BA00 | |
    CMP #$10.b                                                                  ; $15BA02 | |
    BEQ +                                                                       ; $15BA04 | |
    LDA #VEHICLE_FALCON.b                                                       ; $15BA06 | |
    JMP _draw_zoomed_vehicle                                                    ; $15BA08 | |
+   LDA #DIRECTION_LEFT.b                                                       ; $15BA0B | |
    JMP +                                                                       ; $15BA0D |/
@active:
    LDA <r_falcon_altitude                                                      ; $15BA10 |\
    JSL draw_field_sprite_shadow                                                ; $15BA12 | | If the Falcon is the active vehicle, draw a shadow sprite based on
    LDA #112.b                                                                  ; $15BA16 | | the current altitude, set the coordinates to 112, 112, adjusting
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BA18 | | for the altitude, and load the direction into the accumulator.
    LDA #112.b                                                                  ; $15BA1A | |
    SEC                                                                         ; $15BA1C | |
    SBC <r_falcon_altitude                                                      ; $15BA1D | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BA1F | |
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15BA21 | |
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15BA23 | |
    LDA r_direction.w                                                           ; $15BA25 |/
+   ASL A                                                                       ; $15BA28 |\
    ASL A                                                                       ; $15BA29 | | Set the index into the sprite data by multiplying the direction by
    ASL A                                                                       ; $15BA2A | | 32 and then adding 16 if the current frame should use the
    ASL A                                                                       ; $15BA2B | | alternate animation frame. This is determined by indexing into an
    ASL A                                                                       ; $15BA2C | | array based on the current animation speed and masking bits from
    STA <r_draw_field_sprite_tmp                                                ; $15BA2D | | the map frame counter.
    LDA r_vehicle.w                                                             ; $15BA2F | |
    CMP #VEHICLE_FALCON.b                                                       ; $15BA32 | |
    BNE +                                                                       ; $15BA34 | |
    LDA r_airship_animation_speed.w                                             ; $15BA36 | |
    TAX                                                                         ; $15BA39 | |
    LDA <r_map_frame_counter                                                    ; $15BA3A | |
    AND airship_animation_speed_data.w,X                                        ; $15BA3C | |
    BNE +                                                                       ; $15BA3F | |
    LDA #$10.b                                                                  ; $15BA41 | |
    JMP ++                                                                      ; $15BA43 | |
+   LDA #$00.b                                                                  ; $15BA46 | |
++  CLC                                                                         ; $15BA48 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15BA49 | |
    TAX                                                                         ; $15BA4B |/
    LDY #$0000.w                                                                ; $15BA4C |\
-   LDA field_sprite_vehicle_oam_data.w,X                                       ; $15BA4F | | Set the X coordinate in the OAM to the Falcon's X coordinate plus
    CLC                                                                         ; $15BA52 | | the tile offset. Ensure the high bit is set if appropriate.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15BA53 | |
    STA r_oam.87.x,Y                                                            ; $15BA55 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BA58 | |
    ADC #$00.b                                                                  ; $15BA5A | |
    AND #%00000001.b                                                            ; $15BA5C | |
    BEQ +                                                                       ; $15BA5E | |
    LDA #86.b                                                                   ; $15BA60 | |
    JSL set_oam_hi_x                                                            ; $15BA62 |/
+   LDA field_sprite_vehicle_oam_data.w + 1,X                                   ; $15BA66 |\
    CLC                                                                         ; $15BA69 | | Set the Y coordinate of the tile.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15BA6A | |
    STA r_oam.87.y,Y                                                            ; $15BA6C |/
    LDA field_sprite_vehicle_oam_data.w + 2,X                                   ; $15BA6F |\
    CLC                                                                         ; $15BA72 | | Set the tile number by adding $D8 to the read data.
    ADC #$D8.b                                                                  ; $15BA73 | |
    STA r_oam.87.tile,Y                                                         ; $15BA75 |/
    LDA field_sprite_vehicle_oam_data.w + 3,X                                   ; $15BA78 |\
    CLC                                                                         ; $15BA7B | | Set the flags to add 1 to the priority and use the seventh
    ADC #$1C.b                                                                  ; $15BA7C | | palette.
    STA r_oam.87.flags,Y                                                        ; $15BA7E |/
    INX                                                                         ; $15BA81 |\
    INX                                                                         ; $15BA82 | | Increment the index registers and loop until all four tiles have
    INX                                                                         ; $15BA83 | | been set.
    INX                                                                         ; $15BA84 | |
    INY                                                                         ; $15BA85 | |
    INY                                                                         ; $15BA86 | |
    INY                                                                         ; $15BA87 | |
    INY                                                                         ; $15BA88 | |
    CPY #$0010.w                                                                ; $15BA89 | |
    BNE -                                                                       ; $15BA8C |/
    LDA r_plot_flags.8.w                                                        ; $15BA8E |\
    AND #PLOT_FLAG_8_FALCON_DRILL_INSTALLED.b                                   ; $15BA91 | | Check the plot flags to see if the drill is installed.
    BEQ @done                                                                   ; $15BA93 |/
    LDA r_vehicle.w                                                             ; $15BA95 |\
    CMP #VEHICLE_FALCON.b                                                       ; $15BA98 | | Skip drawing the drill if the Falcon isn't the active vehicle and
    BEQ +                                                                       ; $15BA9A | | the zoom level is something other than $10. If the Falcon is not
    LDA <r_zoom_level                                                           ; $15BA9C | | the active vehicle, set the direction to left, otherwise use the
    CMP #$10.b                                                                  ; $15BA9E | | actual direction.
    BEQ ++                                                                      ; $15BAA0 | |
    JMP @done                                                                   ; $15BAA2 | |
+   LDA r_direction.w                                                           ; $15BAA5 | |
    JMP +                                                                       ; $15BAA8 | |
++  LDA #DIRECTION_LEFT.b                                                       ; $15BAAB | |
+   STA <r_draw_field_sprite_tmp                                                ; $15BAAD | |
    TAX                                                                         ; $15BAAF |/
    LDA falcon_drill_oam_offset_data.l,X                                        ; $15BAB0 |\ Load the OAM offset based on the direction.
    TAY                                                                         ; $15BAB4 |/
    LDA <r_draw_field_sprite_tmp                                                ; $15BAB5 |\
    ASL A                                                                       ; $15BAB7 | | Determine the index into the drill OAM data. First, multiply the
    ASL A                                                                       ; $15BAB8 | | direction by 8, and then select one of the two frames in the same
    ASL A                                                                       ; $15BAB9 | | fashion as earlier, by checking against the animation speed.
    STA <r_draw_field_sprite_tmp                                                ; $15BABA | |
    LDA r_vehicle.w                                                             ; $15BABC | |
    CMP #VEHICLE_FALCON.b                                                       ; $15BABF | |
    BNE +                                                                       ; $15BAC1 | |
    LDA r_airship_animation_speed.w                                             ; $15BAC3 | |
    TAX                                                                         ; $15BAC6 | |
    LDA <r_map_frame_counter                                                    ; $15BAC7 | |
    AND airship_animation_speed_data.w,X                                        ; $15BAC9 | |
    BEQ +                                                                       ; $15BACC | |
    LDA #$04.b                                                                  ; $15BACE | |
    JMP ++                                                                      ; $15BAD0 | |
+   LDA #$00.b                                                                  ; $15BAD3 | |
++  CLC                                                                         ; $15BAD5 | |
    ADC <r_draw_field_sprite_tmp                                                ; $15BAD6 | |
    TAX                                                                         ; $15BAD8 |/
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BAD9 |\
    SEC                                                                         ; $15BADB | | As as baseline, subtract 8 from the X coordinate.
    SBC #8.b                                                                    ; $15BADC | |
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BADE | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BAE0 | |
    SBC #$00.b                                                                  ; $15BAE2 |/
    STA <r_check_coordinates_visible_arg_x_hi                                   ; $15BAE4 |\
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BAE6 | | Set the X coordinate of the drill tile to the base X coordinate
    CLC                                                                         ; $15BAE8 | | plus the offset given for the particular direction, setting the
    ADC falcon_drill_oam_data.w,X                                               ; $15BAE9 | | high OAM bit if necessary.
    STA r_oam.86.x,Y                                                            ; $15BAEC | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BAEF | |
    ADC #$00.b                                                                  ; $15BAF1 | |
    AND #%00000001.b                                                            ; $15BAF3 | |
    BEQ +                                                                       ; $15BAF5 | |
    LDA #85.b                                                                   ; $15BAF7 | |
    JSL set_oam_hi_x                                                            ; $15BAF9 |/
+   LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BAFD |\
    CLC                                                                         ; $15BAFF | | Set the remaining OAM data.
    ADC falcon_drill_oam_data.w + 1,X                                           ; $15BB00 | |
    STA r_oam.86.y,Y                                                            ; $15BB03 | |
    LDA falcon_drill_oam_data.w + 2,X                                           ; $15BB06 | |
    STA r_oam.86.tile,Y                                                         ; $15BB09 | |
    LDA falcon_drill_oam_data.w + 3,X                                           ; $15BB0C | |
    STA r_oam.86.flags,Y                                                        ; $15BB0F |/
@done:
    PLB                                                                         ; $15BB12 | Restore the data bank register.
    RTL                                                                         ; $15BB13

; falcon_drill_oam_offset_data ($15:BB14)
;
; An offset added to the OAM index to ensure that the drill is after the Falcon
; in the OAM if the Falcon is pointed up.
falcon_drill_oam_offset_data:
    .db $14                                                                     ; $15BB14 | $00: Up
    .db $00                                                                     ; $15BB15 | $01: Right
    .db $00                                                                     ; $15BB16 | $02: Down
    .db $00                                                                     ; $15BB17 | $03: Left

; falcon_drill_oam_data ($15:BB18)
;
; Data needed to draw the Falcon drill to the OAM. For each of the four
; directions, there are two frames.
falcon_drill_oam_data:
    OAM 12, -4, 0, 0, 3, 6, 0, $F4                                              ; $15BB18 | $00: Drill, up, frame 1
    OAM 12, -4, 0, 0, 3, 6, 0, $F5                                              ; $15BB1C | $01: Drill, up, frame 2
    OAM 24,  8, 0, 1, 3, 6, 0, $F0                                              ; $15BB20 | $02: Drill, right, frame 1
    OAM 24,  8, 0, 1, 3, 6, 0, $F1                                              ; $15BB24 | $03: Drill, right, frame 2
    OAM 13, 13, 0, 0, 3, 6, 0, $F2                                              ; $15BB28 | $04: Drill, down, frame 1
    OAM 13, 13, 0, 0, 3, 6, 0, $F3                                              ; $15BB2C | $05: Drill, down, frame 2
    OAM  0,  8, 0, 0, 3, 6, 0, $F0                                              ; $15BB30 | $06: Drill, left, frame 1
    OAM  0,  8, 0, 0, 3, 6, 0, $F1                                              ; $15BB34 | $07: Drill, left, frame 2

CODE_15BB38:
    RTL                                                                         ; $15BB38

; draw_big_whale_shadow ($15:BB39)
;
; Draws the larger sized shadows used for the Big Whale when closer to the
; ground. Sets the appropriate bytes in the OAM staging area. The smaller
; shadows can be drawn by the generic shadow drawing function.
draw_big_whale_shadow:
    PHB                                                                         ; $15BB39 |\
    LDA #$15.b                                                                  ; $15BB3A | | Set the data bank register to $15.
    PHA                                                                         ; $15BB3C | |
    PLB                                                                         ; $15BB3D |/
    LDA <r_suppress_field_sprite_shadows                                        ; $15BB3E |\ Return if the flag to suppress field sprite shadows is set.
    BNE @done                                                                   ; $15BB40 |/
    LDA <r_map_frame_counter                                                    ; $15BB42 |\
    AND #%00000001.b                                                            ; $15BB44 | | Only draw the shadow on even frames.
    BNE @done                                                                   ; $15BB46 |/
    LDA <r_big_whale_altitude                                                   ; $15BB48 |\
    SEC                                                                         ; $15BB4A | | Determine which shadow to draw by only taking two bits and then
    SBC #$10.b                                                                  ; $15BB4B | | multiplying by 32. Every four steps of altitude increase, the
    CMP #$10.b                                                                  ; $15BB4D | | shadow size will change.
    BNE +                                                                       ; $15BB4F | |
    DEC A                                                                       ; $15BB51 | |
+   AND #%00001100.b                                                            ; $15BB52 | |
    ASL A                                                                       ; $15BB54 | |
    ASL A                                                                       ; $15BB55 | |
    ASL A                                                                       ; $15BB56 | |
    TAX                                                                         ; $15BB57 |/
    LDY #$0000.w                                                                ; $15BB58 |\
-   LDA big_whale_shadow_oam_data.w,X                                           ; $15BB5B | | Loop through the eight tiles, setting the four bytes for each.
    STA r_oam.113,Y                                                             ; $15BB5E | |
    INX                                                                         ; $15BB61 | |
    INY                                                                         ; $15BB62 | |
    CPY #$0020.w                                                                ; $15BB63 |/
    BNE -                                                                       ; $15BB66
@done:
    PLB                                                                         ; $15BB68 | Restore the data bank register.
    RTL                                                                         ; $15BB69

; big_whale_shadow_oam_data ($15:BB6A)
;
; Contains the data necessary to draw the four larger shadows used for the Big
; Whale when closer to the ground.
big_whale_shadow_oam_data:
    OAM 104, 114, 0, 0, 2, 4, 0, $42                                            ; $15BB6A | $00: Large shadow
    OAM 112, 114, 0, 0, 2, 4, 0, $43                                            ; $15BB6E
    OAM 120, 114, 0, 1, 2, 4, 0, $43                                            ; $15BB72
    OAM 128, 114, 0, 1, 2, 4, 0, $42                                            ; $15BB76
    OAM 104, 122, 1, 0, 2, 4, 0, $42                                            ; $15BB7A
    OAM 112, 122, 1, 0, 2, 4, 0, $43                                            ; $15BB7E
    OAM 120, 122, 1, 1, 2, 4, 0, $43                                            ; $15BB82
    OAM 128, 122, 1, 1, 2, 4, 0, $42                                            ; $15BB86

    OAM 104, 114, 0, 0, 2, 4, 0, $40                                            ; $15BB8A | $01: Medium shadow
    OAM 112, 114, 0, 0, 2, 4, 0, $41                                            ; $15BB8E
    OAM 120, 114, 0, 1, 2, 4, 0, $41                                            ; $15BB92
    OAM 128, 114, 0, 1, 2, 4, 0, $40                                            ; $15BB96
    OAM 104, 122, 1, 0, 2, 4, 0, $40                                            ; $15BB9A
    OAM 112, 122, 1, 0, 2, 4, 0, $41                                            ; $15BB9E
    OAM 120, 122, 1, 1, 2, 4, 0, $41                                            ; $15BBA2
    OAM 128, 122, 1, 1, 2, 4, 0, $40                                            ; $15BBA6

    OAM 104, 114, 0, 0, 2, 4, 0, $3E                                            ; $15BBAA | $02: Small shadow
    OAM 112, 114, 0, 0, 2, 4, 0, $3F                                            ; $15BBAE
    OAM 120, 114, 0, 1, 2, 4, 0, $3F                                            ; $15BBB2
    OAM 128, 114, 0, 1, 2, 4, 0, $3E                                            ; $15BBB6
    OAM 104, 122, 1, 0, 2, 4, 0, $3E                                            ; $15BBBA
    OAM 112, 122, 1, 0, 2, 4, 0, $3F                                            ; $15BBBE
    OAM 120, 122, 1, 1, 2, 4, 0, $3F                                            ; $15BBC2
    OAM 128, 122, 1, 1, 2, 4, 0, $3E                                            ; $15BBC6

    OAM 104, 114, 0, 0, 2, 4, 0, $3C                                            ; $15BBCA | $03: Extra small shadow
    OAM 112, 114, 0, 0, 2, 4, 0, $3D                                            ; $15BBCE
    OAM 120, 114, 0, 1, 2, 4, 0, $3D                                            ; $15BBD2
    OAM 128, 114, 0, 1, 2, 4, 0, $3C                                            ; $15BBD6
    OAM 104, 122, 1, 0, 2, 4, 0, $3C                                            ; $15BBDA
    OAM 112, 122, 1, 0, 2, 4, 0, $3D                                            ; $15BBDE
    OAM 120, 122, 1, 1, 2, 4, 0, $3D                                            ; $15BBE2
    OAM 128, 122, 1, 1, 2, 4, 0, $3C                                            ; $15BBE6

; _draw_zoomed_big_whale ($15:BBEA)
;
; Draws the zoomed Big Whale sprite to the appropriate location on the screen
; by setting the sprites in the OAM. Expected to be run as a continuation of
; draw_field_sprite_big_whale and should not be used otherwise.
_draw_zoomed_big_whale:
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BBEA |\
    SEC                                                                         ; $15BBEC | | Subtract 8 from the Y coordinate to properly locate the two-tile
    SBC #8.b                                                                    ; $15BBED | | sprite.
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BBEF |/
    LDX #$0000.w                                                                ; $15BBF1 |\
-   LDA zoomed_big_whale_oam_data.w,X                                           ; $15BBF4 | | Set the X coordinate of the tile.
    CLC                                                                         ; $15BBF7 | |
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15BBF8 | |
    BCS +                                                                       ; $15BBFA | |
    STA r_oam.121.x.w,X                                                         ; $15BBFC |/
    LDA zoomed_big_whale_oam_data.w + 1,X                                       ; $15BBFF |\
    CLC                                                                         ; $15BC02 | | Set the other three properties in the OAM.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15BC03 | |
    STA r_oam.121.y.w,X                                                         ; $15BC05 | |
    LDA zoomed_big_whale_oam_data.w + 2,X                                       ; $15BC08 | |
    STA r_oam.121.tile.w,X                                                      ; $15BC0B | |
    LDA zoomed_big_whale_oam_data.w + 3,X                                       ; $15BC0E | |
    STA r_oam.121.flags.w,X                                                     ; $15BC11 |/
+   INX                                                                         ; $15BC14 |\
    INX                                                                         ; $15BC15 | | Increment and repeat until all four tiles have been set.
    INX                                                                         ; $15BC16 | |
    INX                                                                         ; $15BC17 | |
    CPX #$0010.w                                                                ; $15BC18 | |
    BNE -                                                                       ; $15BC1B |/
    PLB                                                                         ; $15BC1D | Restore the data bank register.
    RTL                                                                         ; $15BC1E

; zoomed_big_whale_oam_data ($15:BC1F)
;
; Contains data necessary to draw the zoomed Big Whale sprite to the OAM.
zoomed_big_whale_oam_data:
    OAM 0, 0, 0, 0, 3, 7, 0, $44                                                ; $15BC1F
    OAM 8, 0, 0, 0, 3, 7, 0, $45                                                ; $15BC23
    OAM 0, 8, 0, 0, 3, 7, 0, $46                                                ; $15BC27
    OAM 8, 8, 0, 0, 3, 7, 0, $47                                                ; $15BC2B

; draw_field_sprite_big_whale ($15:BC2F)
;
; Draws the Big Whale to the OAM data in RAM to be later copied into the actual
; OAM data by the NMI handler.
draw_field_sprite_big_whale:
    PHB                                                                         ; $15BC2F |\
    LDA #$15.b                                                                  ; $15BC30 | | Set the data bank register to $15.
    PHA                                                                         ; $15BC32 | |
    PLB                                                                         ; $15BC33 |/
    LDA r_vehicle.w                                                             ; $15BC34 |\
    CMP #VEHICLE_BIG_WHALE.b                                                    ; $15BC37 | | If the current vehicle is the Big Whale, branch accordingly.
    BNE +                                                                       ; $15BC39 | |
    JMP @active                                                                 ; $15BC3B |/
+   LDA r_big_whale_status.w                                                    ; $15BC3E |\
    BEQ @skip_to_done                                                           ; $15BC41 | | Here, the Big Whale is parked. In this case, only draw the sprite
    LDA r_map_plane.w                                                           ; $15BC43 | | if the Big Whale is active, the Big Whale's plane matches the
    CMP r_big_whale_plane.w                                                     ; $15BC46 | | current plane, and the zoom level mod 16 is zero.
    BNE @skip_to_done                                                           ; $15BC49 | |
    LDA <r_zoom_level                                                           ; $15BC4B | |
    AND #%00001111.b                                                            ; $15BC4D | |
    BNE @skip_to_done                                                           ; $15BC4F |/
    LDA r_big_whale_coordinates.x.w                                             ; $15BC51 |\
    DEC A                                                                       ; $15BC54 | | Subtract 1 from the coordinates because the sprite is extra large.
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC55 | |
    LDA r_big_whale_coordinates.y.w                                             ; $15BC57 | |
    DEC A                                                                       ; $15BC5A | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BC5B |/
    LDA r_map_area.w                                                            ; $15BC5D |\
    CMP #MAP_AREA_MOON.b                                                        ; $15BC60 | | If the Big Whale is on Earth, skip the next set of code.
    BNE @earth                                                                  ; $15BC62 |/
    LDA r_big_whale_coordinates.x.w                                             ; $15BC64 |\
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC67 | | Load the Big Whale X and Y coordinates.
    LDA r_big_whale_coordinates.y.w                                             ; $15BC69 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BC6C |/
    LDA r_current_coordinates.x.w                                               ; $15BC6E |\
    CMP #8.b                                                                    ; $15BC71 | | If the current X coordinate is less than 8 and the Big Whale X
    BCS +                                                                       ; $15BC73 | | coordinate is greater than or equal to 48, subtract 64 from the
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC75 | | Big Whale X coordinate.
    CMP #48.b                                                                   ; $15BC77 | |
    BCC ++                                                                      ; $15BC79 | |
    SEC                                                                         ; $15BC7B | |
    SBC #64.b                                                                   ; $15BC7C | |
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC7E | |
    JMP ++                                                                      ; $15BC80 |/
+   CMP #56.b                                                                   ; $15BC83 |\
    BCC ++                                                                      ; $15BC85 | | If the current X coordinate is greater than or equal to 56 and the
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC87 | | Big Whale X coordinate is less than 16, add 64 to the Big Whale
    CMP #16.b                                                                   ; $15BC89 | | coordinate.
    BCS ++                                                                      ; $15BC8B | |
    CLC                                                                         ; $15BC8D | |
    ADC #64.b                                                                   ; $15BC8E | |
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BC90 |/
++  LDA r_current_coordinates.y.w                                               ; $15BC92 |\
    CMP #8.b                                                                    ; $15BC95 | | Repeat the preceding logic, except with the Y coordinate. The
    BCS +                                                                       ; $15BC97 | | purpose of these adjustments is to wrap the coordinates around so
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BC99 | | that the coordinate visibility routine will find that they are
    CMP #48.b                                                                   ; $15BC9B | | close, since it assumes a 256x256 map instead of a 64x64 one.
    BCC ++                                                                      ; $15BC9D | |
    SEC                                                                         ; $15BC9F | |
    SBC #64.b                                                                   ; $15BCA0 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BCA2 | |
    JMP ++                                                                      ; $15BCA4 | |
+   CMP #56.b                                                                   ; $15BCA7 | |
    BCC ++                                                                      ; $15BCA9 | |
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BCAB | |
    CMP #16.b                                                                   ; $15BCAD | |
    BCS ++                                                                      ; $15BCAF | |
    CLC                                                                         ; $15BCB1 | |
    ADC #64.b                                                                   ; $15BCB2 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BCB4 |/
++  DEC <r_check_coordinates_visible_arg_x_lo                                   ; $15BCB6 |\ Decrement each coordinate by 1.
    DEC <r_check_coordinates_visible_arg_y_lo                                   ; $15BCB8 |/
@earth:
    JSL check_coordinates_visible                                               ; $15BCBA |\
    LDA <r_check_coordinates_visible_result                                     ; $15BCBE | | If the Big Whale is not visible, skip the rest of the function.
    BNE +                                                                       ; $15BCC0 | |
@skip_to_done:                                                                  ;         | |
    JMP @done                                                                   ; $15BCC2 |/
+   LDA <r_zoom_level                                                           ; $15BCC5 |\
    CMP #$10.b                                                                  ; $15BCC7 | | If the zoom level is appropriate, switch to drawing the zoomed
    BEQ +                                                                       ; $15BCC9 | | version of the sprite. Otherwise, set the direction in the
    JMP _draw_zoomed_big_whale                                                  ; $15BCCB | | accumulator to left and continue.
+   LDA #DIRECTION_LEFT.b                                                       ; $15BCCE | |
    JMP +++                                                                     ; $15BCD0 |/
@active:
    LDA <r_big_whale_altitude                                                   ; $15BCD3 |\
    CMP #$10.b                                                                  ; $15BCD5 | | If the Big Whale is the currently active vehicle, start by
    BCS +                                                                       ; $15BCD7 | | drawing the shadow. Then, set the X and Y coordinates to 96, 96
    JSL draw_big_whale_shadow                                                   ; $15BCD9 | | other than subtracting the altitude. Finish by loading the current
    JMP ++                                                                      ; $15BCDD | | direction.
+   SEC                                                                         ; $15BCE0 | |
    SBC #$10.b                                                                  ; $15BCE1 | |
    CMP #$10.b                                                                  ; $15BCE3 | |
    BCC +                                                                       ; $15BCE5 | |
    LDA #$10.b                                                                  ; $15BCE7 | |
+   JSL draw_field_sprite_shadow                                                ; $15BCE9 | |
++  LDA #$60.b                                                                  ; $15BCED | |
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BCEF | |
    LDA #$60.b                                                                  ; $15BCF1 | |
    SEC                                                                         ; $15BCF3 | |
    SBC <r_big_whale_altitude                                                   ; $15BCF4 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BCF6 | |
    STZ <r_check_coordinates_visible_arg_x_hi                                   ; $15BCF8 | |
    STZ <r_check_coordinates_visible_arg_y_hi                                   ; $15BCFA | |
    LDA r_direction.w                                                           ; $15BCFC |/
+++ ASL A                                                                       ; $15BCFF |\
    ASL A                                                                       ; $15BD00 | | Determine the index into the sprite data by multiplying the
    ASL A                                                                       ; $15BD01 | | direction by 32. (Each direction has one 16 tile sprite.) The
    ASL A                                                                       ; $15BD02 | | coordinates and OAM data are stored in separate tables. The Big
    ASL A                                                                       ; $15BD03 | | Whale has no animation other than palette effects.
    STA <r_draw_field_sprite_tmp                                                ; $15BD04 | |
    LDA <r_draw_field_sprite_tmp                                                ; $15BD06 | |
    TAX                                                                         ; $15BD08 | |
    STX <r_draw_field_sprite_big_whale_oam_index                                ; $15BD09 |/
    LDY #$0000.w                                                                ; $15BD0B |\
    STY <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD0E | | The coordinate index is always zero.
-   LDX <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD10 |/
    LDA field_sprite_big_whale_oam_coordinate_data.w,X                          ; $15BD12 |\
    CLC                                                                         ; $15BD15 | | Set the X coordinate for the current tile. Set the high OAM bit if
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15BD16 | | it overflows after adding the tile offset.
    STA r_oam.74.x,Y                                                            ; $15BD18 | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BD1B | |
    ADC #$00.b                                                                  ; $15BD1D | |
    AND #%00000001.b                                                            ; $15BD1F | |
    BEQ +                                                                       ; $15BD21 | |
    LDA #73.b                                                                   ; $15BD23 | |
    JSL set_oam_hi_x                                                            ; $15BD25 |/
+   LDA field_sprite_big_whale_oam_coordinate_data.w + 1,X                      ; $15BD29 |\
    CLC                                                                         ; $15BD2C | | Set the Y coordinate for the tile.
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15BD2D | |
    STA r_oam.74.y,Y                                                            ; $15BD2F |/
    LDX <r_draw_field_sprite_big_whale_oam_index                                ; $15BD32 |\
    LDA field_sprite_big_whale_oam_data.w,X                                     ; $15BD34 | | Load the other index and set the tile and flags.
    STA r_oam.74.tile,Y                                                         ; $15BD37 | |
    LDA field_sprite_big_whale_oam_data.w + 1,X                                 ; $15BD3A | |
    STA r_oam.74.flags,Y                                                        ; $15BD3D |/
    INC <r_draw_field_sprite_big_whale_oam_index                                ; $15BD40 |\
    INC <r_draw_field_sprite_big_whale_oam_index                                ; $15BD42 | | Increment the indexes and loop until the first eight tiles have
    INC <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD44 | | been set.
    INC <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD46 | |
    INY                                                                         ; $15BD48 | |
    INY                                                                         ; $15BD49 | |
    INY                                                                         ; $15BD4A | |
    INY                                                                         ; $15BD4B | |
    CPY #$0020.w                                                                ; $15BD4C | |
    BNE -                                                                       ; $15BD4F |/
    LDY #$0000.w                                                                ; $15BD51 |\
-   LDX <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD54 | | Repeat the process, except for the lower 8 tiles. The main
    LDA field_sprite_big_whale_oam_coordinate_data.w,X                          ; $15BD56 | | difference is that the sprites used in the OAM are at a different
    CLC                                                                         ; $15BD59 | | offset.
    ADC <r_check_coordinates_visible_arg_x_lo                                   ; $15BD5A | |
    STA r_oam.105.x,Y                                                           ; $15BD5C | |
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BD5F | |
    ADC #$00.b                                                                  ; $15BD61 | |
    AND #%00000001.b                                                            ; $15BD63 | |
    BEQ +                                                                       ; $15BD65 | |
    LDA #104.b                                                                  ; $15BD67 | |
    JSL set_oam_hi_x                                                            ; $15BD69 | |
+   LDA field_sprite_big_whale_oam_coordinate_data.w + 1,X                      ; $15BD6D | |
    CLC                                                                         ; $15BD70 | |
    ADC <r_check_coordinates_visible_arg_y_lo                                   ; $15BD71 | |
    STA r_oam.105.y,Y                                                           ; $15BD73 | |
    LDX <r_draw_field_sprite_big_whale_oam_index                                ; $15BD76 | |
    LDA field_sprite_big_whale_oam_data.w,X                                     ; $15BD78 | |
    STA r_oam.105.tile,Y                                                        ; $15BD7B | |
    LDA field_sprite_big_whale_oam_data.w + 1,X                                 ; $15BD7E | |
    STA r_oam.105.flags,Y                                                       ; $15BD81 | |
    INC <r_draw_field_sprite_big_whale_oam_index                                ; $15BD84 | |
    INC <r_draw_field_sprite_big_whale_oam_index                                ; $15BD86 | |
    INC <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD88 | |
    INC <r_draw_field_sprite_big_whale_coordinate_index                         ; $15BD8A | |
    INY                                                                         ; $15BD8C | |
    INY                                                                         ; $15BD8D | |
    INY                                                                         ; $15BD8E | |
    INY                                                                         ; $15BD8F | |
    CPY #$0020.w                                                                ; $15BD90 | |
    BNE -                                                                       ; $15BD93 |/
@done:
    PLB                                                                         ; $15BD95 | Restore the data bank register.
    RTL                                                                         ; $15BD96

; field_sprite_big_whale_oam_coordinate_data ($15:BD97)
;
; Contains the coordinates for each of the 16 tiles of the Big Whale sprite.
field_sprite_big_whale_oam_coordinate_data:
    .db  8, -3                                                                  ; $15BD97
    .db 16, -3                                                                  ; $15BD99
    .db 24, -3                                                                  ; $15BD9B
    .db 32, -3                                                                  ; $15BD9D
    .db  8,  5                                                                  ; $15BD9F
    .db 16,  5                                                                  ; $15BDA1
    .db 24,  5                                                                  ; $15BDA3
    .db 32,  5                                                                  ; $15BDA5
    .db  8, 13                                                                  ; $15BDA7
    .db 16, 13                                                                  ; $15BDA9
    .db 24, 13                                                                  ; $15BDAB
    .db 32, 13                                                                  ; $15BDAD
    .db  8, 21                                                                  ; $15BDAF
    .db 16, 21                                                                  ; $15BDB1
    .db 24, 21                                                                  ; $15BDB3
    .db 32, 21                                                                  ; $15BDB5

; field_sprite_big_whale_oam_data ($15:BDB7)
;
; Contains the tile and flags for each of the tiles involved in drawing the
; Big Whale.
field_sprite_big_whale_oam_data:
    .db $0A, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDB7 | $00: Up
    .db $0B, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDB9
    .db $0C, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDBB
    .db $0A, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDBD
    .db $0E, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDBF
    .db $0F, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDC1
    .db $10, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDC3
    .db $0E, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDC5
    .db $12, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDC7
    .db $13, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDC9
    .db $14, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDCB
    .db $12, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDCD
    .db $16, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDCF
    .db $17, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDD1
    .db $18, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDD3
    .db $19, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDD5

    .db $1D, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDD7 | $01: Right
    .db $0D, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDD9
    .db $1B, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDDB
    .db $1A, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDDD
    .db $21, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDDF
    .db $20, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDE1
    .db $1F, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDE3
    .db $1E, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDE5
    .db $25, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDE7
    .db $24, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDE9
    .db $23, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDEB
    .db $22, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDED
    .db $0D, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDEF
    .db $28, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDF1
    .db $27, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDF3
    .db $26, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BDF5

    .db $FA, (0 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BDF7 | $02: Down
    .db $FB, (0 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BDF9
    .db $FC, (0 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BDFB
    .db $FA, (1 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BDFD
    .db $FE, (0 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BDFF
    .db $FF, (0 << 6) + (2 << 4) + (7 << 1) + 0                                 ; $15BE01
    .db $00, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE03
    .db $0D, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE05
    .db $02, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE07
    .db $03, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE09
    .db $04, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE0B
    .db $02, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE0D
    .db $06, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE0F
    .db $07, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE11
    .db $08, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE13
    .db $06, (1 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE15

    .db $1A, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE17 | $03: Left
    .db $1B, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE19
    .db $0D, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE1B
    .db $1D, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE1D
    .db $1E, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE1F
    .db $1F, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE21
    .db $20, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE23
    .db $21, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE25
    .db $22, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE27
    .db $23, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE29
    .db $24, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE2B
    .db $25, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE2D
    .db $26, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE2F
    .db $27, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE31
    .db $28, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE33
    .db $0D, (0 << 6) + (2 << 4) + (7 << 1) + 1                                 ; $15BE35

; airship_animation_speed_data ($15:BE37)
;
; For a given index corresponding to the desired airship animation speed, gives
; the necessary mask to apply to the frame counter to determine which frame of
; animation should be used.
airship_animation_speed_data:
    .db %00010000                                                               ; $15BE37 | $00
    .db %00010000                                                               ; $15BE38 | $01
    .db %00010000                                                               ; $15BE39 | $02
    .db %00001000                                                               ; $15BE3A | $03
    .db %00001000                                                               ; $15BE3B | $04
    .db %00001000                                                               ; $15BE3C | $05
    .db %00001000                                                               ; $15BE3D | $06
    .db %00000100                                                               ; $15BE3E | $07
    .db %00001000                                                               ; $15BE3F | $08
    .db %00000100                                                               ; $15BE40 | $09
    .db %00000100                                                               ; $15BE41 | $0A
    .db %00000100                                                               ; $15BE42 | $0B
    .db %00000010                                                               ; $15BE43 | $0C
    .db %00000010                                                               ; $15BE44 | $0D
    .db %00000010                                                               ; $15BE45 | $0E
    .db %00000010                                                               ; $15BE46 | $0F

; check_coordinates_visible ($15:BE47)
;
; Given a 16-bit X-coordinate in $060C and a 16-bit Y coordinate in $060E,
; determines if the tile at those coordinates should be visible on screen. If
; so, a positive result is returned in $06D7.
;
; TODO: Try to understand the math behind this function better, especially
;       regarding the airship and Big Whale.
check_coordinates_visible:
    PHB                                                                         ; $15BE47 |\
    LDA #$15.b                                                                  ; $15BE48 | | Save the data bank register and set it to $15.
    PHA                                                                         ; $15BE4A | |
    PLB                                                                         ; $15BE4B |/
    STZ <r_check_coordinates_visible_result                                     ; $15BE4C | Set the result to false to start.
    LDA <r_zoom_level                                                           ; $15BE4E |\
    LSR A                                                                       ; $15BE50 | | Set the Y register by taking the current zoom level and dividing
    LSR A                                                                       ; $15BE51 | | by 16 and then subtracting one. Since zoom level ranges from 16 to
    LSR A                                                                       ; $15BE52 | | 48, this essentially means the Y register will be 0 when not
    LSR A                                                                       ; $15BE53 | | flying, 1 when flying the Enterprise or Falcon, and 2 when flying
    DEC A                                                                       ; $15BE54 | | the Big Whale.
    TAY                                                                         ; $15BE55 |/
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BE56 |\
    CLC                                                                         ; $15BE58 | | Using the data table, add the number of tiles that might be
    ADC check_coordinates_visible_negative_x_data,Y                             ; $15BE59 | | visible to the left of center at a given zoom level to the passed
    SEC                                                                         ; $15BE5C | | X coordinate. Subtract the current X coordinate. If this value is
    SBC r_current_coordinates.x.w                                               ; $15BE5D | | greater than the total number of visible tiles, it is out of range
    CMP check_coordinates_visible_total_x_data,Y                                ; $15BE60 | | and we return. Otherwise, we continue.
    BCC +                                                                       ; $15BE63 | |
    JMP @done                                                                   ; $15BE65 |/
+   STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BE68 | Store the adjusted X coordinate back to RAM.
    CPY #$0000.w                                                                ; $15BE6A |\ If the zoom level is not zoomed in, skip this next block.
    BNE +                                                                       ; $15BE6D |/
    DEC A                                                                       ; $15BE6F |\
    DEC A                                                                       ; $15BE70 | | Subtract two from the X coordinate and multiply by 16. The maximum
    ASL A                                                                       ; $15BE71 | | value at this point is 256, so shift that potential bit into the
    ASL A                                                                       ; $15BE72 | | high byte of the X coordinate.
    ASL A                                                                       ; $15BE73 | |
    ASL A                                                                       ; $15BE74 | | Afterward, subtract the low four bits of the horizontal scroll
    ROL <r_check_coordinates_visible_arg_x_hi                                   ; $15BE75 | | register. This results in the pixel coordinate of the tile in
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BE77 | | question.
    LDA <r_scroll_bg1_horizontal_lo                                             ; $15BE79 | |
    AND #%00001111.b                                                            ; $15BE7B | | THe high byte of the X coordinate is no longer particularly
    STA <r_check_coordinates_visible_tmp                                        ; $15BE7D | | meaningful, the its lowest bit will be set if the pixel coordinate
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BE7F | | is 256.
    SEC                                                                         ; $15BE81 | |
    SBC <r_check_coordinates_visible_tmp                                        ; $15BE82 | | TODO: Maybe reexamine this and make sure the interpretation is
    STA <r_check_coordinates_visible_arg_x_lo                                   ; $15BE84 | | correct.
    LDA <r_check_coordinates_visible_arg_x_hi                                   ; $15BE86 | |
    SBC #$00.b                                                                  ; $15BE88 | |
    STA <r_check_coordinates_visible_arg_x_hi                                   ; $15BE8A |/
+   LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BE8C |\
    CLC                                                                         ; $15BE8E | | Repeat the process for the Y coordinate, again only calculating
    ADC check_coordinates_visible_negative_y_data,Y                             ; $15BE8F | | the pixel coordinates if we are completely zoomed in.
    SEC                                                                         ; $15BE92 | |
    SBC r_current_coordinates.y.w                                               ; $15BE93 | |
    CMP check_coordinates_visible_total_y_data,Y                                ; $15BE96 | |
    BCC +                                                                       ; $15BE99 | |
    JMP @done                                                                   ; $15BE9B | |
+   STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BE9E | |
    CPY #$0000.w                                                                ; $15BEA0 | |
    BNE +                                                                       ; $15BEA3 | |
    DEC A                                                                       ; $15BEA5 | |
    ASL A                                                                       ; $15BEA6 | |
    ASL A                                                                       ; $15BEA7 | |
    ASL A                                                                       ; $15BEA8 | |
    ASL A                                                                       ; $15BEA9 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BEAA | |
    LDA <r_scroll_bg1_vertical_lo                                               ; $15BEAC | |
    AND #%00001111.b                                                            ; $15BEAE | |
    STA <r_check_coordinates_visible_tmp                                        ; $15BEB0 | |
    LDA <r_check_coordinates_visible_arg_y                                      ; $15BEB2 | |
    SEC                                                                         ; $15BEB4 | |
    SBC <r_check_coordinates_visible_tmp                                        ; $15BEB5 | |
    STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BEB7 |/
+   CPY #$0000.w                                                                ; $15BEB9 |\
    BNE +                                                                       ; $15BEBC | | If unzoomed, branch to near the end. If at Enterprise or Big Whale
    JMP @unzoomed                                                               ; $15BEBE | | zoom levels, branch acoordingly.
+   STZ $0A                                                                     ; $15BEC1 | |
    CPY #$0002.w                                                                ; $15BEC3 | |
    BEQ @whale_zoomed                                                           ; $15BEC6 |/
    LDA <r_scroll_bg1_vertical_lo                                               ; $15BEC8 |\
    AND #%00001111.b                                                            ; $15BECA | | If the vertical scroll register mod 16 is zero, set the Y
    BNE +                                                                       ; $15BECC | | coordinate to the value read from the array in ROM. This is the
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BECE | | pixel coordinate corresponding to that particular Y coordinate
    TAX                                                                         ; $15BED0 | | when zoomed at the Enterprise/Falcon level.
    LDA bank14.airship_visible_tiles_offset_data.l,X                            ; $15BED1 | |
    JMP ++                                                                      ; $15BED5 | | If the scroll register mod 16 was not zero, instead take the
+   LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BED8 | | average of the value for the previous coordinate and the current
    BNE +                                                                       ; $15BEDA | | value.
    JMP @done                                                                   ; $15BEDC | |
+   DEC A                                                                       ; $15BEDF | |
    TAX                                                                         ; $15BEE0 | |
    LDA bank14.airship_visible_tiles_offset_data.l + 1,X                        ; $15BEE1 | |
    SEC                                                                         ; $15BEE5 | |
    SBC bank14.airship_visible_tiles_offset_data.l,X                            ; $15BEE6 | |
    LSR A                                                                       ; $15BEEA | |
    CLC                                                                         ; $15BEEB | |
    ADC bank14.airship_visible_tiles_offset_data.l,X                            ; $15BEEC | |
++  STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BEF0 |/
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BEF2 |\
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BEF4 | | Read the data from the table in ROM and set the first parameter
    ASL <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BEF6 | | for the upcoming multiplication to that value.
    ROL <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BEF8 | |
    LDX <r_bank15_math_multiply_16bit_arg_1                                     ; $15BEFA | |
    LDA bank14.airship_visible_tiles_multiplier_data.l,X                        ; $15BEFC | |
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BF00 | |
    LDA bank14.airship_visible_tiles_multiplier_data.l + 1,X                    ; $15BF02 | |
    STA <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BF06 |/
    LDA <r_scroll_bg1_horizontal_lo                                             ; $15BF08 |\
    AND #%00001000.b                                                            ; $15BF0A | | Initially set the second multiplication parameter to an
    LSR A                                                                       ; $15BF0C | | alternating pattern of 8 frames of 0 followed by 8 frames of 1.
    LSR A                                                                       ; $15BF0D | |
    LSR A                                                                       ; $15BF0E | |
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF0F |/
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BF11 |\
    ASL A                                                                       ; $15BF13 | | Now, actually set the second parameter to the X coordinate
    SEC                                                                         ; $15BF14 | | multiplied by 2, and then subtract the previously set value of 0
    SBC <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF15 | | or 1 and then also subtract 38. If this final value has gone
    SEC                                                                         ; $15BF17 | | negative, set an additional variable to 1, and then negate the
    SBC #38.b                                                                   ; $15BF18 | | value.
    BPL +                                                                       ; $15BF1A | |
    INC <r_check_coordinates_visible_tmp_negative                               ; $15BF1C | |
    EOR #%11111111.b                                                            ; $15BF1E | |
    INC A                                                                       ; $15BF20 | |
+   STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF21 | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $15BF23 |/
    JMP @zoomed                                                                 ; $15BF25 | Move on the next part of the function.
@whale_zoomed:
    LDA <r_scroll_bg1_vertical                                                  ; $15BF28 |\
    AND #%00001111.b                                                            ; $15BF2A | | This does the same thing as above except for the Big Whale, and it
    BNE +                                                                       ; $15BF2C | | subtracts 64 instead of 26.
    LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BF2E | |
    TAX                                                                         ; $15BF30 | |
    LDA bank14.big_whale_visible_tiles_offset_data.l,X                          ; $15BF31 | |
    JMP ++                                                                      ; $15BF35 | |
+   LDA <r_check_coordinates_visible_arg_y_lo                                   ; $15BF38 | |
    BNE +                                                                       ; $15BF3A | |
    JMP @done                                                                   ; $15BF3C | |
+   DEC A                                                                       ; $15BF3F | |
    TAX                                                                         ; $15BF40 | |
    LDA bank14.big_whale_visible_tiles_offset_data.l + 1,X                      ; $15BF41 | |
    SEC                                                                         ; $15BF45 | |
    SBC bank14.big_whale_visible_tiles_offset_data.l,X                          ; $15BF46 | |
    LSR A                                                                       ; $15BF4A | |
    CLC                                                                         ; $15BF4B | |
    ADC bank14.big_whale_visible_tiles_offset_data.l,X                          ; $15BF4C | |
++  STA <r_check_coordinates_visible_arg_y_lo                                   ; $15BF50 | |
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BF52 | |
    STZ <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BF54 | |
    ASL <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BF56 | |
    ROL <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BF58 | |
    LDX <r_bank15_math_multiply_16bit_arg_1                                     ; $15BF5A | |
    LDA bank14.big_whale_visible_tiles_multiplier_data.l,X                      ; $15BF5C | |
    STA <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15BF60 | |
    LDA bank14.big_whale_visible_tiles_multiplier_data.l + 1,X                  ; $15BF62 | |
    STA <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15BF66 | |
    LDA <r_scroll_bg1_horizontal_lo                                             ; $15BF68 | |
    AND #%00001000.b                                                            ; $15BF6A | |
    LSR A                                                                       ; $15BF6C | |
    LSR A                                                                       ; $15BF6D | |
    LSR A                                                                       ; $15BF6E | |
    STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF6F | |
    LDA <r_check_coordinates_visible_arg_x_lo                                   ; $15BF71 | |
    ASL A                                                                       ; $15BF73 | |
    SEC                                                                         ; $15BF74 | |
    SBC <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF75 | |
    SEC                                                                         ; $15BF77 | |
    SBC #64.b                                                                   ; $15BF78 | |
    BPL +                                                                       ; $15BF7A | |
    INC <r_check_coordinates_visible_tmp_negative                               ; $15BF7C | |
    EOR #%11111111.b                                                            ; $15BF7E | |
    INC A                                                                       ; $15BF80 | |
+   STA <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15BF81 | |
    STZ <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $15BF83 |/
@zoomed:
    JSL math_multiply_16bit                                                     ; $15BF85 |\
    LSR <r_bank15_math_multiply_16bit_result_hi                                 ; $15BF89 | | Execute the actual multiplication and then divide by $200.
    ROR <r_bank15_math_multiply_16bit_result_md                                 ; $15BF8B |/
    LDA <r_check_coordinates_visible_tmp_negative                               ; $15BF8D |\
    BNE +                                                                       ; $15BF8F | | If the initial second parameter to the multiplication was
    LDA <r_bank15_math_multiply_16bit_result_md                                 ; $15BF91 | | positive, add the value to 120. If this final value was greater
    CLC                                                                         ; $15BF93 | | than 255, leave the function.
    ADC #120.b                                                                  ; $15BF94 | |
    BCS @done                                                                   ; $15BF96 | |
    JMP ++                                                                      ; $15BF98 |/
+   LDA #120.b                                                                  ; $15BF9B |\
    SEC                                                                         ; $15BF9D | | If the parameter was negative, subtract the result from 120
    SBC <r_bank15_math_multiply_16bit_result_md                                 ; $15BF9E | | instead. If it's less than zero, return from the function.
    BCC @done                                                                   ; $15BFA0 |/
++  STA <r_check_coordinates_visible_arg_x                                      ; $15BFA2
@unzoomed:
    INC <r_check_coordinates_visible_result                                     ; $15BFA4 | The sprite should be visible, so set a positive result.
@done:
    PLB                                                                         ; $15BFA6
    RTL                                                                         ; $15BFA7

; check_coordinates_visible_negative_x_data ($15:BFA8)
;
; For each zoom level, provides the maximum number of tiles that need to be
; considered for visibility to the left of center.
check_coordinates_visible_negative_x_data:
    .db 9                                                                       ; $15BFA8 | $00: Ground level
    .db 19                                                                      ; $15BFA9 | $01: Flying airship
    .db 32                                                                      ; $15BFAA | $02: Flying Big Whale

; check_coordinates_visible_total_x_data ($15:BFAB)
;
; For each zoom level, provides the maximum number of tiles that need to be
; considered for visibility horizontally.
check_coordinates_visible_total_x_data:
    .db 19                                                                      ; $15BFAB | $00: Ground level
    .db 44                                                                      ; $15BFAC | $01: Flying airship
    .db 66                                                                      ; $15BFAD | $02: Flying Big Whale

; check_coordinates_visible_negative_y_data ($15:BFAE)
;
; For each zoom level, provides the maximum number of tiles that need to be
; considered for visibility above the center.
check_coordinates_visible_negative_y_data:
    .db 8                                                                       ; $15BFAE | $00: Ground level
    .db 23                                                                      ; $15BFAF | $01: Flying airship
    .db 31                                                                      ; $15BFB0 | $02: Flying Big Whale

; check_coordinates_visible_total_y_data ($15:BFB1)
;
; For each zoom level, provides the maximum number of tiles that need to be
; considered for visibility vertically.
check_coordinates_visible_total_y_data:
    .db 16                                                                      ; $15BFB1 | $00: Ground level
    .db 33                                                                      ; $15BFB2 | $01: Flying airship
    .db 44                                                                      ; $15BFB3 | $02: Flying Big Whale

; field_sprite_vehicle_oam_data ($15:BFB4)
;
; Contains the data necessary for drawing many of the vehicles to the OAM. Each
; of the four directions has two frames of data. Each frame consists of four
; tiles, allowing the vehicle to be of the 16x16 size. When using the data, it
; is necessary to add an offset to the tile number and set the desired palette.
field_sprite_vehicle_oam_data:
    OAM 0, 0, 0, 0, 2, 0, 0, $08                                                ; $15BFB4 | $00: Up, frame 1
    OAM 8, 0, 0, 0, 2, 0, 0, $09                                                ; $15BFB8
    OAM 0, 8, 0, 0, 2, 0, 0, $0A                                                ; $15BFBC
    OAM 8, 8, 0, 0, 2, 0, 0, $0B                                                ; $15BFC0

    OAM 0, 0, 0, 0, 2, 0, 0, $0C                                                ; $15BFC4 | $01: Up, frame 2
    OAM 8, 0, 0, 0, 2, 0, 0, $0D                                                ; $15BFC8
    OAM 0, 8, 0, 0, 2, 0, 0, $0E                                                ; $15BFCC
    OAM 8, 8, 0, 0, 2, 0, 0, $0F                                                ; $15BFD0

    OAM 0, 0, 0, 1, 2, 0, 0, $11                                                ; $15BFD4 | $02: Right, frame 1
    OAM 8, 0, 0, 1, 2, 0, 0, $10                                                ; $15BFD8
    OAM 0, 8, 0, 1, 2, 0, 0, $13                                                ; $15BFDC
    OAM 8, 8, 0, 1, 2, 0, 0, $12                                                ; $15BFE0

    OAM 0, 0, 0, 1, 2, 0, 0, $15                                                ; $15BFE4 | $03: Right, frame 2
    OAM 8, 0, 0, 1, 2, 0, 0, $14                                                ; $15BFE8
    OAM 0, 8, 0, 1, 2, 0, 0, $17                                                ; $15BFEC
    OAM 8, 8, 0, 1, 2, 0, 0, $16                                                ; $15BFF0

    OAM 0, 0, 0, 0, 2, 0, 0, $00                                                ; $15BFF4 | $04: Down, frame 1
    OAM 8, 0, 0, 0, 2, 0, 0, $01                                                ; $15BFF8
    OAM 0, 8, 0, 0, 2, 0, 0, $02                                                ; $15BFFC
    OAM 8, 8, 0, 0, 2, 0, 0, $03                                                ; $15C000

    OAM 0, 0, 0, 0, 2, 0, 0, $04                                                ; $15C004 | $05: Down, frame 2
    OAM 8, 0, 0, 0, 2, 0, 0, $05                                                ; $15C008
    OAM 0, 8, 0, 0, 2, 0, 0, $06                                                ; $15C00C
    OAM 8, 8, 0, 0, 2, 0, 0, $07                                                ; $15C010

    OAM 0, 0, 0, 0, 2, 0, 0, $10                                                ; $15C014 | $06: Left, frame 1
    OAM 8, 0, 0, 0, 2, 0, 0, $11                                                ; $15C018
    OAM 0, 8, 0, 0, 2, 0, 0, $12                                                ; $15C01C
    OAM 8, 8, 0, 0, 2, 0, 0, $13                                                ; $15C020

    OAM 0, 0, 0, 0, 2, 0, 0, $14                                                ; $15C024 | $07: Left, frame 2
    OAM 8, 0, 0, 0, 2, 0, 0, $15                                                ; $15C028
    OAM 0, 8, 0, 0, 2, 0, 0, $16                                                ; $15C02C
    OAM 8, 8, 0, 0, 2, 0, 0, $17                                                ; $15C030

; yellow_chocobo_oam_data ($15:C034)
;
; Contains the data necessary to put a yellow chocobo sprite in the OAM. Each
; location encodes one orientation and frame of the yellow chocobo. It is
; indexed first by the desired direction, and then within that there are two
; separate frames. Each frame has four tiles associated with it, corresponding
; to the upper left, upper right, lower left, and lower right tiles of the
; sprite.
yellow_chocobo_oam_data:
    OAM 0, 0, 0, 0, 3, 4, 0, $24                                                ; $15C034 | $00: Yellow Chocobo Up Frame 1
    OAM 8, 0, 0, 0, 3, 4, 0, $25                                                ; $15C038
    OAM 0, 8, 0, 0, 3, 4, 0, $26                                                ; $15C03C
    OAM 8, 8, 0, 0, 3, 4, 0, $27                                                ; $15C040

    OAM 0, 0, 0, 1, 3, 4, 0, $25                                                ; $15C044 | $01: Yellow Chocobo Up Frame 2
    OAM 8, 0, 0, 1, 3, 4, 0, $24                                                ; $15C048
    OAM 0, 8, 0, 1, 3, 4, 0, $27                                                ; $15C04C
    OAM 8, 8, 0, 1, 3, 4, 0, $26                                                ; $15C050

    OAM 0, 0, 0, 1, 3, 4, 0, $29                                                ; $15C054 | $02: Yellow Chocobo Right Frame 1
    OAM 8, 0, 0, 1, 3, 4, 0, $28                                                ; $15C058
    OAM 0, 8, 0, 1, 3, 4, 0, $2B                                                ; $15C05C
    OAM 8, 8, 0, 1, 3, 4, 0, $2A                                                ; $15C060

    OAM 0, 0, 0, 1, 3, 4, 0, $2D                                                ; $15C064 | $03: Yellow Chocobo Right Frame 2
    OAM 8, 0, 0, 1, 3, 4, 0, $2C                                                ; $15C068
    OAM 0, 8, 0, 1, 3, 4, 0, $2F                                                ; $15C06C
    OAM 8, 8, 0, 1, 3, 4, 0, $2E                                                ; $15C070

    OAM 0, 0, 0, 0, 3, 4, 0, $20                                                ; $15C074 | $04: Yellow Chocobo Down Frame 1
    OAM 8, 0, 0, 0, 3, 4, 0, $21                                                ; $15C078
    OAM 0, 8, 0, 0, 3, 4, 0, $22                                                ; $15C07C
    OAM 8, 8, 0, 0, 3, 4, 0, $23                                                ; $15C080

    OAM 0, 0, 0, 1, 3, 4, 0, $21                                                ; $15C084 | $05: Yellow Chocobo Down Frame 2
    OAM 8, 0, 0, 1, 3, 4, 0, $20                                                ; $15C088
    OAM 0, 8, 0, 1, 3, 4, 0, $23                                                ; $15C08C
    OAM 8, 8, 0, 1, 3, 4, 0, $22                                                ; $15C090

    OAM 0, 0, 0, 0, 3, 4, 0, $28                                                ; $15C094 | $06: Yellow Chocobo Left Frame 1
    OAM 8, 0, 0, 0, 3, 4, 0, $29                                                ; $15C098
    OAM 0, 8, 0, 0, 3, 4, 0, $2A                                                ; $15C09C
    OAM 8, 8, 0, 0, 3, 4, 0, $2B                                                ; $15C0A0

    OAM 0, 0, 0, 0, 3, 4, 0, $2C                                                ; $15C0A4 | $07: Yellow Chocobo Left Frame 2
    OAM 8, 0, 0, 0, 3, 4, 0, $2D                                                ; $15C0A8
    OAM 0, 8, 0, 0, 3, 4, 0, $2E                                                ; $15C0AC
    OAM 8, 8, 0, 0, 3, 4, 0, $2F                                                ; $15C0B0

; player_field_sprite_coordinate_data ($15:C0B4)
;
; For each of the four tiles of the player field sprite, determines the location
; that tile should be drawn on screen.
player_field_sprite_coordinate_data:
    .db 112, 109, 0, 0                                                          ; $15C0B4
    .db 120, 109, 0, 0                                                          ; $15C0B8
    .db 112, 117, 0, 0                                                          ; $15C0BC
    .db 120, 117, 0, 0                                                          ; $15C0C0

; player_field_sprite_oam_data ($15:C0C4)
;
; Contains the non-coordinate player field sprite OAM data. In particular, it
; contains the correct tile number and flags for each tile in each frame of each
; pose.
player_field_sprite_oam_data:
    .db $04, $20                                                                ; $15C0C4 | $00: Player field sprite, up, frame 1
    .db $05, $20                                                                ; $15C0C6
    .db $06, $20                                                                ; $15C0C8
    .db $07, $20                                                                ; $15C0CA

    .db $04, $20                                                                ; $15C0CC | $01: Player field sprite, up, frame 2
    .db $05, $20                                                                ; $15C0CE
    .db $07, $60                                                                ; $15C0D0
    .db $06, $60                                                                ; $15C0D2

    .db $09, $60                                                                ; $15C0D4 | $02: Player field sprite, right, frame 1
    .db $08, $60                                                                ; $15C0D6
    .db $0B, $60                                                                ; $15C0D8
    .db $0A, $60                                                                ; $15C0DA

    .db $0D, $60                                                                ; $15C0DC | $03: Player field sprite, right, frame 2
    .db $0C, $60                                                                ; $15C0DE
    .db $0F, $60                                                                ; $15C0E0
    .db $0E, $60                                                                ; $15C0E2

    .db $00, $20                                                                ; $15C0E4 | $04: Player field sprite, down, frame 1
    .db $01, $20                                                                ; $15C0E6
    .db $02, $20                                                                ; $15C0E8
    .db $03, $20                                                                ; $15C0EA

    .db $00, $20                                                                ; $15C0EC | $05: Player field sprite, down, frame 2
    .db $01, $20                                                                ; $15C0EE
    .db $03, $60                                                                ; $15C0F0
    .db $02, $60                                                                ; $15C0F2

    .db $08, $20                                                                ; $15C0F4 | $06: Player field sprite, left, frame 1
    .db $09, $20                                                                ; $15C0F6
    .db $0A, $20                                                                ; $15C0F8
    .db $0B, $20                                                                ; $15C0FA

    .db $0C, $20                                                                ; $15C0FC | $07: Player field sprite, left, frame 2
    .db $0D, $20                                                                ; $15C0FE
    .db $0E, $20                                                                ; $15C100
    .db $0F, $20                                                                ; $15C102

    .db $14, $20                                                                ; $15C104.C105 | $08: Player field sprite, waving 1, frame 1
    .db $15, $20                                                                ; $15C106.C107
    .db $16, $20                                                                ; $15C108.C109
    .db $17, $20                                                                ; $15C10A.C10B

    .db $18, $20                                                                ; $15C10C.C10D | $09: Player field sprite, waving 1, frame 2
    .db $19, $20                                                                ; $15C10E.C10F
    .db $1A, $20                                                                ; $15C110.C111
    .db $1B, $20                                                                ; $15C112.C113

    .db $18, $20                                                                ; $15C114.C115 | $0A: Player field sprite, waving 2, frame 1
    .db $19, $20                                                                ; $15C116.C117
    .db $1A, $20                                                                ; $15C118.C119
    .db $1B, $20                                                                ; $15C11A.C11B

    .db $18, $20                                                                ; $15C11C.C11D | $0B: Player field sprite, waving 2, frame 2
    .db $19, $20                                                                ; $15C11E.C11F
    .db $1A, $20                                                                ; $15C120.C121
    .db $1B, $20                                                                ; $15C122.C123

    .db $10, $20                                                                ; $15C124.C125 | $0C: Player field sprite, bowing, frame 1
    .db $11, $20                                                                ; $15C126.C127
    .db $12, $20                                                                ; $15C128.C129
    .db $13, $20                                                                ; $15C12A.C12B

    .db $10, $20                                                                ; $15C12C.C12D | $0D: Player field sprite, bowing, frame 2
    .db $11, $20                                                                ; $15C12E.C12F
    .db $12, $20                                                                ; $15C130.C131
    .db $13, $20                                                                ; $15C132.C133

    .db $1C, $20                                                                ; $15C134.C135 | $0E: Player field sprite, lying, frame 1
    .db $1D, $20                                                                ; $15C136.C137
    .db $1E, $20                                                                ; $15C138.C139
    .db $1F, $20                                                                ; $15C13A.C13B

    .db $1C, $20                                                                ; $15C13C.C13D | $0F: Player field sprite, lying, frame 2
    .db $1D, $20                                                                ; $15C13E.C13F
    .db $1E, $20                                                                ; $15C140.C141
    .db $1F, $20                                                                ; $15C142.C143

; copy_whirlpool_field_sprites_to_vram ($15:C144)
;
; Copies enough field sprites from ROM to VRAM to fill $0600 words. The sprite
; set begins with the whirlpool tiles. This procedure only occurs if bit 6 of
; $128A is unset. TODO: Determine the significance of this procedure, as the
; tiles in question are already in VRAM, just at a different location.
copy_whirlpool_field_sprites_to_vram:
    LDA r_plot_flags.11.w                                                       ; $15C144 |\
    AND #PLOT_FLAG_11_ENDING.b                                                  ; $15C147 | | Skip this routine if the ending plot flag is set.
    BNE +                                                                       ; $15C149 |/
    LDX #$5A00.w                                                                ; $15C14B |\
    STX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $15C14E | | Copy field sprites starting with the whirlpool to VRAM.
    LDX #$0600.w                                                                ; $15C150 | |
    STX <r_copy_3bpp_to_vram_arg_words                                          ; $15C153 | |
    LDX #bank1C.field_sprite_whirlpool_data.w                                   ; $15C155 | |
    STX <r_copy_3bpp_to_vram_arg_address                                        ; $15C158 | |
    LDA #:bank1C.field_sprite_whirlpool_data.b                                  ; $15C15A | |
    STA <r_copy_3bpp_to_vram_arg_bank                                           ; $15C15C | |
    JSL copy_3bpp_to_vram                                                       ; $15C15E |/
+   RTL                                                                         ; $15C162

; configure_map_hdma ($15:C163)
;
; Reads a single parameter in $AD, which contains the zoom level. The range
; depends on the vehicle. Based on this information and the current map,
; configures the HDMA channels to handle the mode 7 transformations at each
; scanline. It does not activate these.
configure_map_hdma:
    LDA r_map_area.w                                                            ; $15C163 |\
    CMP #MAP_AREA_DUNGEON                                                       ; $15C166 | | If this is a dungeon area, skip this entire function.
    BNE +                                                                       ; $15C168 | |
    RTL                                                                         ; $15C16A |/
+   STZ reg_ppu_m7b                                                             ; $15C16B |\
    STZ reg_ppu_m7b                                                             ; $15C16E | | Set the B and C values of the transform to zero, as there is no
    STZ reg_ppu_m7c                                                             ; $15C171 | | skew.
    STZ reg_ppu_m7c                                                             ; $15C174 |/
    LDA #$70 | %10000000                                                        ; $15C177 |\
    STA r_hdma_table.1.scanlines.l                                              ; $15C179 | | Set up two 112 line HDMA entries.
    STA r_hdma_table.2.scanlines.l                                              ; $15C17D |/
    LDA r_vehicle.w                                                             ; $15C181 |\
    CMP #VEHICLE_BIG_WHALE                                                      ; $15C184 | | Set up the HDMA addresses for everything other than the Big
    BEQ +                                                                       ; $15C186 | | Whale. The first transfer ultimately references $7FXX00, and the
    LDA <r_zoom_level                                                           ; $15C188 | | second references $7FXXE0 where XX is the zoom level minus 16
    SEC                                                                         ; $15C18A | | times two.
    SBC #$10                                                                    ; $15C18B | |
    ASL A                                                                       ; $15C18D | |
    CLC                                                                         ; $15C18E | |
    ADC #$00                                                                    ; $15C18F | |
    STA r_hdma_table.1.address_hi.l                                             ; $15C191 | |
    STA r_hdma_table.2.address_hi.l                                             ; $15C195 | |
    LDA #$00                                                                    ; $15C199 | |
    STA r_hdma_table.1.address_lo.l                                             ; $15C19B | |
    LDA #$E0                                                                    ; $15C19F | |
    STA r_hdma_table.2.address_lo.l                                             ; $15C1A1 | |
    JMP ++                                                                      ; $15C1A5 |/
+   LDA <r_zoom_level                                                           ; $15C1A8 |\
    SEC                                                                         ; $15C1AA | | The Big Whale uses an alternate set of parameters that zooms out
    SBC #$10                                                                    ; $15C1AB | | further. The addresses are the same as the previous set, but XX
    AND #$FE                                                                    ; $15C1AD | | is now the zoom level, except for the lowest bit, and then added
    CLC                                                                         ; $15C1AF | | to $22.
    ADC #$22                                                                    ; $15C1B0 | |
    STA r_hdma_table.1.address_hi.l                                             ; $15C1B2 | |
    STA r_hdma_table.2.address_hi.l                                             ; $15C1B6 | |
    LDA #$00                                                                    ; $15C1BA | |
    STA r_hdma_table.1.address_lo.l                                             ; $15C1BC | |
    LDA #$E0                                                                    ; $15C1C0 | |
    STA r_hdma_table.2.address_lo.l                                             ; $15C1C2 |/
++  LDA #$80                                                                    ; $15C1C6 |\ Configure a final entry with 128 scanlines of nothing.
    STA r_hdma_table.3.scanlines.l                                              ; $15C1C8 |/
    STZ reg_cpu_hdmaen                                                          ; $15C1CC | Reset HDMA.
    LDA #%01000010                                                              ; $15C1CF |\
    STA reg_cpu_dmap4                                                           ; $15C1D1 | | Configure HDMA with indirect addressing and write twice.
    STA reg_cpu_dmap5                                                           ; $15C1D4 |/
    LDA #<reg_ppu_m7a                                                           ; $15C1D7 |\ Set DMA channel 4 destination to $211B (m7a).
    STA reg_cpu_bbad4                                                           ; $15C1D9 |/
    LDA #<reg_ppu_m7d                                                           ; $15C1DC |\ Set DMA channel 5 destination to $211E (m7d).
    STA reg_cpu_bbad5                                                           ; $15C1DE |/
    LDX #r_hdma_table.w                                                         ; $15C1E1 |\
    STX reg_cpu_a1t4                                                            ; $15C1E4 | | Set source address to $5A00.
    STX reg_cpu_a1t5                                                            ; $15C1E7 |/
    LDA #:r_hdma_table                                                          ; $15C1EA |\
    STA reg_cpu_a1b4                                                            ; $15C1EC | | Set source bank to $7F.
    STA reg_cpu_a1b5                                                            ; $15C1EF |/
    STA reg_cpu_hdb4                                                            ; $15C1F2 |\ Set the HDMA indirect data bank to $7F.
    STA reg_cpu_hdb5                                                            ; $15C1F5 |/
    RTL                                                                         ; $15C1F8

; load_dungeon_palette ($15:C1F9)
;
; Reads the map palette index, and based on that, loads the corresponding
; palette into the lower colors of the second through eighth palettes. The first
; palette is ignored. In addition, the next palette (by index) is loaded into
; the upper eight colors of each of those palettes. This is mainly useful for
; the airship/ship tileset which uses four bits per pixel and can make use of
; the additional colors.
load_dungeon_palette:
    LDA r_map_properties.palette.w                                              ; $15C1F9 |\
    STA <r_load_dungeon_palette_tmp_index_hi                                    ; $15C1FC | | Determine the index into the palette data by multiplying the
    STZ <r_load_dungeon_palette_tmp_index_lo                                    ; $15C1FE | | palette number by 128 (64 colors).
    LSR <r_load_dungeon_palette_tmp_index_hi                                    ; $15C200 | |
    ROR <r_load_dungeon_palette_tmp_index_lo                                    ; $15C202 | |
    LDX <r_load_dungeon_palette_tmp_index                                       ; $15C204 |/
    LDY #_sizeof_palette.w                                                      ; $15C206 | Initialize the Y register to start writing the second palette.
-   LDA bank14.dungeon_palette_data.l + $10,X                                   ; $15C209 |\ Write the color of the chosen palette to the first half of the
    STA r_cgram_data.1.color1,Y                                                 ; $15C20D |/ palette.
    LDA bank14.dungeon_palette_data.l + $90,X                                   ; $15C210 |\ Write the color of the next palette to the second half of the
    STA r_cgram_data.1.color9,Y                                                 ; $15C214 |/ palette. Mainly useful for the airship/ship palettes.
    INX                                                                         ; $15C217 |\ Increment the indexes.
    INY                                                                         ; $15C218 |/
    TYA                                                                         ; $15C219 |\
    AND #%00001111.b                                                            ; $15C21A | | Loop until Y mod 16 reaches zero again.
    BNE -                                                                       ; $15C21C |/
    TYA                                                                         ; $15C21E |\
    CLC                                                                         ; $15C21F | | Add $10 to the Y register to move to the next palette and loop
    ADC #$10.b                                                                  ; $15C220 | | until Y wraps around to zero.
    TAY                                                                         ; $15C222 | |
    BNE -                                                                       ; $15C223 |/
    RTL                                                                         ; $15C225

; load_dialog_palettes ($15:C226)
;
; Loads four 4 color palettes from ROM and places them into the first palette
; in the CG-RAM staging area. Additionally replaces color 2 of the very first
; palette with the configured window color.
load_dialog_palettes:
    LDX #$0000.w                                                                ; $15C226 |\
-   LDA bank0D.dialog_palette_data.l,X                                          ; $15C229 | | Loop through the palette, copying all sixteen colors to the CG-RAM
    STA r_cgram_data.w,X                                                        ; $15C22D | | staging area.
    INX                                                                         ; $15C230 | |
    CPX #bank0D._sizeof_dialog_palette_data.w                                   ; $15C231 | |
    BNE -                                                                       ; $15C234 |/
    LDX r_window_color.w                                                        ; $15C236 |\ Replace the window color with the user's configured window color.
    STX r_cgram_data.1.color2.w                                                 ; $15C239 |/
    RTL                                                                         ; $15C23C

; do_nothing_but_return ($15:C23D)
;
; This function literally does nothing but return.
do_nothing_but_return:
    RTL                                                                         ; $15C23D

; init_spell_lists ($15:C23E)
;
; Initializes spell lists in RAM by copying data from ROM.
init_spell_lists:
    LDX #$0000.w                                                                ; $15C23E |\
    LDY #$0000.w                                                                ; $15C241 | | Initialize indexes.
    STZ r_init_spell_lists_index                                                ; $15C244 |/
@copy_next_byte:
    LDA bank0F.initial_spell_list_data.l,X                                      ; $15C246 |\
    CMP #$FF                                                                    ; $15C24A | | If the next byte specifies a spell, copy that byte to the
    BEQ @fill_with_zero                                                         ; $15C24C | | destination list.
    STA r_spell_lists,Y                                                         ; $15C24E | |
    INY                                                                         ; $15C251 | | Additionally, check if the current list has reached its maximum
    INC r_init_spell_lists_index                                                ; $15C252 | | size. If so, reset the index to zero.
    LDA r_init_spell_lists_index                                                ; $15C254 | |
    CMP #$18                                                                    ; $15C256 | |
    BNE @check_complete                                                         ; $15C258 | |
    STZ r_init_spell_lists_index                                                ; $15C25A | |
    JMP @check_complete                                                         ; $15C25C |/
@fill_with_zero:
    LDA #$00                                                                    ; $15C25F |\
    STA r_spell_lists,Y                                                         ; $15C261 | | On the other hand, if the next byte was $FF, fill the rest of
    INY                                                                         ; $15C264 | | the 24-byte list with zeroes, as the rest of the list is empty.
    INC r_init_spell_lists_index                                                ; $15C265 | |
    LDA r_init_spell_lists_index                                                ; $15C267 | | Reset the index when done, as the spell list is full.
    CMP #$18                                                                    ; $15C269 | |
    BNE @fill_with_zero                                                         ; $15C26B | |
    STZ r_init_spell_lists_index                                                ; $15C26D |/
@check_complete:
    INX                                                                         ; $15C26F |\
    CPY #$0138.w                                                                ; $15C270 | | Check to see if the full 312 bytes have been filled. Repeat the
    BNE @copy_next_byte                                                         ; $15C273 | | loop until they are.
    RTL                                                                         ; $15C275 |/

; unused_draw_coordinates_and_map_id_to_bg3 ($15:C276)
;
; This apparently unused function appears to be a debug function that displays
; the player's current coordinates and map ID to BG3. It's not very polished,
; and the display moves around when dialog boxes are open. It's also unworkable
; on the overworld maps. No call is currently made to this routine, but doing so
; during the NMI handler will result in the display.
unused_draw_coordinates_and_map_id_to_bg3:
    LDA #%10000000.b                                                            ; $15C276 |\ Set the VRAM increment to 1 by 1 after writing to $2119.
    STA reg_ppu_vmainc.w                                                        ; $15C278 |/
    LDX #VRAM_FIELD_TILEMAP_BG3.w + 2 + (4 * 32).w                              ; $15C27B |\ Set the target VRAM address to 2, 4 on BG3.
    STX reg_ppu_vmadd.w                                                         ; $15C27E |/
.if FF4_REGION == "JAPAN"
    LDA <r_encounter_index                                                      ; $15C281 | Load the current encounter index.
.else
    LDA r_current_coordinates.x.w                                               ; $15C281 | Load the current X coordinate.
.endif
    LSR A                                                                       ; $15C284 |\
    LSR A                                                                       ; $15C285 | | Write either a digit or a letter from A-F, depending on the value
    LSR A                                                                       ; $15C286 | | of the four high bits of the value.
    LSR A                                                                       ; $15C287 | |
    CMP #10.b                                                                   ; $15C288 | |
    BCC +                                                                       ; $15C28A | |
    CLC                                                                         ; $15C28C | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C28D | |
    JMP ++                                                                      ; $15C28F | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C292 | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C294 |/
    LDA #%00100000.b                                                            ; $15C297 |\ Set the tile flags for priority 1 with palette 0.
    STA reg_ppu_vmdatah_write.w                                                 ; $15C299 |/
.if FF4_REGION == "JAPAN"
    LDA <r_encounter_index                                                      ; $15C29B | Load the encounter index again.
.else
    LDA r_current_coordinates.x.w                                               ; $15C29C | Load the X coordinate again.
.endif
    AND #%00001111.b                                                            ; $15C29F |\
    CMP #10.b                                                                   ; $15C2A1 | | Repeat the process, except with the low four bits of the value to
    BCC +                                                                       ; $15C2A3 | | draw the second digit.
    CLC                                                                         ; $15C2A5 | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C2A6 | |
    JMP ++                                                                      ; $15C2A8 | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C2AB | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C2AD | |
    LDA #%00100000.b                                                            ; $15C2B0 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $15C2B2 |/
    STZ reg_ppu_vmdatal_write.w                                                 ; $15C2B5 |\ Write a blank tile to the next location to write a space.
    STZ reg_ppu_vmdatah_write.w                                                 ; $15C2B8 |/
.if FF4_REGION == "JAPAN"
    LDA <r_formation_index                                                      ; $15C2B9 | Load the formation index.
.else
    LDA r_current_coordinates.y.w                                               ; $15C2BB | Load the Y coordinate.
.endif
    LSR A                                                                       ; $15C2BE |\
    LSR A                                                                       ; $15C2BF | | Repeat the process for the first digit of this new value.
    LSR A                                                                       ; $15C2C0 | |
    LSR A                                                                       ; $15C2C1 | |
    CMP #10.b                                                                   ; $15C2C2 | |
    BCC +                                                                       ; $15C2C4 | |
    CLC                                                                         ; $15C2C6 | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C2C7 | |
    JMP ++                                                                      ; $15C2C9 | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C2CC | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C2CE | |
    LDA #%00100000.b                                                            ; $15C2D1 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $15C2D3 |/
.if FF4_REGION == "JAPAN"
    LDA <r_formation_index                                                      ; $15C2D3 | Load the formation index.
.else
    LDA r_current_coordinates.y.w                                               ; $15C2D6 | Load the Y coordinate.
.endif
    AND #%00001111.b                                                            ; $15C2D9 |\
    CMP #10.b                                                                   ; $15C2DB | | Repeat the process for the second digit of the value.
    BCC +                                                                       ; $15C2DD | |
    CLC                                                                         ; $15C2DF | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C2E0 | |
    JMP ++                                                                      ; $15C2E2 | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C2E5 | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C2E7 | |
    LDA #%00100000.b                                                            ; $15C2EA | |
    STA reg_ppu_vmdatah_write.w                                                 ; $15C2EC |/
    LDX #VRAM_FIELD_TILEMAP_BG3.w + 2 + (6 * 32).w                              ; $15C2EF |\ Set the VRAM address to point to 2, 6 on BG3.
    STX reg_ppu_vmadd.w                                                         ; $15C2F2 |/
.if FF4_REGION == "JAPAN"
    LDA <r_steps_since_battle                                                   ; $15C2F1 | Load the number of steps since the last battle.
.else
    LDA r_map_id.w                                                              ; $15C2F5 | Load the map ID.
.endif
    LSR A                                                                       ; $15C2F8 |\
    LSR A                                                                       ; $15C2F9 | | Repeat the process for the first digit of this value.
    LSR A                                                                       ; $15C2FA | |
    LSR A                                                                       ; $15C2FB | |
    CMP #10.b                                                                   ; $15C2FC | |
    BCC +                                                                       ; $15C2FE | |
    CLC                                                                         ; $15C300 | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C301 | |
    JMP ++                                                                      ; $15C303 | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C306 | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C308 |/
    LDA #FLAG_P_ACCUMULATOR                                                     ; $15C30B |\
    STA reg_ppu_vmdatah_write.w                                                 ; $15C30D | | Repeat the process for the second digit of the value.
.if FF4_REGION == "JAPAN"                                                       ;         | |
    LDA <r_steps_since_battle                                                   ; $15C30B | |
.else                                                                           ;         | |
    LDA r_map_id.w                                                              ; $15C310 | |
.endif                                                                          ;         | |
    AND #%00001111.b                                                            ; $15C313 | |
    CMP #10.b                                                                   ; $15C315 | |
    BCC +                                                                       ; $15C317 | |
    CLC                                                                         ; $15C319 | |
    ADC #TEXT_UPPERCASE_A.b - 10                                                ; $15C31A | |
    JMP ++                                                                      ; $15C31C | |
+   ORA #TEXT_DIGIT_0.b                                                         ; $15C31F | |
++  STA reg_ppu_vmdatal_write.w                                                 ; $15C321 | |
    LDA #%00100000.b                                                            ; $15C324 | |
    STA reg_ppu_vmdatah_write.w                                                 ; $15C326 |/
    RTL                                                                         ; $15C329

; format_number ($15:C32A)
;
; Given a 24-bit number in $0630, converts the number into decimal and stores
; the 8-digit result as BG3 tile numbers at $0634.
format_number:
    PHX                                                                         ; $15C32A |\ Preserve the values of the X and Y registers.
    PHY                                                                         ; $15C32B |/
    LDX #$0000.w                                                                ; $15C32C | Initialize the X register to zero.
--  LDY #$0080.w                                                                ; $15C32F | Initialize the Y register to $80, the base tile number for digits.
    STZ <r_format_number_arg_hi_hi                                              ; $15C332 | Zero out the highest byte of the argument.
-   REP #FLAG_P_ACCUMULATOR                                                     ; $15C334 |\
    LDA <r_format_number_arg_lo                                                 ; $15C336 | | Attempt to subtract the number corresponding to the current place
    SEC                                                                         ; $15C338 | | being looked at. Keep track of the number of times it can be
    SBC binary_to_decimal_lo_data.l,X                                           ; $15C339 | | subtracted without borrowing. Once a borrow occurs, branch to the
    STA <r_format_number_arg_lo                                                 ; $15C33D | | second half of the loop.
    LDA <r_format_number_arg_hi                                                 ; $15C33F | |
    SBC binary_to_decimal_hi_data.l,X                                           ; $15C341 | | Each time through, increment the Y register so it contains the
    STA <r_format_number_arg_hi                                                 ; $15C345 | | current needed tile number.
    BCC +                                                                       ; $15C347 | |
    INY                                                                         ; $15C349 | |
    JMP -                                                                       ; $15C34A |/
+   LDA <r_format_number_arg_lo                                                 ; $15C34D |\
    CLC                                                                         ; $15C34F | | First, add in the operand once to restore the number to its
    ADC binary_to_decimal_lo_data.l,X                                           ; $15C350 | | state before the borrow.
    STA <r_format_number_arg_lo                                                 ; $15C354 | |
    LDA <r_format_number_arg_hi                                                 ; $15C356 | |
    ADC binary_to_decimal_hi_data.l,X                                           ; $15C358 | |
    STA <r_format_number_arg_hi                                                 ; $15C35C | |
    LDA #$0000.w                                                                ; $15C35E | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C361 |/
    PHX                                                                         ; $15C363 |\
    TXA                                                                         ; $15C364 | | Halve X in two to get the proper index into the result, and then
    LSR A                                                                       ; $15C365 | | set the result to the value in the Y register.
    TAX                                                                         ; $15C366 | |
    TYA                                                                         ; $15C367 | |
    STA <r_format_number_result,X                                               ; $15C368 | |
    PLX                                                                         ; $15C36A |/
    INX                                                                         ; $15C36B |\
    INX                                                                         ; $15C36C | | Increment X and keep going until all 8 places have been
    CPX #$0010.w                                                                ; $15C36D | | considered.
    BNE --                                                                      ; $15C370 |/
    PLY                                                                         ; $15C372 |\ Restore the X and Y registers.
    PLX                                                                         ; $15C373 |/
    RTL                                                                         ; $15C374

; binary_to_decimal_lo_data ($15:C375)
;
; The two lower bytes of the value of each place in a decimal system, from high
; to low.
binary_to_decimal_lo_data:
    .dw $9680                                                                   ; $15C375.C376
    .dw $4240                                                                   ; $15C377.C378
    .dw $86A0                                                                   ; $15C379.C37A
    .dw $2710                                                                   ; $15C37B.C37C
    .dw $03E8                                                                   ; $15C37D.C37E
    .dw $0064                                                                   ; $15C37F.C380
    .dw $000A                                                                   ; $15C381.C382
    .dw $0001                                                                   ; $15C383.C384

; binary_to_decimal_hi_data ($15:C385)
;
; The two upper bytes of the value of each place in a decimal system, from high
; to low.
binary_to_decimal_hi_data:
    .dw $0098                                                                   ; $15C385.C386
    .dw $000F                                                                   ; $15C387.C388
    .dw $0001                                                                   ; $15C389.C38A
    .dw $0000                                                                   ; $15C38B.C38C
    .dw $0000                                                                   ; $15C38D.C38E
    .dw $0000                                                                   ; $15C38F.C390
    .dw $0000                                                                   ; $15C391.C392
    .dw $0000                                                                   ; $15C393.C394

; math_multiply_16bit ($15:C395)
;
; Multiplies the 16-bit parameter in $0618 by the 16-bit parameter in $061A
; and returns the 24-bit result in $0630. Note that if the result exceeds 24
; bits, any overflow will be lost.
math_multiply_16bit:
    STZ <r_bank15_math_multiply_16bit_carry                                     ; $15C395 |\
    STZ <r_bank15_math_multiply_16bit_result_lo                                 ; $15C397 | | Initialize variables that were not parameters.
    STZ <r_bank15_math_multiply_16bit_result_md                                 ; $15C399 | |
    STZ <r_bank15_math_multiply_16bit_result_hi                                 ; $15C39B |/
    LDY #$0010.w                                                                ; $15C39D |\
-   LSR <r_bank15_math_multiply_16bit_arg_1_hi                                  ; $15C3A0 | | For each of the sixteen bits of the first parameter, if set, add
    ROR <r_bank15_math_multiply_16bit_arg_1_lo                                  ; $15C3A2 | | the second parameter shifted to the appropriate location to the
    BCC +                                                                       ; $15C3A4 | | result variable. The end result is a simulation of multiplying by
    LDA <r_bank15_math_multiply_16bit_result_lo                                 ; $15C3A6 | | hand.
    CLC                                                                         ; $15C3A8 | |
    ADC <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15C3A9 | |
    STA <r_bank15_math_multiply_16bit_result_lo                                 ; $15C3AB | |
    LDA <r_bank15_math_multiply_16bit_result_md                                 ; $15C3AD | |
    ADC <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $15C3AF | |
    STA <r_bank15_math_multiply_16bit_result_md                                 ; $15C3B1 | |
    LDA <r_bank15_math_multiply_16bit_result_hi                                 ; $15C3B3 | |
    ADC <r_bank15_math_multiply_16bit_carry                                     ; $15C3B5 | |
    STA <r_bank15_math_multiply_16bit_result_hi                                 ; $15C3B7 | |
+   ASL <r_bank15_math_multiply_16bit_arg_2_lo                                  ; $15C3B9 | |
    ROL <r_bank15_math_multiply_16bit_arg_2_hi                                  ; $15C3BB | |
    ROL <r_bank15_math_multiply_16bit_carry                                     ; $15C3BD | |
    DEY                                                                         ; $15C3BF | |
    BNE -                                                                       ; $15C3C0 |/
    RTL                                                                         ; $15C3C2

; set_big_whale_light_color ($15:C3C3)
;
; Based on one of the frame counters, changes the current color of the Big Whale
; lights to another color. The color index shifts every 8 frames. However, it
; stays at the brightest and darkest levels for two cycles, as these entries are
; in the table twice.
set_big_whale_light_color:
    LDA r_vehicle.w                                                             ; $15C3C3 |\
    CMP #VEHICLE_BIG_WHALE                                                      ; $15C3C6 | | If the current vehicle isn't the Big Whale, skip this entirely.
    BNE +                                                                       ; $15C3C8 |/
    LDA <r_map_frame_counter                                                    ; $15C3CA |\  Determine a 3-bit index that increases every 8 frames. To do this,
    LSR A                                                                       ; $15C3CC | | divide by 4, and then mask out all bits except the three we care
    LSR A                                                                       ; $15C3CD | | about (three starting from the second-lowest). This results in it
    AND #%00001110                                                              ; $15C3CE | | effectively being multiplied by 2.
    TAX                                                                         ; $15C3D0 |/
    LDA big_whale_light_color_data.l,X                                          ; $15C3D1 |\
    STA r_cgram_data.16.color7.w                                                ; $15C3D5 | | Load the associated palette data for the Big Whale lights and send
    LDA big_whale_light_color_data.l + 1,X                                      ; $15C3D8 | | it to the CG-RAM data in RAM.
    STA r_cgram_data.16.color7.w + 1                                            ; $15C3DC |/
+   RTL                                                                         ; $15C3DF

; big_whale_light_color_data ($15:C3E0)
;
; Contains the palette entries that are cycled into CG-RAM every few frames to
; change the color of the lights of the Big Whale.
big_whale_light_color_data:
    COLOR 31, 16, 0                                                             ; $15C3E0
    COLOR 24, 12, 0                                                             ; $15C3E2
    COLOR 16,  8, 0                                                             ; $15C3E4
    COLOR  8,  4, 0                                                             ; $15C3E6
    COLOR  8,  4, 0                                                             ; $15C3E8
    COLOR 16,  8, 0                                                             ; $15C3EA
    COLOR 24, 12, 0                                                             ; $15C3EC
    COLOR 31, 16, 0                                                             ; $15C3EE

; set_tower_of_babil_flash_color ($15:C3F0)
;
; If the appropriate plot flag is set in $7E1288, sets the Tower of Bab-il's
; current flashing color. Otherwise, sets it to black.
set_tower_of_babil_flash_color:
    LDA r_map_area.w                                                            ; $15C3F0 |\
    CMP #MAP_AREA_MOON                                                          ; $15C3F3 | | If the current map area is the moon or a dungeon, skip the function.
    BCS @moon_or_dungeon                                                        ; $15C3F5 |/
    CMP #$00                                                                    ; $15C3F7 |\
    BNE +                                                                       ; $15C3F9 | | If the user is on the overworld, the target color is the 16th
    LDX #palette.color16.w                                                      ; $15C3FB | | of the first palette. If it's the underworld, the target color is
    JMP ++                                                                      ; $15C3FE | | the 16th of the fourth palette.
+   LDX #_sizeof_palette * 3 + palette.color16.w                                ; $15C401 |/
++  LDA r_plot_flags.9.w                                                        ; $15C404 |\
    AND #PLOT_FLAG_9_TOWER_OF_BABIL_FLASHING.b                                  ; $15C407 | | Only continue if the appropriate plot flag is set.
    BEQ +                                                                       ; $15C409 |/
    LDA <r_map_frame_counter                                                    ; $15C40B |\  Put the new color in the CG-RAM data. The low byte is set to twice
    ASL A                                                                       ; $15C40D | | the frame counter, and then the bits are flipped and put into the
    STA r_cgram_data.w,X                                                        ; $15C40E | | high byte. This results in a flashing effect, vaguely rapidly
    EOR #%11111111                                                              ; $15C411 | | moving between green and yellow (with some reds and blues).
    STA r_cgram_data.w + 1,X                                                    ; $15C413 |/
    JMP @moon_or_dungeon                                                        ; $15C416 |\
+   STZ r_cgram_data.w,X                                                        ; $15C419 | | If the plot flag isn't yet, just zero out the colors to black.
    STZ r_cgram_data.w + 1,X                                                    ; $15C41C |/
@moon_or_dungeon:
    RTL                                                                         ; $15C41F

; set_glowing_light_colors ($15:C420)
;
; Checks the current value in $0FDD. If this value is $08, $0A or $0B, applies
; various flashing light effects by setting palette data in the CG-RAM staging
; area. If the value is $09, checks an additional value in $0FE0. If this value
; is not $0F, it will adjust the palettes to create the red glowing effect seen
; in the Land of Monsters. If the value is $0F, it will instead do a green
; effect as seen in the Sylvan Cave.
set_glowing_light_colors:
    LDA r_map_properties.tileset.w                                              ; $15C420 |\
    CMP #TILESET_UNDERWORLD_CAVE                                                ; $15C423 | | If the current map uses the underworld cave tileset, branch to the
    BEQ @glowing_dungeon                                                        ; $15C425 | | glowing dungeon section of the code. Otherwise, if the tileset is
    CMP #TILESET_BIG_WHALE                                                      ; $15C427 | | the Big Whale, Tower, or Giant tileset, branch to the glowing
    BEQ @glowing_lights                                                         ; $15C429 | | lights effect. Otherwise, branch to no effect.
    CMP #TILESET_TOWER                                                          ; $15C42B | |
    BCC @no_effect                                                              ; $15C42D | |
    CMP #TILESET_LUNAR_SUBTERRANE                                               ; $15C42F | |
    BCS @no_effect                                                              ; $15C431 |/
@glowing_lights:
    LDA <r_map_frame_counter                                                    ; $15C433 |\
    LSR A                                                                       ; $15C435 | | For glowing light tilesets, calculate the index based on the map
    LSR A                                                                       ; $15C436 | | frame counter. It changes every eight frames.
    AND #%00001110                                                              ; $15C437 | |
    TAX                                                                         ; $15C439 |/
    REP #FLAG_P_ACCUMULATOR                                                     ; $15C43A |\
    LDA bank14.blue_light_palette_data.l,X                                      ; $15C43C | | Based on the above calculated index, set the appropriate colors
    STA r_cgram_data.2.color2.w                                                 ; $15C440 | | for the red, blue and yellow lights that constantly fade in and
    LDA bank14.red_light_palette_data.l,X                                       ; $15C443 | | out as seen in the Tower of Bab-il and the Big Whale (or other
    STA r_cgram_data.3.color2.w                                                 ; $15C447 | | areas using the same tileset).
    LDA bank14.yellow_light_palette_data.l,X                                    ; $15C44A | |
    STA r_cgram_data.5.color2.w                                                 ; $15C44E | |
    LDA #$0000                                                                  ; $15C451 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C454 |/
    LDA r_map_properties.tileset.w                                              ; $15C456 |\
    CMP #TILESET_GIANT                                                          ; $15C459 | | Skip the next section of code for the Giant tileset.
    BEQ ++                                                                      ; $15C45B |/
    LDA <r_map_frame_counter                                                    ; $15C45D |\
    LSR A                                                                       ; $15C45F | | This section of code appears to be a long, complicated NOOP. It
    LSR A                                                                       ; $15C460 | | calculates an index, and loads a series of ten values from a
    LSR A                                                                       ; $15C461 | | section in ROM. However, it doesn't appear to actually do antyhing
    AND #%00001111                                                              ; $15C462 | | with this data.
    CMP #$08                                                                    ; $15C464 | |
    BCC +                                                                       ; $15C466 | | TODO: Is that section of ROM used for anything else?
    EOR #%11111111                                                              ; $15C468 | |
    CLC                                                                         ; $15C46A | | It's also possible this is here to cause a delay or something, but
    ADC #$09                                                                    ; $15C46B | | who knows.
+   ASL A                                                                       ; $15C46D | |
    TAX                                                                         ; $15C46E | |
    LDY #$0000.w                                                                ; $15C46F | |
-   LDA bank14.DATA_14F806.l,X                                                  ; $15C472 | |
    INX                                                                         ; $15C476 | |
    INY                                                                         ; $15C477 | |
    CPY #$0010.w                                                                ; $15C478 | |
    BNE -                                                                       ; $15C47B |/
++  LDA <r_map_frame_counter                                                    ; $15C47D |\
    LSR A                                                                       ; $15C47F | | Calculate the index to change every four frames with sixteen
    AND #%00011110                                                              ; $15C480 | | possible values.
    TAX                                                                         ; $15C482 |/
    LDY #$0000.w                                                                ; $15C483 |\
-   LDA bank14.pulsing_blue_light_palette_data.l,X                              ; $15C486 | | Copy the pulsing blue light palette data to the staging area in
    STA r_cgram_data.8.color2,Y                                                 ; $15C48A | | RAM. The index is calculated mod 32 so that it automatically
    INX                                                                         ; $15C48D | | wraps around to the start of the array. The ultimate effect is
    TXA                                                                         ; $15C48E | | that the colors cycle.
    AND #%000011111                                                             ; $15C48F | |
    TAX                                                                         ; $15C491 | |
    INY                                                                         ; $15C492 | |
    CPY #$0010.w                                                                ; $15C493 | |
    BNE -                                                                       ; $15C496 |/
@no_effect:
    RTL                                                                         ; $15C498 |
@glowing_dungeon:
    LDA <r_map_frame_counter                                                    ; $15C499 |\
    LSR A                                                                       ; $15C49B | | Set the index based on the frame counter. It changes every
    LSR A                                                                       ; $15C49C | | eight frames and has eight possible values.
    AND #%00001110                                                              ; $15C49D | |
    TAX                                                                         ; $15C49F |/
    LDA r_map_properties.palette.w                                              ; $15C4A0 |\
    CMP #PALETTE_SYLVAN_CAVE                                                    ; $15C4A3 | | If the map uses the Sylvan Cave palette, increase the index which
    BNE +                                                                       ; $15C4A5 | | will change the color of the glow from red to green.
    TXA                                                                         ; $15C4A7 | |
    CLC                                                                         ; $15C4A8 | |
    ADC #$40                                                                    ; $15C4A9 | |
    TAX                                                                         ; $15C4AB |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $15C4AC |\
    LDA bank14.red_glowing_dungeon_palette_data_1.l,X                           ; $15C4AE | | Read various colors from ROM and send them to the CG-RAM staging
    STA r_cgram_data.2.color2.w                                                 ; $15C4B2 | | area in RAM. The first, second and third colors are all used for
    LDA bank14.red_glowing_dungeon_palette_data_2.l,X                           ; $15C4B5 | | various pixels on the walls. The second and fourth colors are used
    STA r_cgram_data.2.color3.w                                                 ; $15C4B9 | | for the floor tiles.
    STA r_cgram_data.6.color3.w                                                 ; $15C4BC | |
    LDA bank14.red_glowing_dungeon_palette_data_3.l,X                           ; $15C4BF | |
    STA r_cgram_data.2.color4.w                                                 ; $15C4C3 | |
    LDA bank14.red_glowing_dungeon_palette_data_4.l,X                           ; $15C4C6 | |
    STA r_cgram_data.6.color2.w                                                 ; $15C4CA | |
    LDA #$0000                                                                  ; $15C4CD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C4D0 |/
    RTL                                                                         ; $15C4D2

; set_magma_glow_colors ($15:C4D3)
;
; Sets the palette to create the magma glow effect, by rotating which colors are
; used every few frames.
set_magma_glow_colors:
    LDA r_map_area.w                                                            ; $15C4D3 |\
    CMP #MAP_AREA_UNDERWORLD                                                    ; $15C4D6 | | If the player isn't in the underworld, skip this function.
    BNE +                                                                       ; $15C4D8 |/
    LDA <r_map_frame_counter                                                    ; $15C4DA |\
    AND #%01110000                                                              ; $15C4DC | | Generate an index suitable for rotating the colors every 16
    LSR A                                                                       ; $15C4DE | | frames, selecting from eight potential values.
    LSR A                                                                       ; $15C4DF | |
    LSR A                                                                       ; $15C4E0 | |
    LSR A                                                                       ; $15C4E1 | |
    TAX                                                                         ; $15C4E2 |/
    LDA underworld_magma_glow_palette_index_data.l,X                            ; $15C4E3 |\ Load the index into the palette data from the table following this
    TAX                                                                         ; $15C4E7 |/ function.
    LDY #$0000.w                                                                ; $15C4E8 |\
    REP #FLAG_P_ACCUMULATOR                                                     ; $15C4EB | | Copy the 16 bytes (8 colors) from the palette data using the index
-   LDA bank14.underworld_magma_glow_palette_data.l,X                           ; $15C4ED | | previously looked up into the CG-RAM staging area in RAM.
    STA r_cgram_data.2.color3,Y                                                 ; $15C4F1 | |
    INX                                                                         ; $15C4F4 | |
    INX                                                                         ; $15C4F5 | |
    INY                                                                         ; $15C4F6 | |
    INY                                                                         ; $15C4F7 | |
    CPY #$0010.w                                                                ; $15C4F8 | |
    BNE -                                                                       ; $15C4FB | |
    LDA #$0000                                                                  ; $15C4FD | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C500 |/
+   RTL                                                                         ; $15C502

underworld_magma_glow_palette_index_data:
    .db $00, $10, $20, $30, $30, $20, $10, $00                                  ; $15C503

; set_zoom_palette ($15:C50B)
;
; For each of the outdoor map areas, alters the palettes subtly to soften the
; appearance of the textures while zoomed out. For instance, the water on the
; overworld is altered to be solid blue. Takes a parameter in the accumulator
; which determines which color is used.
set_zoom_palette:
    AND #%11111110.b                                                            ; $15C50B |\ Calculate the index by taking the high 7 bits of the value in the
    TAX                                                                         ; $15C50D |/ accumulator.
    LDA r_map_area.w                                                            ; $15C50E |\
    BNE +                                                                       ; $15C511 | | If the current map area is 0 (overworld), load different colors
    REP #FLAG_P_ACCUMULATOR                                                     ; $15C513 | | for two of the blue colors in the palette depending on the
    LDA overworld_water_zoom_palette_data_1.l,X                                 ; $15C515 | | passed parameter. The effect is to shift water to being solid blue
    STA r_cgram_data.3.color6.w                                                 ; $15C519 | | when zoomed out while on the airship.
    LDA overworld_water_zoom_palette_data_2.l,X                                 ; $15C51C | |
    STA r_cgram_data.3.color8.w                                                 ; $15C520 | |
    LDA #$0000.w                                                                ; $15C523 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C526 | |
    RTL                                                                         ; $15C528 |/
+   CMP #MAP_AREA_UNDERWORLD.b                                                  ; $15C529 |\
    BNE +                                                                       ; $15C52B | | For the underworld, three areas have their palettes subtly
    REP #FLAG_P_ACCUMULATOR                                                     ; $15C52D | | shifted: 1) The brown plains areas, 2) the brown dirt areas and
    LDA underworld_plains_zoom_palette_data_1.l,X                               ; $15C52F | | 3) the orange plateau areas.
    STA r_cgram_data.1.color13.w                                                ; $15C533 | |
    LDA underworld_plains_zoom_palette_data_2.l,X                               ; $15C536 | |
    STA r_cgram_data.1.color14.w                                                ; $15C53A | |
    LDA underworld_dirt_zoom_palette_data_1.l,X                                 ; $15C53D | |
    STA r_cgram_data.3.color2.w                                                 ; $15C541 | |
    LDA underworld_dirt_zoom_palette_data_2.l,X                                 ; $15C544 | |
    STA r_cgram_data.3.color3.w                                                 ; $15C548 | |
    LDA underworld_dirt_zoom_palette_data_3.l,X                                 ; $15C54B | |
    STA r_cgram_data.3.color4.w                                                 ; $15C54F | |
    LDA underworld_plateau_zoom_palette_data_1.l,X                              ; $15C552 | |
    STA r_cgram_data.1.color3.w                                                 ; $15C556 | |
    LDA underworld_plateau_zoom_palette_data_2.l,X                              ; $15C559 | |
    STA r_cgram_data.1.color6.w                                                 ; $15C55D | |
    LDA underworld_plateau_zoom_palette_data_3.l,X                              ; $15C560 | |
    STA r_cgram_data.1.color2.w                                                 ; $15C564 | |
    LDA #$0000.w                                                                ; $15C567 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C56A | |
    RTL                                                                         ; $15C56C |/
+   REP #FLAG_P_ACCUMULATOR                                                     ; $15C56D |\
    LDA moon_zoom_palette_data_1.l,X                                            ; $15C56F | | Finally, the moon alters the palettes covering both the plains
    STA r_cgram_data.1.color2.w                                                 ; $15C573 | | areas and the plateaus.
    LDA moon_zoom_palette_data_2.l,X                                            ; $15C576 | |
    STA r_cgram_data.1.color6.w                                                 ; $15C57A | |
    LDA moon_zoom_palette_data_3.l,X                                            ; $15C57D | |
    STA r_cgram_data.1.color13.w                                                ; $15C581 | |
    STA r_cgram_data.2.color13.w                                                ; $15C584 | |
    LDA moon_zoom_palette_data_4.l,X                                            ; $15C587 | |
    STA r_cgram_data.1.color3.w                                                 ; $15C58B | |
    LDA moon_zoom_palette_data_5.l,X                                            ; $15C58E | |
    STA r_cgram_data.2.color9.w                                                 ; $15C592 | |
    LDA moon_zoom_palette_data_6.l,X                                            ; $15C595 | |
    STA r_cgram_data.2.color10.w                                                ; $15C599 | |
    LDA moon_zoom_palette_data_7.l,X                                            ; $15C59C | |
    STA r_cgram_data.2.color12.w                                                ; $15C5A0 | |
    LDA #$0000.w                                                                ; $15C5A3 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C5A6 |/
    RTL                                                                         ; $15C5A8

; moon_zoom_palette_data_1
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_1:
    COLOR 14, 15, 15                                                            ; $15C5A9
    COLOR 14, 15, 15                                                            ; $15C5AB
    COLOR 13, 15, 15                                                            ; $15C5AD
    COLOR 13, 14, 14                                                            ; $15C5AF
    COLOR 12, 14, 14                                                            ; $15C5B1
    COLOR 12, 14, 14                                                            ; $15C5B3
    COLOR 11, 13, 13                                                            ; $15C5B5
    COLOR 11, 13, 13                                                            ; $15C5B7
    COLOR 11, 13, 13                                                            ; $15C5B9

; moon_zoom_palette_data_2
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_2:
    COLOR 20, 22, 21                                                            ; $15C5BB
    COLOR 18, 21, 20                                                            ; $15C5BD
    COLOR 17, 19, 18                                                            ; $15C5BF
    COLOR 15, 18, 17                                                            ; $15C5C1
    COLOR 14, 16, 16                                                            ; $15C5C3
    COLOR 13, 15, 15                                                            ; $15C5C5
    COLOR 12, 14, 14                                                            ; $15C5C7
    COLOR 11, 13, 13                                                            ; $15C5C9
    COLOR 11, 13, 13                                                            ; $15C5CB

; moon_zoom_palette_data_3
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_3:
    COLOR 15, 15, 13                                                            ; $15C5CD
    COLOR 15, 15, 13                                                            ; $15C5CF
    COLOR 15, 15, 12                                                            ; $15C5D1
    COLOR 14, 14, 12                                                            ; $15C5D3
    COLOR 14, 14, 11                                                            ; $15C5D5
    COLOR 14, 14, 11                                                            ; $15C5D7
    COLOR 13, 13, 10                                                            ; $15C5D9
    COLOR 13, 13, 10                                                            ; $15C5DB
    COLOR 13, 13, 10                                                            ; $15C5DD

; moon_zoom_palette_data_4
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_4:
    COLOR 11, 13, 13                                                            ; $15C5DF
    COLOR 11, 13, 13                                                            ; $15C5E1
    COLOR 11, 12, 12                                                            ; $15C5E3
    COLOR 10, 12, 12                                                            ; $15C5E5
    COLOR 10, 11, 11                                                            ; $15C5E7
    COLOR 10, 11, 11                                                            ; $15C5E9
    COLOR  9, 10, 10                                                            ; $15C5EB
    COLOR  9, 10, 10                                                            ; $15C5ED
    COLOR  9, 10, 10                                                            ; $15C5EF

; moon_zoom_palette_data_5
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_5:
    COLOR 28, 25, 12                                                            ; $15C5F1
    COLOR 28, 25, 12                                                            ; $15C5F3
    COLOR 27, 24, 12                                                            ; $15C5F5
    COLOR 26, 24, 11                                                            ; $15C5F7
    COLOR 26, 23, 11                                                            ; $15C5F9
    COLOR 25, 23, 11                                                            ; $15C5FB
    COLOR 25, 22, 10                                                            ; $15C5FD
    COLOR 24, 22, 10                                                            ; $15C5FF
    COLOR 24, 22, 10                                                            ; $15C601

; moon_zoom_palette_data_6
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_6:
    COLOR 24, 22, 10                                                            ; $15C603
    COLOR 23, 21, 10                                                            ; $15C605
    COLOR 21, 19,  9                                                            ; $15C607
    COLOR 20, 18,  9                                                            ; $15C609
    COLOR 18, 17,  8                                                            ; $15C60B
    COLOR 17, 16,  8                                                            ; $15C60D
    COLOR 16, 14,  7                                                            ; $15C60F
    COLOR 15, 13,  7                                                            ; $15C611
    COLOR 15, 13,  7                                                            ; $15C613

; moon_zoom_palette_data_7
;
; Contains colors used to soften the apperance when zoomed out.
moon_zoom_palette_data_7:
    COLOR 30, 28, 19                                                            ; $15C615
    COLOR 28, 27, 18                                                            ; $15C617
    COLOR 26, 25, 17                                                            ; $15C619
    COLOR 25, 24, 16                                                            ; $15C61B
    COLOR 23, 22, 13                                                            ; $15C61D
    COLOR 22, 20, 12                                                            ; $15C61F
    COLOR 21, 18, 11                                                            ; $15C621
    COLOR 19, 17, 10                                                            ; $15C623
    COLOR 19, 17, 10                                                            ; $15C625

; underworld_plains_zoom_palette_data_1
;
; Contains colors used to soften the apperance when zoomed out.
underworld_plains_zoom_palette_data_1:
    COLOR  6,  5,  9                                                            ; $15C627
    COLOR  6,  5,  8                                                            ; $15C629
    COLOR  6,  5,  7                                                            ; $15C62B
    COLOR  6,  4,  6                                                            ; $15C62D
    COLOR  7,  4,  5                                                            ; $15C62F
    COLOR  7,  4,  3                                                            ; $15C631
    COLOR  7,  3,  2                                                            ; $15C633
    COLOR  7,  3,  0                                                            ; $15C635
    COLOR  7,  3,  0                                                            ; $15C637

; underworld_plains_zoom_palette_data_2
;
; Contains colors used to soften the apperance when zoomed out.
underworld_plains_zoom_palette_data_2:
    COLOR  7,  3,  0                                                            ; $15C639
    COLOR  7,  3,  0                                                            ; $15C63B
    COLOR  7,  2,  0                                                            ; $15C63D
    COLOR  6,  2,  0                                                            ; $15C63F
    COLOR  6,  1,  0                                                            ; $15C641
    COLOR  6,  1,  0                                                            ; $15C643
    COLOR  5,  0,  0                                                            ; $15C645
    COLOR  5,  0,  0                                                            ; $15C647
    COLOR  5,  0,  0                                                            ; $15C649

; underworld_dirt_zoom_palette_data_1
;
; Contains colors used to soften the apperance when zoomed out.
underworld_dirt_zoom_palette_data_1:
    COLOR 16, 14,  9                                                            ; $15C64B
    COLOR 15, 14,  9                                                            ; $15C64D
    COLOR 15, 13,  8                                                            ; $15C64F
    COLOR 14, 12,  7                                                            ; $15C651
    COLOR 14, 12,  7                                                            ; $15C653
    COLOR 12, 11,  6                                                            ; $15C655
    COLOR 12, 11,  5                                                            ; $15C657
    COLOR 13, 10,  4                                                            ; $15C659
    COLOR 13, 10,  4                                                            ; $15C65B

; underworld_dirt_zoom_palette_data_2
;
; Contains colors used to soften the apperance when zoomed out.
underworld_dirt_zoom_palette_data_2:
    COLOR 15, 13,  8                                                            ; $15C65D
    COLOR 15, 13,  7                                                            ; $15C65F
    COLOR 15, 12,  7                                                            ; $15C661
    COLOR 14, 12,  6                                                            ; $15C663
    COLOR 14, 11,  6                                                            ; $15C665
    COLOR 14, 11,  5                                                            ; $15C667
    COLOR 13, 10,  5                                                            ; $15C669
    COLOR 13, 10,  4                                                            ; $15C66B
    COLOR 13, 10,  4                                                            ; $15C66D

; underworld_dirt_zoom_palette_data_3
;
; Contains colors used to soften the apperance when zoomed out.
underworld_dirt_zoom_palette_data_3:
    COLOR 14, 11,  6                                                            ; $15C66F
    COLOR 14, 11,  6                                                            ; $15C671
    COLOR 14, 11,  6                                                            ; $15C673
    COLOR 14, 11,  5                                                            ; $15C675
    COLOR 13, 10,  5                                                            ; $15C677
    COLOR 13, 10,  5                                                            ; $15C679
    COLOR 13, 10,  4                                                            ; $15C67B
    COLOR 13, 10,  4                                                            ; $15C67D
    COLOR 13, 10,  4                                                            ; $15C67F

; underworld_plateau_zoom_palette_data_1
;
; Contains colors used to soften the apperance when zoomed out.
underworld_plateau_zoom_palette_data_1:
    COLOR 27, 10,  5                                                            ; $15C681
    COLOR 26, 10,  4                                                            ; $15C683
    COLOR 25, 10,  4                                                            ; $15C685
    COLOR 24, 10,  3                                                            ; $15C687
    COLOR 23,  9,  2                                                            ; $15C689
    COLOR 22,  9,  2                                                            ; $15C68B
    COLOR 21,  9,  1                                                            ; $15C68D
    COLOR 21,  9,  0                                                            ; $15C68F
    COLOR 21,  9,  0                                                            ; $15C691

; underworld_plateau_zoom_palette_data_2
;
; Contains colors used to soften the apperance when zoomed out.
underworld_plateau_zoom_palette_data_2:
    COLOR 29, 14,  5                                                            ; $15C693
    COLOR 26, 13,  4                                                            ; $15C695
    COLOR 25, 13,  4                                                            ; $15C697
    COLOR 24, 12,  3                                                            ; $15C699
    COLOR 23, 11,  2                                                            ; $15C69B
    COLOR 22, 11,  2                                                            ; $15C69D
    COLOR 21, 10,  1                                                            ; $15C69F
    COLOR 21,  9,  0                                                            ; $15C6A1
    COLOR 21,  9,  0                                                            ; $15C6A3

; underworld_plateau_zoom_palette_data_3
;
; Contains colors used to soften the apperance when zoomed out.
underworld_plateau_zoom_palette_data_3:
    COLOR 31, 30, 13                                                            ; $15C6A5
    COLOR 29, 27, 11                                                            ; $15C6A7
    COLOR 28, 24, 10                                                            ; $15C6A9
    COLOR 26, 21,  8                                                            ; $15C6AB
    COLOR 25, 18,  6                                                            ; $15C6AD
    COLOR 23, 15,  4                                                            ; $15C6AF
    COLOR 22, 11,  2                                                            ; $15C6B1
    COLOR 21,  9,  0                                                            ; $15C6B3
    COLOR 21,  9,  0                                                            ; $15C6B5

; overworld_water_zoom_palette_data_1
;
; Contains colors used to soften the apperance when zoomed out.
overworld_water_zoom_palette_data_1:
    COLOR  0,  9, 25                                                            ; $15C6B7
    COLOR  0,  9, 23                                                            ; $15C6B9
    COLOR  0,  8, 22                                                            ; $15C6BB
    COLOR  0,  8, 21                                                            ; $15C6BD
    COLOR  0,  7, 20                                                            ; $15C6BF
    COLOR  0,  7, 19                                                            ; $15C6C1
    COLOR  0,  6, 18                                                            ; $15C6C3
    COLOR  0,  6, 17                                                            ; $15C6C5
    COLOR  0,  5, 15                                                            ; $15C6C7

; overworld_water_zoom_palette_data_2
;
; Contains colors used to soften the apperance when zoomed out.
overworld_water_zoom_palette_data_2:
    COLOR  0,  3,  9                                                            ; $15C6C9
    COLOR  0,  3, 10                                                            ; $15C6CB
    COLOR  0,  3, 11                                                            ; $15C6CD
    COLOR  0,  4, 12                                                            ; $15C6CF
    COLOR  0,  4, 13                                                            ; $15C6D1
    COLOR  0,  4, 14                                                            ; $15C6D3
    COLOR  0,  5, 15                                                            ; $15C6D5
    COLOR  0,  5, 15                                                            ; $15C6D7
    COLOR  0,  5, 15                                                            ; $15C6D9

; calculate_alternate_cgram ($15:C6DB)
;
; Assuming palette data has correctly been loaded into the primary CG-RAM
; staging area, this function fills the alternate CG-RAM area with colors
; derived from the base data. The bits of each color are flipped and then
; each component is divided by two to halve the intensity.
calculate_alternate_cgram:
    REP #FLAG_P_ACCUMULATOR                                                     ; $15C6DB |\
    LDX #$0000.w                                                                ; $15C6DD | | Loop through the first 256 bytes of the CG-RAM staging area,
-   LDA r_cgram_data.w,X                                                        ; $15C6E0 | | using the colors as a basis to set the alternate CG-RAM
    EOR #$7FFF.w                                                                ; $15C6E3 | | data. In particular, the bits are flipped and then each color
    AND #$7BDE.w                                                                ; $15C6E6 | | is divided by two, which results in flipped colors with a
    LSR A                                                                       ; $15C6E9 | | maximum half intensity.
    STA r_alternate_cgram_data.w,X                                              ; $15C6EA | |
    INX                                                                         ; $15C6ED | |
    INX                                                                         ; $15C6EE | |
    CPX #$0100.w                                                                ; $15C6EF | |
    BNE -                                                                       ; $15C6F2 | |
    LDA #$0000.w                                                                ; $15C6F4 | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15C6F7 |/
    RTL                                                                         ; $15C6F9

; replace_overworld_plot_tiles ($15:C6FA)
;
; Takes a single parameter in $0693, which is the current Y coordinate to
; process. Replaces any tiles on that row in the in-RAM tilemap that need to
; be replaced depending on plot flags. In particular, it replaces the Damcyan
; castle tiles, the Mist mountain tiles, and the Agart mountain tiles.
replace_overworld_plot_tiles:
    LDA <r_replace_overworld_plot_tiles_arg_y                                   ; $15C6FA |\
    AND #%00111111.b                                                            ; $15C6FC | | Calculate the index by taking the Y coordinate mod 64. (A given Y
    STA <r_replace_overworld_plot_tiles_index_hi                                ; $15C6FE | | coordinate will always be in the same place in the tilemap data.)
    STZ <r_replace_overworld_plot_tiles_index_lo                                ; $15C700 | | The value is multipled by $100 because each row has 256 tiles.
    LDX <r_replace_overworld_plot_tiles_index                                   ; $15C702 |/
    LDA r_plot_flags.3.w                                                        ; $15C704 |\
    AND #PLOT_FLAG_3_DAMCYAN_DESTROYED.b                                        ; $15C707 | | This section replaces the Damcyan tiles with damaged castle tiles
    BEQ ++                                                                      ; $15C709 | | if the appropriate plot flag has been set.
    LDA <r_replace_overworld_plot_tiles_arg_y                                   ; $15C70B | |
    CMP #57.b                                                                   ; $15C70D | |
    BNE +                                                                       ; $15C70F | |
    LDA #$2D.b                                                                  ; $15C711 | |
    STA r_tilemap_data.l + 118,X                                                ; $15C713 | |
    INC A                                                                       ; $15C717 | |
    STA r_tilemap_data.l + 119,X                                                ; $15C718 | |
    RTL                                                                         ; $15C71C | |
+   CMP #58.b                                                                   ; $15C71D | |
    BNE ++                                                                      ; $15C71F | |
    LDA #$3D.b                                                                  ; $15C721 | |
    STA r_tilemap_data.l + 118,X                                                ; $15C723 | |
    INC A                                                                       ; $15C727 | |
    STA r_tilemap_data.l + 119,X                                                ; $15C728 | |
    RTL                                                                         ; $15C72C |/
++  LDA r_plot_flags.2.w                                                        ; $15C72D |\
    AND #PLOT_FLAG_2_MIST_EVENTS_FINISHED.b                                     ; $15C730 | | This section replaces the tiles at and east of Mist with more
    BEQ ++                                                                      ; $15C732 | | mountains if the appropriate plot flag has been set.
    LDA <r_replace_overworld_plot_tiles_arg_y                                   ; $15C734 | |
    CMP #118.b                                                                  ; $15C736 | |
    BNE +                                                                       ; $15C738 | |
    LDA #$13.b                                                                  ; $15C73A | |
    STA r_tilemap_data.l + 97,X                                                 ; $15C73C | |
    STA r_tilemap_data.l + 98,X                                                 ; $15C740 | |
    STA r_tilemap_data.l + 99,X                                                 ; $15C744 | |
    STA r_tilemap_data.l + 100,X                                                ; $15C748 | |
    STA r_tilemap_data.l + 101,X                                                ; $15C74C | |
    RTL                                                                         ; $15C750 | |
+   CMP #119.b                                                                  ; $15C751 | |
    BNE +                                                                       ; $15C753 | |
    LDA #$12.b                                                                  ; $15C755 | |
    STA r_tilemap_data.l + 97,X                                                 ; $15C757 | |
    LDA #$13.b                                                                  ; $15C75B | |
    STA r_tilemap_data.l + 98,X                                                 ; $15C75D | |
    STA r_tilemap_data.l + 99,X                                                 ; $15C761 | |
    STA r_tilemap_data.l + 100,X                                                ; $15C765 | |
    LDA #$14.b                                                                  ; $15C769 | |
    STA r_tilemap_data.l + 101,X                                                ; $15C76B | |
    RTL                                                                         ; $15C76F | |
+   CMP #$78.b                                                                  ; $15C770 | |
    BNE ++                                                                      ; $15C772 | |
    LDA #$13.b                                                                  ; $15C774 | |
    STA r_tilemap_data.l + 97,X                                                 ; $15C776 | |
    STA r_tilemap_data.l + 98,X                                                 ; $15C77A | |
    STA r_tilemap_data.l + 99,X                                                 ; $15C77E | |
    STA r_tilemap_data.l + 100,X                                                ; $15C782 | |
    STA r_tilemap_data.l + 101,X                                                ; $15C786 | |
    RTL                                                                         ; $15C78A |/
++  LDA r_plot_flags.7.w                                                        ; $15C78B |\
    AND #PLOT_FLAG_7_AGART_MOUNTAIN_OPEN.b                                      ; $15C78E | | This final section replaces the Agart mountain with a closed
    BNE ++                                                                      ; $15C790 | | mountain if the mountain is closed (by plot flag).
    LDA <r_replace_overworld_plot_tiles_arg_y                                   ; $15C792 | |
    CMP #210.b                                                                  ; $15C794 | |
    BNE +                                                                       ; $15C796 | |
    LDA #$13.b                                                                  ; $15C798 | |
    STA r_tilemap_data.l + 106,X                                                ; $15C79A | |
    RTL                                                                         ; $15C79E | |
+   CMP #211.b                                                                  ; $15C79F | |
    BNE +                                                                       ; $15C7A1 | |
    LDA #$13.b                                                                  ; $15C7A3 | |
    STA r_tilemap_data.l + 105,X                                                ; $15C7A5 | |
    STA r_tilemap_data.l + 106,X                                                ; $15C7A9 | |
    STA r_tilemap_data.l + 107,X                                                ; $15C7AD | |
    RTL                                                                         ; $15C7B1 | |
+   CMP #212.b                                                                  ; $15C7B2 | |
    BNE +                                                                       ; $15C7B4 | |
    LDA #$13.b                                                                  ; $15C7B6 | |
    STA r_tilemap_data.l + 104,X                                                ; $15C7B8 | |
    STA r_tilemap_data.l + 105,X                                                ; $15C7BC | |
    STA r_tilemap_data.l + 106,X                                                ; $15C7C0 | |
    STA r_tilemap_data.l + 107,X                                                ; $15C7C4 | |
    STA r_tilemap_data.l + 108,X                                                ; $15C7C8 | |
    RTL                                                                         ; $15C7CC | |
+   CMP #213.b                                                                  ; $15C7CD | |
    BNE +                                                                       ; $15C7CF | |
    LDA #$13.b                                                                  ; $15C7D1 | |
    STA r_tilemap_data.l + 105,X                                                ; $15C7D3 | |
    STA r_tilemap_data.l + 106,X                                                ; $15C7D7 | |
    STA r_tilemap_data.l + 107,X                                                ; $15C7DB | |
    RTL                                                                         ; $15C7DF | |
+   CMP #214.b                                                                  ; $15C7E0 | |
    BNE ++                                                                      ; $15C7E2 | |
    LDA #$13.b                                                                  ; $15C7E4 | |
    STA r_tilemap_data.l + 106,X                                                ; $15C7E6 |/
++  RTL                                                                         ; $15C7EA

; copy_tile_change_to_vram_if_pending ($15:C7EB)
;
; Checks for a non-zero value in $06D4. If so, it will copy the two 16-bit
; values at $0700 and $0702 to the VRAM address in $06FE. It will also copy the
; two 16-bit values at $0704 and $0706 to the VRAM address in $06FE + $20. This
; effectively replaces one 16x16 tile in the tilemap.
copy_tile_change_to_vram_if_pending:
    LDA <r_tile_change_pending                                                  ; $15C7EB |\
    BNE +                                                                       ; $15C7ED | | If there is no tile pending to be changed, skip this entire
    RTL                                                                         ; $15C7EF | | function.
+   STZ <r_tile_change_pending                                                  ; $15C7F0 |/
    LDA #%10000000                                                              ; $15C7F2 |\
    STA reg_ppu_vmainc                                                          ; $15C7F4 | | Copy the two tiles in the first row to VRAM.
    LDX r_tile_change_vram_address.w                                            ; $15C7F7 | |
    STX reg_ppu_vmadd                                                           ; $15C7FA | |
    LDX r_tile_change_tile_1.w                                                  ; $15C7FD | |
    STX reg_ppu_vmdatal_write                                                   ; $15C800 | |
    LDX r_tile_change_tile_2.w                                                  ; $15C803 | |
    STX reg_ppu_vmdatal_write                                                   ; $15C806 |/
    LDA r_tile_change_vram_address_lo.w                                         ; $15C809 |\
    CLC                                                                         ; $15C80C | | Add $20 to the VRAM address, which correspond to the next row on
    ADC #$20                                                                    ; $15C80D | | a mode 0 background like in a dungeon.
    STA r_tile_change_vram_address_lo.w                                         ; $15C80F | |
    LDA r_tile_change_vram_address_hi.w                                         ; $15C812 | |
    ADC #$00                                                                    ; $15C815 | |
    STA r_tile_change_vram_address_hi.w                                         ; $15C817 |/
    LDX r_tile_change_vram_address.w                                            ; $15C81A |\
    STX reg_ppu_vmadd                                                           ; $15C81D | | Copy the two tiles in the second row to VRAM.
    LDX r_tile_change_tile_3.w                                                  ; $15C820 | |
    STX reg_ppu_vmdatal_write                                                   ; $15C823 | |
    LDX r_tile_change_tile_4.w                                                  ; $15C826 | |
    STX reg_ppu_vmdatal_write                                                   ; $15C829 |/
    RTL                                                                         ; $15C82C

; load_player_field_sprite_palettes ($15:C82D)
;
; Copies the four 8-color field sprite palettes from ROM to the CG-RAM staging
; area. The upper eight colors in all four of the palettes are filled with
; black.
load_player_field_sprite_palettes:
    LDY #$0000.w                                                                ; $15C82D |\ Initialize loop variables.
    LDX #$0000.w                                                                ; $15C830 |/
--  LDA bank0D.player_field_sprite_palette_data.l,X                             ; $15C833 |\
    STA r_cgram_data + $0100,Y                                                  ; $15C837 | | Copy eight colors from ROM to the CG-RAM staging area. Once
    INX                                                                         ; $15C83A | | sixteen bytes have been copied, finish the loop.
    INY                                                                         ; $15C83B | |
    TYA                                                                         ; $15C83C | |
    AND #%00001111.b                                                            ; $15C83D | |
    BNE --                                                                      ; $15C83F | |
-   LDA #$00.b                                                                  ; $15C841 |/
    STA r_cgram_data + $0100,Y                                                  ; $15C843 |\
    INY                                                                         ; $15C846 | | The second half of the loop fills the second half of each palette
    TYA                                                                         ; $15C847 | | with black. Continue until all four 8-color palettes have been
    AND #%00001111.b                                                            ; $15C848 | | transferred.
    BNE -                                                                       ; $15C84A | |
    CPY #$0080.w                                                                ; $15C84C | |
    BNE --                                                                      ; $15C84F |/
    RTL                                                                         ; $15C851

; handle_r_field_sprite_slot_increment ($15:C852)
;
; Handles pressing R on the field to increment the field sprite slot.
handle_r_field_sprite_slot_increment:
    LDA r_vehicle.w                                                             ; $15C852 |\
    BNE +                                                                       ; $15C855 | | If not on a vehicle, if the R button is pressed, and if the R
    LDA <r_joypad_pressed_lo                                                    ; $15C857 | | button press has not been handled, branch to set the flag
    AND #JOYPAD_L_R.b                                                           ; $15C859 | | indicating it's been handled and fall through to increment the
    BEQ +                                                                       ; $15C85B | | sprite slot.
    LDA <r_joypad_r_pressed                                                     ; $15C85D | |
    BEQ ++                                                                      ; $15C85F | |
+   RTL                                                                         ; $15C861 | |
++  INC <r_joypad_r_pressed                                                     ; $15C862 |/

; increment_field_sprite_slot ($15:C864)
;
; Increments the slot number currently being used for the field sprite. It also
; verifies that there is actually a character in that slot, and will continue
; increment until that is true.
increment_field_sprite_slot:
-   INC r_field_sprite_slot.w                                                   ; $15C864 | Increment the sprite slot.
    LDA r_field_sprite_slot.w                                                   ; $15C867 |\
    CMP #$05                                                                    ; $15C86A | | If the sprite slot has reached 5, reset it back to 0.
    BNE +                                                                       ; $15C86C | |
    LDA #$00                                                                    ; $15C86E | |
    STA r_field_sprite_slot.w                                                   ; $15C870 |/
+   JSL get_player_field_sprite_offset                                          ; $15C873 |\
    LDA r_character_field.1.id.w,X                                              ; $15C877 | | Repeat the process until a slot with a character is found.
    BEQ -                                                                       ; $15C87A |/
    LDA #$01                                                                    ; $15C87C |\ Mark the field sprite as dirty so that it will be redrawn.
    STA <r_player_field_sprite_dirty                                            ; $15C87E |/
    RTL                                                                         ; $15C880

; get_player_field_sprite_offset ($15:C881)
;
; Sets the X register to the field character record for the character currently
; being used as the field sprite.
get_player_field_sprite_offset:
    LDA r_field_sprite_slot.w                                                   ; $15C881 |\
    STZ <r_get_player_field_sprite_offset_tmp_lo                                ; $15C884 | | Effectively multiply the current map sprite's slot by $40 and
    LSR A                                                                       ; $15C886 | | store the result in the X register.
    ROR <r_get_player_field_sprite_offset_tmp_lo                                ; $15C887 | |
    LSR A                                                                       ; $15C889 | |
    ROR <r_get_player_field_sprite_offset_tmp_lo                                ; $15C88A | |
    STA <r_get_player_field_sprite_offset_tmp_hi                                ; $15C88C | |
    LDX <r_get_player_field_sprite_offset_tmp                                   ; $15C88E |/
    RTL                                                                         ; $15C890

; copy_player_field_sprite_to_vram ($15:C891)
;
; Determines the current field sprite (depending on which character is currently
; being displayed) and copies this data to the appropriate location in VRAM.
copy_player_field_sprite_to_vram:
    LDA <r_player_field_sprite_dirty                                            ; $15C891 |\
    BNE +                                                                       ; $15C893 | | Only bother doing something if the field sprite has been flagged
    RTL                                                                         ; $15C895 | | as dirty.
+   STZ <r_player_field_sprite_dirty                                            ; $15C896 |/
    JSL get_player_field_sprite_offset                                          ; $15C898 | Get the offset into the character record for the current player sprite.
    LDA r_character_field.1.status_1.w,X                                        ; $15C89C |\
    AND #STATUS_1_TOAD                                                          ; $15C89F | | If this character is currently a toad, force the toad sprite.
    BEQ +                                                                       ; $15C8A1 | |
    LDA #FIELD_SPRITE_TOAD                                                      ; $15C8A3 | |
    JMP @copy_sprite                                                            ; $15C8A5 |/
+   LDA r_character_field.1.status_1.w,X                                        ; $15C8A8 |\
    AND #STATUS_1_SMALL                                                         ; $15C8AB | | If the character is currently small, force the small sprite.
    BEQ +                                                                       ; $15C8AD | |
    LDA #FIELD_SPRITE_SMALL                                                     ; $15C8AF | |
    JMP @copy_sprite                                                            ; $15C8B1 |/
+   LDA r_character_field.1.status_1.w,X                                        ; $15C8B4 |\
    AND #STATUS_1_PIG                                                           ; $15C8B7 | | If the character is currently a pig, force the pig sprite.
    BEQ +                                                                       ; $15C8B9 | |
    LDA #FIELD_SPRITE_PIG                                                       ; $15C8BB | |
    JMP @copy_sprite                                                            ; $15C8BD |/
+   LDA r_character_field.1.sprite_class.w,X                                    ; $15C8C0 |\ Otherwise, get the sprite index from the character record.
    AND #%00011111                                                              ; $15C8C3 |/
@copy_sprite:                                                                   ;         |\
    STA <r_copy_player_field_sprite_to_vram_tmp                                 ; $15C8C5 | | Calculate the offset into the sprite data. Each sprite that can be
    ASL A                                                                       ; $15C8C7 | | used on the world takes 768 or $300 bytes. Therefore, the index is
    CLC                                                                         ; $15C8C8 | | multiplied by 3 and then added to the upper byte of the base
    ADC <r_copy_player_field_sprite_to_vram_tmp                                 ; $15C8C9 | | address (which happens to be $8000, as the entirety of bank $1B is
    CLC                                                                         ; $15C8CB | | sprite data). Finally, this is put into the high byte of a 16-bit
    ADC #bank1B.field_sprite_player_data >> 8                                   ; $15C8CC | | locaton in memory for an argument to the sprite-copying function.
    STA <r_copy_3bpp_to_vram_arg_address_hi                                     ; $15C8CE | |
    STZ <r_copy_3bpp_to_vram_arg_address_lo                                     ; $15C8D0 |/
    LDX #$4000.w                                                                ; $15C8D2 |\ Set the target VRAM address to $4000, which is where the OAM
    STX <r_copy_3bpp_to_vram_arg_vram_address                                   ; $15C8D5 |/ character tables are currently stored.
    LDX #$0200.w                                                                ; $15C8D7 |\ The sprite set will take up $400 bytes in VRAM once expanded so
    STX <r_copy_3bpp_to_vram_arg_words                                          ; $15C8DA |/ copy $200 words.
    LDA #:bank1B.field_sprite_player_data                                       ; $15C8DC |\ Set the bank number to the bank of the sprite data.
    STA <r_copy_3bpp_to_vram_arg_bank                                           ; $15C8DE |/
    JSL copy_3bpp_to_vram                                                       ; $15C8E0 | Copy the sprite data to VRAM.
    RTL                                                                         ; $15C8E4

; init_ppu ($15:C8E5)
;
; This function initializes various PPU registers and PPU-related CPU registers.
init_ppu:
    LDA #$80                                                                    ; $15C8E5 |\ Set PPU to force blank and set brightness to 0.
    STA reg_ppu_inidisp                                                         ; $15C8E7 |/
    LDA #$00                                                                    ; $15C8EA |\ Disable NMI, timer interrupts, and automatic joypad reading.
    STA reg_cpu_nmitimen                                                        ; $15C8EC |/
    LDA #$02                                                                    ; $15C8EF |\ Set OAM size to 8x8/16x16, and set the object storage segment.
    STA reg_ppu_objsel                                                          ; $15C8F1 |/
    STZ reg_ppu_oamaddl                                                         ; $15C8F4 |\ Initialize the OAM address register to 0.
    STZ reg_ppu_oamaddh                                                         ; $15C8F7 |/
    STZ reg_ppu_mosaic                                                          ; $15C8FA | Disable pixelation.
    LDA #$19                                                                    ; $15C8FD |\
    STA reg_ppu_bg1sc                                                           ; $15C8FF | | Initialize the locations of BG1, BG2 and BG3 in VRAM
    LDA #$33                                                                    ; $15C902 | | and their sizes.
    STA reg_ppu_bg2sc                                                           ; $15C904 | |
    LDA #$29                                                                    ; $15C907 | |
    STA reg_ppu_bg3sc                                                           ; $15C909 |/
    LDA #$00                                                                    ; $15C90C |\
    STA reg_ppu_bg12nba                                                         ; $15C90E | | Initialize the locations of BG character data in VRAM.
    LDA #$02                                                                    ; $15C911 | |
    STA reg_ppu_bg34nba                                                         ; $15C913 |/
    STZ reg_ppu_bg3h0fs                                                         ; $15C916 |\
    STZ reg_ppu_bg3h0fs                                                         ; $15C919 | | Initialize the BG3 scroll value to zero.
    STZ reg_ppu_bg3v0fs                                                         ; $15C91C | |
    STZ reg_ppu_bg3v0fs                                                         ; $15C91F |/
    LDA #$80                                                                    ; $15C922 |\ Set the VRAM address increment for 16-bit reads and to
    STA reg_ppu_vmainc                                                          ; $15C924 |/ increment 1x1.
    STZ reg_ppu_m7sel                                                           ; $15C927 |\
    STZ reg_ppu_m7a                                                             ; $15C92A | | Initialize mode 7 and the settings for the current
    LDA #$04                                                                    ; $15C92D | | transformation.
    STA reg_ppu_m7a                                                             ; $15C92F | |
    STZ reg_ppu_m7b                                                             ; $15C932 | |
    STZ reg_ppu_m7b                                                             ; $15C935 | |
    STZ reg_ppu_m7c                                                             ; $15C938 | |
    STZ reg_ppu_m7c                                                             ; $15C93B | |
    STZ reg_ppu_m7d                                                             ; $15C93E | |
    LDA #$04                                                                    ; $15C941 | |
    STA reg_ppu_m7d                                                             ; $15C943 | |
    LDA #$80                                                                    ; $15C946 | |
    STA reg_ppu_m7x                                                             ; $15C948 | |
    STA reg_ppu_m7x                                                             ; $15C94B | |
    STA reg_ppu_m7y                                                             ; $15C94E | |
    STA reg_ppu_m7y                                                             ; $15C951 |/
    STA reg_ppu_cgadd                                                           ; $15C954 | Set the CG-RAM address to $80.
    LDA #$33                                                                    ; $15C957 |\
    STA reg_ppu_w12sel                                                          ; $15C959 | | Initialize the window mask settings.
    LDA #$00                                                                    ; $15C95C | |
    STA reg_ppu_w34sel                                                          ; $15C95E | |
    LDA #$F3                                                                    ; $15C961 | |
    STA reg_ppu_wobjsel                                                         ; $15C963 |/
    LDA #$01                                                                    ; $15C966 |\
    STA reg_ppu_wh0                                                             ; $15C968 | | Initialize the window locations.
    LDA #$FE                                                                    ; $15C96B | |
    STA reg_ppu_wh1                                                             ; $15C96D | |
    STZ reg_ppu_wh2                                                             ; $15C970 | |
    LDA #$FF                                                                    ; $15C973 | |
    STA reg_ppu_wh3                                                             ; $15C975 |/
    STZ reg_ppu_wbglog                                                          ; $15C978 |\ Set the window logic for all BG and OBJ to OR.
    STZ reg_ppu_wobjlog                                                         ; $15C97B |/
    LDA #$17                                                                    ; $15C97E |\ Set OBJ, BG1, BG2 and BG3 to be the main screens.
    STA reg_ppu_tm                                                              ; $15C980 |/
    LDA #$11                                                                    ; $15C983 |\ Set OBJ and BG1 to be the sub screens.
    STA reg_ppu_ts                                                              ; $15C985 |/
    LDA #$17                                                                    ; $15C988 |\ Set OBJ, BG1, BG2 and BG3 to be visible in a window.
    STA reg_ppu_tmw                                                             ; $15C98A |/
    STZ reg_ppu_tsw                                                             ; $15C98D | Set no sub screens to be visible in a window.
    LDA #$E0                                                                    ; $15C990 |\ Set the fixed color addition/subtraction color to black.
    STA reg_ppu_coldata                                                         ; $15C992 |/
    STZ reg_ppu_setini                                                          ; $15C995 | Initially disable several special PPU settings.
    LDA #$FF                                                                    ; $15C998 |\ Use all bits in the programmable I/O port as input.
    STA reg_cpu_wrio                                                            ; $15C99A |/
    STZ reg_cpu_htimel                                                          ; $15C99D |\ Set the horizontal IRQ position to 0.
    STZ reg_cpu_htimeh                                                          ; $15C9A0 |/
    STZ reg_cpu_vtimel                                                          ; $15C9A3 |\ Set the vertical IRQ position to 0.
    STZ reg_cpu_vtimeh                                                          ; $15C9A6 |/
    STZ reg_cpu_mdmaen                                                          ; $15C9A9 | Disable DMA.
    STZ reg_cpu_hdmaen                                                          ; $15C9AC | Disable H-DMA.
    RTL                                                                         ; $15C9AF

; init_ram ($15:C9B0)
;
; This function initializes RAM, mostly by zeroing it out, with the following
; exceptions:
;
;    $0200 - $02FF: Stack and interrupt handlers
;    $0FFF:         Frame counter
;    $1900 - $19FF: PRNG data copied from ROM
;    $1A00 - $1A64: Only zeroed if PRNG data in RAM doesn't match PRNG data in
;                   ROM (effectively a hard reset). Various temporary values,
;                   mostly related to joypads.
;    $1E00 - $1FFF: Audio related
init_ram:
    LDX #$0000.w                                                                ; $15C9B0 |\
-   LDA r_prng_data.w,X                                                         ; $15C9B3 | | Compare the PRNG data in RAM to the PRNG data in ROM. If
    CMP bank14.prng_data.l,X                                                    ; $15C9B6 | | different, then continue to the next section. Otherwise,
    BNE +                                                                       ; $15C9BA | | skip it and move on.
    INX                                                                         ; $15C9BC | |
    CPX #$0100.w                                                                ; $15C9BD | |
    BEQ ++                                                                      ; $15C9C0 | |
    JMP -                                                                       ; $15C9C2 |/
+   LDX #$1A00.w                                                                ; $15C9C5 |\
-   STZ $0000.w,X                                                               ; $15C9C8 | | Zero out RAM from $1A00 to $1A64.
    INX                                                                         ; $15C9CB | |
    CPX #$1A65.w                                                                ; $15C9CC | |
    BNE -                                                                       ; $15C9CF |/
++  LDX #$0000.w                                                                ; $15C9D1 |\
-   STZ $0000.w,X                                                               ; $15C9D4 | | Zero out RAM from $0000 to $01FF.
    INX                                                                         ; $15C9D7 | |
    CPX #$0200.w                                                                ; $15C9D8 | |
    BNE -                                                                       ; $15C9DB |/
    LDX #$0300.w                                                                ; $15C9DD |\
-   STZ $0000.w,X                                                               ; $15C9E0 | | Zero out RAM from $0300 to $0FFE.
    INX                                                                         ; $15C9E3 | |
    CPX #$0FFF.w                                                                ; $15C9E4 | |
    BNE -                                                                       ; $15C9E7 | |
    INX                                                                         ; $15C9E9 |/
-   STZ $0000.w,X                                                               ; $15C9EA |\
    INX                                                                         ; $15C9ED | | Zero out RAM from $1000 to $19FF.
    CPX #$1A00.w                                                                ; $15C9EE | |
    BNE -                                                                       ; $15C9F1 |/
    LDX #$1A65.w                                                                ; $15C9F3 |\
-   STZ $0000.w,X                                                               ; $15C9F6 | | Zero out RAM from $1A65 to $1DFF.
    INX                                                                         ; $15C9F9 | |
    CPX #$1E00.w                                                                ; $15C9FA | |
    BNE -                                                                       ; $15C9FD |/
    LDX #$2000.w                                                                ; $15C9FF |\
    LDA #$00                                                                    ; $15CA02 | | Zero out RAM from $7E:2000 to $7E:FFFF.
-   STA $7E0000,X                                                               ; $15CA04 | |
    INX                                                                         ; $15CA08 | |
    BNE -                                                                       ; $15CA09 |/
-   STA $7F0000,X                                                               ; $15CA0B |\
    INX                                                                         ; $15CA0F | | Zero out RAM from $7F:0000 to $7F:FFFF.
    BNE -                                                                       ; $15CA10 |/
    LDX #$0000.w                                                                ; $15CA12 |\
-   LDA bank14.prng_data.l,X                                                    ; $15CA15 | | Copy the 256 bytes of PRNG data from ROM to RAM.
    STA r_prng_data.w,X                                                         ; $15CA19 | |
    INX                                                                         ; $15CA1C | |
    CPX #$0100.w                                                                ; $15CA1D | |
    BNE -                                                                       ; $15CA20 |/
    RTL                                                                         ; $15CA22

; joypad_filter_unpressed_buttons ($15:CA23)
;
; Sets the values in $0650 through $0657 to zero if the corresponding button is
; not currently pressed. It only resets this value. It will not set a value if
; it's not already set. The order of the buttons is X, Y, L, R, A, B, Select,
; Start.
joypad_filter_unpressed_buttons:
    LDA <r_joypad_pressed_lo                                                    ; $15CA23 |\
    AND #JOYPAD_L_A.b                                                           ; $15CA25 | | Reset the A pressed value if A is not pressed.
    BNE +                                                                       ; $15CA27 | |
    STZ <r_joypad_a_pressed                                                     ; $15CA29 |/
+   LDA <r_joypad_pressed_lo                                                    ; $15CA2B |\
    AND #JOYPAD_L_X.b                                                           ; $15CA2D | | Reset the X pressed value if X is not pressed.
    BNE +                                                                       ; $15CA2F | |
    STZ <r_joypad_x_pressed                                                     ; $15CA31 |/
+   LDA <r_joypad_pressed_lo                                                    ; $15CA33 |\
    AND #JOYPAD_L_L.b                                                           ; $15CA35 | | Reset the L pressed value if L is not pressed.
    BNE +                                                                       ; $15CA37 | |
    STZ <r_joypad_l_pressed                                                     ; $15CA39 |/
+   LDA <r_joypad_pressed_lo                                                    ; $15CA3B |\
    AND #JOYPAD_L_R.b                                                           ; $15CA3D | | Reset the R pressed value if R is not pressed.
    BNE +                                                                       ; $15CA3F | |
    STZ <r_joypad_r_pressed                                                     ; $15CA41 |/
+   LDA <r_joypad_pressed_hi                                                    ; $15CA43 |\
    AND #JOYPAD_H_B.b                                                           ; $15CA45 | | Reset the B pressed value if B is not pressed.
    BNE +                                                                       ; $15CA47 | |
    STZ <r_joypad_b_pressed                                                     ; $15CA49 |/
+   LDA <r_joypad_pressed_hi                                                    ; $15CA4B |\
    AND #JOYPAD_H_Y.b                                                           ; $15CA4D | | Reset the Y pressed value if Y is not pressed.
    BNE +                                                                       ; $15CA4F | |
    STZ <r_joypad_y_pressed                                                     ; $15CA51 |/
+   LDA <r_joypad_pressed_hi                                                    ; $15CA53 |\
    AND #JOYPAD_H_SELECT.b                                                      ; $15CA55 | | Reset the select pressed value if select is not pressed.
    BNE +                                                                       ; $15CA57 | |
    STZ <r_joypad_select_pressed                                                ; $15CA59 |/
+   LDA <r_joypad_pressed_hi                                                    ; $15CA5B |\
    AND #JOYPAD_H_START.b                                                       ; $15CA5D | | Reset the start pressed value if start is not pressed.
    BNE +                                                                       ; $15CA5F | |
    STZ <r_joypad_start_pressed                                                 ; $15CA61 |/
+   RTL                                                                         ; $15CA63

; copy_cgram_to_ppu ($15:CA64)
;
; Copies CG-RAM data from RAM to CG-RAM.
copy_cgram_to_ppu:
    STZ reg_cpu_mdmaen                                                          ; $15CA64 | Reset DMA.
    STZ reg_ppu_cgadd                                                           ; $15CA67 | Set CG-RAM address to zero.
    LDA #$02                                                                    ; $15CA6A |\ Set the DMA to write each value to the same register twice.
    STA reg_cpu_dmap0                                                           ; $15CA6C |/
    LDA #<reg_ppu_cgdata                                                        ; $15CA6F |\ Set the DMA write address to $2122 (CG-RAM write).
    STA reg_cpu_bbad0                                                           ; $15CA71 |/
    LDA #$00                                                                    ; $15CA74 |\ Set the DMA read bank to $00.
    STA reg_cpu_a1b0                                                            ; $15CA76 |/
    LDX #r_cgram_data.w                                                         ; $15CA79 |\ Set the DMA read address to $0CDB.
    STX reg_cpu_a1t0                                                            ; $15CA7C |/
    LDX #$0200.w                                                                ; $15CA7F |\ Set the DMA to copy 512 bytes.
    STX reg_cpu_das0                                                            ; $15CA82 |/
    LDA #%00000001                                                              ; $15CA85 |\ Enable the DMA transfer on channel 0.
    STA reg_cpu_mdmaen                                                          ; $15CA87 |/
    RTL                                                                         ; $15CA8A

; start_vram_dma ($15:CA8B)
;
; This function starts a DMA transfer from main memory to VRAM. It takes four
; parameters: the 8-bit bank to read from in $3C, the 16-bit address to read
; from in $3D, the 16-bit VRAM target address in $47, and the 16-bit number of
; bytes to transfer in $45.
start_vram_dma:
    LDA #$80                                                                    ; $15CA8B |\ Set the VRAM address increment to 1x1.
    STA reg_ppu_vmainc                                                          ; $15CA8D |/
    STZ reg_cpu_mdmaen                                                          ; $15CA90 | Reset DMA.
    LDA #$01                                                                    ; $15CA93 |\ Configure DMA to write L,H for VRAM.
    STA reg_cpu_dmap0                                                           ; $15CA95 |/
    LDA #$18                                                                    ; $15CA98 |\ Configure the DMA write destination to $2118 to write to VRAM.
    STA reg_cpu_bbad0                                                           ; $15CA9A |/
    LDA <r_start_vram_dma_arg_bank                                              ; $15CA9D |\ Set the DMA read bank to the passed parameter.
    STA reg_cpu_a1b0                                                            ; $15CA9F |/
    LDX <r_start_vram_dma_arg_vram_target                                       ; $15CAA2 |\ Set the VRAM write address to the passed parameter.
    STX reg_ppu_vmaddl                                                          ; $15CAA4 |/
    LDX <r_start_vram_dma_arg_address                                           ; $15CAA7 |\ Set the read address to the passed parameter.
    STX reg_cpu_a1t0                                                            ; $15CAA9 |/
    LDX <r_start_vram_dma_arg_bytes                                             ; $15CAAC |\
    STX reg_cpu_das0                                                            ; $15CAAE |/ Set number of bytes to transfer to the given parameter.
    LDA #$01                                                                    ; $15CAB1 |\
    STA reg_cpu_mdmaen                                                          ; $15CAB3 |/ Start DMA transfer.
    RTL                                                                         ; $15CAB6

; start_fixed_vram_dma ($15:CAB7)
;
; This function starts a DMA transfer from main memory to VRAM. It takes three
; parameters: the 8-bit fixed value to write in $0676, the 16-bit target VRAM
; address in $0647, and the 16-bit number of bytes to transfer in $0645.
start_fixed_vram_dma:
    LDA #%10000000.b                                                            ; $15CAB7 |\ Set the VRAM address increment to 1x1, high byte.
    STA reg_ppu_vmainc                                                          ; $15CAB9 |/
    STZ reg_cpu_mdmaen                                                          ; $15CABC | Reset DMA.
    LDA #%00001001.b                                                            ; $15CABF |\ Configure the DMA to write L,H for VRAM.
    STA reg_cpu_dmap0                                                           ; $15CAC1 |/
    LDA #<reg_ppu_vmdatal_write.b                                               ; $15CAC4 |\ Set the DMA write destination to $2118 (VRAM write).
    STA reg_cpu_bbad0                                                           ; $15CAC6 |/
    LDX <r_start_fixed_vram_dma_arg_vram_target                                 ; $15CAC9 |\ Set the VRAM write address to the passed parameter.
    STX reg_ppu_vmadd                                                           ; $15CACB |/
    LDX #r_start_fixed_vram_dma_arg_value.w                                     ; $15CACE |\ Set the read address to $00:$0676.
    STX reg_cpu_a1t0                                                            ; $15CAD1 | |
    STZ reg_cpu_a1b0                                                            ; $15CAD4 |/
    LDX <r_start_fixed_vram_dma_arg_bytes                                       ; $15CAD7 |\ Set the number of bytes to transfer to the given parameter.
    STX reg_cpu_das0                                                            ; $15CAD9 |/
    LDA #%00000001.b                                                            ; $15CADC |\ Enable the DMA.
    STA reg_cpu_mdmaen                                                          ; $15CADE |/
    RTL                                                                         ; $15CAE1

; copy_oam_to_ppu ($15:CAE2)
;
; This function copies the OAM (stored at $00:0300) to PPU.
copy_oam_to_ppu:
    STZ reg_ppu_oamaddl                                                         ; $15CAE2 | Reset the OAM address.
    STZ reg_cpu_mdmaen                                                          ; $15CAE5 | Reset DMA.
    STZ reg_cpu_dmap0                                                           ; $15CAE8 | Configure for single-byte DMA.
    LDA #$04                                                                    ; $15CAEB |\ Set the DMA write address to $2104 (OAM write).
    STA reg_cpu_bbad0                                                           ; $15CAED |/
    LDX #r_oam.w                                                                ; $15CAF0 |\ Set the DMA read address to $0300.
    STX reg_cpu_a1t0                                                            ; $15CAF3 |/
    LDA #$00                                                                    ; $15CAF6 |\ Set the DMA read bank to $00.
    STA reg_cpu_a1b0                                                            ; $15CAF8 |/
    LDX #$0220.w                                                                ; $15CAFB |\ Configure the DMA transfer to copy $220 bytes.
    STX reg_cpu_das0                                                            ; $15CAFE |/
    LDA #$01                                                                    ; $15CB01 |\ Enable the DMA on channel 0.
    STA reg_cpu_mdmaen                                                          ; $15CB03 |/
    RTL                                                                         ; $15CB06

; load_dungeon_animated_tiles ($15:CB07)
;
; Loads the animated tiles relevant for the current map, and stores them at
; $7F5000.
load_dungeon_animated_tiles:
    LDA r_map_properties.tileset.w                                              ; $15CB07 |\
    TAX                                                                         ; $15CB0A | | Calculate the offset into the animated tiles data by reading the
    LDA dungeon_animated_tiles_index_data.l,X                                   ; $15CB0B | | index from ROM and multiplying by $180.
    STA <r_generic_tmp_index.hi                                                 ; $15CB0F | |
    STZ <r_generic_tmp_index.lo                                                 ; $15CB11 | |
    LSR <r_generic_tmp_index.hi                                                 ; $15CB13 | |
    ROR <r_generic_tmp_index.lo                                                 ; $15CB15 | |
    LDA <r_generic_tmp_index.hi                                                 ; $15CB17 | |
    CLC                                                                         ; $15CB19 | |
    ADC dungeon_animated_tiles_index_data.l,X                                   ; $15CB1A | |
    STA <r_generic_tmp_index.hi                                                 ; $15CB1E | |
    LDX <r_generic_tmp_index                                                    ; $15CB20 |/
    LDY #$0000.w                                                                ; $15CB22 | Initialize the Y register to zero.
    LDA #:r_tile_animations.b                                                   ; $15CB25 |\
    PHA                                                                         ; $15CB27 | | Set the data bank register to $7F.
    PLB                                                                         ; $15CB28 |/
--  LDA bank1F.dungeon_animated_tiles_data.l,X                                  ; $15CB29 |\
    STA r_tile_animations.w,Y                                                   ; $15CB2D | | Transfer the first 16 bytes directly.
    INX                                                                         ; $15CB30 | |
    INY                                                                         ; $15CB31 | |
    TYA                                                                         ; $15CB32 | |
    AND #%00001111.b                                                            ; $15CB33 | |
    BNE --                                                                      ; $15CB35 |/
-   LDA bank1F.dungeon_animated_tiles_data.l,X                                  ; $15CB37 |\
    STA r_tile_animations.w,Y                                                   ; $15CB3B | | The next eight bytes need to be alternated with zeroes to expand
    INX                                                                         ; $15CB3E | | the data from eight bytes to sixteen bytes.
    INY                                                                         ; $15CB3F | |
    LDA #0.b                                                                    ; $15CB40 | |
    STA r_tile_animations.w ,Y                                                  ; $15CB42 | |
    INY                                                                         ; $15CB45 | |
    TYA                                                                         ; $15CB46 | |
    AND #%00001111.b                                                            ; $15CB47 | |
    BNE -                                                                       ; $15CB49 |/
    CPY #$0800.w                                                                ; $15CB4B |\ Continue until a total of $800 bytes have been written (and $600
    BNE --                                                                      ; $15CB4E |/ read from ROM).
    LDA #$00.b                                                                  ; $15CB50 |\
    PHA                                                                         ; $15CB52 | | Set the data bank register to zero.
    PLB                                                                         ; $15CB53 |/
    RTL                                                                         ; $15CB54

; dungeon_animated_tiles_index_data ($15:CB55)
;
; For each tileset, provides the offset of the first set of animated tiles to
; load. Not every tileset actually uses these tiles, but they are loaded
; nonetheless. $10 may not actually refer to actual tile data.
dungeon_animated_tiles_index_data:
    .db $00                                                                     ; $15CB55 | $00: Airship
    .db $00                                                                     ; $15CB56 | $01: Lunar Core
    .db $00                                                                     ; $15CB57 | $02: Cavern
    .db $02                                                                     ; $15CB58 | $03: Castle Exterior
    .db $03                                                                     ; $15CB59 | $04: Town Exterior
    .db $06                                                                     ; $15CB5A | $05: Town Interior
    .db $07                                                                     ; $15CB5B | $06: Castle Interior
    .db $0A                                                                     ; $15CB5C | $07: Crystal Room
    .db $0A                                                                     ; $15CB5D | $08: Big Whale
    .db $0A                                                                     ; $15CB5E | $09: Underworld Cave
    .db $0A                                                                     ; $15CB5F | $0A: Tower
    .db $0A                                                                     ; $15CB60 | $0B: Giant
    .db $0D                                                                     ; $15CB61 | $0C: Lunar Subterrane
    .db $0D                                                                     ; $15CB62 | $0D: Mountain
    .db $0D                                                                     ; $15CB63 | $0E: Waterway
    .db $10                                                                     ; $15CB64 | $0F: Ship

; copy_animated_tiles_to_vram ($15:CB65)
;
; Copies animated tiles from $7F:5000 to $1200 in VRAM.
copy_animated_tiles_to_vram:
    LDA r_map_area.w                                                            ; $15CB65 |\
    CMP #MAP_AREA_DUNGEON                                                       ; $15CB68 | | This function only applies to dungeon maps. Second, it only does
    BNE +                                                                       ; $15CB6A | | something if the current frame counter mod 8 is equal to 0 or 1.
    LDA <r_map_frame_counter                                                    ; $15CB6C | | (In other words, it executes on two consecutive frames every eight
    AND #%00000110                                                              ; $15CB6E | | overall frames.) However, the calling function only calls it on
    BEQ ++                                                                      ; $15CB70 | | even frames, so it executes once every eight frames.
+   RTL                                                                         ; $15CB72 |/
++  LDA <r_map_frame_counter                                                    ; $15CB73 |\
    AND #%00011000                                                              ; $15CB75 | | Calculate the offset to start at $5000 plus $80 times the frame
    STA <r_copy_animated_tiles_to_vram_offset_lo                                ; $15CB77 | | counter divided by 8, wrapping around to $00 instead of going to
    STZ <r_copy_animated_tiles_to_vram_offset_hi                                ; $15CB79 | | $200. Each animation has four frames, and this allows it to
    REP #FLAG_P_ACCUMULATOR                                                     ; $15CB7B | | rotate through the four frames.
    ASL <r_copy_animated_tiles_to_vram_offset                                   ; $15CB7D | |
    ASL <r_copy_animated_tiles_to_vram_offset                                   ; $15CB7F | |
    ASL <r_copy_animated_tiles_to_vram_offset                                   ; $15CB81 | |
    ASL <r_copy_animated_tiles_to_vram_offset                                   ; $15CB83 | |
    LDA <r_copy_animated_tiles_to_vram_offset                                   ; $15CB85 | |
    CLC                                                                         ; $15CB87 | |
    ADC #r_tile_animations & $FFFF                                              ; $15CB88 | |
    STA <r_copy_animated_tiles_to_vram_offset                                   ; $15CB8B | |
    LDA #$0000                                                                  ; $15CB8D | |
    SEP #FLAG_P_ACCUMULATOR                                                     ; $15CB90 |/
    LDA #%10000000                                                              ; $15CB92 |\
    STA reg_ppu_vmainc                                                          ; $15CB94 | | Configure the DMA to write to VRAM.
    STZ reg_cpu_mdmaen                                                          ; $15CB97 | |
    LDA #%00000001                                                              ; $15CB9A | |
    STA reg_cpu_dmap0                                                           ; $15CB9C | |
    LDA #<reg_ppu_vmdatal_write                                                 ; $15CB9F | |
    STA reg_cpu_bbad0                                                           ; $15CBA1 |/
    LDX #$1200.w                                                                ; $15CBA4 |\ Write to VRAM at $1200, which is where the animated tiles are.
    STX reg_ppu_vmadd                                                           ; $15CBA7 |/
    LDA #:r_tile_animations                                                     ; $15CBAA |\ Set the bank to read from to the bank where tiles are stored.
    STA reg_cpu_a1b0                                                            ; $15CBAC |/
    LDX #$1200.w                                                                ; $15CBAF |\ Set the VRAM address again for some reason.
    STX reg_ppu_vmadd                                                           ; $15CBB2 |/
    LDY #$0004.w                                                                ; $15CBB5 |\
-   LDX <r_copy_animated_tiles_to_vram_offset                                   ; $15CBB8 | | Loop to perform four DMA transfers, once for each set of four
    STX reg_cpu_a1t0                                                            ; $15CBBA | | tiles.
    LDX #$0080.w                                                                ; $15CBBD | |
    STX reg_cpu_das0                                                            ; $15CBC0 | |
    LDA #%00000001                                                              ; $15CBC3 | |
    STA reg_cpu_mdmaen                                                          ; $15CBC5 | |
    LDA <r_copy_animated_tiles_to_vram_offset_hi                                ; $15CBC8 | |
    CLC                                                                         ; $15CBCA | |
    ADC #$02                                                                    ; $15CBCB | |
    STA <r_copy_animated_tiles_to_vram_offset_hi                                ; $15CBCD | |
    DEY                                                                         ; $15CBCF | |
    BNE -                                                                       ; $15CBD0 |/
    RTL                                                                         ; $15CBD2

; The remainder of this file was data and has been excluded from this copy.
